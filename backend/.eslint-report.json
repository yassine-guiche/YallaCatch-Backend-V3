[{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\app.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'app' is defined but never used. Allowed unused args must match /^_/u.","line":79,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":79,"endColumn":57},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'dataVar' is defined but never used. Allowed unused args must match /^_/u.","line":400,"column":40,"nodeType":"Identifier","messageId":"unusedVar","endLine":400,"endColumn":47}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import Fastify, { FastifyInstance, FastifyReply, FastifyRequest } from 'fastify';\nimport { config, isDevelopment, isProduction } from '@/config';\nimport { logger } from '@/lib/logger';\nimport { typedLogger } from '@/lib/typed-logger';\n\n// Import middleware\nimport { errorHandler } from '@/middleware/error';\nimport { requestLogger } from '@/middleware/logging';\nimport { security } from '@/middleware/security';\nimport { getCompressionMiddleware } from '@/middleware/compression';\nimport { metrics } from '@/middleware/metrics';\nimport { ipRateLimit, initializeRateLimiters } from '@/middleware/distributed-rate-limit';\nimport { healthCheck, livenessProbe, readinessProbe, initializeHealthChecks } from '@/middleware/health';\nimport { setupWebSocket } from '@/lib/websocket';\nimport MetricsService from '@/services/metrics';\nimport { redisClient } from '@/config/redis';\n\n// Import all route modules\nimport authRoutes from '@/modules/auth/routes';\nimport prizesRoutes from '@/modules/prizes/routes';\nimport claimsRoutes from '@/modules/claims/routes';\nimport rewardsRoutes from '@/modules/rewards/routes';\nimport usersRoutes from '@/modules/users/routes';\nimport adminRoutes from '@/modules/admin/routes';\nimport notificationsRoutes from '@/modules/notifications/routes';\n// import analyticsRoutes from '@/modules/analytics/routes'; // Merged into admin module\nimport gamificationRoutes from '@/modules/gamification/routes';\n// import partnersRoutes from '@/modules/partners/routes'; // Merged into admin module\nimport arRoutes from '@/modules/ar/routes';\nimport gameRoutes from '@/modules/game/routes';\nimport captureRoutes from '@/modules/capture/routes';\nimport marketplaceRoutes from '@/modules/marketplace/routes';\nimport partnerMarketplaceRoutes from '@/modules/marketplace/partner.routes';\nimport socialRoutes from '@/modules/social/routes';\nimport offlineRoutes from '@/modules/offline/routes';\nimport integrationRoutes from '@/modules/integration/routes';\nimport admobRoutes from '@/modules/admob/index';\n\n/**\n * Create and configure Fastify application\n */\nexport async function createApp(): Promise<FastifyInstance> {\n  const app = Fastify({\n    logger: isDevelopment ? {\n      transport: {\n        target: 'pino-pretty',\n        options: {\n          colorize: true,\n          translateTime: 'HH:MM:ss Z',\n          ignore: 'pid,hostname',\n        },\n      },\n    } : logger,\n    trustProxy: isProduction,\n    bodyLimit: config.UPLOAD_MAX_SIZE,\n    keepAliveTimeout: 30000,\n    connectionTimeout: 30000,\n    pluginTimeout: 30000,\n    requestIdHeader: 'x-request-id',\n    requestIdLogLabel: 'reqId',\n    genReqId: () => {\n      return Math.random().toString(36).substring(2, 15) + \n             Math.random().toString(36).substring(2, 15);\n    },\n  });\n\n  // Initialize middleware and services\n  await initializeMiddleware(app);\n  await registerCorePlugins(app);\n  await registerRoutes(app);\n  await registerErrorHandlers(app);\n\n  return app;\n}\n\n/**\n * Initialize middleware and external services\n */\nasync function initializeMiddleware(app: FastifyInstance): Promise<void> {\n  // Initialize rate limiters\n  initializeRateLimiters();\n  \n  // Initialize health checks\n  initializeHealthChecks();\n  \n  typedLogger.info('Middleware initialized');\n}\n\n/**\n * Register core Fastify plugins\n */\nasync function registerCorePlugins(app: FastifyInstance): Promise<void> {\n  // CORS support (locked to allowed origins)\n  const { default: cors } = await import('@fastify/cors');\n  const allowedOrigins = config.CORS_ORIGINS || [];\n  await app.register(cors, {\n    origin: (origin: string, cb: (err: Error | null, allow?: boolean) => void) => {\n      if (!origin) return cb(null, true); // non-browser clients\n      if (allowedOrigins.includes(origin)) return cb(null, true);\n      return cb(new Error('CORS origin not allowed'));\n    },\n    credentials: config.CORS_CREDENTIALS,\n    methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS', 'HEAD'],\n    allowedHeaders: [\n      'Origin',\n      'X-Requested-With',\n      'Content-Type',\n      'Accept',\n      'Authorization',\n      'X-Request-ID',\n      'X-Device-ID',\n      'X-Platform',\n      'X-App-Version',\n      'X-Session-ID',\n      'X-CSRF-Token',\n    ],\n    maxAge: 86400,\n  });\n\n  // Explicit OPTIONS handler to ensure browsers receive CORS headers (catch-all before routing)\n  const preflightHandler = (request: FastifyRequest, reply: FastifyReply): void => {\n    const origin = request.headers.origin as string | undefined;\n    const allowOrigin = origin && (config.CORS_ORIGINS || []).includes(origin)\n      ? origin\n      : (!origin ? (config.CORS_ORIGINS || [])[0] : null);\n    if (!allowOrigin && origin) {\n      reply.code(403).send({ success: false, error: 'CORS_REJECTED' });\n      return;\n    }\n    reply\n      .header('Access-Control-Allow-Origin', allowOrigin || '')\n      .header('Access-Control-Allow-Credentials', 'true')\n      .header('Access-Control-Allow-Methods', 'GET,POST,PUT,PATCH,DELETE,OPTIONS,HEAD')\n      .header(\n        'Access-Control-Allow-Headers',\n        'Origin, X-Requested-With, Content-Type, Accept, Authorization, X-Request-ID, X-Device-ID, X-Platform, X-App-Version, X-Session-ID, X-CSRF-Token'\n      )\n      .code(204)\n      .send();\n  };\n  app.addHook('onRequest', async (request, reply) => {\n    if (request.method === 'OPTIONS') {\n      // Short-circuit preflight before hitting any route\n      preflightHandler(request, reply);\n      return;\n    }\n  });\n  app.options('*', preflightHandler);\n  app.options('/api/*', preflightHandler);\n\n  // Security headers\n  await app.register(import('@fastify/helmet'), {\n    contentSecurityPolicy: isDevelopment ? false : {\n      directives: {\n        defaultSrc: [\"'self'\"],\n        styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n        scriptSrc: [\"'self'\"],\n        imgSrc: [\"'self'\", 'data:', 'https:'],\n        connectSrc: [\"'self'\"],\n        fontSrc: [\"'self'\"],\n        objectSrc: [\"'none'\"],\n        mediaSrc: [\"'self'\"],\n        frameSrc: [\"'none'\"],\n      },\n    },\n    crossOriginEmbedderPolicy: false,\n  });\n\n  // Rate limiting via custom RedisRateLimit (global hook added below)\n\n  // Multipart support for file uploads\n  await app.register(import('@fastify/multipart'), {\n    limits: {\n      fieldNameSize: 100,\n      fieldSize: 100,\n      fields: 10,\n      fileSize: config.UPLOAD_MAX_SIZE,\n      files: 5,\n      headerPairs: 2000,\n    },\n  });\n\n  // Static file serving\n  await app.register(import('@fastify/static'), {\n    root: config.UPLOAD_DESTINATION,\n    prefix: '/uploads/',\n    decorateReply: false,\n  });\n\n  // Swagger documentation (development only)\n  if (isDevelopment || config.ENABLE_SWAGGER) {\n    await app.register(import('@fastify/swagger'), {\n      swagger: {\n        info: {\n          title: 'YallaCatch! API',\n          description: 'AR Geolocation Game Backend API',\n          version: '1.0.0',\n        },\n        host: `localhost:${config.PORT}`,\n        schemes: ['http', 'https'],\n        consumes: ['application/json'],\n        produces: ['application/json'],\n        securityDefinitions: {\n          Bearer: {\n            type: 'apiKey',\n            name: 'Authorization',\n            in: 'header',\n            description: 'Enter your bearer token in the format: Bearer <token>',\n          },\n        },\n      },\n    });\n\n    await app.register(import('@fastify/swagger-ui'), {\n      routePrefix: '/docs',\n      uiConfig: {\n        docExpansion: 'list',\n        deepLinking: false,\n      },\n      staticCSP: true,\n      transformStaticCSP: (header) => header,\n    });\n  }\n\n  // Response compression (adaptive based on environment)\n  const compressionMiddleware = getCompressionMiddleware();\n  app.addHook('onSend', compressionMiddleware);\n\n  typedLogger.info('Core plugins registered');\n}\n\n/**\n * Register application routes\n */\nasync function registerRoutes(app: FastifyInstance): Promise<void> {\n  // Add hooks for middleware\n  app.addHook('onRequest', requestLogger);\n  app.addHook('onRequest', security);\n  // Custom global distributed rate limiter (IP-based)\n  app.addHook('onRequest', ipRateLimit);\n\n  const maintenanceCache = { active: false, message: null as string | null, checkedAt: 0 };\n  type MaintenanceStatus = { active: boolean; message: string | null; checkedAt: number };\n  const isMaintenanceBypass = (url: string) => {\n    return (\n      url.startsWith('/health') ||\n      url.startsWith('/metrics') ||\n      url.startsWith('/docs') ||\n      url.startsWith('/api/v1/auth') ||\n      url.startsWith('/api/v1/admin')\n    );\n  };\n  const getMaintenanceStatus = async (): Promise<MaintenanceStatus> => {\n    const now = Date.now();\n    if (now - maintenanceCache.checkedAt < 5000) return maintenanceCache;\n    maintenanceCache.checkedAt = now;\n    if (!redisClient || redisClient.status !== 'ready') return maintenanceCache;\n    try {\n      const raw = await redisClient.get('system:maintenance');\n      if (!raw) {\n        maintenanceCache.active = false;\n        maintenanceCache.message = null;\n        return maintenanceCache;\n      }\n      const parsed = JSON.parse(raw) as { active?: boolean; message?: string };\n      maintenanceCache.active = parsed.active === true;\n      maintenanceCache.message = parsed.message || null;\n      return maintenanceCache;\n    } catch {\n      maintenanceCache.active = false;\n      maintenanceCache.message = null;\n      return maintenanceCache;\n    }\n  };\n\n  app.addHook('onRequest', async (request, reply) => {\n    const url = request.url || '';\n    if (isMaintenanceBypass(url)) return;\n    const status = await getMaintenanceStatus();\n    if (!status.active) return;\n    reply.code(503).send({\n      success: false,\n      error: 'MAINTENANCE_MODE',\n      message: status.message || 'System is under maintenance',\n      timestamp: new Date().toISOString(),\n    });\n  });\n  \n  if (config.METRICS_ENABLED) {\n    app.addHook('onRequest', metrics.onRequest);\n    app.addHook('onResponse', metrics.onResponse);\n    app.addHook('onRequest', async (request) => {\n      (request as FastifyRequest & { apiMetricsStart?: number }).apiMetricsStart = Date.now();\n    });\n    app.addHook('onResponse', async (request, reply) => {\n      const requestWithMetrics = request as FastifyRequest & {\n        apiMetricsStart?: number;\n        routerPath?: string;\n        routeOptions?: { url?: string };\n        user?: { sub?: string };\n      };\n      const start = requestWithMetrics.apiMetricsStart;\n      if (!start) return;\n      const duration = Date.now() - start;\n      const endpoint =\n        requestWithMetrics.routerPath ||\n        requestWithMetrics.routeOptions?.url ||\n        request.url.split('?')[0];\n      const userId = requestWithMetrics.user?.sub;\n      await MetricsService.recordAPIMetrics(endpoint, request.method, reply.statusCode, duration, userId);\n    });\n  }\n\n  // Health check endpoints (optionally gated in production)\n  const requireHealthAccess = async (request: FastifyRequest, reply: FastifyReply): Promise<void> => {\n    if (isProduction && config.HEALTH_AUTH_TOKEN) {\n      const token = request.headers['x-health-token'];\n      if (token !== config.HEALTH_AUTH_TOKEN) {\n        reply.code(403).send({\n          success: false,\n          error: 'FORBIDDEN',\n          message: 'Unauthorized health access',\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n    }\n  };\n\n  app.get('/health', { preHandler: requireHealthAccess }, healthCheck);\n  app.get('/health/live', { preHandler: requireHealthAccess }, livenessProbe);\n  app.get('/health/ready', { preHandler: requireHealthAccess }, readinessProbe);\n\n  // Metrics endpoint\n  if (config.METRICS_ENABLED && config.PROMETHEUS_ENABLED) {\n    app.get('/metrics', async (request, reply) => {\n      if (config.METRICS_AUTH_TOKEN) {\n        const token = request.headers['x-metrics-token'];\n        if (token !== config.METRICS_AUTH_TOKEN) {\n          return reply.code(403).send({ success: false, error: 'FORBIDDEN', message: 'Unauthorized metrics access' });\n        }\n      }\n      reply.type('text/plain');\n      return metrics.getMetrics();\n    });\n  }\n\n  // API version prefix\n  const apiPrefix = '/api/v1';\n\n  // Public routes (no authentication required)\n  await app.register(authRoutes, { prefix: `${apiPrefix}/auth` });\n\n  // Game API routes (require authentication)\n  await app.register(prizesRoutes, { prefix: `${apiPrefix}/prizes` });\n  await app.register(claimsRoutes, { prefix: `${apiPrefix}/claims` });\n  await app.register(rewardsRoutes, { prefix: `${apiPrefix}/rewards` });\n  await app.register(usersRoutes, { prefix: `${apiPrefix}/users` });\n  await app.register(gamificationRoutes, { prefix: `${apiPrefix}/gamification` });\n  await app.register(arRoutes, { prefix: `${apiPrefix}` });\n  await app.register(gameRoutes, { prefix: `${apiPrefix}/game` }); // Unity game endpoints\n  await app.register(captureRoutes, { prefix: `${apiPrefix}/capture` });\n  await app.register(marketplaceRoutes, { prefix: `${apiPrefix}/marketplace` });\n  // Partner portal marketplace alias (clean URLs for partners)\n  await app.register(partnerMarketplaceRoutes, { prefix: `${apiPrefix}/partner` });\n  await app.register(socialRoutes, { prefix: `${apiPrefix}/social` });\n  await app.register(offlineRoutes, { prefix: `${apiPrefix}/offline` });\n  await app.register(integrationRoutes, { prefix: `${apiPrefix}/integration` });\n  await app.register(admobRoutes, { prefix: `${apiPrefix}/admob` });\n\n  // Admin API routes (require admin authentication)\n  await app.register(adminRoutes, { prefix: `${apiPrefix}/admin` });\n  await app.register(notificationsRoutes, { prefix: `${apiPrefix}/notifications` });\n  // await app.register(analyticsRoutes, { prefix: `${apiPrefix}/analytics` }); // Merged into admin module\n  // await app.register(partnersRoutes, { prefix: `${apiPrefix}/partners` }); // Merged into admin module\n\n  // WebSocket routes (shared implementation with production server)\n  await setupWebSocket(app);\n\n  // Catch-all route for 404\n  app.setNotFoundHandler(async (request, reply) => {\n    reply.code(404).send({\n      success: false,\n      error: 'Not Found',\n      message: `Route ${request.method} ${request.url} not found`,\n      timestamp: new Date().toISOString(),\n    });\n  });\n\n  typedLogger.info('Routes registered');\n}\n\n/**\n * Register error handlers\n */\nasync function registerErrorHandlers(app: FastifyInstance): Promise<void> {\n  app.setErrorHandler(errorHandler);\n\n  // Validation error handler\n  app.setSchemaErrorFormatter((errors, dataVar) => {\n    return new Error(\n      `Validation failed: ${errors.map(e => `${e.instancePath} ${e.message}`).join(', ')}`\n    );\n  });\n\n  typedLogger.info('Error handlers registered');\n}\n\nexport default createApp;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\config\\database.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\config\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\config\\redis.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'isProduction' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'logger' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":16}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import Redis, { RedisOptions } from 'ioredis';\nimport { config, isProduction } from './index';\nimport { logger } from '@/lib/logger';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { ErrorLike, JSONValue } from '@/types';\n\n// Redis connection options\nconst redisOptions: RedisOptions = {\n  lazyConnect: true,\n  maxRetriesPerRequest: 3,\n  enableReadyCheck: true,\n  connectTimeout: 10000,\n  commandTimeout: 5000,\n  family: 4, // Use IPv4\n  keepAlive: 30000,\n  db: 0,\n  password: config.REDIS_PASSWORD,\n  keyPrefix: 'yallacatch:',\n};\n\n// Connection state management\nlet isConnected = false;\nlet connectionPromise: Promise<Redis> | null = null;\n\n// Main Redis client\nexport let redisClient: Redis;\n\n// Separate client for pub/sub SUBSCRIBER operations (enters subscriber mode, cannot publish)\nexport let redisPubSub: Redis;\n\n// Separate client for PUBLISHING operations (cannot subscribe)\nexport let redisPublisher: Redis;\n\nconst getErrorMessage = (error: ErrorLike) =>\n  error instanceof Error ? error.message : typeof error === 'string' ? error : error.message || 'Unknown error';\n\ntype CacheModule = {\n  setCacheClient?: (client: Redis) => void;\n};\n\n/**\n * Connect to Redis with retry logic\n */\nexport const connectRedis = async (): Promise<Redis> => {\n  if (isConnected && redisClient?.status === 'ready') {\n    return redisClient;\n  }\n\n  if (connectionPromise) {\n    return connectionPromise;\n  }\n\n  connectionPromise = createRedisConnection();\n\n  try {\n    redisClient = await connectionPromise;\n    \n    // Create separate pub/sub subscriber client (for subscribe only)\n    redisPubSub = redisClient.duplicate();\n    await redisPubSub.connect();\n\n    // Create separate publisher client (for publish only)\n    redisPublisher = redisClient.duplicate();\n    await redisPublisher.connect();\n\n    isConnected = true;\n    typedLogger.info('Redis connected successfully', {\n      host: redisClient.options.host,\n      port: redisClient.options.port,\n      db: redisClient.options.db,\n      status: redisClient.status,\n    });\n\n    // Propagate the live client to cache service without creating import cycles\n    try {\n      const cacheModule = await import('@/services/cache');\n      const typedCacheModule = cacheModule as CacheModule;\n      if (typeof typedCacheModule.setCacheClient === 'function') {\n        typedCacheModule.setCacheClient(redisClient);\n      }\n    } catch (err) {\n      typedLogger.error('Failed to set cache client', { error: getErrorMessage(err) });\n    }\n\n    return redisClient;\n  } catch (error) {\n    isConnected = false;\n    connectionPromise = null;\n    typedLogger.error('Redis connection failed', { error: getErrorMessage(error) });\n    throw error;\n  }\n};\n\n/**\n * Create Redis connection with event listeners\n */\nconst createRedisConnection = async (): Promise<Redis> => {\n  const client = new Redis(config.REDIS_URL, redisOptions);\n\n  // Set up event listeners\n  client.on('connect', () => {\n    typedLogger.info('Redis connection established');\n  });\n\n  client.on('ready', () => {\n    typedLogger.info('Redis client ready');\n    isConnected = true;\n  });\n\n  client.on('error', (error) => {\n    typedLogger.error('Redis connection error', { error: getErrorMessage(error) });\n    isConnected = false;\n  });\n\n  client.on('close', () => {\n    typedLogger.warn('Redis connection closed');\n    isConnected = false;\n  });\n\n  client.on('reconnecting', (ms) => {\n    typedLogger.info('Redis reconnecting', { delay: ms });\n  });\n\n  client.on('end', () => {\n    typedLogger.info('Redis connection ended');\n    isConnected = false;\n  });\n\n  // Connect to Redis\n  await client.connect();\n  return client;\n};\n\n/**\n * Disconnect from Redis\n */\nexport const disconnectRedis = async (): Promise<void> => {\n  try {\n    if (redisPubSub) {\n      await redisPubSub.disconnect();\n    }\n    if (redisPublisher) {\n      await redisPublisher.disconnect();\n    }\n    if (redisClient) {\n      await redisClient.disconnect();\n    }\n    isConnected = false;\n    connectionPromise = null;\n    typedLogger.info('Redis disconnected successfully');\n  } catch (error) {\n    typedLogger.error('Error disconnecting from Redis', { error: getErrorMessage(error) });\n    throw error;\n  }\n};\n\n/**\n * Redis cache utility functions\n */\nexport class RedisCache {\n  private static client: Redis;\n\n  static initialize(client: Redis) {\n    this.client = client;\n  }\n\n  /**\n   * Set a value in cache with TTL\n   */\n  static async set(key: string, value: JSONValue, ttl: number = config.CACHE_TTL): Promise<void> {\n    try {\n      const serialized = JSON.stringify(value);\n      await this.client.setex(key, ttl, serialized);\n    } catch (error) {\n      typedLogger.error('Redis cache set error', { key, error: getErrorMessage(error) });\n      throw error;\n    }\n  }\n\n  /**\n   * Get a value from cache\n   */\n  static async get<T = JSONValue>(key: string): Promise<T | null> {\n    try {\n      const value = await this.client.get(key);\n      return value ? (JSON.parse(value) as T) : null;\n    } catch (error) {\n      typedLogger.error('Redis cache get error', { key, error: getErrorMessage(error) });\n      return null;\n    }\n  }\n\n  /**\n   * Delete a key from cache\n   */\n  static async del(key: string): Promise<void> {\n    try {\n      await this.client.del(key);\n    } catch (error) {\n      typedLogger.error('Redis cache delete error', { key, error: getErrorMessage(error) });\n      throw error;\n    }\n  }\n\n  /**\n   * Check if a key exists in cache\n   */\n  static async exists(key: string): Promise<boolean> {\n    try {\n      const result = await this.client.exists(key);\n      return result === 1;\n    } catch (error) {\n      typedLogger.error('Redis cache exists error', { key, error: getErrorMessage(error) });\n      return false;\n    }\n  }\n\n  /**\n   * Set TTL for a key\n   */\n  static async expire(key: string, ttl: number): Promise<void> {\n    try {\n      await this.client.expire(key, ttl);\n    } catch (error) {\n      typedLogger.error('Redis cache expire error', { key, ttl, error: getErrorMessage(error) });\n      throw error;\n    }\n  }\n\n  /**\n   * Increment a counter\n   */\n  static async incr(key: string, ttl?: number): Promise<number> {\n    try {\n      const result = await this.client.incr(key);\n      if (ttl && result === 1) {\n        await this.client.expire(key, ttl);\n      }\n      return result;\n    } catch (error) {\n      typedLogger.error('Redis cache increment error', { key, error: getErrorMessage(error) });\n      throw error;\n    }\n  }\n\n  /**\n   * Add item to a set\n   */\n  static async sadd(key: string, member: string, ttl?: number): Promise<void> {\n    try {\n      await this.client.sadd(key, member);\n      if (ttl) {\n        await this.client.expire(key, ttl);\n      }\n    } catch (error) {\n      typedLogger.error('Redis set add error', { key, member, error: getErrorMessage(error) });\n      throw error;\n    }\n  }\n\n  /**\n   * Get all members of a set\n   */\n  static async smembers(key: string): Promise<string[]> {\n    try {\n      const members = await this.client.smembers(key);\n      return members || [];\n    } catch (error) {\n      typedLogger.error('Redis set members error', { key, error: getErrorMessage(error) });\n      return [];\n    }\n  }\n\n  /**\n   * Check if member exists in set\n   */\n  static async sismember(key: string, member: string): Promise<boolean> {\n    try {\n      const result = await this.client.sismember(key, member);\n      return result === 1;\n    } catch (error) {\n      typedLogger.error('Redis set member check error', { key, member, error: getErrorMessage(error) });\n      return false;\n    }\n  }\n\n\n  /**\n   * Remove member from set\n   */\n  static async srem(key: string, member: string): Promise<void> {\n    try {\n      await this.client.srem(key, member);\n    } catch (error) {\n      typedLogger.error('Redis set remove error', { key, member, error: getErrorMessage(error) });\n      throw error;\n    }\n  }\n\n  /**\n   * Push item to list\n   */\n  static async lpush(key: string, value: JSONValue, ttl?: number): Promise<void> {\n    try {\n      const serialized = JSON.stringify(value);\n      await this.client.lpush(key, serialized);\n      if (ttl) {\n        await this.client.expire(key, ttl);\n      }\n    } catch (error) {\n      typedLogger.error('Redis list push error', { key, error: getErrorMessage(error) });\n      throw error;\n    }\n  }\n\n  /**\n   * Get list range\n   */\n  static async lrange<T = JSONValue>(key: string, start: number = 0, stop: number = -1): Promise<T[]> {\n    try {\n      const values = await this.client.lrange(key, start, stop);\n      return values.map(value => JSON.parse(value) as T);\n    } catch (error) {\n      typedLogger.error('Redis list range error', { key, start, stop, error: getErrorMessage(error) });\n      return [];\n    }\n  }\n\n  /**\n   * Clear all cache\n   */\n  static async clear(): Promise<void> {\n    try {\n      const keys = await this.client.keys('yallacatch:*');\n      if (keys.length > 0) {\n        await this.client.del(...keys);\n      }\n    } catch (error) {\n      typedLogger.error('Redis cache clear error', { error: getErrorMessage(error) });\n      throw error;\n    }\n  }\n}\n\n/**\n * Rate limiting utility\n */\nexport class RedisRateLimit {\n  private static client: Redis;\n\n  static initialize(client: Redis) {\n    this.client = client;\n  }\n\n  /**\n   * Check rate limit for a key\n   */\n  static async checkLimit(\n    key: string,\n    limit: number,\n    windowMs: number,\n    identifier?: string\n  ): Promise<{ allowed: boolean; remaining: number; resetTime: number }> {\n    try {\n      const fullKey = identifier ? `ratelimit:${key}:${identifier}` : `ratelimit:${key}`;\n      const current = await this.client.incr(fullKey);\n      \n      if (current === 1) {\n        await this.client.expire(fullKey, Math.ceil(windowMs / 1000));\n      }\n\n      const ttl = await this.client.ttl(fullKey);\n      const resetTime = Date.now() + (ttl * 1000);\n      const remaining = Math.max(0, limit - current);\n\n      return {\n        allowed: current <= limit,\n        remaining,\n        resetTime,\n      };\n    } catch (error) {\n      typedLogger.error('Redis rate limit error', { key, error: getErrorMessage(error) });\n      // Allow request on Redis error\n      return { allowed: true, remaining: limit, resetTime: Date.now() + windowMs };\n    }\n  }\n\n  /**\n   * Reset rate limit for a key\n   */\n  static async resetLimit(key: string, identifier?: string): Promise<void> {\n    try {\n      const fullKey = identifier ? `ratelimit:${key}:${identifier}` : `ratelimit:${key}`;\n      await this.client.del(fullKey);\n    } catch (error) {\n      typedLogger.error('Redis rate limit reset error', { key, error: getErrorMessage(error) });\n      throw error;\n    }\n  }\n}\n\n/**\n * Session management utility\n */\nexport class RedisSession {\n  private static client: Redis;\n\n  static initialize(client: Redis) {\n    this.client = client;\n  }\n\n  /**\n   * Create a session\n   */\n  static async create(sessionId: string, data: JSONValue, ttl: number = 86400): Promise<void> {\n    try {\n      const key = `session:${sessionId}`;\n      await this.client.setex(key, ttl, JSON.stringify(data));\n    } catch (error) {\n      typedLogger.error('Redis session create error', { sessionId, error: getErrorMessage(error) });\n      throw error;\n    }\n  }\n\n  /**\n   * Get session data\n   */\n  static async get<T = JSONValue>(sessionId: string): Promise<T | null> {\n    try {\n      const key = `session:${sessionId}`;\n      const data = await this.client.get(key);\n      return data ? (JSON.parse(data) as T) : null;\n    } catch (error) {\n      typedLogger.error('Redis session get error', { sessionId, error: getErrorMessage(error) });\n      return null;\n    }\n  }\n\n  /**\n   * Update session data\n   */\n  static async update(sessionId: string, data: JSONValue, ttl?: number): Promise<void> {\n    try {\n      const key = `session:${sessionId}`;\n      if (ttl) {\n        await this.client.setex(key, ttl, JSON.stringify(data));\n      } else {\n        await this.client.set(key, JSON.stringify(data));\n      }\n    } catch (error) {\n      typedLogger.error('Redis session update error', { sessionId, error: getErrorMessage(error) });\n      throw error;\n    }\n  }\n\n  /**\n   * Delete a session\n   */\n  static async destroy(sessionId: string): Promise<void> {\n    try {\n      const key = `session:${sessionId}`;\n      await this.client.del(key);\n    } catch (error) {\n      typedLogger.error('Redis session destroy error', { sessionId, error: getErrorMessage(error) });\n      throw error;\n    }\n  }\n\n  /**\n   * Extend session TTL\n   */\n  static async extend(sessionId: string, ttl: number): Promise<void> {\n    try {\n      const key = `session:${sessionId}`;\n      await this.client.expire(key, ttl);\n    } catch (error) {\n      typedLogger.error('Redis session extend error', { sessionId, error: getErrorMessage(error) });\n      throw error;\n    }\n  }\n}\n\n/**\n * Get Redis connection status\n */\nexport const getConnectionStatus = () => {\n  return {\n    isConnected,\n    status: redisClient?.status || 'disconnected',\n    host: redisClient?.options?.host,\n    port: redisClient?.options?.port,\n    db: redisClient?.options?.db,\n  };\n};\n\n/**\n * Health check for Redis\n */\nexport const healthCheck = async (): Promise<boolean> => {\n  try {\n    if (!isConnected || redisClient?.status !== 'ready') {\n      return false;\n    }\n\n    // Ping Redis\n    const result = await redisClient.ping();\n    return result === 'PONG';\n  } catch (error) {\n    typedLogger.error('Redis health check failed', { error: getErrorMessage(error) });\n    return false;\n  }\n};\n\n// Initialize utilities when Redis connects\nexport const initializeRedisUtilities = (client: Redis): void => {\n  RedisCache.initialize(client);\n  RedisRateLimit.initialize(client);\n  RedisSession.initialize(client);\n};\n\n// Handle process termination\nprocess.on('SIGINT', async () => {\n  try {\n    await disconnectRedis();\n  } catch (error) {\n    typedLogger.error('Error during Redis graceful shutdown', { error: getErrorMessage(error) });\n  }\n});\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\jobs\\index.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'logger' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":16},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":101,"column":78,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":101,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3251,3254],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3251,3254],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":114,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":114,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3613,3616],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3613,3616],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":130,"column":82,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":130,"endColumn":85,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4149,4152],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4149,4152],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":152,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":152,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4804,4807],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4804,4807],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":158,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":158,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5011,5014],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5011,5014],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":174,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":174,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5534,5537],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5534,5537],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":175,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":175,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5555,5558],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5555,5558],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":175,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":175,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5598,5601],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5598,5601],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":180,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":180,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5757,5760],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5757,5760],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { logger } from '@/lib/logger';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { Analytics } from '@/models/Analytics';\nimport { Prize } from '@/models/Prize';\nimport { User } from '@/models/User';\nimport { Reward } from '@/models/Reward';\nimport { Claim } from '@/models/Claim';\nimport { Notification } from '@/models/Notification';\nimport { NotificationStatus } from '@/types';\nimport UnifiedNotificationService from '@/services/notification-service';\n\n// Service function to generate daily analytics\nasync function generateDailyAnalytics() {\n  try {\n    const now = new Date();\n    const startOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n    const endOfDay = new Date(startOfDay.getTime() + 24 * 60 * 60 * 1000);\n\n    // Gather metrics for the day\n    const [\n      userMetrics,\n      prizeMetrics,\n      claimMetrics,\n      rewardMetrics\n    ] = await Promise.all([\n      // User metrics\n      User.aggregate([{\n        $match: {\n          $or: [\n            { createdAt: { $gte: startOfDay, $lt: endOfDay } },\n            { lastActive: { $gte: startOfDay, $lt: endOfDay } }\n          ]\n        }\n      }, {\n        $group: {\n          _id: null,\n          totalUsers: { $sum: 1 },\n          activeUsers: {\n            $sum: { $cond: [{ $gte: ['$lastActive', startOfDay] }, 1, 0] }\n          }\n        }\n      }]),\n\n      // Prize metrics\n      Prize.aggregate([{\n        $match: { createdAt: { $gte: startOfDay, $lt: endOfDay } }\n      }, {\n        $group: { _id: null, totalPrizes: { $sum: 1 } }\n      }]),\n\n      // Claim metrics\n      Claim.aggregate([{\n        $match: { claimedAt: { $gte: startOfDay, $lt: endOfDay } }\n      }, {\n        $group: {\n          _id: null,\n          totalClaims: { $sum: 1 },\n          totalPoints: { $sum: '$pointsAwarded' }\n        }\n      }]),\n\n      // Reward metrics\n      Reward.aggregate([{\n        $match: { createdAt: { $gte: startOfDay, $lt: endOfDay } }\n      }, {\n        $group: { _id: null, totalRewards: { $sum: 1 } }\n      }])\n    ]);\n\n    // Prepare the analytics data\n    const analyticsData = {\n      date: startOfDay,\n      metrics: {\n        totalUsers: userMetrics[0]?.totalUsers || 0,\n        activeUsers: userMetrics[0]?.activeUsers || 0,\n        newUsers: userMetrics[0]?.totalUsers || 0,\n        totalPrizes: prizeMetrics[0]?.totalPrizes || 0,\n        claimedPrizes: claimMetrics[0]?.totalClaims || 0,\n        totalRewards: rewardMetrics[0]?.totalRewards || 0,\n        redeemedRewards: 0, // Would need redemption aggregation\n        totalPoints: claimMetrics[0]?.totalPoints || 0,\n        averageSessionTime: 0, // Would need session data\n        retentionRate: 0,\n        conversionRate: 0,\n      },\n      generatedAt: new Date(),\n    };\n\n    // Save or update the analytics record\n    const existingRecord = await Analytics.findOne({ date: startOfDay });\n    if (existingRecord) {\n      Object.assign(existingRecord, analyticsData);\n      await existingRecord.save();\n    } else {\n      await Analytics.create(analyticsData);\n    }\n\n    typedLogger.info('Daily analytics generated', { date: startOfDay.toISOString() });\n    return analyticsData;\n  } catch (error) {\n    typedLogger.error('Error generating daily analytics', { error: (error as any).message });\n    throw error;\n  }\n}\n\nexport async function startScheduledJobs() {\n  try {\n    // Start daily analytics job\n    setInterval(async () => {\n      try {\n        await generateDailyAnalytics();\n        typedLogger.info('Daily analytics generated');\n      } catch (error) {\n        typedLogger.error('Daily analytics job error', { error: (error as any).message });\n      }\n    }, 24 * 60 * 60 * 1000); // Every 24 hours\n\n    // Start expired prizes cleanup job\n    setInterval(async () => {\n      try {\n        const result = await Prize.deleteMany({\n          expiresAt: { $lt: new Date() },\n          status: 'active'\n        });\n        \n        if (result.deletedCount > 0) {\n          typedLogger.info('Expired prizes cleaned up', { count: result.deletedCount });\n        }\n      } catch (error) {\n        typedLogger.error('Expired prizes cleanup job error', { error: (error as any).message });\n      }\n    }, 60 * 60 * 1000); // Every hour\n\n    // Start ban expiry check job\n    setInterval(async () => {\n      try {\n        const result = await User.updateMany(\n          {\n            isBanned: true,\n            banExpiresAt: { $lt: new Date() }\n          },\n          {\n            $unset: { banExpiresAt: 1, banReason: 1 },\n            $set: { isBanned: false }\n          }\n        );\n        \n        if (result.modifiedCount > 0) {\n          typedLogger.info('Expired bans lifted', { count: result.modifiedCount });\n        }\n      } catch (error) {\n        typedLogger.error('Ban expiry check job error', { error: (error as any).message });\n      }\n    }, 60 * 60 * 1000); // Every hour\n\n    typedLogger.info('Scheduled jobs started');\n  } catch (error) {\n    typedLogger.error('Failed to start scheduled jobs', { error: (error as any).message });\n    throw error;\n  }\n}\n\n// Process scheduled notifications every minute\nsetInterval(async () => {\n  try {\n    const now = new Date();\n    const due = await Notification.find({ status: NotificationStatus.SCHEDULED, scheduledFor: { $lte: now } });\n    for (const n of due) {\n      try {\n        const result = await UnifiedNotificationService.processScheduledNotification(n._id.toString());\n        if (!result.success) {\n          throw new Error('SCHEDULED_DELIVERY_FAILED');\n        }\n      } catch (err: any) {\n        (n as any).status = NotificationStatus.FAILED as any;\n        await n.save();\n        typedLogger.error('Scheduled notification send failed', { id: n._id, error: err.message });\n      }\n    }\n  } catch (err: any) {\n    typedLogger.error('Scheduled notifications job error', { error: err.message });\n  }\n}, 60 * 1000);\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\lib\\audit-logger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\lib\\jwt.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Algorithm' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'logger' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'pattern' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":272,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":272,"endColumn":18}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import jwt, { Algorithm } from 'jsonwebtoken';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { config, jwtPrivateKey, jwtPublicKey } from '@/config';\nimport { logger, logSecurity } from './logger';\nimport { RedisCache } from '@/config/redis';\nimport crypto from 'crypto';\nimport { ErrorLike } from '@/types';\n\n// JWT payload interface\nexport interface JWTPayload {\n  sub: string; // User ID\n  email?: string;\n  role: string;\n  deviceId?: string;\n  sessionId: string;\n  iat?: number;\n  exp?: number;\n  iss?: string;\n  aud?: string;\n  jti?: string; // JWT ID for revocation\n}\n\n// Token pair interface\nexport interface TokenPair {\n  accessToken: string;\n  refreshToken: string;\n  expiresIn: number;\n  tokenType: 'Bearer';\n}\n\n// JWT verification result\nexport interface JWTVerificationResult {\n  valid: boolean;\n  expired: boolean;\n  decoded: JWTPayload | null;\n  error?: string;\n}\n\nconst getErrorMessage = (error: ErrorLike) =>\n  error instanceof Error ? error.message : typeof error === 'string' ? error : error.message || 'Unknown error';\n\n/**\n * Generate a unique JWT ID\n */\nconst generateJTI = (): string => {\n  return crypto.randomBytes(16).toString('hex');\n};\n\n/**\n * Sign JWT access token\n */\nexport const signAccessToken = (payload: Omit<JWTPayload, 'iat' | 'exp' | 'iss' | 'aud' | 'jti'>): string => {\n  const jti = generateJTI();\n  const tokenPayload: JWTPayload = {\n    ...payload,\n    iss: config.JWT_ISSUER,\n    aud: config.JWT_AUDIENCE,\n    jti,\n  };\n\n  try {\n    const token = jwt.sign(\n      tokenPayload,\n      jwtPrivateKey,\n      {\n        algorithm: 'RS256' as jwt.Algorithm | undefined,\n        expiresIn: config.JWT_ACCESS_EXPIRY || '15m',\n      } as jwt.SignOptions\n    );\n\n    // Store JTI for potential revocation\n    RedisCache.set(`jti:${jti}`, { userId: payload.sub, type: 'access' }, 15 * 60); // 15 minutes\n    // Track in user/session sets for bulk revocation\n    RedisCache.sadd(`user_tokens:${payload.sub}`, jti, 15 * 60);\n    if (payload.sessionId) {\n      RedisCache.sadd(`session_tokens:${payload.sessionId}`, jti, 15 * 60);\n    }\n\n    typedLogger.debug('Access token signed', { userId: payload.sub, jti });\n    return token;\n  } catch (error) {\n    typedLogger.error('Error signing access token', { error: getErrorMessage(error), userId: payload.sub });\n    throw new Error('Failed to sign access token');\n  }\n};\n\n/**\n * Sign JWT refresh token\n */\nexport const signRefreshToken = (payload: Omit<JWTPayload, 'iat' | 'exp' | 'iss' | 'aud' | 'jti'>): string => {\n  const jti = generateJTI();\n  const tokenPayload: JWTPayload = {\n    ...payload,\n    iss: config.JWT_ISSUER,\n    aud: config.JWT_AUDIENCE,\n    jti,\n  };\n\n  try {\n    const token = jwt.sign(\n      tokenPayload,\n      jwtPrivateKey,\n      {\n        algorithm: 'RS256' as jwt.Algorithm | undefined,\n        expiresIn: config.JWT_REFRESH_EXPIRY || '30d',\n      } as jwt.SignOptions\n    );\n\n    // Store JTI for potential revocation (longer TTL for refresh tokens)\n    const refreshTtl = 30 * 24 * 60 * 60; // 30 days\n    RedisCache.set(`jti:${jti}`, { userId: payload.sub, type: 'refresh' }, refreshTtl);\n    // Track in user/session sets\n    RedisCache.sadd(`user_tokens:${payload.sub}`, jti, refreshTtl);\n    if (payload.sessionId) {\n      RedisCache.sadd(`session_tokens:${payload.sessionId}`, jti, refreshTtl);\n    }\n\n    typedLogger.debug('Refresh token signed', { userId: payload.sub, jti });\n    return token;\n  } catch (error) {\n    typedLogger.error('Error signing refresh token', { error: getErrorMessage(error), userId: payload.sub });\n    throw new Error('Failed to sign refresh token');\n  }\n};\n\n/**\n * Sign token pair (access + refresh)\n */\nexport const signTokenPair = (payload: Omit<JWTPayload, 'iat' | 'exp' | 'iss' | 'aud' | 'jti'>): TokenPair => {\n  try {\n    const accessToken = signAccessToken(payload);\n    const refreshToken = signRefreshToken(payload);\n\n    // Parse expiry time\n    const decoded = jwt.decode(accessToken) as JWTPayload;\n    const expiresIn = decoded.exp! - Math.floor(Date.now() / 1000);\n\n    typedLogger.info('Token pair generated', { userId: payload.sub, sessionId: payload.sessionId });\n\n    return {\n      accessToken,\n      refreshToken,\n      expiresIn,\n      tokenType: 'Bearer',\n    };\n  } catch (error) {\n    typedLogger.error('Error generating token pair', { error: getErrorMessage(error), userId: payload.sub });\n    throw new Error('Failed to generate token pair');\n  }\n};\n\n/**\n * Verify JWT token\n */\nexport const verifyToken = async (token: string): Promise<JWTVerificationResult> => {\n  try {\n    const decoded = jwt.verify(token, jwtPublicKey, {\n      algorithms: ['RS256'],\n      issuer: config.JWT_ISSUER,\n      audience: config.JWT_AUDIENCE,\n    }) as JWTPayload;\n\n    // Check if token is revoked\n    if (decoded.jti) {\n      const isRevoked = await RedisCache.exists(`revoked:${decoded.jti}`);\n      if (isRevoked) {\n        logSecurity('revoked_token_used', 'medium', { jti: decoded.jti, userId: decoded.sub });\n        return {\n          valid: false,\n          expired: false,\n          decoded: null,\n          error: 'Token has been revoked',\n        };\n      }\n    }\n\n    return {\n      valid: true,\n      expired: false,\n      decoded,\n    };\n  } catch (error) {\n    if (error instanceof jwt.TokenExpiredError) {\n      return {\n        valid: false,\n        expired: true,\n        decoded: null,\n        error: 'Token has expired',\n      };\n    }\n\n    if (error instanceof jwt.JsonWebTokenError) {\n      logSecurity('invalid_token_used', 'medium', { error: getErrorMessage(error) });\n      return {\n        valid: false,\n        expired: false,\n        decoded: null,\n        error: 'Invalid token',\n      };\n    }\n\n    typedLogger.error('JWT verification error', { error: getErrorMessage(error) });\n    return {\n      valid: false,\n      expired: false,\n      decoded: null,\n      error: 'Token verification failed',\n    };\n  }\n};\n\n/**\n * Refresh access token using refresh token\n */\nexport const refreshAccessToken = async (refreshToken: string): Promise<TokenPair | null> => {\n  try {\n    const verificationResult = await verifyToken(refreshToken);\n    \n    if (!verificationResult.valid || !verificationResult.decoded) {\n      logSecurity('invalid_refresh_token', 'medium', { error: verificationResult.error });\n      return null;\n    }\n\n    const { sub, email, role, deviceId, sessionId } = verificationResult.decoded;\n\n    // Generate new token pair\n    const newTokenPair = signTokenPair({\n      sub,\n      email,\n      role,\n      deviceId,\n      sessionId,\n    });\n\n    // Revoke old refresh token\n    if (verificationResult.decoded.jti) {\n      await revokeToken(verificationResult.decoded.jti);\n    }\n\n    typedLogger.info('Access token refreshed', { userId: sub, sessionId });\n    return newTokenPair;\n  } catch (error) {\n    typedLogger.error('Error refreshing access token', { error: getErrorMessage(error) });\n    return null;\n  }\n};\n\n/**\n * Revoke a token by JTI\n */\nexport const revokeToken = async (jti: string): Promise<void> => {\n  try {\n    // Add to revocation list with a TTL matching the token's max lifetime\n    await RedisCache.set(`revoked:${jti}`, true, 30 * 24 * 60 * 60); // 30 days\n    \n    // Remove from active JTI list\n    await RedisCache.del(`jti:${jti}`);\n    \n    typedLogger.info('Token revoked', { jti });\n  } catch (error) {\n    typedLogger.error('Error revoking token', { error: getErrorMessage(error), jti });\n    throw new Error('Failed to revoke token');\n  }\n};\n\n/**\n * Revoke all tokens for a user\n */\nexport const revokeAllUserTokens = async (userId: string): Promise<void> => {\n  try {\n    // Get all active JTIs for the user\n    const pattern = `jti:*`;\n    const keys = await RedisCache.smembers(`user_tokens:${userId}`);\n    \n    // Revoke each token\n    const revokePromises = keys.map(jti => revokeToken(jti));\n    await Promise.all(revokePromises);\n    \n    // Clear user token list\n    await RedisCache.del(`user_tokens:${userId}`);\n    \n    typedLogger.info('All user tokens revoked', { userId, count: keys.length });\n  } catch (error) {\n    typedLogger.error('Error revoking all user tokens', { error: getErrorMessage(error), userId });\n    throw new Error('Failed to revoke user tokens');\n  }\n};\n\n/**\n * Revoke all tokens for a session\n */\nexport const revokeSessionTokens = async (sessionId: string): Promise<void> => {\n  try {\n    // Get all active JTIs for the session\n    const keys = await RedisCache.smembers(`session_tokens:${sessionId}`);\n    \n    // Revoke each token\n    const revokePromises = keys.map(jti => revokeToken(jti));\n    await Promise.all(revokePromises);\n    \n    // Clear session token list\n    await RedisCache.del(`session_tokens:${sessionId}`);\n    \n    typedLogger.info('All session tokens revoked', { sessionId, count: keys.length });\n  } catch (error) {\n    typedLogger.error('Error revoking session tokens', { error: getErrorMessage(error), sessionId });\n    throw new Error('Failed to revoke session tokens');\n  }\n};\n\n/**\n * Extract token from Authorization header\n */\nexport const extractTokenFromHeader = (authHeader?: string): string | null => {\n  if (!authHeader) {\n    return null;\n  }\n\n  const parts = authHeader.split(' ');\n  if (parts.length !== 2 || parts[0] !== 'Bearer') {\n    return null;\n  }\n\n  return parts[1];\n};\n\n/**\n * Decode token without verification (for debugging)\n */\nexport const decodeToken = (token: string): JWTPayload | null => {\n  try {\n    return jwt.decode(token) as JWTPayload;\n  } catch (error) {\n    typedLogger.error('Error decoding token', { error: getErrorMessage(error) });\n    return null;\n  }\n};\n\n/**\n * Get token expiration time\n */\nexport const getTokenExpiration = (token: string): Date | null => {\n  try {\n    const decoded = decodeToken(token);\n    if (!decoded || !decoded.exp) {\n      return null;\n    }\n    return new Date(decoded.exp * 1000);\n  } catch (error) {\n    typedLogger.error('Error getting token expiration', { error: getErrorMessage(error) });\n    return null;\n  }\n};\n\n/**\n * Check if token is expired\n */\nexport const isTokenExpired = (token: string): boolean => {\n  const expiration = getTokenExpiration(token);\n  if (!expiration) {\n    return true;\n  }\n  return expiration.getTime() < Date.now();\n};\n\n/**\n * Get remaining token lifetime in seconds\n */\nexport const getTokenRemainingLifetime = (token: string): number => {\n  const expiration = getTokenExpiration(token);\n  if (!expiration) {\n    return 0;\n  }\n  return Math.max(0, Math.floor((expiration.getTime() - Date.now()) / 1000));\n};\n\n/**\n * Validate token format\n */\nexport const isValidTokenFormat = (token: string): boolean => {\n  if (!token || typeof token !== 'string') {\n    return false;\n  }\n\n  // JWT should have 3 parts separated by dots\n  const parts = token.split('.');\n  if (parts.length !== 3) {\n    return false;\n  }\n\n  // Each part should be valid base64\n  try {\n    parts.forEach(part => {\n      Buffer.from(part, 'base64');\n    });\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\n\n/**\n * Generate secure session ID\n */\nexport const generateSessionId = (): string => {\n  return crypto.randomBytes(32).toString('hex');\n};\n\n/**\n * Hash sensitive data for logging\n */\nexport const hashForLogging = (data: string): string => {\n  return crypto.createHash('sha256').update(data).digest('hex').substring(0, 8);\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\lib\\logger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\lib\\typed-logger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\lib\\websocket.ts","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":267,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":267,"endColumn":71},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":268,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":268,"endColumn":56}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyInstance } from 'fastify';\nimport { WebSocket } from 'ws';\nimport fastifyWebsocket from '@fastify/websocket';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { verifyToken } from '@/lib/jwt';\nimport { Metadata } from '@/types';\n\n// Socket.IO instance reference (set from server.ts)\ninterface SocketIOServer {\n  to(room: string): { emit(event: string, data: Metadata): void };\n}\n\nlet socketIO: SocketIOServer | null = null;\n\nexport function setSocketIO(io: SocketIOServer) {\n  socketIO = io;\n  typedLogger.info('Socket.IO instance registered in websocket module');\n}\n\ninterface WebSocketClient {\n  id: string;\n  userId: string;\n  isAdmin: boolean;\n  ws: WebSocket;\n  subscriptions: Set<string>;\n  connectedAt: Date;\n}\n\ninterface WebSocketMessage {\n  type: string;\n  data?: Metadata;\n  room?: string;\n}\n\nclass WebSocketManager {\n  private clients: Map<string, WebSocketClient> = new Map();\n  private rooms: Map<string, Set<string>> = new Map(); // room -> clientIds\n  private eventQueue: Metadata[] = [];\n  private maxQueueSize = 1000;\n\r\n  addClient(client: WebSocketClient) {\r\n    this.clients.set(client.id, client);\r\n    typedLogger.info('WebSocket client connected', { userId: client.userId, clientId: client.id });\r\n  }\r\n\r\n  removeClient(clientId: string) {\r\n    const client = this.clients.get(clientId);\r\n    if (client) {\r\n      // Remove from all rooms\r\n      this.rooms.forEach(members => members.delete(clientId));\r\n      this.clients.delete(clientId);\r\n      typedLogger.info('WebSocket client disconnected', { userId: client.userId, clientId });\r\n    }\r\n  }\r\n\r\n  getClient(clientId: string): WebSocketClient | undefined {\r\n    return this.clients.get(clientId);\r\n  }\r\n\r\n  getClientsByUserId(userId: string): WebSocketClient[] {\r\n    return Array.from(this.clients.values()).filter(c => c.userId === userId);\r\n  }\r\n\r\n  getAdminClients(): WebSocketClient[] {\r\n    return Array.from(this.clients.values()).filter(c => c.isAdmin);\r\n  }\r\n\r\n  joinRoom(clientId: string, room: string) {\r\n    if (!this.rooms.has(room)) {\r\n      this.rooms.set(room, new Set());\r\n    }\r\n    this.rooms.get(room)!.add(clientId);\r\n    const client = this.clients.get(clientId);\r\n    if (client) {\r\n      client.subscriptions.add(room);\r\n    }\r\n  }\r\n\r\n  leaveRoom(clientId: string, room: string) {\r\n    const roomMembers = this.rooms.get(room);\r\n    if (roomMembers) {\r\n      roomMembers.delete(clientId);\r\n    }\r\n    const client = this.clients.get(clientId);\r\n    if (client) {\r\n      client.subscriptions.delete(room);\r\n    }\r\n  }\r\n\r\n  broadcastToRoom(room: string, message: Metadata) {\n    const roomMembers = this.rooms.get(room);\r\n    if (!roomMembers) return;\r\n\r\n    roomMembers.forEach(clientId => {\r\n      const client = this.clients.get(clientId);\r\n      if (client && !client.ws.destroyed) {\r\n        try {\r\n          client.ws.write(JSON.stringify(message));\r\n        } catch (error) {\r\n          typedLogger.error('Failed to write to client', { clientId, error });\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  broadcastToAdmins(message: Metadata) {\n    this.getAdminClients().forEach(client => {\r\n      if (!client.ws.destroyed) {\r\n        try {\r\n          client.ws.write(JSON.stringify(message));\r\n        } catch (error) {\r\n          typedLogger.error('Failed to write to admin client', { error });\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  broadcastToUser(userId: string, message: Metadata) {\n    this.getClientsByUserId(userId).forEach(client => {\r\n      if (!client.ws.destroyed) {\r\n        try {\r\n          client.ws.write(JSON.stringify(message));\r\n        } catch (error) {\r\n          typedLogger.error('Failed to write to user client', { userId, error });\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  broadcastToAll(message: Metadata) {\n    this.clients.forEach(client => {\r\n      if (!client.ws.destroyed) {\r\n        try {\r\n          client.ws.write(JSON.stringify(message));\r\n        } catch (error) {\r\n          typedLogger.error('Failed to write to client', { error });\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  queueEvent(event: Metadata) {\n    if (this.eventQueue.length < this.maxQueueSize) {\r\n      this.eventQueue.push(event);\r\n    } else {\r\n      // Remove oldest event if queue is full\r\n      this.eventQueue.shift();\r\n      this.eventQueue.push(event);\r\n    }\r\n  }\r\n\r\n  getEventHistory(limit: number = 50): Metadata[] {\n    return this.eventQueue.slice(-limit);\n  }\n\r\n  getStats() {\r\n    return {\r\n      totalClients: this.clients.size,\r\n      adminClients: this.getAdminClients().length,\r\n      rooms: this.rooms.size,\r\n      queueSize: this.eventQueue.length\r\n    };\r\n  }\r\n}\r\n\r\nexport const wsManager = new WebSocketManager();\r\n\r\nexport async function setupWebSocket(fastify: FastifyInstance) {\r\n  await fastify.register(fastifyWebsocket);\r\n\r\n  fastify.get('/ws', { websocket: true }, async (socket, request) => {\r\n    try {\r\n      // Authenticate user (Authorization header or ?token= query for backward compatibility)\n      const authHeader = request.headers.authorization || request.headers.Authorization;\n      const headerToken = typeof authHeader === 'string' ? authHeader.replace('Bearer ', '') : '';\n      const queryToken = (request.query as { token?: string })?.token;\n      const token = headerToken || queryToken;\n\n      if (!token) {\n        socket.write(JSON.stringify({ type: 'error', message: 'Unauthorized' }));\n        socket.end();\n        return;\n      }\n\n      const verification = await verifyToken(token);\n      if (!verification.valid || !verification.decoded) {\n        socket.write(JSON.stringify({ type: 'error', message: 'Unauthorized' }));\n        socket.end();\n        return;\n      }\n\n      const userId = verification.decoded.sub || 'unknown';\n      const role = verification.decoded.role || '';\n      const isAdmin = ['admin', 'super_admin', 'moderator'].includes(role);\n\r\n      const clientId = `${userId}-${Date.now()}-${Math.random()}`;\r\n      const client: WebSocketClient = {\r\n        id: clientId,\r\n        userId,\r\n        isAdmin,\r\n        ws: socket,\r\n        subscriptions: new Set(),\r\n        connectedAt: new Date()\r\n      };\r\n\r\n      wsManager.addClient(client);\r\n\r\n      // Send welcome message (compat with legacy clients)\n      const welcomePayload = {\n        clientId,\n        userId,\n        isAdmin,\n        timestamp: new Date().toISOString()\n      };\n      socket.write(JSON.stringify({ type: 'connected', ...welcomePayload }));\n      socket.write(JSON.stringify({ type: 'welcome', ...welcomePayload }));\n\r\n      // Handle incoming messages\r\n      socket.on('data', (data: Buffer) => {\r\n        try {\r\n          const message = JSON.parse(data.toString()) as WebSocketMessage;\n          handleWebSocketMessage(client, message);\n        } catch (error) {\n          typedLogger.error('WebSocket message parse error', { error });\n        }\n      });\r\n\r\n      // Handle disconnection\r\n      socket.on('end', () => {\r\n        wsManager.removeClient(clientId);\r\n      });\r\n\r\n      // Handle errors\r\n      socket.on('error', (error) => {\r\n        typedLogger.error('WebSocket error', { clientId, error });\r\n        wsManager.removeClient(clientId);\r\n      });\r\n    } catch (error) {\r\n      typedLogger.error('WebSocket setup error', { error });\r\n      socket.end();\r\n    }\r\n  });\r\n\r\n  typedLogger.info('WebSocket endpoint registered at /ws');\r\n}\r\n\r\nfunction handleWebSocketMessage(client: WebSocketClient, message: WebSocketMessage) {\n  const { type, data, room } = message;\n  const roomName = room || 'general';\n\n  switch (type) {\n    case 'subscribe':\n      if (!canAccessRoom(client, roomName)) {\n        client.ws.write(JSON.stringify({ type: 'error', message: 'ROOM_FORBIDDEN', room: roomName }));\n        return;\n      }\n      wsManager.joinRoom(client.id, roomName);\n      client.ws.write(JSON.stringify({ type: 'subscribed', room: roomName }));\n      break;\n\n    case 'unsubscribe':\n      wsManager.leaveRoom(client.id, roomName);\n      client.ws.write(JSON.stringify({ type: 'unsubscribed', room: roomName }));\n      break;\n\r\n    case 'get-history':\r\n      const limit = typeof data?.limit === 'number' ? data.limit : 50;\n      const history = wsManager.getEventHistory(limit);\n      client.ws.write(JSON.stringify({ type: 'history', data: history }));\n      break;\n\r\n    case 'get-stats':\r\n      if (client.isAdmin) {\r\n        const stats = wsManager.getStats();\r\n        client.ws.write(JSON.stringify({ type: 'stats', data: stats }));\r\n      }\r\n      break;\r\n\r\n    case 'ping':\r\n      client.ws.write(JSON.stringify({ type: 'pong', timestamp: new Date().toISOString() }));\r\n      break;\r\n\r\n    default:\r\n      typedLogger.warn('Unknown WebSocket message type', { type });\n  }\n}\n\nfunction canAccessRoom(client: WebSocketClient, room: string): boolean {\n  if (!room) return false;\n  if (room === 'admin' || room === 'dashboard' || room === 'marketplace' || room === 'rewards') {\n    return client.isAdmin;\n  }\n  if (room.startsWith('user:')) {\n    return client.isAdmin || room === `user:${client.userId}`;\n  }\n  if (room.startsWith('game') || room.startsWith('geo')) {\n    return true;\n  }\n  if (room === 'game-events') {\n    return true;\n  }\n  return client.isAdmin;\n}\n\r\nexport function broadcastGameEvent(event: Metadata) {\n  const basePayload = {\n    data: event,\n    timestamp: new Date().toISOString()\n  };\n  const message = { type: 'game-event', ...basePayload };\n  const legacyMessage = { type: 'game_event', ...basePayload };\n  wsManager.queueEvent(event);\n  wsManager.broadcastToRoom('game-events', message);\n  wsManager.broadcastToRoom('game-events', legacyMessage);\n  \r\n  // Also emit to Socket.IO if available\r\n  if (socketIO) {\r\n    socketIO.to('game').emit('game_event', event);\r\n  }\r\n}\r\n\r\nexport function broadcastAdminEvent(event: Metadata) {\n  const message = {\r\n    type: 'admin-event',\r\n    data: event,\r\n    timestamp: new Date().toISOString()\r\n  };\r\n  wsManager.queueEvent(event);\r\n  wsManager.broadcastToAdmins(message);\r\n  \r\n  // Also emit to Socket.IO rooms\r\n  if (socketIO) {\r\n    const eventType = typeof event.type === 'string' ? event.type : 'admin_update';\n    \r\n    // Send to all admin rooms\r\n    socketIO.to('admin').emit(eventType, event);\r\n    socketIO.to('dashboard').emit(eventType, event);\r\n    socketIO.to('dashboard').emit('stats_update', { stats: event.stats || event });\n    \r\n    // Send marketplace events to marketplace room\r\n    if (eventType.includes('marketplace')) {\r\n      socketIO.to('marketplace').emit(eventType, event);\r\n      socketIO.to('rewards').emit(eventType, event);\r\n    }\r\n    \r\n    // Send reward events to rewards room\r\n    if (eventType.includes('reward') || eventType.includes('redemption')) {\r\n      socketIO.to('rewards').emit(eventType, event);\r\n      socketIO.to('marketplace').emit(eventType, event);\r\n    }\r\n    \r\n    typedLogger.debug('Socket.IO admin event emitted', { eventType, rooms: ['admin', 'dashboard', 'marketplace', 'rewards'] });\r\n  }\r\n}\r\n\r\nexport function broadcastUserNotification(userId: string, notification: Metadata) {\n  const message = {\r\n    type: 'notification',\r\n    data: notification,\r\n    timestamp: new Date().toISOString()\r\n  };\r\n  wsManager.broadcastToUser(userId, message);\r\n}\r\n\r\nexport function broadcastRoomEvent(room: string, event: Metadata) {\n  const message = {\r\n    type: 'room-event',\r\n    data: event,\r\n    timestamp: new Date().toISOString()\r\n  };\r\n  wsManager.queueEvent(event);\r\n  wsManager.broadcastToRoom(room, message);\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\middleware\\auth.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'logger' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'reply' is defined but never used. Allowed unused args must match /^_/u.","line":220,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":220,"endColumn":22}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';\nimport { verifyToken, extractTokenFromHeader } from '@/lib/jwt';\nimport { User } from '@/models/User';\nimport { UserRole } from '@/types';\nimport { logger, logSecurity } from '@/lib/logger';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { parseCookies } from '@/utils/cookies';\nimport { ErrorLike } from '@/types';\n\nconst ACCESS_COOKIE_NAME = 'access_token';\nconst getErrorMessage = (error: ErrorLike) =>\n  error instanceof Error ? error.message : typeof error === 'string' ? error : error.message || 'Unknown error';\n\n// Extend FastifyRequest to include user\ndeclare module 'fastify' {\n  interface FastifyRequest {\n    user?: {\n      sub: string;\n      email?: string;\n      role: string;\n      deviceId?: string;\n      sessionId?: string; // Made optional to match common authentication patterns\n      displayName?: string;\n      iat?: number;\n      exp?: number;\n    };\n  }\n}\n\n/**\n * Authentication middleware\n */\nexport async function authenticate(\n  request: FastifyRequest,\n  reply: FastifyReply\n): Promise<void> {\n  try {\n    const headerToken = extractTokenFromHeader(request.headers.authorization);\n    const cookieToken = parseCookies(request.headers.cookie as string | undefined)[ACCESS_COOKIE_NAME];\n    const token = headerToken || cookieToken;\n    \n    if (!token) {\n      return reply.code(401).send({\n        success: false,\n        error: 'MISSING_TOKEN',\n        message: 'Authorization token is required',\n        timestamp: new Date().toISOString(),\n      });\n    }\n\n    const verificationResult = await verifyToken(token);\n    \n    if (!verificationResult.valid || !verificationResult.decoded) {\n      logSecurity('invalid_token_used', 'medium', {\n        token: token.substring(0, 20) + '...',\n        error: verificationResult.error,\n        ip: request.ip,\n        userAgent: request.headers['user-agent'],\n      });\n      \n      return reply.code(401).send({\n        success: false,\n        error: 'INVALID_TOKEN',\n        message: verificationResult.error || 'Invalid or expired token',\n        timestamp: new Date().toISOString(),\n      });\n    }\n\n    // Check if user still exists and is not banned\n    const user = await User.findById(verificationResult.decoded.sub);\n    \n    if (!user) {\n      logSecurity('token_for_deleted_user', 'medium', {\n        userId: verificationResult.decoded.sub,\n        ip: request.ip,\n      });\n      \n      return reply.code(401).send({\n        success: false,\n        error: 'USER_NOT_FOUND',\n        message: 'User account no longer exists',\n        timestamp: new Date().toISOString(),\n      });\n    }\n\n    if (user.isBanned) {\n      if (user.banExpiresAt && user.banExpiresAt > new Date()) {\n        logSecurity('banned_user_access_attempt', 'high', {\n          userId: user._id,\n          banReason: user.banReason,\n          banExpiresAt: user.banExpiresAt,\n          ip: request.ip,\n        });\n        \n        return reply.code(403).send({\n          success: false,\n          error: 'USER_BANNED',\n          message: 'Account is temporarily banned',\n          banExpiresAt: user.banExpiresAt,\n          timestamp: new Date().toISOString(),\n        });\n      } else {\n        // Unban expired bans\n        user.unban();\n        await user.save();\n      }\n    }\n\n    if (user.deletedAt) {\n      return reply.code(401).send({\n        success: false,\n        error: 'USER_DELETED',\n        message: 'User account has been deleted',\n        timestamp: new Date().toISOString(),\n      });\n    }\n\n    // Update last active timestamp (throttled to 5 minutes)\n    const now = Date.now();\n    const last = user.lastActive ? user.lastActive.getTime() : 0;\n    if (now - last > 5 * 60 * 1000) {\n      user.lastActive = new Date(now);\n      await user.save();\n    }\n\n    // Attach user to request\n    request.user = verificationResult.decoded;\n\n  } catch (error) {\n    typedLogger.error('Authentication middleware error', {\n      error: getErrorMessage(error),\n      ip: request.ip,\n      userAgent: request.headers['user-agent'],\n    });\n    \n    return reply.code(500).send({\n      success: false,\n      error: 'AUTHENTICATION_ERROR',\n      message: 'Authentication failed',\n      timestamp: new Date().toISOString(),\n    });\n  }\n}\n\n/**\n * Admin authentication middleware\n */\nexport async function requireAdmin(\n  request: FastifyRequest,\n  reply: FastifyReply\n): Promise<void> {\n  if (!request.user) {\n    return reply.code(401).send({\n      success: false,\n      error: 'AUTHENTICATION_REQUIRED',\n      message: 'Authentication required',\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  const adminRoles = [UserRole.ADMIN, UserRole.MODERATOR, UserRole.SUPER_ADMIN];\n  \n  if (!adminRoles.includes(request.user.role as UserRole)) {\n    logSecurity('unauthorized_admin_access', 'high', {\n      userId: request.user.sub,\n      role: request.user.role,\n      endpoint: request.url,\n      method: request.method,\n      ip: request.ip,\n    });\n    \n    return reply.code(403).send({\n      success: false,\n      error: 'INSUFFICIENT_PERMISSIONS',\n      message: 'Admin privileges required',\n      timestamp: new Date().toISOString(),\n    });\n  }\n}\n\n/**\n * Super admin authentication middleware\n */\nexport async function requireSuperAdmin(\n  request: FastifyRequest,\n  reply: FastifyReply\n): Promise<void> {\n  if (!request.user) {\n    return reply.code(401).send({\n      success: false,\n      error: 'AUTHENTICATION_REQUIRED',\n      message: 'Authentication required',\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  if (request.user.role !== UserRole.SUPER_ADMIN) {\n    logSecurity('unauthorized_super_admin_access', 'critical', {\n      userId: request.user.sub,\n      role: request.user.role,\n      endpoint: request.url,\n      method: request.method,\n      ip: request.ip,\n    });\n    \n    return reply.code(403).send({\n      success: false,\n      error: 'INSUFFICIENT_PERMISSIONS',\n      message: 'Super admin privileges required',\n      timestamp: new Date().toISOString(),\n    });\n  }\n}\n\n/**\n * Optional authentication middleware\n */\nexport async function optionalAuth(\n  request: FastifyRequest,\n  reply: FastifyReply\n): Promise<void> {\n  try {\n    const headerToken = extractTokenFromHeader(request.headers.authorization);\n    const cookieToken = parseCookies(request.headers.cookie as string | undefined)[ACCESS_COOKIE_NAME];\n    const token = headerToken || cookieToken;\n    \n    if (!token) {\n      return; // No token provided, continue without authentication\n    }\n\n    const verificationResult = await verifyToken(token);\n    \n    if (verificationResult.valid && verificationResult.decoded) {\n      // Check if user still exists\n      const user = await User.findById(verificationResult.decoded.sub);\n      \n      if (user && !user.isBanned && !user.deletedAt) {\n        request.user = verificationResult.decoded;\n        \n        // Update last active timestamp\n        user.lastActive = new Date();\n        await user.save();\n      }\n    }\n  } catch (error) {\n    // Silently fail for optional auth\n    typedLogger.debug('Optional auth failed', { error: getErrorMessage(error) });\n  }\n}\n\n/**\n * Role-based access control middleware factory\n */\nexport function requireRole(allowedRoles: UserRole[]) {\n  return async (request: FastifyRequest, reply: FastifyReply): Promise<void> => {\n    if (!request.user) {\n      return reply.code(401).send({\n        success: false,\n        error: 'AUTHENTICATION_REQUIRED',\n        message: 'Authentication required',\n        timestamp: new Date().toISOString(),\n      });\n    }\n\n    if (!allowedRoles.includes(request.user.role as UserRole)) {\n      logSecurity('unauthorized_role_access', 'medium', {\n        userId: request.user.sub,\n        userRole: request.user.role,\n        requiredRoles: allowedRoles,\n        endpoint: request.url,\n        method: request.method,\n        ip: request.ip,\n      });\n      \n      return reply.code(403).send({\n        success: false,\n        error: 'INSUFFICIENT_PERMISSIONS',\n        message: `Required roles: ${allowedRoles.join(', ')}`,\n        timestamp: new Date().toISOString(),\n      });\n    }\n  };\n}\n\n/**\n * Device validation middleware\n */\nexport async function validateDevice(\n  request: FastifyRequest,\n  reply: FastifyReply\n): Promise<void> {\n  const deviceId = request.headers['x-device-id'] as string;\n  const platform = request.headers['x-platform'] as string;\n  \n  if (!deviceId) {\n    return reply.code(400).send({\n      success: false,\n      error: 'MISSING_DEVICE_ID',\n      message: 'Device ID header is required',\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  if (!platform) {\n    return reply.code(400).send({\n      success: false,\n      error: 'MISSING_PLATFORM',\n      message: 'Platform header is required',\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  // Validate device ID format\n  if (deviceId.length < 10 || deviceId.length > 100) {\n    return reply.code(400).send({\n      success: false,\n      error: 'INVALID_DEVICE_ID',\n      message: 'Device ID must be between 10 and 100 characters',\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  // Validate platform\n  const validPlatforms = ['iOS', 'Android', 'Web'];\n  if (!validPlatforms.includes(platform)) {\n    return reply.code(400).send({\n      success: false,\n      error: 'INVALID_PLATFORM',\n      message: `Platform must be one of: ${validPlatforms.join(', ')}`,\n      timestamp: new Date().toISOString(),\n    });\n  }\n}\n\n/**\n * Rate limiting by user middleware\n */\nexport function rateLimitByUser(maxRequests: number, windowMs: number) {\n  const userRequests = new Map<string, { count: number; resetTime: number }>();\n  \n  return async (request: FastifyRequest, reply: FastifyReply): Promise<void> => {\n    if (!request.user) {\n      return; // Skip rate limiting for unauthenticated requests\n    }\n\n    const userId = request.user.sub;\n    const now = Date.now();\n    const userLimit = userRequests.get(userId);\n\n    if (!userLimit || now > userLimit.resetTime) {\n      // Reset or create new limit\n      userRequests.set(userId, {\n        count: 1,\n        resetTime: now + windowMs,\n      });\n      return;\n    }\n\n    if (userLimit.count >= maxRequests) {\n      const retryAfter = Math.ceil((userLimit.resetTime - now) / 1000);\n      \n      logSecurity('user_rate_limit_exceeded', 'low', {\n        userId,\n        endpoint: request.url,\n        method: request.method,\n        count: userLimit.count,\n        limit: maxRequests,\n      });\n      \n      return reply.code(429).send({\n        success: false,\n        error: 'RATE_LIMIT_EXCEEDED',\n        message: 'Too many requests from this user',\n        retryAfter,\n        timestamp: new Date().toISOString(),\n      });\n    }\n\n    userLimit.count++;\n  };\n}\n\n// Register middleware with Fastify\nexport default async function authPlugin(fastify: FastifyInstance) {\n  fastify.decorate('authenticate', authenticate);\n  fastify.decorate('requireAdmin', requireAdmin);\n  fastify.decorate('requireSuperAdmin', requireSuperAdmin);\n  fastify.decorate('optionalAuth', optionalAuth);\n  fastify.decorate('requireRole', requireRole);\n  fastify.decorate('validateDevice', validateDevice);\n  fastify.decorate('rateLimitByUser', rateLimitByUser);\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\middleware\\compression.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'logger' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":16}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyRequest, FastifyReply } from 'fastify';\nimport * as zlib from 'zlib';\nimport { logger } from '@/lib/logger';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { config } from '@/config';\nimport { ErrorLike, JSONValue } from '@/types';\n\n/**\n * Compression options\n */\ninterface CompressionOptions {\n  threshold?: number;\n  level?: number;\n  chunkSize?: number;\n  windowBits?: number;\n  memLevel?: number;\n  strategy?: number;\n  filter?: (request: FastifyRequest, reply: FastifyReply) => boolean;\n}\n\nconst getErrorMessage = (error: ErrorLike) =>\n  error instanceof Error ? error.message : typeof error === 'string' ? error : error.message || 'Unknown error';\n\n/**\n * Default compression options\n */\nconst defaultOptions: CompressionOptions = {\n  threshold: 1024, // Only compress responses larger than 1KB\n  level: 6, // Compression level (1-9, 6 is good balance)\n  chunkSize: 16 * 1024, // 16KB chunks\n  windowBits: 15,\n  memLevel: 8,\n  strategy: zlib.constants.Z_DEFAULT_STRATEGY,\n  filter: (request, reply) => {\n    // Default filter - compress most content types\n    return shouldCompress(request, reply);\n  },\n};\n\n/**\n * MIME types that should be compressed\n */\nconst compressibleTypes = [\n  'text/html',\n  'text/css',\n  'text/javascript',\n  'text/plain',\n  'text/xml',\n  'text/csv',\n  'application/javascript',\n  'application/json',\n  'application/xml',\n  'application/rss+xml',\n  'application/atom+xml',\n  'application/x-javascript',\n  'application/x-font-ttf',\n  'application/vnd.ms-fontobject',\n  'font/opentype',\n  'image/svg+xml',\n  'image/x-icon',\n  'application/octet-stream',\n];\n\n/**\n * Check if content should be compressed\n */\nfunction shouldCompress(request: FastifyRequest, reply: FastifyReply): boolean {\n  // Don't compress if client doesn't accept encoding\n  const acceptEncoding = request.headers['accept-encoding'] as string;\n  if (!acceptEncoding) {\n    return false;\n  }\n  \n  // Get content type\n  const contentType = reply.getHeader('content-type') as string;\n  if (!contentType) {\n    return false;\n  }\n  \n  // Check if content type is compressible\n  const isCompressible = compressibleTypes.some(type => \n    contentType.toLowerCase().includes(type)\n  );\n  \n  if (!isCompressible) {\n    return false;\n  }\n  \n  // Don't compress already compressed content\n  const contentEncoding = reply.getHeader('content-encoding');\n  if (contentEncoding) {\n    return false;\n  }\n  \n  // Don't compress small responses\n  const contentLength = reply.getHeader('content-length');\n  if (contentLength && parseInt(contentLength as string) < (defaultOptions.threshold || 1024)) {\n    return false;\n  }\n  \n  // Don't compress if cache-control says no-transform\n  const cacheControl = reply.getHeader('cache-control') as string;\n  if (cacheControl && cacheControl.includes('no-transform')) {\n    return false;\n  }\n  \n  return true;\n}\n\n/**\n * Get best compression method based on client support\n */\nfunction getBestEncoding(acceptEncoding: string): string | null {\n  const encodings = acceptEncoding.toLowerCase().split(',').map(e => e.trim());\n  \n  // Prefer brotli if available\n  if (encodings.some(e => e.includes('br'))) {\n    return 'br';\n  }\n  \n  // Then gzip\n  if (encodings.some(e => e.includes('gzip'))) {\n    return 'gzip';\n  }\n  \n  // Finally deflate\n  if (encodings.some(e => e.includes('deflate'))) {\n    return 'deflate';\n  }\n  \n  return null;\n}\n\n/**\n * Create compression stream based on encoding\n */\nfunction createCompressionStream(encoding: string, options: CompressionOptions): zlib.Gzip | zlib.Deflate | zlib.BrotliCompress {\n  const zlibOptions = {\n    level: options.level,\n    chunkSize: options.chunkSize,\n    windowBits: options.windowBits,\n    memLevel: options.memLevel,\n    strategy: options.strategy,\n  };\n  \n  switch (encoding) {\n    case 'gzip':\n      return zlib.createGzip(zlibOptions);\n    case 'deflate':\n      return zlib.createDeflate(zlibOptions);\n    case 'br':\n      return zlib.createBrotliCompress({\n        params: {\n          [zlib.constants.BROTLI_PARAM_QUALITY]: options.level || 6,\n          [zlib.constants.BROTLI_PARAM_SIZE_HINT]: options.chunkSize || 16384,\n        },\n      });\n    default:\n      throw new Error(`Unsupported encoding: ${encoding}`);\n  }\n}\n\n/**\n * Compression middleware\n */\nexport async function compression(\n  request: FastifyRequest,\n  reply: FastifyReply,\n  payload: Buffer | string | JSONValue | NodeJS.ReadableStream,\n  options: CompressionOptions = {}\n): Promise<Buffer | string | JSONValue | NodeJS.ReadableStream> {\n  const opts = { ...defaultOptions, ...options };\n  \n  // Skip compression if disabled\n  if (config.COMPRESSION_ENABLED === false) {\n    return payload;\n  }\n  \n  // Skip if filter says no\n  if (opts.filter && !opts.filter(request, reply)) {\n    return payload;\n  }\n  \n  // Skip if no payload or payload is not string/buffer\n  if (!payload || (typeof payload !== 'string' && !Buffer.isBuffer(payload))) {\n    return payload;\n  }\n  \n  // Skip if payload is too small\n  const payloadSize = Buffer.isBuffer(payload) ? payload.length : Buffer.byteLength(payload);\n  if (payloadSize < (opts.threshold || 1024)) {\n    return payload;\n  }\n  \n  // Get client's accepted encodings\n  const acceptEncoding = request.headers['accept-encoding'] as string;\n  if (!acceptEncoding) {\n    return payload;\n  }\n  \n  // Determine best encoding\n  const encoding = getBestEncoding(acceptEncoding);\n  if (!encoding) {\n    return payload;\n  }\n  \n  try {\n    // Create compression stream\n    const compressionStream = createCompressionStream(encoding, opts);\n    \n    // Convert payload to buffer if needed\n    const buffer = Buffer.isBuffer(payload) ? payload : Buffer.from(payload);\n    \n    // Compress the data\n    const compressed = await compressBuffer(buffer, compressionStream);\n    \n    // Set compression headers\n    reply.header('Content-Encoding', encoding);\n    reply.header('Content-Length', compressed.length);\n    reply.removeHeader('content-length'); // Remove original content-length\n    \n    // Add vary header for caching\n    const varyHeader = reply.getHeader('vary') as string;\n    if (varyHeader) {\n      if (!varyHeader.toLowerCase().includes('accept-encoding')) {\n        reply.header('Vary', `${varyHeader}, Accept-Encoding`);\n      }\n    } else {\n      reply.header('Vary', 'Accept-Encoding');\n    }\n    \n    // Log compression stats\n    const compressionRatio = ((buffer.length - compressed.length) / buffer.length * 100).toFixed(1);\n    \n    typedLogger.debug('Response compressed', {\n      encoding,\n      originalSize: buffer.length,\n      compressedSize: compressed.length,\n      compressionRatio: `${compressionRatio}%`,\n      url: request.url,\n    });\n    \n    return compressed;\n    \n  } catch (error) {\n    typedLogger.error('Compression failed', {\n      error: getErrorMessage(error),\n      encoding,\n      payloadSize,\n      url: request.url,\n    });\n    \n    // Return original payload if compression fails\n    return payload;\n  }\n}\n\n/**\n * Compress buffer using stream\n */\nfunction compressBuffer(buffer: Buffer, compressionStream: NodeJS.ReadWriteStream): Promise<Buffer> {\n  return new Promise((resolve, reject) => {\n    const chunks: Buffer[] = [];\n    \n    compressionStream.on('data', (chunk) => {\n      chunks.push(chunk);\n    });\n    \n    compressionStream.on('end', () => {\n      resolve(Buffer.concat(chunks));\n    });\n    \n    compressionStream.on('error', (error) => {\n      reject(error);\n    });\n    \n    compressionStream.write(buffer);\n    compressionStream.end();\n  });\n}\n\n/**\n * Create compression middleware with custom options\n */\nexport function createCompressionMiddleware(options: CompressionOptions = {}) {\n  return async (\n    request: FastifyRequest,\n    reply: FastifyReply,\n    payload: Buffer | string | JSONValue | NodeJS.ReadableStream\n  ): Promise<Buffer | string | JSONValue | NodeJS.ReadableStream> => {\n    return compression(request, reply, payload, options);\n  };\n}\n\n/**\n * High compression for static assets\n */\nexport const highCompression = createCompressionMiddleware({\n  level: 9, // Maximum compression\n  threshold: 512, // Compress smaller files too\n  filter: (request, reply) => {\n    // Only for static assets\n    const url = request.url;\n    return url.includes('/static/') || url.includes('/assets/') || shouldCompress(request, reply);\n  },\n});\n\n/**\n * Fast compression for API responses\n */\nexport const fastCompression = createCompressionMiddleware({\n  level: 1, // Fast compression\n  threshold: 2048, // Only larger responses\n  filter: (request, reply) => {\n    // Only for API responses\n    const url = request.url;\n    return url.startsWith('/api/') && shouldCompress(request, reply);\n  },\n});\n\n/**\n * Adaptive compression based on response size\n */\nexport const adaptiveCompression = createCompressionMiddleware({\n  level: 6, // Default level\n  filter: (request, reply) => {\n    if (!shouldCompress(request, reply)) {\n      return false;\n    }\n    \n    // Adjust compression level based on response size\n    const contentLength = reply.getHeader('content-length');\n    if (contentLength) {\n      const size = parseInt(contentLength as string);\n      \n      // Use higher compression for larger responses\n      if (size > 100 * 1024) { // > 100KB\n        defaultOptions.level = 9;\n      } else if (size > 10 * 1024) { // > 10KB\n        defaultOptions.level = 6;\n      } else {\n        defaultOptions.level = 3;\n      }\n    }\n    \n    return true;\n  },\n});\n\n/**\n * Get appropriate compression middleware based on environment\n */\nexport function getCompressionMiddleware(): (\n  request: FastifyRequest,\n  reply: FastifyReply,\n  payload: Buffer | string | JSONValue | NodeJS.ReadableStream\n) => Promise<Buffer | string | JSONValue | NodeJS.ReadableStream> {\n  if (config.NODE_ENV === 'production') {\n    return adaptiveCompression;\n  } else if (config.NODE_ENV === 'development') {\n    return fastCompression;\n  } else {\n    return compression;\n  }\n}\n\n/**\n * Pre-compression for static files\n */\nexport async function precompressStaticFiles(filePath: string): Promise<void> {\n  // This would be used in a build step to pre-compress static files\n  const fs = await import('fs');\n  const path = await import('path');\n  \n  try {\n    const content = await fs.promises.readFile(filePath);\n    \n    // Create gzip version\n    const gzipped = await compressBuffer(content, zlib.createGzip({ level: 9 }));\n    await fs.promises.writeFile(`${filePath}.gz`, gzipped);\n    \n    // Create brotli version if available\n    if (zlib.createBrotliCompress) {\n      const brotli = await compressBuffer(content, zlib.createBrotliCompress({\n        params: {\n          [zlib.constants.BROTLI_PARAM_QUALITY]: 9,\n        },\n      }));\n      await fs.promises.writeFile(`${filePath}.br`, brotli);\n    }\n    \n    typedLogger.info('Static file pre-compressed', {\n      file: path.basename(filePath),\n      originalSize: content.length,\n      gzipSize: gzipped.length,\n    });\n    \n  } catch (error) {\n    typedLogger.error('Failed to pre-compress static file', {\n      file: filePath,\n      error: getErrorMessage(error),\n    });\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\middleware\\cors.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'logger' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'request' is defined but never used. Allowed unused args must match /^_/u.","line":303,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":303,"endColumn":51}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyRequest, FastifyReply } from 'fastify';\nimport { config } from '@/config';\nimport { logger } from '@/lib/logger';\nimport { typedLogger } from '@/lib/typed-logger';\n\n/**\n * CORS configuration options\n */\ninterface CorsOptions {\n  origin: string | string[] | boolean | ((origin: string, request: FastifyRequest) => boolean);\n  credentials?: boolean;\n  methods?: string[];\n  allowedHeaders?: string[];\n  exposedHeaders?: string[];\n  maxAge?: number;\n  preflightContinue?: boolean;\n  optionsSuccessStatus?: number;\n}\n\n/**\n * Default CORS configuration\n */\nconst defaultCorsOptions: CorsOptions = {\n  origin: config.CORS_ORIGINS || [\n    'http://localhost:3000',\n    'http://localhost:3001',\n    'http://localhost:5173',\n    'http://127.0.0.1:5173',\n  ],\n  credentials: true,\n  methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS', 'HEAD'],\n  allowedHeaders: [\n    'Origin',\n    'X-Requested-With',\n    'Content-Type',\n    'Accept',\n    'Authorization',\n    'X-Request-ID',\n    'X-Device-ID',\n    'X-Platform',\n    'X-App-Version',\n    'X-Session-ID',\n    'X-CSRF-Token',\n    'X-Real-IP',\n    'X-Forwarded-For',\n    'User-Agent',\n  ],\n  exposedHeaders: [\n    'X-RateLimit-Limit',\n    'X-RateLimit-Remaining',\n    'X-RateLimit-Reset',\n    'X-Request-ID',\n    'X-Response-Time',\n    'Retry-After',\n  ],\n  maxAge: 86400, // 24 hours\n  optionsSuccessStatus: 204,\n};\n\n/**\n * Check if origin is allowed\n */\nfunction isOriginAllowed(origin: string, allowedOrigins: string | string[] | boolean): boolean {\n  if (allowedOrigins === true) {\n    return true;\n  }\n  \n  if (allowedOrigins === false) {\n    return false;\n  }\n  \n  if (typeof allowedOrigins === 'string') {\n    return origin === allowedOrigins || allowedOrigins === '*';\n  }\n  \n  if (Array.isArray(allowedOrigins)) {\n    return allowedOrigins.includes(origin) || allowedOrigins.includes('*');\n  }\n  \n  return false;\n}\n\n/**\n * Get allowed origin for request\n */\nfunction getAllowedOrigin(\n  request: FastifyRequest,\n  corsOptions: CorsOptions\n): string | null {\n  const origin = request.headers.origin;\n  \n  if (!origin) {\n    // No origin header (same-origin request or non-browser)\n    return null;\n  }\n  \n  if (typeof corsOptions.origin === 'function') {\n    return corsOptions.origin(origin, request) ? origin : null;\n  }\n  \n  if (isOriginAllowed(origin, corsOptions.origin)) {\n    return origin;\n  }\n  \n  // Check for development/localhost patterns\n  if (config.NODE_ENV === 'development') {\n    const localhostPattern = /^https?:\\/\\/(localhost|127\\.0\\.0\\.1|0\\.0\\.0\\.0)(:\\d+)?$/;\n    if (localhostPattern.test(origin)) {\n      return origin;\n    }\n  }\n  \n  return null;\n}\n\n/**\n * CORS middleware\n */\nexport async function cors(\n  request: FastifyRequest,\n  reply: FastifyReply,\n  options: Partial<CorsOptions> = {}\n): Promise<void> {\n  const corsOptions: CorsOptions = { ...defaultCorsOptions, ...options };\n  const origin = request.headers.origin;\n  const method = request.method;\n  \n  // Log CORS request for debugging\n  if (config.NODE_ENV === 'development') {\n    typedLogger.debug('CORS request', {\n      origin,\n      method,\n      url: request.url,\n      headers: request.headers,\n    });\n  }\n  \n  // Handle preflight requests\n  if (method === 'OPTIONS') {\n    await handlePreflightRequest(request, reply, corsOptions);\n    return;\n  }\n  \n  // Handle actual requests\n  await handleActualRequest(request, reply, corsOptions);\n}\n\n/**\n * Handle preflight OPTIONS request\n */\nasync function handlePreflightRequest(\n  request: FastifyRequest,\n  reply: FastifyReply,\n  corsOptions: CorsOptions\n): Promise<void> {\n  const origin = request.headers.origin;\n  const requestMethod = request.headers['access-control-request-method'];\n  const requestHeaders = request.headers['access-control-request-headers'];\n  \n  // Check if origin is allowed\n  const allowedOrigin = getAllowedOrigin(request, corsOptions);\n  \n  if (!allowedOrigin && origin) {\n    typedLogger.warn('CORS preflight rejected - origin not allowed', {\n      origin,\n      ip: request.ip,\n      userAgent: request.headers['user-agent'],\n    });\n    \n    reply.code(403).send({\n      success: false,\n      error: 'Forbidden',\n      message: 'CORS origin not allowed',\n      type: 'CORS_ORIGIN_NOT_ALLOWED',\n    });\n    return;\n  }\n  \n  // Set CORS headers for preflight\n  if (allowedOrigin) {\n    reply.header('Access-Control-Allow-Origin', allowedOrigin);\n  }\n  \n  if (corsOptions.credentials) {\n    reply.header('Access-Control-Allow-Credentials', 'true');\n  }\n  \n  // Allow requested method if it's in allowed methods\n  if (requestMethod && corsOptions.methods?.includes(requestMethod)) {\n    reply.header('Access-Control-Allow-Methods', corsOptions.methods.join(', '));\n  } else if (requestMethod) {\n    typedLogger.warn('CORS preflight rejected - method not allowed', {\n      origin,\n      requestMethod,\n      allowedMethods: corsOptions.methods,\n    });\n    \n    reply.code(405).send({\n      success: false,\n      error: 'Method Not Allowed',\n      message: `Method ${requestMethod} not allowed`,\n      type: 'CORS_METHOD_NOT_ALLOWED',\n    });\n    return;\n  }\n  \n  // Allow requested headers if they're in allowed headers\n  if (requestHeaders) {\n    const requestedHeaders = requestHeaders.split(',').map(h => h.trim().toLowerCase());\n    const allowedHeadersLower = corsOptions.allowedHeaders?.map(h => h.toLowerCase()) || [];\n    \n    const invalidHeaders = requestedHeaders.filter(h => !allowedHeadersLower.includes(h));\n    \n    if (invalidHeaders.length > 0) {\n      typedLogger.warn('CORS preflight rejected - headers not allowed', {\n        origin,\n        invalidHeaders,\n        allowedHeaders: corsOptions.allowedHeaders,\n      });\n      \n      reply.code(403).send({\n        success: false,\n        error: 'Forbidden',\n        message: `Headers not allowed: ${invalidHeaders.join(', ')}`,\n        type: 'CORS_HEADERS_NOT_ALLOWED',\n      });\n      return;\n    }\n    \n    reply.header('Access-Control-Allow-Headers', corsOptions.allowedHeaders?.join(', ') || '');\n  }\n  \n  // Set max age for preflight cache\n  if (corsOptions.maxAge) {\n    reply.header('Access-Control-Max-Age', corsOptions.maxAge.toString());\n  }\n  \n  // Send successful preflight response\n  reply.code(corsOptions.optionsSuccessStatus || 204).send();\n}\n\n/**\n * Handle actual CORS request\n */\nasync function handleActualRequest(\n  request: FastifyRequest,\n  reply: FastifyReply,\n  corsOptions: CorsOptions\n): Promise<void> {\n  const origin = request.headers.origin;\n  \n  // Check if origin is allowed\n  const allowedOrigin = getAllowedOrigin(request, corsOptions);\n  \n  if (!allowedOrigin && origin) {\n    typedLogger.warn('CORS request rejected - origin not allowed', {\n      origin,\n      method: request.method,\n      url: request.url,\n      ip: request.ip,\n    });\n    \n    reply.code(403).send({\n      success: false,\n      error: 'Forbidden',\n      message: 'CORS origin not allowed',\n      type: 'CORS_ORIGIN_NOT_ALLOWED',\n    });\n    return;\n  }\n  \n  // Set CORS headers for actual request\n  if (allowedOrigin) {\n    reply.header('Access-Control-Allow-Origin', allowedOrigin);\n  }\n  \n  if (corsOptions.credentials) {\n    reply.header('Access-Control-Allow-Credentials', 'true');\n  }\n  \n  // Expose headers to client\n  if (corsOptions.exposedHeaders?.length) {\n    reply.header('Access-Control-Expose-Headers', corsOptions.exposedHeaders.join(', '));\n  }\n  \n  // Vary header for caching\n  reply.header('Vary', 'Origin');\n}\n\n/**\n * Create CORS middleware with custom options\n */\nexport function createCorsMiddleware(options: Partial<CorsOptions> = {}) {\n  return async (request: FastifyRequest, reply: FastifyReply): Promise<void> => {\n    await cors(request, reply, options);\n  };\n}\n\n/**\n * Strict CORS for production\n */\nexport const strictCors = createCorsMiddleware({\n  origin: (origin: string, request: FastifyRequest) => {\n    // Only allow specific production domains\n    const allowedDomains = [\n      'https://yallacatch.tn',\n      'https://www.yallacatch.tn',\n      'https://admin.yallacatch.tn',\n      'https://api.yallacatch.tn',\n    ];\n    \n    return allowedDomains.includes(origin);\n  },\n  credentials: true,\n  methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'],\n  maxAge: 3600, // 1 hour\n});\n\n/**\n * Development CORS (more permissive)\n */\nexport const developmentCors = createCorsMiddleware({\n  origin: true, // Allow all origins in development\n  credentials: true,\n  methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS', 'HEAD'],\n  maxAge: 86400, // 24 hours\n});\n\n/**\n * API-only CORS (no credentials)\n */\nexport const apiCors = createCorsMiddleware({\n  origin: config.CORS_ORIGINS,\n  credentials: false,\n  methods: ['GET', 'POST'],\n  allowedHeaders: ['Content-Type', 'Authorization', 'X-Request-ID'],\n  maxAge: 3600,\n});\n\n/**\n * Get appropriate CORS middleware based on environment\n */\nexport function getCorsMiddleware(): (request: FastifyRequest, reply: FastifyReply) => Promise<void> {\n  if (config.NODE_ENV === 'production') {\n    return strictCors;\n  } else if (config.NODE_ENV === 'development') {\n    return developmentCors;\n  } else {\n    return cors;\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\middleware\\distributed-rate-limit.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'logger' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'config' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":16},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":139,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":139,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4098,4101],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4098,4101],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":196,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":196,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5798,5801],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5798,5801],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":212,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":212,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6247,6250],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6247,6250],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":217,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":217,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6383,6386],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6383,6386],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":242,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":242,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7082,7085],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7082,7085],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":247,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":247,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7218,7221],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7218,7221],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":270,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":270,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7845,7848],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7845,7848],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":346,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":346,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9785,9788],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9785,9788],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":389,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":389,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10937,10940],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10937,10940],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyRequest, FastifyReply } from 'fastify';\nimport { RateLimiterRedis, RateLimiterRes } from 'rate-limiter-flexible';\nimport { redisClient } from '@/config/redis';\nimport { logger, logSecurity } from '@/lib/logger';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { config } from '@/config';\n\n/**\n * Distributed rate limiter configurations\n */\nexport interface RateLimitConfig {\n  keyPrefix: string;\n  points: number;\n  duration: number;\n  blockDuration?: number;\n  execEvenly?: boolean;\n}\n\n/**\n * Create a distributed rate limiter using Redis\n */\nfunction createRateLimiter(rateLimitConfig: RateLimitConfig): RateLimiterRedis {\n  return new RateLimiterRedis({\n    storeClient: redisClient,\n    keyPrefix: rateLimitConfig.keyPrefix,\n    points: rateLimitConfig.points,\n    duration: rateLimitConfig.duration,\n    blockDuration: rateLimitConfig.blockDuration || rateLimitConfig.duration,\n    execEvenly: rateLimitConfig.execEvenly || false,\n  });\n}\n\n/**\n * Rate limiter instances\n */\nlet limiters: {\n  global: RateLimiterRedis;\n  auth: RateLimiterRedis;\n  user: RateLimiterRedis;\n  claims: RateLimiterRedis;\n  admin: RateLimiterRedis;\n  websocket: RateLimiterRedis;\n} | null = null;\n\nfunction ensureLimiters() {\n  if (limiters) return limiters;\n  if (!redisClient) {\n    throw new Error('Redis client not initialized for rate limiting');\n  }\n  limiters = {\n  // Global IP-based rate limiting\n  global: createRateLimiter({\n    keyPrefix: 'global_rate_limit',\n    points: 1000, // 1000 requests (increased for dev)\n    duration: 900, // per 15 minutes\n    blockDuration: 60, // block for 1 minute only\n  }),\n\n  // Authentication endpoints\n  auth: createRateLimiter({\n    keyPrefix: 'auth_rate_limit',\n    points: 20, // 20 attempts (increased for dev)\n    duration: 900, // per 15 minutes\n    blockDuration: 300, // block for 5 minutes\n  }),\n\n  // User-specific rate limiting\n  user: createRateLimiter({\n    keyPrefix: 'user_rate_limit',\n    points: 1000, // 1000 requests\n    duration: 3600, // per hour\n    blockDuration: 3600, // block for 1 hour\n  }),\n\n  // Claims (prize capture) rate limiting\n  claims: createRateLimiter({\n    keyPrefix: 'claims_rate_limit',\n    points: 50, // 50 claims\n    duration: 3600, // per hour\n    blockDuration: 1800, // block for 30 minutes\n  }),\n\n  // Admin operations\n  admin: createRateLimiter({\n    keyPrefix: 'admin_rate_limit',\n    points: 500, // 500 requests\n    duration: 3600, // per hour\n    blockDuration: 600, // block for 10 minutes\n  }),\n\n  // WebSocket connections\n  websocket: createRateLimiter({\n    keyPrefix: 'websocket_rate_limit',\n    points: 10, // 10 connections\n    duration: 60, // per minute\n    blockDuration: 300, // block for 5 minutes\n  }),\n  };\n  return limiters;\n}\n\n/**\n * Generic rate limiting middleware factory\n */\nexport function createRateLimitMiddleware(\n  limiter: RateLimiterRedis,\n  keyExtractor: (request: FastifyRequest) => string,\n  options: {\n    skipSuccessfulRequests?: boolean;\n    skipFailedRequests?: boolean;\n    onLimitReached?: (request: FastifyRequest, rateLimiterRes: RateLimiterRes) => void;\n  } = {}\n) {\n  return async (request: FastifyRequest, reply: FastifyReply): Promise<void> => {\n    try {\n      const key = keyExtractor(request);\n      \n      // Try to consume a point\n      const rateLimiterRes = await limiter.consume(key);\n      \n      // Add rate limit headers\n      reply.headers({\n        'X-RateLimit-Limit': limiter.points,\n        'X-RateLimit-Remaining': rateLimiterRes.remainingPoints || 0,\n        'X-RateLimit-Reset': (new Date(Date.now() + rateLimiterRes.msBeforeNext)).toISOString(),\n      });\n\n    } catch (rateLimiterRes) {\n      if (rateLimiterRes instanceof RateLimiterRes) {\n        const secs = Math.round(rateLimiterRes.msBeforeNext / 1000) || 1;\n        \n        // Log rate limit exceeded\n        logSecurity('rate_limit_exceeded', 'medium', {\n          key: keyExtractor(request),\n          ip: request.ip,\n          userAgent: request.headers['user-agent'],\n          endpoint: request.url,\n          method: request.method,\n          userId: (request as any).user?.sub,\n          retryAfter: secs,\n        });\n\n        // Call custom handler if provided\n        if (options.onLimitReached) {\n          options.onLimitReached(request, rateLimiterRes);\n        }\n\n        reply.code(429).headers({\n          'Retry-After': secs,\n          'X-RateLimit-Limit': limiter.points,\n          'X-RateLimit-Remaining': 0,\n          'X-RateLimit-Reset': (new Date(Date.now() + rateLimiterRes.msBeforeNext)).toISOString(),\n        });\n\n        return reply.send({\n          success: false,\n          error: 'RATE_LIMIT_EXCEEDED',\n          message: 'Too many requests',\n          retryAfter: secs,\n          timestamp: new Date().toISOString(),\n        });\n      }\n\n      // Other error\n      typedLogger.error('Rate limiter error', {\n        error: rateLimiterRes.message || rateLimiterRes,\n        key: keyExtractor(request),\n        ip: request.ip,\n      });\n\n      // Don't block on rate limiter errors, just log and continue\n    }\n  };\n}\n\n/**\n * IP-based rate limiting (skips OPTIONS preflight requests)\n */\nexport const ipRateLimit = async (request: FastifyRequest, reply: FastifyReply) => {\n  // Skip rate limiting for OPTIONS preflight requests\n  if (request.method === 'OPTIONS') {\n    return;\n  }\n  return createRateLimitMiddleware(ensureLimiters().global, (req) => req.ip)(request, reply);\n};\n\n/**\n * User-based rate limiting (skips OPTIONS preflight requests)\n */\nexport const userRateLimit = async (request: FastifyRequest, reply: FastifyReply) => {\n  // Skip rate limiting for OPTIONS preflight requests\n  if (request.method === 'OPTIONS') {\n    return;\n  }\n  return createRateLimitMiddleware(ensureLimiters().user, (req) => {\n    const user = (req as any).user;\n    return user?.sub || req.ip;\n  })(request, reply);\n};\n\n/**\n * Authentication rate limiting (skips OPTIONS preflight requests)\n */\nexport const authRateLimit = async (request: FastifyRequest, reply: FastifyReply) => {\n  // Skip rate limiting for OPTIONS preflight requests\n  if (request.method === 'OPTIONS') {\n    return;\n  }\n  return createRateLimitMiddleware(\n    ensureLimiters().auth,\n    (req) => {\n      const body = req.body as any;\n      return body?.email || req.ip;\n    },\n    {\n      onLimitReached: (req, rateLimiterRes) => {\n        const body = req.body as any;\n        logSecurity('auth_rate_limit_exceeded', 'high', {\n          email: body?.email,\n          ip: req.ip,\n          userAgent: req.headers['user-agent'],\n          endpoint: req.url,\n          method: req.method,\n          msBeforeNext: rateLimiterRes.msBeforeNext,\n        });\n      },\n    }\n  )(request, reply);\n};\n\n/**\n * Claims rate limiting (skips OPTIONS preflight requests)\n */\nexport const claimsRateLimit = async (request: FastifyRequest, reply: FastifyReply) => {\n  // Skip rate limiting for OPTIONS preflight requests\n  if (request.method === 'OPTIONS') {\n    return;\n  }\n  return createRateLimitMiddleware(\n    ensureLimiters().claims,\n    (req) => {\n      const user = (req as any).user;\n      return user?.sub || req.ip;\n    },\n    {\n      onLimitReached: (req, rateLimiterRes) => {\n        const user = (req as any).user;\n        logSecurity('claims_rate_limit_exceeded', 'medium', {\n          userId: user?.sub,\n          ip: req.ip,\n          endpoint: req.url,\n          msBeforeNext: rateLimiterRes.msBeforeNext,\n        });\n      },\n    }\n  )(request, reply);\n};\n\n/**\n * Admin rate limiting (skips OPTIONS preflight requests)\n */\nexport const adminRateLimit = async (request: FastifyRequest, reply: FastifyReply) => {\n  // Skip rate limiting for OPTIONS preflight requests\n  if (request.method === 'OPTIONS') {\n    return;\n  }\n  return createRateLimitMiddleware(\n    ensureLimiters().admin,\n    (req) => {\n      const user = (req as any).user;\n      return `admin:${user?.sub || req.ip}`;\n    }\n  )(request, reply);\n};\n\n/**\n * WebSocket connection rate limiting (skips OPTIONS preflight requests)\n */\nexport const websocketRateLimit = async (request: FastifyRequest, reply: FastifyReply) => {\n  // Skip rate limiting for OPTIONS preflight requests\n  if (request.method === 'OPTIONS') {\n    return;\n  }\n  return createRateLimitMiddleware(\n    ensureLimiters().websocket,\n    (req) => `ws:${req.ip}`\n  )(request, reply);\n};\n\n/**\n * Adaptive rate limiting based on user behavior\n */\nexport class AdaptiveRateLimiter {\n  private suspiciousUsers = new Set<string>();\n  private strictLimiter: RateLimiterRedis;\n  private normalLimiter: RateLimiterRedis;\n\n  constructor() {\n    this.strictLimiter = createRateLimiter({\n      keyPrefix: 'adaptive_strict',\n      points: 10,\n      duration: 60,\n      blockDuration: 300,\n    });\n\n    this.normalLimiter = createRateLimiter({\n      keyPrefix: 'adaptive_normal',\n      points: 100,\n      duration: 60,\n      blockDuration: 60,\n    });\n  }\n\n  markSuspicious(userId: string): void {\n    this.suspiciousUsers.add(userId);\n    \n    // Remove after 1 hour\n    setTimeout(() => {\n      this.suspiciousUsers.delete(userId);\n    }, 3600000);\n\n    logSecurity('user_marked_suspicious', 'high', {\n      userId,\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  async checkLimit(userId: string, ip: string): Promise<boolean> {\n    const key = userId || ip;\n    const limiter = this.suspiciousUsers.has(userId) ? this.strictLimiter : this.normalLimiter;\n\n    try {\n      await limiter.consume(key);\n      return true;\n    } catch (rateLimiterRes) {\n      if (rateLimiterRes instanceof RateLimiterRes) {\n        return false;\n      }\n      // On error, allow the request\n      return true;\n    }\n  }\n\n  createMiddleware() {\n    return async (request: FastifyRequest, reply: FastifyReply): Promise<void> => {\n      const user = (request as any).user;\n      const userId = user?.sub;\n      const ip = request.ip;\n\n      const allowed = await this.checkLimit(userId, ip);\n      \n      if (!allowed) {\n        logSecurity('adaptive_rate_limit_exceeded', 'high', {\n          userId,\n          ip,\n          isSuspicious: this.suspiciousUsers.has(userId),\n          endpoint: request.url,\n        });\n\n        return reply.code(429).send({\n          success: false,\n          error: 'RATE_LIMIT_EXCEEDED',\n          message: 'Request rate too high',\n          timestamp: new Date().toISOString(),\n        });\n      }\n    };\n  }\n}\n\n// Initialize rate limiters function\nexport function initializeRateLimiters() {\n  ensureLimiters();\n  typedLogger.info('Rate limiters initialized');\n}\n\n// Export singleton instance (lazy initialization to avoid Redis connection issues)\nlet _adaptiveRateLimiter: AdaptiveRateLimiter | null = null;\nexport const getAdaptiveRateLimiter = () => {\n  if (!_adaptiveRateLimiter) {\n    _adaptiveRateLimiter = new AdaptiveRateLimiter();\n  }\n  return _adaptiveRateLimiter;\n};\n\n/**\n * Rate limiting plugin for Fastify\n */\nexport default async function rateLimitPlugin(fastify: any) {\n  // Register rate limiters as decorators\n  fastify.decorate('rateLimiters', limiters);\n  fastify.decorate('ipRateLimit', ipRateLimit);\n  fastify.decorate('userRateLimit', userRateLimit);\n  fastify.decorate('authRateLimit', authRateLimit);\n  fastify.decorate('claimsRateLimit', claimsRateLimit);\n  fastify.decorate('adminRateLimit', adminRateLimit);\n  fastify.decorate('websocketRateLimit', websocketRateLimit);\n  fastify.decorate('adaptiveRateLimiter', getAdaptiveRateLimiter());\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\middleware\\error.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'logger' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":16},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":23,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[883,886],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[883,886],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":24,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[970,973],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[970,973],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":25,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":25,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1024,1027],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1024,1027],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":26,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1111,1114],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1111,1114],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":27,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1154,1157],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1154,1157],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":28,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1242,1245],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1242,1245],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":31,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1335,1338],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1335,1338],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":32,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":32,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1421,1424],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1421,1424],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":33,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1475,1478],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1475,1478],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":34,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1561,1564],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1561,1564],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":37,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1655,1658],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1655,1658],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":39,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1777,1780],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1777,1780],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":41,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1915,1918],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1915,1918],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":45,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2140,2143],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2140,2143],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":66,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":66,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2585,2588],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2585,2588],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":72,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2763,2766],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2763,2766],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":79,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2941,2944],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2941,2944],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":82,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":82,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3049,3052],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3049,3052],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":86,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":86,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3173,3176],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3173,3176],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":90,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3331,3334],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3331,3334],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":95,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":95,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3466,3469],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3466,3469],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":96,"column":81,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":96,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3561,3564],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3561,3564],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":124,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":124,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4502,4505],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4502,4505],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":154,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":154,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5316,5319],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5316,5319],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":168,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":168,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5829,5832],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5829,5832],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":26,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyError, FastifyRequest, FastifyReply } from 'fastify';\nimport { logger } from '@/lib/logger';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { config } from '@/config';\nimport { ZodError } from 'zod';\nimport { alerts } from '@/services/alerting';\n\n/**\n * Format Zod validation errors into meaningful messages for the frontend\n */\nfunction formatZodErrors(error: ZodError): { message: string; fields: Record<string, string> } {\n  const fields: Record<string, string> = {};\n  const messages: string[] = [];\n\n  for (const issue of error.issues) {\n    const path = issue.path.join('.');\n    let fieldMessage = issue.message;\n\n    // Add more context based on error code\n    if (issue.code === 'invalid_type') {\n      fieldMessage = `${path} must be ${issue.expected}, received ${issue.received}`;\n    } else if (issue.code === 'too_small') {\n      if ((issue as any).type === 'string') {\n        fieldMessage = `${path} must be at least ${(issue as any).minimum} characters`;\n      } else if ((issue as any).type === 'number') {\n        fieldMessage = `${path} must be at least ${(issue as any).minimum}`;\n      } else if ((issue as any).type === 'array') {\n        fieldMessage = `${path} must have at least ${(issue as any).minimum} items`;\n      }\n    } else if (issue.code === 'too_big') {\n      if ((issue as any).type === 'string') {\n        fieldMessage = `${path} must be at most ${(issue as any).maximum} characters`;\n      } else if ((issue as any).type === 'number') {\n        fieldMessage = `${path} must be at most ${(issue as any).maximum}`;\n      }\n    } else if (issue.code === 'invalid_string') {\n      if ((issue as any).validation === 'email') {\n        fieldMessage = `${path} must be a valid email address`;\n      } else if ((issue as any).validation === 'url') {\n        fieldMessage = `${path} must be a valid URL (e.g., https://example.com)`;\n      } else if ((issue as any).validation === 'datetime') {\n        fieldMessage = `${path} must be a valid ISO 8601 datetime (e.g., 2024-01-15T10:30:00Z)`;\n      }\n    } else if (issue.code === 'invalid_enum_value') {\n      const options = (issue as any).options?.join(', ') || 'valid options';\n      fieldMessage = `${path} must be one of: ${options}`;\n    }\n\n    fields[path || 'value'] = fieldMessage;\n    messages.push(fieldMessage);\n  }\n\n  return {\n    message: messages.join('; '),\n    fields,\n  };\n}\n\nexport async function errorHandler(\n  error: FastifyError,\n  request: FastifyRequest,\n  reply: FastifyReply\n) {\n  // Log error\n  typedLogger.error('Request error', {\n    error: (error as any).message,\n    stack: error.stack,\n    url: request.url,\n    method: request.method,\n    ip: request.ip,\n    userAgent: request.headers['user-agent'],\n    userId: (request as any).user?.sub,\n    statusCode: error.statusCode,\n  });\n\n  if (!error.statusCode || error.statusCode >= 500) {\n    alerts.high(\n      'Server Error Detected',\n      `${(error as any).message} on ${request.method} ${request.url}`,\n      'error_handler',\n      {\n        error: (error as any).message,\n        url: request.url,\n        method: request.method,\n        ip: request.ip,\n        userId: (request as any).user?.sub,\n        statusCode: error.statusCode,\n      }\n    ).catch((alertError) => {\n      typedLogger.warn('Alerting failed', { error: (alertError as any)?.message });\n    });\n  }\n\n  // Handle Zod validation errors with meaningful messages\n  if (error instanceof ZodError || (error as any).issues) {\n    const zodError = error instanceof ZodError ? error : new ZodError((error as any).issues || []);\n    const { message, fields } = formatZodErrors(zodError);\n    return reply.code(400).send({\n      success: false,\n      error: 'VALIDATION_ERROR',\n      message: `Validation failed: ${message}`,\n      fields, // Field-specific error messages for frontend form handling\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  // Handle Fastify schema validation errors\n  if (error.validation) {\n    return reply.code(400).send({\n      success: false,\n      error: 'VALIDATION_ERROR',\n      message: 'Request validation failed',\n      details: config.NODE_ENV === 'development' ? error.validation : undefined,\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  // Handle rate limit errors\n  if (error.statusCode === 429) {\n    return reply.code(429).send({\n      success: false,\n      error: 'RATE_LIMIT_EXCEEDED',\n      message: 'Too many requests. Please wait before trying again.',\n      retryAfter: (error as any).retryAfter || 60,\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  // Handle authentication errors\n  if (error.statusCode === 401) {\n    return reply.code(401).send({\n      success: false,\n      error: 'UNAUTHORIZED',\n      message: 'Authentication required. Please log in to access this resource.',\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  // Handle authorization errors\n  if (error.statusCode === 403) {\n    return reply.code(403).send({\n      success: false,\n      error: 'FORBIDDEN',\n      message: 'You do not have permission to perform this action.',\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  // Handle not found errors\n  if (error.statusCode === 404) {\n    return reply.code(404).send({\n      success: false,\n      error: 'NOT_FOUND',\n      message: (error as any).message || 'The requested resource was not found.',\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  // Generic error response\n  const statusCode = error.statusCode || 500;\n  const isDevelopment = config.NODE_ENV === 'development';\n  \n  return reply.code(statusCode).send({\n    success: false,\n    error: statusCode === 500 ? 'INTERNAL_SERVER_ERROR' : error.code || 'UNKNOWN_ERROR',\n    message: statusCode === 500 \n      ? 'An unexpected error occurred. Please try again later.' \n      : (error as any).message,\n    ...(isDevelopment && { stack: error.stack }),\n    timestamp: new Date().toISOString(),\n  });\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\middleware\\health-checks.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'logger' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":16}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';\nimport mongoose from 'mongoose';\nimport { redisClient } from '@/config/redis';\nimport { logger } from '@/lib/logger';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { config } from '@/config';\nimport { ErrorLike, Metadata } from '@/types';\n\n/**\n * Health check status interface\n */\ninterface HealthStatus {\n  status: 'healthy' | 'unhealthy' | 'degraded';\n  timestamp: string;\n  version: string;\n  environment: string;\n  uptime: number;\n  checks: {\n    [key: string]: {\n      status: 'pass' | 'fail' | 'warn';\n      message?: string;\n      responseTime?: number;\n      details?: Metadata;\n    };\n  };\n}\n\n/**\n * Individual health check interface\n */\ninterface HealthCheck {\n  name: string;\n  check: () => Promise<{ status: 'pass' | 'fail' | 'warn'; message?: string; details?: Metadata }>;\n  timeout?: number;\n  critical?: boolean;\n}\n\n/**\n * Health check registry\n */\nclass HealthCheckRegistry {\n  private checks = new Map<string, HealthCheck>();\n\n  register(check: HealthCheck): void {\n    this.checks.set(check.name, check);\n  }\n\n  async runAll(): Promise<HealthStatus['checks']> {\n    const results: HealthStatus['checks'] = {};\n\n    for (const [name, check] of this.checks.entries()) {\n      const startTime = Date.now();\n      \n      try {\n        const timeoutPromise = new Promise<never>((_, reject) => {\n          setTimeout(() => reject(new Error('Health check timeout')), check.timeout || 5000);\n        });\n\n        const checkPromise = check.check();\n        const result = await Promise.race([checkPromise, timeoutPromise]);\n        \n        results[name] = {\n          ...result,\n          responseTime: Date.now() - startTime,\n        };\n      } catch (error) {\n        results[name] = {\n          status: 'fail',\n          message: getErrorMessage(error),\n          responseTime: Date.now() - startTime,\n        };\n      }\n    }\n\n    return results;\n  }\n\n  async runCheck(name: string): Promise<HealthStatus['checks'][string] | null> {\n    const check = this.checks.get(name);\n    if (!check) return null;\n\n    const startTime = Date.now();\n    \n    try {\n      const result = await check.check();\n      return {\n        ...result,\n        responseTime: Date.now() - startTime,\n      };\n    } catch (error) {\n      return {\n        status: 'fail',\n        message: getErrorMessage(error),\n        responseTime: Date.now() - startTime,\n      };\n    }\n  }\n}\n\nconst getErrorMessage = (error: ErrorLike) =>\n  error instanceof Error ? error.message : typeof error === 'string' ? error : error.message || 'Unknown error';\n\n// Create health check registry\nexport const healthRegistry = new HealthCheckRegistry();\n\n/**\n * MongoDB health check\n */\nhealthRegistry.register({\n  name: 'mongodb',\n  timeout: 5000,\n  critical: true,\n  check: async () => {\n    try {\n      const state = mongoose.connection.readyState;\n      \n      switch (state) {\n        case 0:\n          return { status: 'fail', message: 'MongoDB disconnected' };\n        case 1:\n          // Test with a simple operation\n          await mongoose.connection.db.admin().ping();\n          return { \n            status: 'pass', \n            message: 'MongoDB connected',\n            details: {\n              readyState: 'connected',\n              host: mongoose.connection.host,\n              port: mongoose.connection.port,\n              name: mongoose.connection.name,\n            }\n          };\n        case 2:\n          return { status: 'warn', message: 'MongoDB connecting' };\n        case 3:\n          return { status: 'warn', message: 'MongoDB disconnecting' };\n        default:\n          return { status: 'fail', message: 'MongoDB unknown state' };\n      }\n    } catch (error) {\n      return { \n        status: 'fail', \n        message: `MongoDB error: ${getErrorMessage(error)}`,\n        details: { error: getErrorMessage(error) }\n      };\n    }\n  },\n});\n\n/**\n * Redis health check\n */\nhealthRegistry.register({\n  name: 'redis',\n  timeout: 5000,\n  critical: true,\n  check: async () => {\n    try {\n      if (!redisClient) {\n        return { status: 'fail', message: 'Redis client not initialized' };\n      }\n\n      const status = redisClient.status;\n      \n      if (status !== 'ready') {\n        return { \n          status: 'fail', \n          message: `Redis not ready: ${status}`,\n          details: { status }\n        };\n      }\n\n      // Test with a ping\n      const pong = await redisClient.ping();\n      \n      if (pong !== 'PONG') {\n        return { status: 'fail', message: 'Redis ping failed' };\n      }\n\n      return { \n        status: 'pass', \n        message: 'Redis connected',\n        details: {\n          status,\n          host: redisClient.options.host,\n          port: redisClient.options.port,\n          db: redisClient.options.db,\n        }\n      };\n    } catch (error) {\n      return { \n        status: 'fail', \n        message: `Redis error: ${getErrorMessage(error)}`,\n        details: { error: getErrorMessage(error) }\n      };\n    }\n  },\n});\n\n/**\n * Memory usage health check\n */\nhealthRegistry.register({\n  name: 'memory',\n  timeout: 1000,\n  critical: false,\n  check: async () => {\n    try {\n      const usage = process.memoryUsage();\n      const totalMB = Math.round(usage.rss / 1024 / 1024);\n      const heapUsedMB = Math.round(usage.heapUsed / 1024 / 1024);\n      const heapTotalMB = Math.round(usage.heapTotal / 1024 / 1024);\n      \n      // Warning if using more than 1GB\n      const warningThreshold = 1024; // MB\n      const criticalThreshold = 2048; // MB\n      \n      let status: 'pass' | 'warn' | 'fail' = 'pass';\n      let message = 'Memory usage normal';\n      \n      if (totalMB > criticalThreshold) {\n        status = 'fail';\n        message = `Memory usage critical: ${totalMB}MB`;\n      } else if (totalMB > warningThreshold) {\n        status = 'warn';\n        message = `Memory usage high: ${totalMB}MB`;\n      }\n\n      return {\n        status,\n        message,\n        details: {\n          rss: `${totalMB}MB`,\n          heapUsed: `${heapUsedMB}MB`,\n          heapTotal: `${heapTotalMB}MB`,\n          external: `${Math.round(usage.external / 1024 / 1024)}MB`,\n        }\n      };\n    } catch (error) {\n      return { \n        status: 'fail', \n        message: `Memory check error: ${getErrorMessage(error)}` \n      };\n    }\n  },\n});\n\n/**\n * Disk space health check\n */\nhealthRegistry.register({\n  name: 'disk',\n  timeout: 2000,\n  critical: false,\n  check: async () => {\n    try {\n      const fs = await import('fs/promises');\n      const stats = await fs.statfs('./');\n      \n      const totalBytes = stats.bavail * stats.bsize;\n      const totalGB = Math.round(totalBytes / 1024 / 1024 / 1024);\n      \n      // Warning if less than 1GB free\n      const warningThreshold = 1; // GB\n      const criticalThreshold = 0.5; // GB\n      \n      let status: 'pass' | 'warn' | 'fail' = 'pass';\n      let message = 'Disk space sufficient';\n      \n      if (totalGB < criticalThreshold) {\n        status = 'fail';\n        message = `Disk space critical: ${totalGB}GB free`;\n      } else if (totalGB < warningThreshold) {\n        status = 'warn';\n        message = `Disk space low: ${totalGB}GB free`;\n      }\n\n      return {\n        status,\n        message,\n        details: {\n          freeSpace: `${totalGB}GB`,\n          blockSize: stats.bsize,\n          availableBlocks: stats.bavail,\n        }\n      };\n    } catch (error) {\n      return { \n        status: 'warn', \n        message: `Disk check error: ${getErrorMessage(error)}` \n      };\n    }\n  },\n});\n\n/**\n * External services health check (example)\n */\nhealthRegistry.register({\n  name: 'external_services',\n  timeout: 10000,\n  critical: false,\n  check: async () => {\n    try {\n      const checks: Array<{ service: string; status: 'pass' | 'warn' | 'fail'; error?: string }> = [];\n      \n      // Check AWS S3 (if used)\n      if (config.AWS_S3_BUCKET) {\n        try {\n          const s3Module = await import('@aws-sdk/client-s3').catch(() => null);\n          if (!s3Module) {\n            checks.push({ service: 's3', status: 'warn', error: 'client_not_installed' });\n          } else {\n            type S3Module = {\n              S3Client: new (args: { region?: string }) => { send: (command: Metadata) => Promise<Metadata> };\n              HeadBucketCommand: new (args: { Bucket: string }) => Metadata;\n            };\n            const typedModule = s3Module as Partial<S3Module>;\n            if (typeof typedModule.S3Client !== 'function' || typeof typedModule.HeadBucketCommand !== 'function') {\n              checks.push({ service: 's3', status: 'warn', error: 'client_missing_exports' });\n            } else {\n              const s3Client = new typedModule.S3Client({ region: config.AWS_REGION });\n              await s3Client.send(new typedModule.HeadBucketCommand({ Bucket: config.AWS_S3_BUCKET }));\n              checks.push({ service: 's3', status: 'pass' });\n            }\n          }\n        } catch (error) {\n          checks.push({ service: 's3', status: 'fail', error: getErrorMessage(error) });\n        }\n      }\n\n      const failedServices = checks.filter(c => c.status === 'fail');\n      \n      if (failedServices.length === 0) {\n        return {\n          status: 'pass',\n          message: 'All external services available',\n          details: { services: checks }\n        };\n      } else if (failedServices.length < checks.length) {\n        return {\n          status: 'warn',\n          message: `Some external services unavailable: ${failedServices.map(s => s.service).join(', ')}`,\n          details: { services: checks }\n        };\n      } else {\n        return {\n          status: 'fail',\n          message: 'All external services unavailable',\n          details: { services: checks }\n        };\n      }\n    } catch (error) {\n      return { \n        status: 'warn', \n        message: `External services check error: ${getErrorMessage(error)}` \n      };\n    }\n  },\n});\n\n/**\n * Basic health check endpoint\n */\nexport async function healthCheck(\n  request: FastifyRequest,\n  reply: FastifyReply\n): Promise<void> {\n  const status: HealthStatus = {\n    status: 'healthy',\n    timestamp: new Date().toISOString(),\n    version: process.env.npm_package_version || '1.0.0',\n    environment: config.NODE_ENV,\n    uptime: Math.floor(process.uptime()),\n    checks: {},\n  };\n\n  reply.send(status);\n}\n\n/**\n * Detailed readiness check\n */\nexport async function readinessCheck(\n  request: FastifyRequest,\n  reply: FastifyReply\n): Promise<void> {\n  try {\n    const checks = await healthRegistry.runAll();\n    \n    // Determine overall status\n    const criticalChecks = ['mongodb', 'redis'];\n    const failedCritical = criticalChecks.some(name => \n      checks[name] && checks[name].status === 'fail'\n    );\n    \n    const hasFailures = Object.values(checks).some(check => check.status === 'fail');\n    const hasWarnings = Object.values(checks).some(check => check.status === 'warn');\n    \n    let overallStatus: 'healthy' | 'unhealthy' | 'degraded';\n    let statusCode: number;\n    \n    if (failedCritical) {\n      overallStatus = 'unhealthy';\n      statusCode = 503; // Service Unavailable\n    } else if (hasFailures) {\n      overallStatus = 'degraded';\n      statusCode = 200; // OK but degraded\n    } else if (hasWarnings) {\n      overallStatus = 'degraded';\n      statusCode = 200;\n    } else {\n      overallStatus = 'healthy';\n      statusCode = 200;\n    }\n\n    const status: HealthStatus = {\n      status: overallStatus,\n      timestamp: new Date().toISOString(),\n      version: process.env.npm_package_version || '1.0.0',\n      environment: config.NODE_ENV,\n      uptime: Math.floor(process.uptime()),\n      checks,\n    };\n\n    reply.code(statusCode).send(status);\n  } catch (error) {\n    typedLogger.error('Readiness check error', { error: getErrorMessage(error) });\n    \n    reply.code(503).send({\n      status: 'unhealthy',\n      timestamp: new Date().toISOString(),\n      version: process.env.npm_package_version || '1.0.0',\n      environment: config.NODE_ENV,\n      uptime: Math.floor(process.uptime()),\n      error: 'Health check failed',\n      checks: {},\n    });\n  }\n}\n\n/**\n * Liveness check (simpler, just checks if the process is running)\n */\nexport async function livenessCheck(\n  request: FastifyRequest,\n  reply: FastifyReply\n): Promise<void> {\n  reply.send({\n    status: 'alive',\n    timestamp: new Date().toISOString(),\n    uptime: Math.floor(process.uptime()),\n    pid: process.pid,\n  });\n}\n\n/**\n * Individual health check endpoint\n */\nexport async function individualHealthCheck(\n  request: FastifyRequest<{ Params: { checkName: string } }>,\n  reply: FastifyReply\n): Promise<void> {\n  const { checkName } = request.params;\n  \n  const result = await healthRegistry.runCheck(checkName);\n  \n  if (!result) {\n    return reply.code(404).send({\n      error: 'Health check not found',\n      availableChecks: Array.from(healthRegistry['checks'].keys()),\n    });\n  }\n\n  const statusCode = result.status === 'fail' ? 503 : 200;\n  reply.code(statusCode).send({\n    check: checkName,\n    ...result,\n    timestamp: new Date().toISOString(),\n  });\n}\n\n/**\n * Health check plugin for Fastify\n */\nexport default async function healthPlugin(fastify: FastifyInstance) {\n  // Register health check routes\n  fastify.get('/health', healthCheck);\n  fastify.get('/health/ready', readinessCheck);\n  fastify.get('/health/live', livenessCheck);\n  fastify.get('/health/check/:checkName', individualHealthCheck);\n  \n  // Register health registry as decorator\n  fastify.decorate('healthRegistry', healthRegistry);\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\middleware\\health.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'logger' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":16},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":26,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[557,560],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[557,560],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":87,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":87,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2096,2099],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2096,2099],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":120,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":120,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3052,3055],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3052,3055],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":128,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":128,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3321,3324],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3321,3324],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'startTime' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":156,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":156,"endColumn":18},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":185,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":185,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4779,4782],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4779,4782],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":208,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":208,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5300,5303],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5300,5303],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":213,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":213,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5442,5445],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5442,5445],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":257,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":257,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6497,6500],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6497,6500],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":306,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":306,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7480,7483],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7480,7483],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":351,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":351,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8603,8606],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8603,8606],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":398,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":398,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9723,9726],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9723,9726],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":417,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":417,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10239,10242],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10239,10242],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":439,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":439,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10884,10887],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10884,10887],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":460,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":460,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11436,11439],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11436,11439],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":481,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":481,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11978,11981],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11978,11981],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":492,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":492,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12316,12319],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12316,12319],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":18,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyRequest, FastifyReply } from 'fastify';\nimport { logger } from '@/lib/logger';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { config } from '@/config';\n\n/**\n * Health check status\n */\ninterface HealthStatus {\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  timestamp: string;\n  uptime: number;\n  version: string;\n  environment: string;\n  checks: HealthCheck[];\n}\n\n/**\n * Individual health check\n */\ninterface HealthCheck {\n  name: string;\n  status: 'pass' | 'fail' | 'warn';\n  duration: number;\n  message?: string;\n  details?: any;\n}\n\n/**\n * Health check function type\n */\ntype HealthCheckFunction = () => Promise<HealthCheck>;\n\n/**\n * Registered health checks\n */\nconst healthChecks = new Map<string, HealthCheckFunction>();\n\n/**\n * Register a health check\n */\nexport function registerHealthCheck(name: string, checkFn: HealthCheckFunction): void {\n  healthChecks.set(name, checkFn);\n  typedLogger.debug(`Health check registered: ${name}`);\n}\n\n/**\n * Basic health check endpoint\n */\nexport async function healthCheck(\n  request: FastifyRequest,\n  reply: FastifyReply\n): Promise<void> {\n  const startTime = Date.now();\n  \n  try {\n    const status: HealthStatus = {\n      status: 'healthy',\n      timestamp: new Date().toISOString(),\n      uptime: process.uptime(),\n      version: process.env.npm_package_version || '1.0.0',\n      environment: config.NODE_ENV,\n      checks: [],\n    };\n    \n    // Run all health checks\n    const checkPromises = Array.from(healthChecks.entries()).map(async ([name, checkFn]) => {\n      const checkStart = Date.now();\n      try {\n        const result = await Promise.race([\n          checkFn(),\n          new Promise<HealthCheck>((_, reject) => \n            setTimeout(() => reject(new Error('Health check timeout')), 5000)\n          ),\n        ]);\n        \n        return {\n          ...result,\n          name,\n          duration: Date.now() - checkStart,\n        };\n      } catch (error) {\n        return {\n          name,\n          status: 'fail' as const,\n          duration: Date.now() - checkStart,\n          message: (error as any).message,\n        };\n      }\n    });\n    \n    status.checks = await Promise.all(checkPromises);\n    \n    // Determine overall status\n    const hasFailures = status.checks.some(check => check.status === 'fail');\n    const hasWarnings = status.checks.some(check => check.status === 'warn');\n    \n    if (hasFailures) {\n      status.status = 'unhealthy';\n      reply.code(503);\n    } else if (hasWarnings) {\n      status.status = 'degraded';\n      reply.code(200);\n    } else {\n      status.status = 'healthy';\n      reply.code(200);\n    }\n    \n    // Add response time header\n    reply.header('X-Response-Time', `${Date.now() - startTime}ms`);\n    \n    // Cache control for health checks\n    reply.header('Cache-Control', 'no-cache, no-store, must-revalidate');\n    reply.header('Pragma', 'no-cache');\n    reply.header('Expires', '0');\n    \n    reply.send(status);\n    \n  } catch (error) {\n    typedLogger.error('Health check failed', { error: (error as any).message });\n    \n    reply.code(503).send({\n      status: 'unhealthy',\n      timestamp: new Date().toISOString(),\n      uptime: process.uptime(),\n      version: process.env.npm_package_version || '1.0.0',\n      environment: config.NODE_ENV,\n      error: (error as any).message,\n      checks: [],\n    });\n  }\n}\n\n/**\n * Liveness probe (basic server health)\n */\nexport async function livenessProbe(\n  request: FastifyRequest,\n  reply: FastifyReply\n): Promise<void> {\n  // Simple liveness check - just verify the server is running\n  reply.code(200).send({\n    status: 'alive',\n    timestamp: new Date().toISOString(),\n    uptime: process.uptime(),\n  });\n}\n\n/**\n * Readiness probe (dependencies health)\n */\nexport async function readinessProbe(\n  request: FastifyRequest,\n  reply: FastifyReply\n): Promise<void> {\n  const startTime = Date.now();\n  \n  try {\n    // Check critical dependencies only\n    const criticalChecks = ['database', 'redis'];\n    const checks: HealthCheck[] = [];\n    \n    for (const checkName of criticalChecks) {\n      const checkFn = healthChecks.get(checkName);\n      if (checkFn) {\n        const checkStart = Date.now();\n        try {\n          const result = await Promise.race([\n            checkFn(),\n            new Promise<HealthCheck>((_, reject) => \n              setTimeout(() => reject(new Error('Readiness check timeout')), 3000)\n            ),\n          ]);\n          \n          checks.push({\n            ...result,\n            name: checkName,\n            duration: Date.now() - checkStart,\n          });\n        } catch (error) {\n          checks.push({\n            name: checkName,\n            status: 'fail',\n            duration: Date.now() - checkStart,\n            message: (error as any).message,\n          });\n        }\n      }\n    }\n    \n    const hasFailures = checks.some(check => check.status === 'fail');\n    \n    if (hasFailures) {\n      reply.code(503).send({\n        status: 'not_ready',\n        timestamp: new Date().toISOString(),\n        checks,\n      });\n    } else {\n      reply.code(200).send({\n        status: 'ready',\n        timestamp: new Date().toISOString(),\n        checks,\n      });\n    }\n    \n  } catch (error) {\n    typedLogger.error('Readiness probe failed', { error: (error as any).message });\n    \n    reply.code(503).send({\n      status: 'not_ready',\n      timestamp: new Date().toISOString(),\n      error: (error as any).message,\n    });\n  }\n}\n\n/**\n * Database health check\n */\nexport async function databaseHealthCheck(): Promise<HealthCheck> {\n  try {\n    const mongooseModule = await import('mongoose');\n    const mongoose = mongooseModule.default;\n\n    if (mongoose.connection.readyState !== 1) {\n      return {\n        name: 'database',\n        status: 'fail',\n        duration: 0,\n        message: 'Database not connected',\n      };\n    }\n    \n    // Test database with a simple query\n    const startTime = Date.now();\n    await mongoose.connection.db.admin().ping();\n    const duration = Date.now() - startTime;\n    \n    return {\n      name: 'database',\n      status: 'pass',\n      duration,\n      message: 'Database connection healthy',\n      details: {\n        readyState: mongoose.connection.readyState,\n        host: mongoose.connection.host,\n        name: mongoose.connection.name,\n      },\n    };\n    \n  } catch (error) {\n    return {\n      name: 'database',\n      status: 'fail',\n      duration: 0,\n      message: `Database health check failed: ${(error as any).message}`,\n    };\n  }\n}\n\n/**\n * Redis health check\n */\nexport async function redisHealthCheck(): Promise<HealthCheck> {\n  try {\n    const { redisClient } = await import('@/config/redis');\n\n    if (!redisClient) {\n      return {\n        name: 'redis',\n        status: 'fail',\n        duration: 0,\n        message: 'Redis client not available',\n      };\n    }\n\n    const startTime = Date.now();\n    const pong = await redisClient.ping();\n    const duration = Date.now() - startTime;\n\n    if (pong !== 'PONG') {\n      return {\n        name: 'redis',\n        status: 'fail',\n        duration,\n        message: 'Redis ping failed',\n      };\n    }\n\n    return {\n      name: 'redis',\n      status: 'pass',\n      duration,\n      message: 'Redis connection healthy',\n      details: {\n        status: redisClient.status,\n      },\n    };\n\n  } catch (error) {\n    return {\n      name: 'redis',\n      status: 'fail',\n      duration: 0,\n      message: `Redis health check failed: ${(error as any).message}`,\n    };\n  }\n}\n\n/**\n * Memory health check\n */\nexport async function memoryHealthCheck(): Promise<HealthCheck> {\n  try {\n    const memUsage = process.memoryUsage();\n    const totalMemory = memUsage.heapTotal;\n    const usedMemory = memUsage.heapUsed;\n    const memoryUsagePercent = (usedMemory / totalMemory) * 100;\n    \n    let status: 'pass' | 'warn' | 'fail' = 'pass';\n    let message = 'Memory usage normal';\n    \n    if (memoryUsagePercent > 90) {\n      status = 'fail';\n      message = 'Memory usage critical';\n    } else if (memoryUsagePercent > 80) {\n      status = 'warn';\n      message = 'Memory usage high';\n    }\n    \n    return {\n      name: 'memory',\n      status,\n      duration: 0,\n      message,\n      details: {\n        heapUsed: memUsage.heapUsed,\n        heapTotal: memUsage.heapTotal,\n        external: memUsage.external,\n        rss: memUsage.rss,\n        usagePercent: Math.round(memoryUsagePercent * 100) / 100,\n      },\n    };\n    \n  } catch (error) {\n    return {\n      name: 'memory',\n      status: 'fail',\n      duration: 0,\n      message: `Memory health check failed: ${(error as any).message}`,\n    };\n  }\n}\n\n/**\n * Disk space health check\n */\nexport async function diskHealthCheck(): Promise<HealthCheck> {\n  try {\n    const fs = await import('fs');\n    const stats = await fs.promises.statfs(process.cwd());\n    \n    const totalSpace = stats.blocks * stats.bsize;\n    const freeSpace = stats.bavail * stats.bsize;\n    const usedSpace = totalSpace - freeSpace;\n    const usagePercent = (usedSpace / totalSpace) * 100;\n    \n    let status: 'pass' | 'warn' | 'fail' = 'pass';\n    let message = 'Disk space normal';\n    \n    if (usagePercent > 95) {\n      status = 'fail';\n      message = 'Disk space critical';\n    } else if (usagePercent > 85) {\n      status = 'warn';\n      message = 'Disk space low';\n    }\n    \n    return {\n      name: 'disk',\n      status,\n      duration: 0,\n      message,\n      details: {\n        totalSpace,\n        freeSpace,\n        usedSpace,\n        usagePercent: Math.round(usagePercent * 100) / 100,\n      },\n    };\n    \n  } catch (error) {\n    return {\n      name: 'disk',\n      status: 'fail',\n      duration: 0,\n      message: `Disk health check failed: ${(error as any).message}`,\n    };\n  }\n}\n\n/**\n * External service health check\n */\nexport async function externalServiceHealthCheck(): Promise<HealthCheck> {\n  try {\n    // Check external dependencies like AWS, etc.\n    const checks = [];\n    \n    // AWS S3 check (if configured)\n    if (config.AWS_S3_BUCKET) {\n      try {\n        // Simple AWS credential check\n        const s3Module = await import('@aws-sdk/client-s3').catch(() => null);\n        if (s3Module) {\n          const { S3Client, HeadBucketCommand } = s3Module as any;\n          const s3Client = new S3Client({ region: config.AWS_REGION });\n\n          const startTime = Date.now();\n          await s3Client.send(new HeadBucketCommand({ Bucket: config.AWS_S3_BUCKET }));\n\n          checks.push({\n            service: 'aws_s3',\n            status: 'pass',\n            duration: Date.now() - startTime,\n          });\n        } else {\n          checks.push({\n            service: 'aws_s3',\n            status: 'warn',\n            error: 'client_not_installed',\n          });\n        }\n      } catch (error) {\n        checks.push({\n          service: 'aws_s3',\n          status: 'fail',\n          error: (error as any).message,\n        });\n      }\n    }\n\n    \n    const hasFailures = checks.some(check => check.status === 'fail');\n    \n    return {\n      name: 'external_services',\n      status: hasFailures ? 'warn' : 'pass',\n      duration: 0,\n      message: hasFailures ? 'Some external services unavailable' : 'External services healthy',\n      details: { services: checks },\n    };\n    \n  } catch (error) {\n    return {\n      name: 'external_services',\n      status: 'fail',\n      duration: 0,\n      message: `External services health check failed: ${(error as any).message}`,\n    };\n  }\n}\n\n/**\n * Initialize default health checks\n */\nexport function initializeHealthChecks(): void {\n  registerHealthCheck('database', databaseHealthCheck);\n  registerHealthCheck('redis', redisHealthCheck);\n  registerHealthCheck('memory', memoryHealthCheck);\n  registerHealthCheck('disk', diskHealthCheck);\n  registerHealthCheck('external_services', externalServiceHealthCheck);\n  \n  typedLogger.info('Health checks initialized');\n}\n\n/**\n * Get health check summary\n */\nexport async function getHealthSummary(): Promise<any> {\n  const checks = await Promise.all(\n    Array.from(healthChecks.entries()).map(async ([name, checkFn]) => {\n      try {\n        const result = await checkFn();\n        return { ...result, name };\n      } catch (error) {\n        return {\n          name,\n          status: 'fail',\n          duration: 0,\n          message: (error as any).message,\n        };\n      }\n    })\n  );\n  \n  const healthy = checks.filter(c => c.status === 'pass').length;\n  const warnings = checks.filter(c => c.status === 'warn').length;\n  const failures = checks.filter(c => c.status === 'fail').length;\n  \n  return {\n    timestamp: new Date().toISOString(),\n    summary: {\n      total: checks.length,\n      healthy,\n      warnings,\n      failures,\n    },\n    checks,\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\middleware\\logging.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":17,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[469,472],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[469,472],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'payload' is defined but never used. Allowed unused args must match /^_/u.","line":17,"column":59,"nodeType":"Identifier","messageId":"unusedVar","endLine":17,"endColumn":66},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":38,"column":90,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":93,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1187,1190],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1187,1190],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'reply' is defined but never used. Allowed unused args must match /^_/u.","line":44,"column":44,"nodeType":"Identifier","messageId":"unusedVar","endLine":44,"endColumn":63},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":46,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1420,1423],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1420,1423],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":51,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":51,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1599,1602],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1599,1602],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'request' is defined but never used. Allowed unused args must match /^_/u.","line":80,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":80,"endColumn":58},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'reply' is defined but never used. Allowed unused args must match /^_/u.","line":80,"column":60,"nodeType":"Identifier","messageId":"unusedVar","endLine":80,"endColumn":79}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyRequest, FastifyReply } from 'fastify';\nimport { typedLogger } from '@/lib/typed-logger';\n\nexport async function requestLogger(request: FastifyRequest, reply: FastifyReply) {\n  const start = Date.now();\n  \n  // Log request\n  typedLogger.info('Request started', {\n    method: request.method,\n    url: request.url,\n    ip: request.ip,\n    userAgent: request.headers['user-agent'],\n    requestId: request.id,\n  });\n\n  // Log response when done\n  (reply as any).addHook('onSend', async (request, reply, payload) => {\n    const duration = Date.now() - start;\n    \n    typedLogger.info('Request completed', {\n      method: request.method,\n      url: request.url,\n      statusCode: reply.statusCode,\n      duration,\n      requestId: request.id,\n    });\n  });\n}\n\nexport async function security(request: FastifyRequest, reply: FastifyReply) {\n  // Add security headers\n  reply.header('X-Content-Type-Options', 'nosniff');\n  reply.header('X-Frame-Options', 'DENY');\n  reply.header('X-XSS-Protection', '1; mode=block');\n  reply.header('Referrer-Policy', 'strict-origin-when-cross-origin');\n}\n\nexport async function compression(request: FastifyRequest, reply: FastifyReply, payload: any) {\n  // Simple compression logic (in production, use @fastify/compress)\n  return payload;\n}\n\nexport const metrics = {\n  async onRequest(request: FastifyRequest, reply: FastifyReply) {\n    // Track request metrics\n    (request as any).startTime = Date.now();\n  },\n\n  async onResponse(request: FastifyRequest, reply: FastifyReply) {\n    // Track response metrics\n    const duration = Date.now() - ((request as any).startTime || 0);\n    \n    // In production, send to metrics service\n    typedLogger.debug('Request metrics', {\n      method: request.method,\n      url: request.url,\n      statusCode: reply.statusCode,\n      duration,\n    });\n  },\n\n  getMetrics() {\n    // Return Prometheus-style metrics\n    return `# HELP yallacatch_requests_total Total number of requests\n# TYPE yallacatch_requests_total counter\nyallacatch_requests_total 0\n\n# HELP yallacatch_request_duration_seconds Request duration in seconds\n# TYPE yallacatch_request_duration_seconds histogram\nyallacatch_request_duration_seconds_bucket{le=\"0.1\"} 0\nyallacatch_request_duration_seconds_bucket{le=\"0.5\"} 0\nyallacatch_request_duration_seconds_bucket{le=\"1.0\"} 0\nyallacatch_request_duration_seconds_bucket{le=\"+Inf\"} 0\nyallacatch_request_duration_seconds_sum 0\nyallacatch_request_duration_seconds_count 0\n`;\n  },\n};\n\nexport async function healthCheck(request: FastifyRequest, reply: FastifyReply) {\n  return {\n    status: 'ok',\n    timestamp: new Date().toISOString(),\n    version: process.env.npm_package_version || '1.0.0',\n    environment: process.env.NODE_ENV || 'development',\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\middleware\\metrics.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'reply' is defined but never used. Allowed unused args must match /^_/u.","line":41,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":41,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'now' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":251,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":251,"endColumn":12},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":337,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":337,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10718,10721],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10718,10721],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'reply' is defined but never used. Allowed unused args must match /^_/u.","line":416,"column":36,"nodeType":"Identifier","messageId":"unusedVar","endLine":416,"endColumn":55}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyRequest, FastifyReply } from 'fastify';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { config } from '@/config';\n\n/**\n * Metrics collector interface\n */\ninterface MetricsCollector {\n  httpRequestsTotal: Map<string, number>;\n  httpRequestDuration: Map<string, number[]>;\n  httpRequestSize: Map<string, number[]>;\n  httpResponseSize: Map<string, number[]>;\n  activeConnections: number;\n  errorCounts: Map<string, number>;\n  businessMetrics: Map<string, number>;\n}\n\n/**\n * Global metrics collector\n */\nconst metricsCollector: MetricsCollector = {\n  httpRequestsTotal: new Map(),\n  httpRequestDuration: new Map(),\n  httpRequestSize: new Map(),\n  httpResponseSize: new Map(),\n  activeConnections: 0,\n  errorCounts: new Map(),\n  businessMetrics: new Map(),\n};\n\n/**\n * Request timing storage\n */\nconst requestTimings = new Map<string, number>();\n\n/**\n * Metrics middleware - onRequest hook\n */\nexport async function onRequest(\n  request: FastifyRequest,\n  reply: FastifyReply\n): Promise<void> {\n  // Record request start time\n  const requestId = request.id;\n  requestTimings.set(requestId, Date.now());\n  \n  // Increment active connections\n  metricsCollector.activeConnections++;\n  \n  // Record request size\n  const contentLength = parseInt(request.headers['content-length'] || '0');\n  if (contentLength > 0) {\n    const sizeKey = `${request.method}:${getRoutePattern(request.url)}`;\n    if (!metricsCollector.httpRequestSize.has(sizeKey)) {\n      metricsCollector.httpRequestSize.set(sizeKey, []);\n    }\n    metricsCollector.httpRequestSize.get(sizeKey)!.push(contentLength);\n  }\n  \n  // Log request for debugging\n  if (config.METRICS_DEBUG) {\n    typedLogger.debug('Request started', {\n      requestId,\n      method: request.method,\n      url: request.url,\n      userAgent: request.headers['user-agent'],\n      ip: request.ip,\n    });\n  }\n}\n\n/**\n * Metrics middleware - onResponse hook\n */\nexport async function onResponse(\n  request: FastifyRequest,\n  reply: FastifyReply\n): Promise<void> {\n  const requestId = request.id;\n  const startTime = requestTimings.get(requestId);\n  \n  if (startTime) {\n    // Calculate request duration\n    const duration = Date.now() - startTime;\n    requestTimings.delete(requestId);\n    \n    // Record metrics\n    recordHttpMetrics(request, reply, duration);\n    \n    // Decrement active connections\n    metricsCollector.activeConnections--;\n    \n    // Record business metrics\n    recordBusinessMetrics(request, reply);\n    \n    // Log response for debugging\n    if (config.METRICS_DEBUG) {\n      typedLogger.debug('Request completed', {\n        requestId,\n        method: request.method,\n        url: request.url,\n        statusCode: reply.statusCode,\n        duration,\n        responseSize: reply.getHeader('content-length'),\n      });\n    }\n  }\n}\n\n/**\n * Record HTTP metrics\n */\nfunction recordHttpMetrics(\n  request: FastifyRequest,\n  reply: FastifyReply,\n  duration: number\n): void {\n  const method = request.method;\n  const route = getRoutePattern(request.url);\n  const statusCode = reply.statusCode;\n  const statusClass = Math.floor(statusCode / 100) * 100;\n  \n  // HTTP requests total\n  const totalKey = `${method}:${route}:${statusCode}`;\n  metricsCollector.httpRequestsTotal.set(\n    totalKey,\n    (metricsCollector.httpRequestsTotal.get(totalKey) || 0) + 1\n  );\n  \n  // HTTP request duration\n  const durationKey = `${method}:${route}`;\n  if (!metricsCollector.httpRequestDuration.has(durationKey)) {\n    metricsCollector.httpRequestDuration.set(durationKey, []);\n  }\n  metricsCollector.httpRequestDuration.get(durationKey)!.push(duration);\n  \n  // Keep only last 1000 duration measurements\n  const durations = metricsCollector.httpRequestDuration.get(durationKey)!;\n  if (durations.length > 1000) {\n    durations.splice(0, durations.length - 1000);\n  }\n  \n  // Response size\n  const responseSize = parseInt(reply.getHeader('content-length') as string || '0');\n  if (responseSize > 0) {\n    const responseSizeKey = `${method}:${route}`;\n    if (!metricsCollector.httpResponseSize.has(responseSizeKey)) {\n      metricsCollector.httpResponseSize.set(responseSizeKey, []);\n    }\n    metricsCollector.httpResponseSize.get(responseSizeKey)!.push(responseSize);\n  }\n  \n  // Error counts\n  if (statusClass >= 400) {\n    const errorKey = `${statusClass}:${route}`;\n    metricsCollector.errorCounts.set(\n      errorKey,\n      (metricsCollector.errorCounts.get(errorKey) || 0) + 1\n    );\n  }\n}\n\n/**\n * Record business-specific metrics\n */\nfunction recordBusinessMetrics(\n  request: FastifyRequest,\n  reply: FastifyReply\n): void {\n  const url = request.url;\n  const method = request.method;\n  const statusCode = reply.statusCode;\n  \n  // User registrations\n  if (method === 'POST' && url.includes('/auth/register') && statusCode === 201) {\n    incrementBusinessMetric('user_registrations_total');\n  }\n  \n  // User logins\n  if (method === 'POST' && url.includes('/auth/login') && statusCode === 200) {\n    incrementBusinessMetric('user_logins_total');\n  }\n  \n  // Prize claims\n  if (method === 'POST' && url.includes('/claims') && statusCode === 200) {\n    incrementBusinessMetric('prize_claims_total');\n  }\n  \n  // Reward redemptions\n  if (method === 'POST' && url.includes('/redeem') && statusCode === 200) {\n    incrementBusinessMetric('reward_redemptions_total');\n  }\n  \n  // Failed authentications\n  if (method === 'POST' && url.includes('/auth/') && statusCode === 401) {\n    incrementBusinessMetric('auth_failures_total');\n  }\n  \n  // API errors\n  if (statusCode >= 500) {\n    incrementBusinessMetric('api_errors_total');\n  }\n}\n\n/**\n * Increment business metric\n */\nfunction incrementBusinessMetric(metric: string, value: number = 1): void {\n  metricsCollector.businessMetrics.set(\n    metric,\n    (metricsCollector.businessMetrics.get(metric) || 0) + value\n  );\n}\n\n/**\n * Get route pattern from URL (remove IDs and query params)\n */\nfunction getRoutePattern(url: string): string {\n  return url\n    .split('?')[0] // Remove query params\n    .replace(/\\/[0-9a-f]{24}/g, '/:id') // Replace MongoDB ObjectIds\n    .replace(/\\/\\d+/g, '/:id') // Replace numeric IDs\n    .replace(/\\/[0-9a-f-]{36}/g, '/:uuid') // Replace UUIDs\n    .toLowerCase();\n}\n\n/**\n * Calculate percentile from array of numbers\n */\nfunction calculatePercentile(values: number[], percentile: number): number {\n  if (values.length === 0) return 0;\n  \n  const sorted = [...values].sort((a, b) => a - b);\n  const index = Math.ceil((percentile / 100) * sorted.length) - 1;\n  return sorted[Math.max(0, index)];\n}\n\n/**\n * Calculate average from array of numbers\n */\nfunction calculateAverage(values: number[]): number {\n  if (values.length === 0) return 0;\n  return values.reduce((sum, value) => sum + value, 0) / values.length;\n}\n\n/**\n * Generate Prometheus metrics format\n */\nexport function getMetrics(): string {\n  const lines: string[] = [];\n  const now = Date.now();\n  \n  // HTTP requests total\n  lines.push('# HELP http_requests_total Total number of HTTP requests');\n  lines.push('# TYPE http_requests_total counter');\n  \n  for (const [key, value] of metricsCollector.httpRequestsTotal.entries()) {\n    const [method, route, status] = key.split(':');\n    lines.push(`http_requests_total{method=\"${method}\",route=\"${route}\",status=\"${status}\"} ${value}`);\n  }\n  \n  // HTTP request duration\n  lines.push('# HELP http_request_duration_seconds HTTP request duration in seconds');\n  lines.push('# TYPE http_request_duration_seconds histogram');\n  \n  for (const [key, durations] of metricsCollector.httpRequestDuration.entries()) {\n    const [method, route] = key.split(':');\n    const durationsInSeconds = durations.map(d => d / 1000);\n    \n    const p50 = calculatePercentile(durationsInSeconds, 50);\n    const p95 = calculatePercentile(durationsInSeconds, 95);\n    const p99 = calculatePercentile(durationsInSeconds, 99);\n    const avg = calculateAverage(durationsInSeconds);\n    \n    lines.push(`http_request_duration_seconds{method=\"${method}\",route=\"${route}\",quantile=\"0.5\"} ${p50.toFixed(3)}`);\n    lines.push(`http_request_duration_seconds{method=\"${method}\",route=\"${route}\",quantile=\"0.95\"} ${p95.toFixed(3)}`);\n    lines.push(`http_request_duration_seconds{method=\"${method}\",route=\"${route}\",quantile=\"0.99\"} ${p99.toFixed(3)}`);\n    lines.push(`http_request_duration_seconds_sum{method=\"${method}\",route=\"${route}\"} ${(avg * durations.length).toFixed(3)}`);\n    lines.push(`http_request_duration_seconds_count{method=\"${method}\",route=\"${route}\"} ${durations.length}`);\n  }\n  \n  // Active connections\n  lines.push('# HELP http_connections_active Number of active HTTP connections');\n  lines.push('# TYPE http_connections_active gauge');\n  lines.push(`http_connections_active ${metricsCollector.activeConnections}`);\n  \n  // Error counts\n  lines.push('# HELP http_errors_total Total number of HTTP errors');\n  lines.push('# TYPE http_errors_total counter');\n  \n  for (const [key, value] of metricsCollector.errorCounts.entries()) {\n    const [status, route] = key.split(':');\n    lines.push(`http_errors_total{status=\"${status}\",route=\"${route}\"} ${value}`);\n  }\n  \n  // Business metrics\n  lines.push('# HELP yallacatch_business_events_total Total number of business events');\n  lines.push('# TYPE yallacatch_business_events_total counter');\n  \n  for (const [metric, value] of metricsCollector.businessMetrics.entries()) {\n    lines.push(`yallacatch_${metric} ${value}`);\n  }\n  \n  // System metrics\n  const memUsage = process.memoryUsage();\n  lines.push('# HELP nodejs_memory_usage_bytes Node.js memory usage in bytes');\n  lines.push('# TYPE nodejs_memory_usage_bytes gauge');\n  lines.push(`nodejs_memory_heap_used_bytes ${memUsage.heapUsed}`);\n  lines.push(`nodejs_memory_heap_total_bytes ${memUsage.heapTotal}`);\n  lines.push(`nodejs_memory_external_bytes ${memUsage.external}`);\n  lines.push(`nodejs_memory_rss_bytes ${memUsage.rss}`);\n  \n  // Process uptime\n  lines.push('# HELP nodejs_process_uptime_seconds Process uptime in seconds');\n  lines.push('# TYPE nodejs_process_uptime_seconds counter');\n  lines.push(`nodejs_process_uptime_seconds ${process.uptime()}`);\n  \n  // Event loop lag (if available)\n  if (process.hrtime) {\n    const start = process.hrtime();\n    setImmediate(() => {\n      const delta = process.hrtime(start);\n      const lag = (delta[0] * 1e9 + delta[1]) / 1e6; // Convert to milliseconds\n      \n      lines.push('# HELP nodejs_eventloop_lag_seconds Event loop lag in seconds');\n      lines.push('# TYPE nodejs_eventloop_lag_seconds gauge');\n      lines.push(`nodejs_eventloop_lag_seconds ${(lag / 1000).toFixed(6)}`);\n    });\n  }\n  \n  return lines.join('\\n') + '\\n';\n}\n\n/**\n * Get metrics in JSON format for debugging\n */\nexport function getMetricsJson(): any {\n  return {\n    timestamp: new Date().toISOString(),\n    http: {\n      requestsTotal: Object.fromEntries(metricsCollector.httpRequestsTotal),\n      activeConnections: metricsCollector.activeConnections,\n      errors: Object.fromEntries(metricsCollector.errorCounts),\n    },\n    business: Object.fromEntries(metricsCollector.businessMetrics),\n    system: {\n      memory: process.memoryUsage(),\n      uptime: process.uptime(),\n      cpuUsage: process.cpuUsage(),\n    },\n    performance: {\n      requestDurations: Array.from(metricsCollector.httpRequestDuration.entries()).map(\n        ([key, durations]) => ({\n          route: key,\n          count: durations.length,\n          avg: calculateAverage(durations),\n          p95: calculatePercentile(durations, 95),\n          p99: calculatePercentile(durations, 99),\n        })\n      ),\n    },\n  };\n}\n\n/**\n * Reset metrics (useful for testing)\n */\nexport function resetMetrics(): void {\n  metricsCollector.httpRequestsTotal.clear();\n  metricsCollector.httpRequestDuration.clear();\n  metricsCollector.httpRequestSize.clear();\n  metricsCollector.httpResponseSize.clear();\n  metricsCollector.activeConnections = 0;\n  metricsCollector.errorCounts.clear();\n  metricsCollector.businessMetrics.clear();\n  requestTimings.clear();\n}\n\n/**\n * Custom metric recording functions\n */\nexport const metrics = {\n  onRequest,\n  onResponse,\n  getMetrics,\n  getMetricsJson,\n  resetMetrics,\n  \n  // Custom metric functions\n  incrementCounter: (name: string, labels: Record<string, string> = {}, value: number = 1) => {\n    const key = `${name}:${JSON.stringify(labels)}`;\n    metricsCollector.businessMetrics.set(\n      key,\n      (metricsCollector.businessMetrics.get(key) || 0) + value\n    );\n  },\n  \n  recordDuration: (name: string, duration: number, labels: Record<string, string> = {}) => {\n    const key = `${name}:${JSON.stringify(labels)}`;\n    if (!metricsCollector.httpRequestDuration.has(key)) {\n      metricsCollector.httpRequestDuration.set(key, []);\n    }\n    metricsCollector.httpRequestDuration.get(key)!.push(duration);\n  },\n  \n  setGauge: (name: string, value: number, labels: Record<string, string> = {}) => {\n    const key = `${name}:${JSON.stringify(labels)}`;\n    metricsCollector.businessMetrics.set(key, value);\n  },\n};\n\n/**\n * Middleware to track custom business events\n */\nexport function trackBusinessEvent(eventName: string, labels: Record<string, string> = {}) {\n  return (request: FastifyRequest, reply: FastifyReply) => {\n    metrics.incrementCounter(`business_event_${eventName}`, {\n      ...labels,\n      method: request.method,\n      route: getRoutePattern(request.url),\n    });\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\middleware\\require-online.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'logger' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":16},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":115,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":115,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3245,3248],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3245,3248],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyRequest, FastifyReply } from 'fastify';\nimport { User } from '@/models';\nimport { logger } from '@/lib/logger';\nimport { typedLogger } from '@/lib/typed-logger';\n\n/**\n * Middleware to ensure user is online before performing certain actions\n * \n * This middleware checks if:\n * 1. User has synced recently (within last 5 minutes)\n * 2. User is not in offline mode\n * \n * Use this middleware for actions that require real-time connectivity:\n * - Marketplace purchases\n * - Reward redemptions\n * - Point transfers\n * - Real-time competitions\n */\nexport async function requireOnline(\n  request: FastifyRequest,\n  reply: FastifyReply\n) {\n  try {\n    const userId = request.user?.sub;\n    \n    if (!userId) {\n      return reply.code(401).send({\n        success: false,\n        error: 'Authentication required',\n        code: 'UNAUTHORIZED',\n      });\n    }\n\n    // Fetch user to check online status\n    const user = await User.findById(userId).select('lastSync offlineMode');\n    \n    if (!user) {\n      return reply.code(404).send({\n        success: false,\n        error: 'User not found',\n        code: 'USER_NOT_FOUND',\n      });\n    }\n\n    // Check if user is in offline mode\n    if (user.offlineMode) {\n      typedLogger.warn('Offline user attempted online-only action', {\n        userId,\n        path: request.url,\n        method: request.method,\n      });\n\n      return reply.code(403).send({\n        success: false,\n        error: 'Cette action n├®cessite une connexion internet active',\n        code: 'OFFLINE_NOT_ALLOWED',\n        message: {\n          en: 'This action requires an active internet connection',\n          fr: 'Cette action n├®cessite une connexion internet active',\n          ar: '┘èÏ¬ÏÀ┘äÏ¿ ┘çÏ░Ïº Ïº┘äÏÑÏ¼Ï▒ÏºÏí ÏºÏ¬ÏÁÏº┘äÏº┘ï ┘åÏ┤ÏÀ┘ïÏº Ï¿Ïº┘äÏÑ┘åÏ¬Ï▒┘åÏ¬',\n        },\n      });\n    }\n\n    // Check if last sync was recent (within 5 minutes)\n    const SYNC_THRESHOLD = 5 * 60 * 1000; // 5 minutes in milliseconds\n    const lastSyncTime = user.lastSync ? new Date(user.lastSync).getTime() : 0;\n    const now = Date.now();\n\n    if (now - lastSyncTime > SYNC_THRESHOLD) {\n      typedLogger.warn('User sync too old for online-only action', {\n        userId,\n        lastSync: user.lastSync,\n        timeSinceSync: now - lastSyncTime,\n        path: request.url,\n      });\n\n      return reply.code(403).send({\n        success: false,\n        error: 'Veuillez synchroniser votre application avant de continuer',\n        code: 'SYNC_REQUIRED',\n        message: {\n          en: 'Please sync your app before continuing',\n          fr: 'Veuillez synchroniser votre application avant de continuer',\n          ar: '┘èÏ▒Ï¼┘ë ┘àÏ▓Ïº┘à┘åÏ® Ï¬ÏÀÏ¿┘è┘é┘â ┘éÏ¿┘ä Ïº┘ä┘àÏ¬ÏºÏ¿Ï╣Ï®',\n        },\n        lastSync: user.lastSync,\n      });\n    }\n\n    // User is online and synced - proceed\n    typedLogger.debug('Online check passed', {\n      userId,\n      lastSync: user.lastSync,\n    });\n\n  } catch (error) {\n    typedLogger.error('Error in requireOnline middleware', {\n      error,\n      userId: request.user?.sub,\n    });\n\n    return reply.code(500).send({\n      success: false,\n      error: 'Internal server error',\n      code: 'INTERNAL_ERROR',\n    });\n  }\n  return undefined;\n}\n\n/**\n * Decorator to add requireOnline to Fastify instance\n */\nexport function registerRequireOnline(fastify: any) {\n  fastify.decorate('requireOnline', requireOnline);\n}\n\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\middleware\\security.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'logger' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'reply' is defined but never used. Allowed unused args must match /^_/u.","line":171,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":171,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ip' is defined but never used. Allowed unused args must match /^_/u.","line":245,"column":38,"nodeType":"Identifier","messageId":"unusedVar","endLine":245,"endColumn":48},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":282,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":282,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7732,7735],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7732,7735],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":282,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":282,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7738,7741],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7738,7741],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":297,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":297,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8226,8229],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8226,8229],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":323,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":323,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8852,8855],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8852,8855],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyRequest, FastifyReply } from 'fastify';\nimport { logger } from '@/lib/logger';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { config } from '@/config';\n\n/**\n * Security middleware for request validation and protection\n */\nexport async function security(\n  request: FastifyRequest,\n  reply: FastifyReply\n): Promise<void> {\n  // Add security headers\n  addSecurityHeaders(reply);\n  \n  // Validate request\n  validateRequest(request, reply);\n  \n  // Check for suspicious activity\n  await detectSuspiciousActivity(request, reply);\n}\n\n/**\n * Add security headers to response\n */\nfunction addSecurityHeaders(reply: FastifyReply): void {\n  // Prevent clickjacking\n  reply.header('X-Frame-Options', 'DENY');\n  \n  // Prevent MIME type sniffing\n  reply.header('X-Content-Type-Options', 'nosniff');\n  \n  // Enable XSS protection\n  reply.header('X-XSS-Protection', '1; mode=block');\n  \n  // Referrer policy\n  reply.header('Referrer-Policy', 'strict-origin-when-cross-origin');\n  \n  // Content Security Policy\n  if (config.NODE_ENV === 'production') {\n    reply.header('Content-Security-Policy', \n      \"default-src 'self'; \" +\n      \"script-src 'self' 'unsafe-inline'; \" +\n      \"style-src 'self' 'unsafe-inline'; \" +\n      \"img-src 'self' data: https:; \" +\n      \"font-src 'self'; \" +\n      \"connect-src 'self'; \" +\n      \"frame-ancestors 'none';\"\n    );\n  }\n  \n  // HSTS (HTTP Strict Transport Security)\n  if (config.NODE_ENV === 'production') {\n    reply.header('Strict-Transport-Security', 'max-age=31536000; includeSubDomains; preload');\n  }\n  \n  // Permissions Policy\n  reply.header('Permissions-Policy', \n    'camera=(), microphone=(), geolocation=(self), payment=()'\n  );\n  \n  // Remove server information\n  reply.removeHeader('Server');\n  reply.removeHeader('X-Powered-By');\n}\n\n/**\n * Validate incoming request for security issues\n */\nfunction validateRequest(request: FastifyRequest, reply: FastifyReply): void {\n  const url = request.url;\n  const userAgent = request.headers['user-agent'] || '';\n  const method = request.method;\n  \n  // Check for common attack patterns in URL\n  const suspiciousPatterns = [\n    // SQL Injection patterns\n    /(\\b(union|select|insert|update|delete|drop|create|alter|exec|execute)\\b)/i,\n    // XSS patterns\n    /(<script|javascript:|vbscript:|onload=|onerror=)/i,\n    // Path traversal\n    /(\\.\\.\\/|\\.\\.\\\\|%2e%2e%2f|%2e%2e%5c)/i,\n    // Command injection\n    /(\\b(cmd|exec|system|eval|shell_exec)\\b)/i,\n    // File inclusion\n    /(\\b(include|require|file_get_contents)\\b)/i,\n  ];\n  \n  for (const pattern of suspiciousPatterns) {\n    if (pattern.test(url) || pattern.test(userAgent)) {\n      typedLogger.warn('Suspicious request detected', {\n        ip: request.ip,\n        url,\n        userAgent,\n        method,\n        pattern: pattern.source,\n      });\n      \n      reply.code(400).send({\n        success: false,\n        error: 'Bad Request',\n        message: 'Invalid request format',\n        type: 'SECURITY_VIOLATION',\n      });\n      return;\n    }\n  }\n  \n  // Check for oversized headers\n  const maxHeaderSize = 8192; // 8KB\n  const headerSize = JSON.stringify(request.headers).length;\n  \n  if (headerSize > maxHeaderSize) {\n    typedLogger.warn('Oversized headers detected', {\n      ip: request.ip,\n      headerSize,\n      maxHeaderSize,\n    });\n    \n    reply.code(413).send({\n      success: false,\n      error: 'Request Entity Too Large',\n      message: 'Request headers too large',\n      type: 'HEADERS_TOO_LARGE',\n    });\n    return;\n  }\n  \n  // Validate Content-Type for POST/PUT requests\n  if (['POST', 'PUT', 'PATCH'].includes(method)) {\n    const contentType = request.headers['content-type'];\n    \n    if (!contentType) {\n      reply.code(400).send({\n        success: false,\n        error: 'Bad Request',\n        message: 'Content-Type header is required',\n        type: 'MISSING_CONTENT_TYPE',\n      });\n      return;\n    }\n    \n    // Allow only specific content types\n    const allowedContentTypes = [\n      'application/json',\n      'multipart/form-data',\n      'application/x-www-form-urlencoded',\n    ];\n    \n    const isValidContentType = allowedContentTypes.some(type => \n      contentType.toLowerCase().startsWith(type)\n    );\n    \n    if (!isValidContentType) {\n      reply.code(415).send({\n        success: false,\n        error: 'Unsupported Media Type',\n        message: 'Invalid Content-Type',\n        type: 'INVALID_CONTENT_TYPE',\n      });\n      return;\n    }\n  }\n}\n\n/**\n * Detect suspicious activity patterns\n */\nasync function detectSuspiciousActivity(\n  request: FastifyRequest,\n  reply: FastifyReply\n): Promise<void> {\n  const ip = request.ip;\n  const userAgent = request.headers['user-agent'] || '';\n  const url = request.url;\n  \n  // Check for bot/crawler patterns\n  const botPatterns = [\n    /bot|crawler|spider|scraper/i,\n    /curl|wget|python|java|go-http/i,\n    /postman|insomnia|httpie/i,\n  ];\n  \n  const isBot = botPatterns.some(pattern => pattern.test(userAgent));\n  \n  if (isBot && !isAllowedBot(userAgent)) {\n    typedLogger.warn('Suspicious bot activity detected', {\n      ip,\n      userAgent,\n      url,\n    });\n    \n    // Don't block immediately, but log for monitoring\n    typedLogger.warn('Bot detected', { userAgent });\n  }\n  \n  // Check for rapid requests (basic protection)\n  await checkRapidRequests(ip, request);\n  \n  // Validate geographic location if available\n  await validateGeographicLocation(request);\n}\n\n/**\n * Check if bot is allowed (search engines, monitoring tools, etc.)\n */\nfunction isAllowedBot(userAgent: string): boolean {\n  const allowedBots = [\n    /googlebot/i,\n    /bingbot/i,\n    /slurp/i, // Yahoo\n    /duckduckbot/i,\n    /uptimerobot/i,\n    /pingdom/i,\n    /newrelic/i,\n  ];\n  \n  return allowedBots.some(pattern => pattern.test(userAgent));\n}\n\n/**\n * Check for rapid requests from same IP\n */\nasync function checkRapidRequests(ip: string, request: FastifyRequest): Promise<void> {\n  // This would typically use Redis to track request counts\n  // For now, we'll just log suspicious patterns\n  \n  const requestCount = await getRecentRequestCount(ip);\n  \n  if (requestCount > 100) { // More than 100 requests in recent window\n    typedLogger.warn('Rapid requests detected', {\n      ip,\n      requestCount,\n      userAgent: request.headers['user-agent'],\n    });\n    \n    // Could implement temporary IP blocking here\n    typedLogger.warn('High request rate', { ip, count: requestCount });\n  }\n}\n\n/**\n * Get recent request count for IP (mock implementation)\n */\nasync function getRecentRequestCount(ip: string): Promise<number> {\n  // In a real implementation, this would query Redis\n  // For now, return a mock value\n  return Math.floor(Math.random() * 50);\n}\n\n/**\n * Validate geographic location for suspicious activity\n */\nasync function validateGeographicLocation(request: FastifyRequest): Promise<void> {\n  // Check for location spoofing indicators\n  const xForwardedFor = request.headers['x-forwarded-for'] as string;\n  const xRealIp = request.headers['x-real-ip'] as string;\n  const cfConnectingIp = request.headers['cf-connecting-ip'] as string;\n  \n  const ips = [request.ip, xForwardedFor, xRealIp, cfConnectingIp]\n    .filter(Boolean)\n    .map(ip => ip?.split(',')[0]?.trim())\n    .filter(Boolean);\n  \n  // If multiple different IPs are present, it might indicate proxy/VPN usage\n  const uniqueIps = [...new Set(ips)];\n  \n  if (uniqueIps.length > 2) {\n    typedLogger.info('Multiple IP addresses detected', {\n      ips: uniqueIps,\n      userAgent: request.headers['user-agent'],\n    });\n    \n    // Log for analysis but don't block\n    typedLogger.info('Proxy/VPN usage suspected', { ips: uniqueIps });\n  }\n}\n\n/**\n * Input sanitization middleware\n */\nexport function sanitizeInput(input: any): any {\n  if (typeof input === 'string') {\n    // Remove potentially dangerous characters\n    return input\n      .replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, '') // Remove script tags\n      .replace(/javascript:/gi, '') // Remove javascript: protocol\n      .replace(/on\\w+\\s*=/gi, '') // Remove event handlers\n      .trim();\n  }\n  \n  if (Array.isArray(input)) {\n    return input.map(sanitizeInput);\n  }\n  \n  if (input && typeof input === 'object') {\n    const sanitized: any = {};\n    for (const [key, value] of Object.entries(input)) {\n      sanitized[sanitizeInput(key)] = sanitizeInput(value);\n    }\n    return sanitized;\n  }\n  \n  return input;\n}\n\n/**\n * CSRF protection middleware\n */\nexport async function csrfProtection(\n  request: FastifyRequest,\n  reply: FastifyReply\n): Promise<void> {\n  // Skip CSRF for GET, HEAD, OPTIONS\n  if (['GET', 'HEAD', 'OPTIONS'].includes(request.method)) {\n    return;\n  }\n  \n  // Check for CSRF token in header or body\n  const csrfToken = \n    request.headers['x-csrf-token'] as string ||\n    request.headers['x-xsrf-token'] as string ||\n    (request.body as any)?.csrfToken;\n  \n  if (!csrfToken) {\n    reply.code(403).send({\n      success: false,\n      error: 'Forbidden',\n      message: 'CSRF token missing',\n      type: 'CSRF_TOKEN_MISSING',\n    });\n    return;\n  }\n  \n  // Validate CSRF token (simplified - in production use crypto-secure validation)\n  const expectedToken = generateCSRFToken(request);\n  \n  if (csrfToken !== expectedToken) {\n    typedLogger.warn('Invalid CSRF token', {\n      ip: request.ip,\n      provided: csrfToken,\n      expected: expectedToken,\n    });\n    \n    reply.code(403).send({\n      success: false,\n      error: 'Forbidden',\n      message: 'Invalid CSRF token',\n      type: 'CSRF_TOKEN_INVALID',\n    });\n    return;\n  }\n}\n\n/**\n * Generate CSRF token (simplified implementation)\n */\nfunction generateCSRFToken(request: FastifyRequest): string {\n  // In production, use a more secure implementation with crypto\n  const sessionId = request.headers['x-session-id'] as string || 'anonymous';\n  return Buffer.from(`${sessionId}:${config.JWT_SECRET}`).toString('base64');\n}\n\n/**\n * Request size limiter\n */\nexport async function requestSizeLimiter(\n  request: FastifyRequest,\n  reply: FastifyReply\n): Promise<void> {\n  const contentLength = parseInt(request.headers['content-length'] || '0');\n  const maxSize = getMaxRequestSize(request.url);\n  \n  if (contentLength > maxSize) {\n    reply.code(413).send({\n      success: false,\n      error: 'Request Entity Too Large',\n      message: `Request size exceeds limit of ${maxSize} bytes`,\n      type: 'REQUEST_TOO_LARGE',\n    });\n    return;\n  }\n}\n\n/**\n * Get maximum request size based on endpoint\n */\nfunction getMaxRequestSize(url: string): number {\n  // Upload endpoints allow larger requests\n  if (url.includes('/upload')) {\n    return 50 * 1024 * 1024; // 50MB\n  }\n  \n  // API endpoints have smaller limits\n  return 1 * 1024 * 1024; // 1MB\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\models\\ABTest.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":6,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":6,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[176,179],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[176,179],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Schema, model, Document } from 'mongoose';\r\n\r\nexport interface IVariant {\r\n  name: string;\r\n  trafficAllocation: number; // percentage 0-100\r\n  config: Record<string, any>;\r\n  conversions: number;\r\n  impressions: number;\r\n}\r\n\r\nexport interface IABTest extends Document {\r\n  name: string;\r\n  description?: string;\r\n  type: 'feature' | 'ui' | 'mechanics' | 'rewards' | 'pricing';\r\n  status: 'draft' | 'active' | 'paused' | 'ended';\r\n  variants: IVariant[];\r\n  metrics: {\r\n    metricName: string;\r\n    baseline: number;\r\n    targetImprovement: number;\r\n    significance: number;\r\n    winner?: string;\r\n  }[];\r\n  startDate: Date;\r\n  endDate?: Date;\r\n  winnerVariant?: string;\r\n  sampleSize: number;\r\n  confidenceLevel: number; // e.g., 0.95 for 95%\r\n  createdBy: Schema.Types.ObjectId;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\nconst ABTestSchema = new Schema<IABTest>(\r\n  {\r\n    name: { type: String, required: true, unique: true },\r\n    description: String,\r\n    type: { type: String, enum: ['feature', 'ui', 'mechanics', 'rewards', 'pricing'], required: true },\r\n    status: { type: String, enum: ['draft', 'active', 'paused', 'ended'], default: 'draft' },\r\n    variants: [\r\n      {\r\n        name: { type: String, required: true },\r\n        trafficAllocation: { type: Number, required: true, min: 0, max: 100 },\r\n        config: Schema.Types.Mixed,\r\n        conversions: { type: Number, default: 0 },\r\n        impressions: { type: Number, default: 0 }\r\n      }\r\n    ],\r\n    metrics: [\r\n      {\r\n        metricName: String,\r\n        baseline: Number,\r\n        targetImprovement: Number,\r\n        significance: { type: Number, default: 0 },\r\n        winner: String\r\n      }\r\n    ],\r\n    startDate: { type: Date, required: true },\r\n    endDate: Date,\r\n    winnerVariant: String,\r\n    sampleSize: { type: Number, default: 1000 },\r\n    confidenceLevel: { type: Number, default: 0.95 },\r\n    createdBy: { type: Schema.Types.ObjectId, ref: 'User' },\r\n    createdAt: { type: Date, default: Date.now },\r\n    updatedAt: { type: Date, default: Date.now }\r\n  },\r\n  { timestamps: true }\r\n);\r\n\r\n// Index for faster queries\r\nABTestSchema.index({ status: 1, startDate: -1 });\r\nABTestSchema.index({ type: 1 });\r\n\r\nexport const ABTest = model<IABTest>('ABTest', ABTestSchema);\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\models\\ARSession.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\models\\Achievement.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\models\\AdMobView.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\models\\Analytics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\models\\AuditLog.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":23,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[704,707],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[704,707],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":24,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[737,740],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[737,740],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":27,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[790,793],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[790,793],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":28,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[809,812],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[809,812],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":52,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":52,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1338,1341],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1338,1341],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import mongoose, { Schema, Document, Types } from 'mongoose';\n\nexport interface IAuditLog extends Document {\n  _id: Types.ObjectId;\n  \n  // Who performed the action\n  userId?: string;\n  userEmail?: string;\n  userRole?: string;\n  sessionId?: string;\n  \n  // What action was performed\n  action: string; // e.g., 'create', 'update', 'delete', 'login', 'claim_prize'\n  resource: string; // e.g., 'user', 'prize', 'reward', 'session'\n  resourceId?: string;\n  \n  // Action details\n  description?: string;\n  category: 'auth' | 'game' | 'admin' | 'system' | 'security' | 'business';\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  \n  // Before and after state (for updates)\n  previousData?: Record<string, any>;\n  newData?: Record<string, any>;\n  changes?: {\n    field: string;\n    oldValue: any;\n    newValue: any;\n  }[];\n  \n  // Request context\n  requestId?: string;\n  method?: string; // HTTP method\n  endpoint?: string; // API endpoint\n  userAgent?: string;\n  ipAddress?: string;\n  \n  // Location context (for game actions)\n  location?: {\n    coordinates: [number, number]; // [longitude, latitude]\n    city?: string;\n    country?: string;\n  };\n  \n  // Result and metadata\n  success: boolean;\n  errorMessage?: string;\n  errorCode?: string;\n  responseTime?: number; // milliseconds\n  \n  // Additional context\n  metadata?: Record<string, any>;\n  tags?: string[];\n  \n  // Compliance and retention\n  retentionPeriod?: number; // days\n  complianceFlags?: string[];\n  \n  timestamp: Date;\n  createdAt: Date;\n}\n\nconst AuditLogSchema = new Schema<IAuditLog>({\n  // User information\n  userId: {\n    type: String,\n    index: true,\n  },\n  userEmail: {\n    type: String,\n    index: true,\n  },\n  userRole: {\n    type: String,\n    enum: ['user', 'moderator', 'admin', 'super_admin', 'system'],\n    index: true,\n  },\n  sessionId: {\n    type: String,\n    index: true,\n  },\n  \n  // Action information\n  action: {\n    type: String,\n    required: true,\n    index: true,\n    maxlength: 100,\n  },\n  resource: {\n    type: String,\n    required: true,\n    index: true,\n    maxlength: 50,\n  },\n  resourceId: {\n    type: String,\n    index: true,\n  },\n  \n  // Action details\n  description: {\n    type: String,\n    maxlength: 500,\n  },\n  category: {\n    type: String,\n    enum: ['auth', 'game', 'admin', 'system', 'security', 'business'],\n    required: true,\n    index: true,\n  },\n  severity: {\n    type: String,\n    enum: ['low', 'medium', 'high', 'critical'],\n    default: 'low',\n    index: true,\n  },\n  \n  // Data changes\n  previousData: {\n    type: Schema.Types.Mixed,\n  },\n  newData: {\n    type: Schema.Types.Mixed,\n  },\n  changes: [{\n    field: {\n      type: String,\n      required: true,\n    },\n    oldValue: Schema.Types.Mixed,\n    newValue: Schema.Types.Mixed,\n  }],\n  \n  // Request context\n  requestId: {\n    type: String,\n    index: true,\n  },\n  method: {\n    type: String,\n    enum: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS', 'HEAD'],\n  },\n  endpoint: {\n    type: String,\n    maxlength: 200,\n  },\n  userAgent: {\n    type: String,\n    maxlength: 500,\n  },\n  ipAddress: {\n    type: String,\n    index: true,\n  },\n  \n  // Location context\n  location: {\n    coordinates: {\n      type: [Number],\n      validate: {\n        validator: function(coords: number[]) {\n          if (!coords || coords.length !== 2) return true; // Optional field\n          return coords[0] >= -180 && coords[0] <= 180 && // longitude\n                 coords[1] >= -90 && coords[1] <= 90;     // latitude\n        },\n        message: 'Coordinates must be [longitude, latitude] within valid ranges'\n      }\n    },\n    city: String,\n    country: String,\n  },\n  \n  // Result information\n  success: {\n    type: Boolean,\n    required: true,\n    index: true,\n  },\n  errorMessage: {\n    type: String,\n    maxlength: 1000,\n  },\n  errorCode: {\n    type: String,\n    maxlength: 50,\n  },\n  responseTime: {\n    type: Number,\n    min: 0,\n  },\n  \n  // Additional context\n  metadata: {\n    type: Schema.Types.Mixed,\n  },\n  tags: [{\n    type: String,\n    maxlength: 50,\n  }],\n  \n  // Compliance\n  retentionPeriod: {\n    type: Number,\n    default: 2555, // 7 years in days\n    min: 1,\n  },\n  complianceFlags: [{\n    type: String,\n    enum: ['gdpr', 'pci', 'hipaa', 'sox', 'pii'],\n  }],\n  \n  timestamp: {\n    type: Date,\n    required: true,\n    default: Date.now,\n    index: true,\n  },\n}, {\n  timestamps: true,\n});\n\n// Compound indexes for common queries\nAuditLogSchema.index({ userId: 1, timestamp: -1 });\nAuditLogSchema.index({ category: 1, timestamp: -1 });\nAuditLogSchema.index({ action: 1, resource: 1, timestamp: -1 });\nAuditLogSchema.index({ severity: 1, timestamp: -1 });\nAuditLogSchema.index({ success: 1, timestamp: -1 });\nAuditLogSchema.index({ ipAddress: 1, timestamp: -1 });\n\n// NOTE: TTL index removed - it was causing immediate deletion of logs\n// Retention should be handled by a scheduled cleanup job instead\n\n// Geospatial index for location-based queries\nAuditLogSchema.index({ 'location.coordinates': '2dsphere' });\n\n// Text index for searching descriptions and error messages\nAuditLogSchema.index({\n  description: 'text',\n  errorMessage: 'text',\n  action: 'text',\n  resource: 'text',\n});\n\n// Virtual for formatted timestamp\nAuditLogSchema.virtual('formattedTimestamp').get(function() {\n  return this.timestamp.toISOString();\n});\n\n// Virtual for age in hours\nAuditLogSchema.virtual('ageHours').get(function() {\n  return Math.floor((Date.now() - this.timestamp.getTime()) / (1000 * 60 * 60));\n});\n\n// Virtual for checking if log is expired\nAuditLogSchema.virtual('isExpired').get(function() {\n  if (!this.retentionPeriod) return false;\n  const expirationDate = new Date(this.createdAt.getTime() + (this.retentionPeriod * 24 * 60 * 60 * 1000));\n  return Date.now() > expirationDate.getTime();\n});\n\n// Method to add tag\nAuditLogSchema.methods.addTag = function(tag: string) {\n  if (!this.tags.includes(tag)) {\n    this.tags.push(tag);\n    return this.save();\n  }\n  return Promise.resolve(this);\n};\n\n// Method to remove tag\nAuditLogSchema.methods.removeTag = function(tag: string) {\n  this.tags = this.tags.filter(t => t !== tag);\n  return this.save();\n};\n\n// Method to check if action is sensitive\nAuditLogSchema.methods.isSensitive = function(): boolean {\n  const sensitiveActions = [\n    'login_failed',\n    'password_change',\n    'account_delete',\n    'admin_access',\n    'data_export',\n    'ban_user',\n    'unban_user',\n    'system_config_change',\n  ];\n  \n  return sensitiveActions.includes(this.action) || \n         this.severity === 'critical' ||\n         this.complianceFlags.length > 0;\n};\n\n// Static method to log action\nAuditLogSchema.statics.logAction = function(logData: Partial<IAuditLog>) {\n  const auditLog = new this({\n    ...logData,\n    timestamp: logData.timestamp || new Date(),\n  });\n  \n  return auditLog.save();\n};\n\n// Static method to get user activity\nAuditLogSchema.statics.getUserActivity = function(userId: string, days: number = 30) {\n  const startDate = new Date();\n  startDate.setDate(startDate.getDate() - days);\n  \n  return this.find({\n    userId,\n    timestamp: { $gte: startDate }\n  })\n  .sort({ timestamp: -1 })\n  .limit(1000);\n};\n\n// Static method to get security events\nAuditLogSchema.statics.getSecurityEvents = function(hours: number = 24) {\n  const startDate = new Date();\n  startDate.setHours(startDate.getHours() - hours);\n  \n  return this.find({\n    $or: [\n      { category: 'security' },\n      { severity: { $in: ['high', 'critical'] } },\n      { success: false, action: { $regex: /login|auth/ } },\n    ],\n    timestamp: { $gte: startDate }\n  })\n  .sort({ timestamp: -1 });\n};\n\n// Static method to get failed actions by IP\nAuditLogSchema.statics.getFailedActionsByIP = function(ipAddress: string, hours: number = 1) {\n  const startDate = new Date();\n  startDate.setHours(startDate.getHours() - hours);\n  \n  return this.countDocuments({\n    ipAddress,\n    success: false,\n    timestamp: { $gte: startDate }\n  });\n};\n\n// Static method to get statistics\nAuditLogSchema.statics.getStatistics = function(days: number = 7) {\n  const startDate = new Date();\n  startDate.setDate(startDate.getDate() - days);\n  \n  return this.aggregate([\n    {\n      $match: {\n        timestamp: { $gte: startDate }\n      }\n    },\n    {\n      $group: {\n        _id: null,\n        totalActions: { $sum: 1 },\n        successfulActions: {\n          $sum: { $cond: ['$success', 1, 0] }\n        },\n        failedActions: {\n          $sum: { $cond: ['$success', 0, 1] }\n        },\n        uniqueUsers: { $addToSet: '$userId' },\n        uniqueIPs: { $addToSet: '$ipAddress' },\n        categoriesCount: {\n          $push: '$category'\n        },\n        severityCount: {\n          $push: '$severity'\n        }\n      }\n    },\n    {\n      $project: {\n        totalActions: 1,\n        successfulActions: 1,\n        failedActions: 1,\n        successRate: {\n          $multiply: [\n            { $divide: ['$successfulActions', '$totalActions'] },\n            100\n          ]\n        },\n        uniqueUserCount: { $size: '$uniqueUsers' },\n        uniqueIPCount: { $size: '$uniqueIPs' },\n        categoriesCount: 1,\n        severityCount: 1\n      }\n    }\n  ]);\n};\n\n// Static method to cleanup expired logs\nAuditLogSchema.statics.cleanupExpiredLogs = function() {\n  const now = new Date();\n  \n  return this.deleteMany({\n    $expr: {\n      $lt: [\n        { $add: ['$createdAt', { $multiply: ['$retentionPeriod', 24 * 60 * 60 * 1000] }] },\n        now\n      ]\n    }\n  });\n};\n\n// Static method to get audit trail for resource\nAuditLogSchema.statics.getAuditTrail = function(resource: string, resourceId: string) {\n  return this.find({\n    resource,\n    resourceId\n  })\n  .sort({ timestamp: -1 })\n  .populate('userId', 'displayName email');\n};\n\n// Pre-save middleware to set default values and validate\nAuditLogSchema.pre('save', function(next) {\n  // Set default timestamp if not provided\n  if (!this.timestamp) {\n    this.timestamp = new Date();\n  }\n  \n  // Auto-detect severity based on action and success\n  if (!this.severity || this.severity === 'low') {\n    if (!this.success) {\n      if (this.action.includes('login') || this.action.includes('auth')) {\n        this.severity = 'medium';\n      } else if (this.action.includes('delete') || this.action.includes('ban')) {\n        this.severity = 'high';\n      }\n    }\n    \n    if (this.category === 'security') {\n      this.severity = 'high';\n    }\n  }\n  \n  // Add compliance flags based on action\n  if (!this.complianceFlags) {\n    this.complianceFlags = [];\n  }\n  \n  if (this.action.includes('personal_data') || this.action.includes('profile')) {\n    if (!this.complianceFlags.includes('gdpr')) {\n      this.complianceFlags.push('gdpr');\n    }\n  }\n  \n  if (this.action.includes('payment') || this.action.includes('card')) {\n    if (!this.complianceFlags.includes('pci')) {\n      this.complianceFlags.push('pci');\n    }\n  }\n  \n  next();\n});\n\n// Post-save middleware for real-time alerts\nAuditLogSchema.post('save', function(doc) {\n  // Send real-time alerts for critical events\n  if (doc.severity === 'critical' || (doc.category === 'security' && !doc.success)) {\n    // Log critical events for monitoring\n    console.log('AUDIT_CRITICAL_EVENT', {\n      logId: doc._id,\n      action: doc.action,\n      resource: doc.resource,\n      userId: doc.userId,\n      ipAddress: doc.ipAddress,\n      timestamp: doc.timestamp,\n    });\n  }\n});\n\nexport const AuditLog = (mongoose.models.AuditLog as mongoose.Model<IAuditLog>) || mongoose.model<IAuditLog>('AuditLog', AuditLogSchema);\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\models\\Claim.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'logger' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":16}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Schema, model, Model, Types } from 'mongoose';\nimport { IClaim } from '@/types';\nimport { logger } from '@/lib/logger';\n\nconst claimSchema = new Schema<IClaim>({\n  userId: {\n    type: Schema.Types.ObjectId,\n    ref: 'User',\n    required: true,\n    index: true,\n  },\n  prizeId: {\n    type: Schema.Types.ObjectId,\n    ref: 'Prize',\n    required: true,\n    index: true,\n  },\n  location: {\n    lat: {\n      type: Number,\n      required: true,\n      min: -90,\n      max: 90,\n    },\n    lng: {\n      type: Number,\n      required: true,\n      min: -180,\n      max: 180,\n    },\n    accuracy: {\n      type: Number,\n      min: 0,\n    },\n  },\n  distance: {\n    type: Number,\n    required: true,\n    min: 0,\n  },\n  pointsAwarded: {\n    type: Number,\n    required: true,\n    min: 0,\n  },\n  deviceSignals: {\n    speed: Number,\n    mockLocation: Boolean,\n    attestationToken: String,\n  },\n  validationChecks: {\n    distanceValid: {\n      type: Boolean,\n      required: true,\n    },\n    timeValid: {\n      type: Boolean,\n      required: true,\n    },\n    speedValid: {\n      type: Boolean,\n      required: true,\n    },\n    cooldownValid: {\n      type: Boolean,\n      required: true,\n    },\n    dailyLimitValid: {\n      type: Boolean,\n      required: true,\n    },\n  },\n  status: {\n    type: String,\n    enum: ['pending', 'approved', 'rejected', 'overridden'],\n    default: 'approved',\n    index: true,\n  },\n  riskScore: {\n    type: Number,\n    default: 0,\n    min: 0,\n    max: 100,\n  },\n  riskFactors: {\n    type: [String],\n    default: [],\n  },\n  flaggedAt: {\n    type: Date,\n  },\n  adminNotes: {\n    type: String,\n  },\n  overriddenBy: {\n    type: Schema.Types.ObjectId,\n    ref: 'User',\n  },\n  overriddenAt: {\n    type: Date,\n  },\n  antiCheatDetails: {\n    type: Schema.Types.Mixed,\n  },\n  idempotencyKey: {\n    type: String,\n    required: true,\n    unique: true,\n    index: true,\n  },\n  claimedAt: {\n    type: Date,\n    default: Date.now,\n    index: true,\n  },\n  metadata: {\n    type: Schema.Types.Mixed,\n    default: {},\n  },\n}, {\n  timestamps: true,\n  toJSON: { virtuals: true },\n  toObject: { virtuals: true }\n});\n\n// Indexes\nclaimSchema.index({ userId: 1, claimedAt: -1 });\nclaimSchema.index({ prizeId: 1, claimedAt: -1 });\nclaimSchema.index({ claimedAt: -1 });\nclaimSchema.index({ status: 1, claimedAt: -1 });\nclaimSchema.index({ 'location.lat': 1, 'location.lng': 1 });\n\n// Virtual fields\nclaimSchema.virtual('isValid').get(function() {\n  return Object.values(this.validationChecks).every(check => check === true);\n});\n\n// Static methods\nclaimSchema.statics.findByUser = function(\n  userId: Types.ObjectId,\n  options: { limit?: number } = {}\n) {\n  return this.find({ userId })\n    .populate('prizeId', 'name description points rarity category')\n    .sort({ claimedAt: -1 })\n    .limit(options.limit || 50);\n};\n\nclaimSchema.statics.findByPrize = function(prizeId: Types.ObjectId) {\n  return this.find({ prizeId })\n    .populate('userId', 'displayName level')\n    .sort({ claimedAt: -1 });\n};\n\nclaimSchema.statics.getUserStats = async function(userId: Types.ObjectId) {\n  const stats = await this.aggregate([\n    { $match: { userId } },\n    {\n      $group: {\n        _id: null,\n        totalClaims: { $sum: 1 },\n        totalPoints: { $sum: '$pointsAwarded' },\n        averageDistance: { $avg: '$distance' },\n        validClaims: {\n          $sum: {\n            $cond: [\n              {\n                $and: [\n                  '$validationChecks.distanceValid',\n                  '$validationChecks.timeValid',\n                  '$validationChecks.speedValid',\n                  '$validationChecks.cooldownValid',\n                  '$validationChecks.dailyLimitValid'\n                ]\n              },\n              1,\n              0\n            ]\n          }\n        }\n      }\n    }\n  ]);\n  \n  return stats[0] || {\n    totalClaims: 0,\n    totalPoints: 0,\n    averageDistance: 0,\n    validClaims: 0,\n  };\n};\n\nexport const Claim: Model<IClaim> = model<IClaim>('Claim', claimSchema);\nexport default Claim;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\models\\Code.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\models\\DeviceToken.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\models\\Distribution.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\models\\Friendship.ts","messages":[{"ruleId":"@typescript-eslint/ban-types","severity":2,"message":"Don't use `{}` as a type. `{}` actually means \"any non-nullish value\".\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.\n- If you want a type meaning \"empty object\", you probably want `Record<string, never>` instead.\n- If you really want a type meaning \"any non-nullish value\", you probably want `NonNullable<unknown>` instead.","line":39,"column":69,"nodeType":"TSTypeLiteral","messageId":"bannedTypeMessage","endLine":39,"endColumn":71,"suggestions":[{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"object"},"fix":{"range":[724,726],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"unknown"},"fix":{"range":[724,726],"text":"unknown"},"desc":"Replace `{}` with `unknown`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"Record<string, never>"},"fix":{"range":[724,726],"text":"Record<string, never>"},"desc":"Replace `{}` with `Record<string, never>`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"NonNullable<unknown>"},"fix":{"range":[724,726],"text":"NonNullable<unknown>"},"desc":"Replace `{}` with `NonNullable<unknown>`."}]},{"ruleId":"@typescript-eslint/ban-types","severity":2,"message":"Don't use `{}` as a type. `{}` actually means \"any non-nullish value\".\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.\n- If you want a type meaning \"empty object\", you probably want `Record<string, never>` instead.\n- If you really want a type meaning \"any non-nullish value\", you probably want `NonNullable<unknown>` instead.","line":104,"column":65,"nodeType":"TSTypeLiteral","messageId":"bannedTypeMessage","endLine":104,"endColumn":67,"suggestions":[{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"object"},"fix":{"range":[2138,2140],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"unknown"},"fix":{"range":[2138,2140],"text":"unknown"},"desc":"Replace `{}` with `unknown`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"Record<string, never>"},"fix":{"range":[2138,2140],"text":"Record<string, never>"},"desc":"Replace `{}` with `Record<string, never>`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"NonNullable<unknown>"},"fix":{"range":[2138,2140],"text":"NonNullable<unknown>"},"desc":"Replace `{}` with `NonNullable<unknown>`."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Schema, model, Types, Model } from 'mongoose';\n\n/**\n * Friendship Status Enum\n */\nexport enum FriendshipStatus {\n  PENDING = 'pending',\n  ACCEPTED = 'accepted',\n  REJECTED = 'rejected',\n  BLOCKED = 'blocked',\n}\n\n/**\n * Friendship Interface\n */\nexport interface IFriendship {\n  _id: Types.ObjectId;\n  userId: Types.ObjectId;\n  friendId: Types.ObjectId;\n  status: FriendshipStatus;\n  message?: string;\n  requestedAt: Date;\n  acceptedAt?: Date;\n  rejectedAt?: Date;\n  blockedAt?: Date;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface IFriendshipMethods {\n  accept(): void;\n  reject(): void;\n  block(): void;\n}\n\n/**\n * Friendship Schema\n */\nconst friendshipSchema = new Schema<IFriendship, Model<IFriendship, {}, IFriendshipMethods>, IFriendshipMethods>({\n  userId: {\n    type: Schema.Types.ObjectId,\n    ref: 'User',\n    required: true,\n    index: true,\n  },\n  friendId: {\n    type: Schema.Types.ObjectId,\n    ref: 'User',\n    required: true,\n    index: true,\n  },\n  status: {\n    type: String,\n    enum: Object.values(FriendshipStatus),\n    default: FriendshipStatus.PENDING,\n    index: true,\n  },\n  message: {\n    type: String,\n    default: '',\n    maxlength: 500,\n  },\n  requestedAt: {\n    type: Date,\n    default: Date.now,\n  },\n  acceptedAt: {\n    type: Date,\n  },\n  rejectedAt: {\n    type: Date,\n  },\n  blockedAt: {\n    type: Date,\n  },\n}, {\n  timestamps: true,\n});\n\n// Index compos├® pour ├®viter les doublons et optimiser les requ├¬tes\nfriendshipSchema.index({ userId: 1, friendId: 1 }, { unique: true });\nfriendshipSchema.index({ userId: 1, status: 1 });\nfriendshipSchema.index({ friendId: 1, status: 1 });\n\n// M├®thodes d'instance\nfriendshipSchema.methods.accept = function(): void {\n  this.status = FriendshipStatus.ACCEPTED;\n  this.acceptedAt = new Date();\n};\n\nfriendshipSchema.methods.reject = function(): void {\n  this.status = FriendshipStatus.REJECTED;\n  this.rejectedAt = new Date();\n};\n\nfriendshipSchema.methods.block = function(): void {\n  this.status = FriendshipStatus.BLOCKED;\n  this.blockedAt = new Date();\n};\n\n/**\n * Friendship Model\n */\nexport const Friendship = model<IFriendship, Model<IFriendship, {}, IFriendshipMethods>>('Friendship', friendshipSchema);\nexport default Friendship;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\models\\Notification.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\models\\OfflineQueue.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\models\\Partner.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\models\\PowerUp.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\models\\Prize.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Model' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'IPrizeDocument' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":25},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":312,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":312,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6893,6896],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6893,6896],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":321,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":321,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7206,7209],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7206,7209],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":343,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":343,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7917,7920],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7917,7920],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":438,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":438,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10433,10436],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10433,10436],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":450,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":450,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10647,10650],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10647,10650],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":452,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":452,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10675,10678],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10675,10678],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":501,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":501,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11753,11756],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11753,11756],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":502,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":502,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11780,11783],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11780,11783],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":558,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":558,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13214,13217],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13214,13217],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Schema, model, Model, Document, Types } from 'mongoose';\nimport { IPrize, IPrizeModel, PrizeType, PrizeDisplayType, PrizeContentType, PrizeCategory, PrizeRarity, PrizeStatus, LocationType } from '@/types';\nimport { TUNISIA_BOUNDS, TUNISIA_CITIES } from '@/config';\nimport { typedLogger } from '@/lib/typed-logger';\n\n// Define extended interface for Prize with virtuals and methods\ninterface IPrizeDocument extends IPrize, Document {\n  rarityWeight: number;\n  estimatedValue: number;\n  findNearestCity(): string;\n}\n\n// Prize schema\nconst prizeSchema = new Schema<IPrize>({\n  name: {\n    type: String,\n    required: true,\n    trim: true,\n    minlength: 2,\n    maxlength: 100,\n    index: true,\n  },\n  description: {\n    type: String,\n    required: true,\n    trim: true,\n    maxlength: 500,\n  },\n  type: {\n    type: String,\n    enum: Object.values(PrizeType),\n    required: true,\n    index: true,\n  },\n  displayType: {\n    type: String,\n    enum: Object.values(PrizeDisplayType),\n    default: PrizeDisplayType.STANDARD,\n    index: true,\n  },\n  contentType: {\n    type: String,\n    enum: Object.values(PrizeContentType),\n    default: PrizeContentType.POINTS,\n    required: true,\n    index: true,\n  },\n  category: {\n    type: String,\n    enum: Object.values(PrizeCategory),\n    required: true,\n    index: true,\n  },\n  points: {\n    type: Number,\n    required: false, // Now optional, use pointsReward instead\n    min: 1,\n    max: 10000,\n    index: true,\n  },\n  pointsReward: {\n    amount: {\n      type: Number,\n      min: 1,\n      max: 10000,\n    },\n    bonusMultiplier: {\n      type: Number,\n      min: 1,\n      max: 10,\n      default: 1,\n    },\n  },\n  directReward: {\n    rewardId: {\n      type: Schema.Types.ObjectId,\n      ref: 'Reward',\n    },\n    autoRedeem: {\n      type: Boolean,\n      default: true,\n    },\n    probability: {\n      type: Number,\n      min: 0,\n      max: 1,\n      default: 1,\n    },\n  },\n  rarity: {\n    type: String,\n    enum: Object.values(PrizeRarity),\n    required: true,\n    index: true,\n  },\n  quantity: {\n    type: Number,\n    default: 1,\n    min: 1,\n    max: 1000,\n  },\n  claimedCount: {\n    type: Number,\n    default: 0,\n    min: 0,\n  },\n  location: {\n    type: {\n      type: String,\n      enum: Object.values(LocationType),\n      default: LocationType.GPS,\n      required: true,\n    },\n    coordinates: {\n      type: [Number], // [lng, lat]\n      required: true,\n      validate: {\n        validator: function(coords: number[]) {\n          if (coords.length !== 2) return false;\n          const [lng, lat] = coords;\n          \n          // Validate coordinates are within Tunisia bounds\n          return lng >= TUNISIA_BOUNDS.west && \n                 lng <= TUNISIA_BOUNDS.east && \n                 lat >= TUNISIA_BOUNDS.south && \n                 lat <= TUNISIA_BOUNDS.north;\n        },\n        message: 'Coordinates must be within Tunisia bounds'\n      }\n    },\n    radius: {\n      type: Number,\n      default: 50,\n      min: 10,\n      max: 500,\n    },\n    city: {\n      type: String,\n      required: true,\n      enum: Object.keys(TUNISIA_CITIES),\n      index: true,\n    },\n    address: {\n      type: String,\n      trim: true,\n      maxlength: 200,\n    },\n    markerUrl: {\n      type: String,\n      validate: {\n        validator: function(url: string) {\n          return !url || /^https?:\\/\\/.+/.test(url);\n        },\n        message: 'Invalid marker URL format'\n      }\n    },\n    confidenceThreshold: {\n      type: Number,\n      min: 0.1,\n      max: 1.0,\n      default: 0.8,\n    },\n  },\n  visibility: {\n    startAt: {\n      type: Date,\n      default: Date.now,\n      index: true,\n    },\n    endAt: {\n      type: Date,\n      index: true,\n    },\n  },\n  expiresAt: {\n    type: Date,\n  },\n  status: {\n    type: String,\n    enum: Object.values(PrizeStatus),\n    default: PrizeStatus.ACTIVE,\n    index: true,\n  },\n  createdBy: {\n    type: Schema.Types.ObjectId,\n    ref: 'User',\n    required: true,\n    index: true,\n  },\n  distributionId: {\n    type: Schema.Types.ObjectId,\n    ref: 'Distribution',\n    index: true,\n  },\n  imageUrl: {\n    type: String,\n    validate: {\n      validator: function(url: string) {\n        return !url || /^https?:\\/\\/.+/.test(url);\n      },\n      message: 'Invalid image URL format'\n    }\n  },\n  value: {\n    type: Number,\n    min: 0,\n  },\n  tags: [{\n    type: String,\n    trim: true,\n    lowercase: true,\n  }],\n  capturedAt: {\n    type: Date,\n    index: true,\n  },\n  capturedBy: {\n    type: Schema.Types.ObjectId,\n    ref: 'User',\n    index: true,\n  },\n  metadata: {\n    type: Schema.Types.Mixed,\n    default: {},\n  },\n}, {\n  timestamps: true,\n  toJSON: { virtuals: true },\n  toObject: { virtuals: true }\n});\n\n// Indexes for optimal performance\nprizeSchema.index({ 'location.coordinates': '2dsphere' });\nprizeSchema.index({ \n  status: 1, \n  'visibility.startAt': 1, \n  'visibility.endAt': 1 \n});\nprizeSchema.index({ 'location.city': 1, status: 1 });\nprizeSchema.index({ createdAt: -1 });\nprizeSchema.index({ rarity: 1, category: 1 });\nprizeSchema.index({ points: -1 });\nprizeSchema.index({ expiresAt: 1 }, { expireAfterSeconds: 0 });\n\n// Compound indexes for complex queries\nprizeSchema.index({ \n  'location.city': 1, \n  status: 1, \n  rarity: 1 \n});\nprizeSchema.index({ \n  status: 1, \n  'visibility.startAt': 1, \n  'visibility.endAt': 1,\n  expiresAt: 1 \n});\nprizeSchema.index({ \n  distributionId: 1, \n  status: 1 \n});\n\n// Text index for search\nprizeSchema.index({ \n  name: 'text', \n  description: 'text', \n  tags: 'text' \n});\n\n// Virtual fields\nprizeSchema.virtual('isActive').get(function() {\n  const now = new Date();\n  return this.status === PrizeStatus.ACTIVE &&\n         this.visibility.startAt <= now &&\n         (!this.visibility.endAt || this.visibility.endAt > now) &&\n         (!this.expiresAt || this.expiresAt > now);\n});\n\nprizeSchema.virtual('isAvailable').get(function() {\n  return this.status === PrizeStatus.ACTIVE && this.claimedCount < this.quantity;\n});\n\nprizeSchema.virtual('isExpired').get(function() {\n  const now = new Date();\n  return (this.expiresAt && this.expiresAt <= now) ||\n         (this.visibility.endAt && this.visibility.endAt <= now);\n});\n\nprizeSchema.virtual('remainingQuantity').get(function() {\n  return Math.max(0, this.quantity - this.claimedCount);\n});\n\nprizeSchema.virtual('claimRate').get(function() {\n  return this.quantity > 0 ? (this.claimedCount / this.quantity) * 100 : 0;\n});\n\nprizeSchema.virtual('rarityWeight').get(function() {\n  const weights = {\n    [PrizeRarity.COMMON]: 1,\n    [PrizeRarity.UNCOMMON]: 2,\n    [PrizeRarity.RARE]: 3,\n    [PrizeRarity.EPIC]: 4,\n    [PrizeRarity.LEGENDARY]: 5,\n  };\n  return weights[this.rarity] || 1;\n});\n\nprizeSchema.virtual('estimatedValue').get(function() {\n  if (this.value) return this.value;\n\n  // Estimate value based on points and rarity\n  const baseValue = this.points * 0.1; // 10 points = 1 TND\n  const rarityMultiplier = (this as any).rarityWeight;\n  return Math.round(baseValue * rarityMultiplier * 100) / 100;\n});\n\n// Pre-save middleware\nprizeSchema.pre('save', function(next) {\n  try {\n    // Auto-set city based on coordinates if not provided\n    if (!this.location.city && this.location.coordinates) {\n      this.location.city = (this as any).findNearestCity();\n    }\n\n    // Set expiration if not provided\n    if (!this.expiresAt && this.isNew) {\n      this.expiresAt = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000); // 30 days\n    }\n\n    // Validate visibility dates\n    if (this.visibility.endAt && this.visibility.startAt >= this.visibility.endAt) {\n      throw new Error('End date must be after start date');\n    }\n\n    // Auto-capture if quantity reached\n    if (this.claimedCount >= this.quantity && this.status === PrizeStatus.ACTIVE) {\n      this.status = PrizeStatus.CAPTURED;\n      this.capturedAt = new Date();\n    }\n\n    next();\n  } catch (error) {\n    typedLogger.error('Error in prize pre-save middleware', {\n      error: (error as any).message,\n      prizeId: this._id\n    });\n    next(error);\n  }\n});\n\n// Instance methods\nprizeSchema.methods.findNearestCity = function(): string {\n  const [lng, lat] = this.location.coordinates;\n  let nearestCity = 'Tunis';\n  let minDistance = Infinity;\n  \n  Object.entries(TUNISIA_CITIES).forEach(([city, coords]) => {\n    const distance = this.calculateDistance(lat, lng, coords.lat, coords.lng);\n    if (distance < minDistance) {\n      minDistance = distance;\n      nearestCity = city;\n    }\n  });\n  \n  return nearestCity;\n};\n\nprizeSchema.methods.calculateDistance = function(\n  lat1: number, lng1: number, \n  lat2: number, lng2: number\n): number {\n  const R = 6371e3; // Earth's radius in meters\n  const ¤å1 = lat1 * Math.PI / 180;\n  const ¤å2 = lat2 * Math.PI / 180;\n  const ╬ö¤å = (lat2 - lat1) * Math.PI / 180;\n  const ╬ö╬╗ = (lng2 - lng1) * Math.PI / 180;\n\n  const a = Math.sin(╬ö¤å/2) * Math.sin(╬ö¤å/2) +\n            Math.cos(¤å1) * Math.cos(¤å2) *\n            Math.sin(╬ö╬╗/2) * Math.sin(╬ö╬╗/2);\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n\n  return R * c;\n};\n\nprizeSchema.methods.isWithinRadius = function(lat: number, lng: number): boolean {\n  const [prizeLng, prizeLat] = this.location.coordinates;\n  const distance = this.calculateDistance(lat, lng, prizeLat, prizeLng);\n  return distance <= this.location.radius;\n};\n\nprizeSchema.methods.claim = function(userId: Types.ObjectId): boolean {\n  if (!this.isAvailable) {\n    return false;\n  }\n  \n  this.claimedCount += 1;\n  \n  if (this.claimedCount >= this.quantity) {\n    this.status = PrizeStatus.CAPTURED;\n    this.capturedAt = new Date();\n    this.capturedBy = userId;\n  }\n  \n  return true;\n};\n\nprizeSchema.methods.activate = function(): void {\n  if (this.status === PrizeStatus.INACTIVE) {\n    this.status = PrizeStatus.ACTIVE;\n    this.visibility.startAt = new Date();\n  }\n};\n\nprizeSchema.methods.deactivate = function(): void {\n  if (this.status === PrizeStatus.ACTIVE) {\n    this.status = PrizeStatus.INACTIVE;\n  }\n};\n\nprizeSchema.methods.revoke = function(): void {\n  this.status = PrizeStatus.REVOKED;\n};\n\nprizeSchema.methods.extend = function(hours: number): void {\n  if (!this.expiresAt) {\n    this.expiresAt = new Date(Date.now() + hours * 60 * 60 * 1000);\n  } else {\n    this.expiresAt = new Date(this.expiresAt.getTime() + hours * 60 * 60 * 1000);\n  }\n};\n\nprizeSchema.methods.updateLocation = function(\n  lat: number, \n  lng: number, \n  radius?: number\n): void {\n  this.location.coordinates = [lng, lat];\n  this.location.city = (this as any).findNearestCity();\n  \n  if (radius) {\n    this.location.radius = radius;\n  }\n};\n\n// Static methods\nprizeSchema.statics.findNearby = function(\n  lat: number, \n  lng: number, \n  radiusKm: number = 5,\n  options: any = {}\n) {\n  const query: any = {\n    'location.coordinates': {\n      $near: {\n        $geometry: {\n          type: 'Point',\n          coordinates: [lng, lat]\n        },\n        $maxDistance: radiusKm * 1000 // Convert to meters\n      }\n    },\n    status: PrizeStatus.ACTIVE,\n    'visibility.startAt': { $lte: new Date() },\n    $and: [\n      {\n        $or: [\n          { 'visibility.endAt': { $exists: false } },\n          { 'visibility.endAt': { $gt: new Date() } }\n        ]\n      },\n      {\n        $or: [\n          { expiresAt: { $exists: false } },\n          { expiresAt: { $gt: new Date() } }\n        ]\n      }\n    ]\n  };\n  \n  if (options.category) {\n    query.category = options.category;\n  }\n  \n  if (options.rarity) {\n    query.rarity = options.rarity;\n  }\n  \n  if (options.minPoints) {\n    query.points = { $gte: options.minPoints };\n  }\n  \n  if (options.maxPoints) {\n    query.points = { ...query.points, $lte: options.maxPoints };\n  }\n  \n  return this.find(query)\n    .limit(options.limit || 50)\n    .sort({ points: -1 });\n};\n\nprizeSchema.statics.findByCity = function(city: string, options: any = {}) {\n  const query: any = {\n    'location.city': city,\n    status: PrizeStatus.ACTIVE,\n    'visibility.startAt': { $lte: new Date() },\n    $or: [\n      { 'visibility.endAt': { $exists: false } },\n      { 'visibility.endAt': { $gt: new Date() } }\n    ]\n  };\n  \n  return this.find(query)\n    .limit(options.limit || 100)\n    .sort(options.sort || { points: -1 });\n};\n\nprizeSchema.statics.findExpired = function() {\n  const now = new Date();\n  return this.find({\n    $or: [\n      { expiresAt: { $lte: now } },\n      { 'visibility.endAt': { $lte: now } }\n    ],\n    status: { $ne: PrizeStatus.EXPIRED }\n  });\n};\n\nprizeSchema.statics.findByDistribution = function(distributionId: Types.ObjectId) {\n  return this.find({ distributionId });\n};\n\nprizeSchema.statics.getStatsByCity = async function() {\n  return this.aggregate([\n    {\n      $group: {\n        _id: '$location.city',\n        totalPrizes: { $sum: 1 },\n        activePrizes: {\n          $sum: {\n            $cond: [{ $eq: ['$status', PrizeStatus.ACTIVE] }, 1, 0]\n          }\n        },\n        claimedPrizes: {\n          $sum: {\n            $cond: [{ $eq: ['$status', PrizeStatus.CAPTURED] }, 1, 0]\n          }\n        },\n        totalPoints: { $sum: '$points' },\n        averagePoints: { $avg: '$points' },\n        rarityDistribution: { $push: '$rarity' }\n      }\n    },\n    { $sort: { totalPrizes: -1 } }\n  ]);\n};\n\nprizeSchema.statics.getHeatmapData = async function(city?: string) {\n  const match: any = {\n    status: PrizeStatus.ACTIVE,\n    'visibility.startAt': { $lte: new Date() }\n  };\n  \n  if (city) {\n    match['location.city'] = city;\n  }\n  \n  return this.aggregate([\n    { $match: match },\n    {\n      $group: {\n        _id: {\n          lat: { $round: [{ $arrayElemAt: ['$location.coordinates', 1] }, 3] },\n          lng: { $round: [{ $arrayElemAt: ['$location.coordinates', 0] }, 3] }\n        },\n        count: { $sum: 1 },\n        totalPoints: { $sum: '$points' },\n        averagePoints: { $avg: '$points' }\n      }\n    },\n    {\n      $project: {\n        _id: 0,\n        lat: '$_id.lat',\n        lng: '$_id.lng',\n        count: 1,\n        totalPoints: 1,\n        averagePoints: { $round: ['$averagePoints', 0] }\n      }\n    }\n  ]);\n};\n\nprizeSchema.statics.cleanupExpired = async function() {\n  const result = await this.updateMany(\n    {\n      $or: [\n        { expiresAt: { $lte: new Date() } },\n        { 'visibility.endAt': { $lte: new Date() } }\n      ],\n      status: { $ne: PrizeStatus.EXPIRED }\n    },\n    { \n      $set: { \n        status: PrizeStatus.EXPIRED \n      } \n    }\n  );\n  \n  typedLogger.info('Expired prizes cleaned up', { \n    modifiedCount: result.modifiedCount \n  });\n  \n  return result;\n};\n\n// Create and export the model\nexport const Prize: IPrizeModel = model<IPrize, IPrizeModel>('Prize', prizeSchema);\nexport default Prize;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\models\\Redemption.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\models\\Report.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\models\\Reward.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Types' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'logger' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":16},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":106,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":106,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2271,2274],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2271,2274],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":159,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":159,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3629,3632],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3629,3632],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":160,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":160,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3656,3659],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3656,3659],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":194,"column":83,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":194,"endColumn":86,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4468,4471],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4468,4471],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":205,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":205,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4764,4767],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4764,4767],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Schema, model, Model, Types } from 'mongoose';\nimport { IReward, RewardCategory } from '@/types';\nimport { logger } from '@/lib/logger';\n\nconst rewardSchema = new Schema<IReward>({\n  name: {\n    type: String,\n    required: true,\n    trim: true,\n    minlength: 2,\n    maxlength: 100,\n    index: true,\n  },\n  description: {\n    type: String,\n    required: true,\n    trim: true,\n    maxlength: 500,\n  },\n  category: {\n    type: String,\n    enum: Object.values(RewardCategory),\n    required: true,\n    index: true,\n  },\n  pointsCost: {\n    type: Number,\n    required: true,\n    min: 1,\n    max: 100000,\n    index: true,\n  },\n  stockQuantity: {\n    type: Number,\n    required: true,\n    min: 0,\n  },\n  stockReserved: {\n    type: Number,\n    default: 0,\n    min: 0,\n  },\n  stockAvailable: {\n    type: Number,\n    required: true,\n    min: 0,\n  },\n  imageUrl: {\n    type: String,\n    validate: {\n      validator: function(url: string) {\n        return !url || /^https?:\\/\\/.+/.test(url);\n      },\n      message: 'Invalid image URL format'\n    }\n  },\n  isActive: {\n    type: Boolean,\n    default: true,\n    index: true,\n  },\n  isPopular: {\n    type: Boolean,\n    default: false,\n    index: true,\n  },\n  partnerId: {\n    type: Schema.Types.ObjectId,\n    ref: 'Partner',\n    index: true,\n  },\n  metadata: {\n    type: Schema.Types.Mixed,\n    default: {},\n  },\n  updatedBy: {\n    type: Schema.Types.ObjectId,\n    ref: 'User',\n    index: true,\n  },\n}, {\n  timestamps: true,\n  toJSON: { virtuals: true },\n  toObject: { virtuals: true }\n});\n\n// Indexes\nrewardSchema.index({ category: 1, pointsCost: 1 });\nrewardSchema.index({ isActive: 1, pointsCost: 1 });\nrewardSchema.index({ isPopular: 1, pointsCost: 1 });\nrewardSchema.index({ name: 'text', description: 'text' });\nrewardSchema.index({ 'metadata.isSponsored': 1, isActive: 1, createdAt: -1 });\n\n// Virtual fields\nrewardSchema.virtual('isAvailable').get(function() {\n  return this.isActive && this.stockAvailable > 0;\n});\n\nrewardSchema.virtual('stockUsed').get(function() {\n  return this.stockQuantity - this.stockAvailable - this.stockReserved;\n});\n\nrewardSchema.virtual('popularityScore').get(function() {\n  // Simple popularity calculation based on stock usage\n  if (this.stockQuantity === 0) return 0;\n  return ((this as any).stockUsed / this.stockQuantity) * 100;\n});\n\n// Pre-save middleware\nrewardSchema.pre('save', function(next) {\n  // Ensure stock consistency\n  if (this.stockReserved + this.stockAvailable > this.stockQuantity) {\n    this.stockAvailable = Math.max(0, this.stockQuantity - this.stockReserved);\n  }\n  \n  next();\n});\n\n// Instance methods\nrewardSchema.methods.reserveStock = function(quantity: number = 1): boolean {\n  if (this.stockAvailable < quantity) {\n    return false;\n  }\n  \n  this.stockAvailable -= quantity;\n  this.stockReserved += quantity;\n  return true;\n};\n\nrewardSchema.methods.releaseReservation = function(quantity: number = 1): void {\n  const toRelease = Math.min(quantity, this.stockReserved);\n  this.stockReserved -= toRelease;\n  this.stockAvailable += toRelease;\n};\n\nrewardSchema.methods.confirmRedemption = function(quantity: number = 1): boolean {\n  if (this.stockReserved < quantity) {\n    return false;\n  }\n  \n  this.stockReserved -= quantity;\n  return true;\n};\n\nrewardSchema.methods.addStock = function(quantity: number): void {\n  this.stockQuantity += quantity;\n  this.stockAvailable += quantity;\n};\n\nrewardSchema.methods.activate = function(): void {\n  this.isActive = true;\n};\n\nrewardSchema.methods.deactivate = function(): void {\n  this.isActive = false;\n};\n\n// Static methods\nrewardSchema.statics.findAvailable = function(options: any = {}) {\n  const query: any = {\n    isActive: true,\n    stockAvailable: { $gt: 0 },\n  };\n  \n  if (options.category) {\n    query.category = options.category;\n  }\n  \n  if (options.maxCost) {\n    query.pointsCost = { $lte: options.maxCost };\n  }\n  \n  if (options.minCost) {\n    query.pointsCost = { ...query.pointsCost, $gte: options.minCost };\n  }\n  \n  return this.find(query)\n    .populate('partnerId', 'name logo')\n    .sort(options.sort || { pointsCost: 1 })\n    .limit(options.limit || 50);\n};\n\nrewardSchema.statics.findPopular = function(limit: number = 10) {\n  return this.find({\n    isActive: true,\n    stockAvailable: { $gt: 0 },\n    isPopular: true,\n  })\n    .populate('partnerId', 'name logo')\n    .sort({ pointsCost: 1 })\n    .limit(limit);\n};\n\nrewardSchema.statics.findByCategory = function(category: RewardCategory, options: any = {}) {\n  return this.find({\n    category,\n    isActive: true,\n    stockAvailable: { $gt: 0 },\n  })\n    .populate('partnerId', 'name logo')\n    .sort(options.sort || { pointsCost: 1 })\n    .limit(options.limit || 50);\n};\n\nrewardSchema.statics.searchRewards = function(query: string, options: any = {}) {\n  return this.find({\n    $text: { $search: query },\n    isActive: true,\n    stockAvailable: { $gt: 0 },\n  })\n    .populate('partnerId', 'name logo logoUrl')\n    .sort({ score: { $meta: 'textScore' } })\n    .limit(options.limit || 20);\n};\n\nrewardSchema.statics.getStats = async function() {\n  const stats = await this.aggregate([\n    {\n      $group: {\n        _id: null,\n        totalRewards: { $sum: 1 },\n        activeRewards: {\n          $sum: { $cond: ['$isActive', 1, 0] }\n        },\n        totalStock: { $sum: '$stockQuantity' },\n        availableStock: { $sum: '$stockAvailable' },\n        reservedStock: { $sum: '$stockReserved' },\n        totalValue: { $sum: { $multiply: ['$pointsCost', '$stockQuantity'] } },\n        categoryDistribution: { $push: '$category' },\n      }\n    }\n  ]);\n  \n  return stats[0] || {\n    totalRewards: 0,\n    activeRewards: 0,\n    totalStock: 0,\n    availableStock: 0,\n    reservedStock: 0,\n    totalValue: 0,\n    categoryDistribution: [],\n  };\n};\n\nrewardSchema.statics.getLowStockRewards = function(threshold: number = 10) {\n  return this.find({\n    isActive: true,\n    stockAvailable: { $lte: threshold, $gt: 0 },\n  })\n    .populate('partnerId', 'name')\n    .sort({ stockAvailable: 1 });\n};\n\nexport const Reward: Model<IReward> = model<IReward>('Reward', rewardSchema);\nexport default Reward;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\models\\Session.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\models\\Settings.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\models\\User.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Model' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'AchievementTrigger' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":115,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":133},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":38,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[994,997],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[994,997],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/ban-types","severity":2,"message":"Don't use `{}` as a type. `{}` actually means \"any non-nullish value\".\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.\n- If you want a type meaning \"empty object\", you probably want `Record<string, never>` instead.\n- If you really want a type meaning \"any non-nullish value\", you probably want `NonNullable<unknown>` instead.","line":71,"column":64,"nodeType":"TSTypeLiteral","messageId":"bannedTypeMessage","endLine":71,"endColumn":66,"suggestions":[{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"object"},"fix":{"range":[1725,1727],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"unknown"},"fix":{"range":[1725,1727],"text":"unknown"},"desc":"Replace `{}` with `unknown`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"Record<string, never>"},"fix":{"range":[1725,1727],"text":"Record<string, never>"},"desc":"Replace `{}` with `Record<string, never>`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"NonNullable<unknown>"},"fix":{"range":[1725,1727],"text":"NonNullable<unknown>"},"desc":"Replace `{}` with `NonNullable<unknown>`."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":441,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":441,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9455,9458],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9455,9458],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":444,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":444,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9539,9542],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9539,9542],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":453,"column":79,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":453,"endColumn":82,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9825,9828],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9825,9828],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":466,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":466,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10260,10263],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10260,10263],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":498,"column":85,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":498,"endColumn":88,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11298,11301],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11298,11301],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":558,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":558,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12877,12880],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12877,12880],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":559,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":559,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12946,12949],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12946,12949],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":560,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":560,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13024,13027],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13024,13027],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":561,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":561,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13103,13106],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13103,13106],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":604,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":604,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14158,14161],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14158,14161],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":620,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":620,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14582,14585],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14582,14585],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":722,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":722,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17319,17322],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17319,17322],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":769,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":769,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18576,18579],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18576,18579],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":17,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Schema, model, Model } from 'mongoose';\nimport bcrypt from 'bcryptjs';\nimport { IUser, IDevice, IUserModel, IUserMethods, IUserVirtuals, UserRole, UserLevel, Platform, Language, Theme, AchievementTrigger } from '@/types';\nimport { DeviceToken, DevicePlatform } from '@/models/DeviceToken';\nimport { config } from '@/config';\nimport { typedLogger } from '@/lib/typed-logger';\n\n// Device subdocument schema\nconst deviceSchema = new Schema<IDevice>({\n  deviceId: { \n    type: String, \n    required: true,\n    index: true,\n  },\n  platform: { \n    type: String, \n    enum: Object.values(Platform), \n    required: true \n  },\n  fcmToken: { \n    type: String,\n    sparse: true,\n  },\n  model: { type: String },\n  osVersion: { type: String },\n  appVersion: { type: String },\n  userAgent: { type: String },\n  lastUsed: { \n    type: Date, \n    default: Date.now \n  },\n  isActive: { \n    type: Boolean, \n    default: true \n  },\n}, { _id: false });\n\nconst normalizeNotificationPreferences = (value: any) => {\n  if (typeof value === 'boolean') {\n    return {\n      push: value,\n      email: value,\n      sms: value,\n      inApp: value,\n      types: {},\n    };\n  }\n\n  if (value && typeof value === 'object' && !Array.isArray(value)) {\n    return {\n      push: value.push ?? true,\n      email: value.email ?? false,\n      sms: value.sms ?? false,\n      inApp: value.inApp ?? true,\n      types: value.types && typeof value.types === 'object' ? value.types : {},\n    };\n  }\n\n  return {\n    push: true,\n    email: false,\n    sms: false,\n    inApp: true,\n    types: {},\n  };\n};\n\nconst isBcryptHash = (value: string) => /^\\$2[aby]\\$\\d{2}\\$/.test(value);\n\n// Main user schema\nconst userSchema = new Schema<IUser, IUserModel, IUserMethods, {}, IUserVirtuals>({\n  email: { \n    type: String, \n    unique: true, \n    sparse: true,\n    lowercase: true,\n    trim: true,\n    validate: {\n      validator: function(email: string) {\n        return !email || /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email);\n      },\n      message: 'Invalid email format'\n    }\n  },\n  username: {\n    type: String,\n    unique: true,\n    sparse: true,\n    lowercase: true,\n    trim: true,\n    minlength: 3,\n    maxlength: 50,\n  },\n  passwordHash: { \n    type: String,\n    select: false, // Don't include in queries by default\n  },\n  displayName: { \n    type: String, \n    required: true,\n    trim: true,\n    minlength: 2,\n    maxlength: 50,\n  },\n  role: { \n    type: String, \n    enum: Object.values(UserRole), \n    default: UserRole.PLAYER,\n    index: true,\n  },\n  status: {\n    type: String,\n    enum: ['active', 'suspended', 'banned', 'deleted', 'inactive'],\n    default: 'active',\n    index: true,\n  },\n  partnerId: {\n    type: Schema.Types.ObjectId,\n    ref: 'Partner',\n    index: true,\n    required: false,\n  },\n  points: {\n    available: { \n      type: Number, \n      default: 0,\n      min: 0,\n    },\n    total: { \n      type: Number, \n      default: 0,\n      min: 0,\n      index: true, // For leaderboards\n    },\n    spent: { \n      type: Number, \n      default: 0,\n      min: 0,\n    },\n  },\n  level: { \n    type: String, \n    enum: Object.values(UserLevel), \n    default: UserLevel.BRONZE,\n    index: true,\n  },\n  location: {\n    lat: { \n      type: Number,\n      min: -90,\n      max: 90,\n    },\n    lng: { \n      type: Number,\n      min: -180,\n      max: 180,\n    },\n    city: { \n      type: String,\n      index: true,\n    },\n    lastUpdated: { \n      type: Date \n    },\n  },\n  stats: {\n    prizesFound: { \n      type: Number, \n      default: 0,\n      min: 0,\n    },\n    rewardsRedeemed: { \n      type: Number, \n      default: 0,\n      min: 0,\n    },\n    sessionsCount: { \n      type: Number, \n      default: 0,\n      min: 0,\n    },\n    totalPlayTime: { \n      type: Number, \n      default: 0,\n      min: 0, // in seconds\n    },\n    totalDistance: {\n      type: Number,\n      default: 0,\n      min: 0, // in meters\n    },\n    longestStreak: { \n      type: Number, \n      default: 0,\n      min: 0,\n    },\n    currentStreak: { \n      type: Number, \n      default: 0,\n      min: 0,\n    },\n    favoriteCity: { \n      type: String \n    },\n    lastClaimDate: { \n      type: Date \n    },\n    dailyClaimsCount: { \n      type: Number, \n      default: 0,\n      min: 0,\n    },\n  },\n  devices: [deviceSchema],\n  preferences: {\n    notifications: {\n      push: {\n        type: Boolean,\n        default: true,\n      },\n      email: {\n        type: Boolean,\n        default: false,\n      },\n      sms: {\n        type: Boolean,\n        default: false,\n      },\n      inApp: {\n        type: Boolean,\n        default: true,\n      },\n      types: {\n        type: Schema.Types.Mixed,\n        default: {},\n      },\n    },\n    language: { \n      type: String, \n      enum: Object.values(Language), \n      default: Language.FR \n    },\n    theme: { \n      type: String, \n      enum: Object.values(Theme), \n      default: Theme.LIGHT \n    },\n  },\n  isGuest: {\n    type: Boolean,\n    default: false,\n    index: true,\n  },\n  isBanned: {\n    type: Boolean,\n    default: false,\n    index: true,\n  },\n  offlineMode: {\n    type: Boolean,\n    default: false,\n    index: true,\n  },\n  lastSync: {\n    type: Date,\n    index: true,\n  },\n  // Game inventory and effects system\n  inventory: {\n    powerUps: [{\n      id: String,\n      type: { type: String },\n      quantity: { type: Number, default: 0 },\n      expiresAt: Date\n    }],\n    items: [{\n      id: String,\n      name: String,\n      type: String,\n      quantity: { type: Number, default: 0 },\n      expiresAt: Date\n    }]\n  },\n  activeEffects: [{\n    type: String,\n    effect: Schema.Types.Mixed,\n    expiresAt: Date,\n    createdAt: { type: Date, default: Date.now }\n  }],\n  banReason: {\n    type: String\n  },\n  banExpiresAt: {\n    type: Date,\n    index: true,\n  },\n  phoneNumber: {\n    type: String,\n    sparse: true,  // Allows multiple null values but unique for non-null values\n  },\n  avatar: {\n    type: String,\n    default: null,\n  },\n  lastIp: {\n    type: String,\n    index: true,\n  },\n  lastUserAgent: {\n    type: String,\n  },\n  lastActive: {\n    type: Date,\n    default: Date.now,\n    index: true,\n  },\n  deletedAt: {\n    type: Date,\n    index: true,\n  },\n}, {\n  timestamps: true,\n  toJSON: {\n    virtuals: true,\n    transform: function(doc, ret) {\n      delete ret.passwordHash;\n      delete ret.__v;\n      return ret;\n    }\n  },\n  toObject: {\n    virtuals: true,\n    transform: function(doc, ret) {\n      delete ret.passwordHash;\n      delete ret.__v;\n      return ret;\n    }\n  }\n});\n\n// Compound indexes\nuserSchema.index({ role: 1, lastActive: -1 });\nuserSchema.index({ 'location.city': 1, level: 1 });\nuserSchema.index({ isBanned: 1, deletedAt: 1 });\n\n// Virtual fields\nuserSchema.virtual('isActive').get(function() {\n  const oneWeekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);\n  return this.lastActive > oneWeekAgo;\n});\n\nuserSchema.virtual('levelProgress').get(function() {\n  const levelRequirements = {\n    [UserLevel.BRONZE]: 0,\n    [UserLevel.SILVER]: 1000,\n    [UserLevel.GOLD]: 5000,\n    [UserLevel.PLATINUM]: 15000,\n    [UserLevel.DIAMOND]: 50000,\n  };\n  \n  const currentRequirement = levelRequirements[this.level];\n  const nextLevel = Object.values(UserLevel)[Object.values(UserLevel).indexOf(this.level) + 1];\n  const nextRequirement = nextLevel ? levelRequirements[nextLevel] : null;\n  \n  if (!nextRequirement) {\n    return { \n      progress: 100, \n      pointsToNext: 0, \n      nextLevel: null,\n      currentLevel: this.level,\n      pointsForNext: 0\n    };\n  }\n  \n  const progress = Math.min(100, ((this.points.total - currentRequirement) / (nextRequirement - currentRequirement)) * 100);\n  const pointsToNext = Math.max(0, nextRequirement - this.points.total);\n  \n  return { \n    progress, \n    pointsToNext, \n    nextLevel,\n    currentLevel: this.level,\n    pointsForNext: pointsToNext\n  };\n});\n\nuserSchema.virtual('activeDevice').get(function() {\n  if (!this.devices || !Array.isArray(this.devices)) return null;\n  return this.devices.find(device => device.isActive) || this.devices[0];\n});\n\n// isGuest is a real field in the schema, not a virtual\n\nuserSchema.virtual('canClaim').get(function() {\n  if (this.isBanned) return false;\n  if (this.deletedAt) return false;\n  \n  // Check daily limit\n  const today = new Date();\n  const lastClaim = this.stats.lastClaimDate;\n  \n  if (lastClaim && \n      lastClaim.toDateString() === today.toDateString() && \n      this.stats.dailyClaimsCount >= config.GAME_MAX_DAILY_CLAIMS) {\n    return false;\n  }\n  \n  return true;\n});\n\nuserSchema.pre('init', function(doc) {\n  if (doc && doc.preferences) {\n    doc.preferences.notifications = normalizeNotificationPreferences(doc.preferences.notifications);\n  }\n});\n\n// Pre-save middleware for password hashing\nuserSchema.pre('save', async function(next) {\n  try {\n    if (this.preferences) {\n      this.preferences.notifications = normalizeNotificationPreferences(this.preferences.notifications);\n    }\n\n    if (this.deletedAt) {\n      this.status = 'deleted';\n    } else if (this.isBanned) {\n      this.status = 'banned';\n    } else if (!this.status) {\n      this.status = 'active';\n    }\n\n    // Hash password if modified\n    if (this.isModified('passwordHash') && this.passwordHash) {\n      // Use bcrypt everywhere for portability across environments\n      if (!isBcryptHash(this.passwordHash)) {\n        this.passwordHash = await bcrypt.hash(this.passwordHash, config.BCRYPT_ROUNDS);\n      }\n    }\n    \n    // Update level based on points\n    (this as any).updateLevel();\n\n    // Reset daily claims count if it's a new day\n    (this as any).resetDailyClaimsIfNeeded();\n    \n    // Update last active timestamp\n    if (this.isModified('lastActive') || this.isNew) {\n      this.lastActive = new Date();\n    }\n    \n    next();\n  } catch (error) {\n    typedLogger.error('Error in user pre-save middleware', { error: (error as any).message, userId: this._id });\n    next(error);\n  }\n});\n\n// Instance methods\nuserSchema.methods.comparePassword = async function(candidatePassword: string): Promise<boolean> {\n  try {\n    if (!this.passwordHash) return false;\n    \n    // Always use bcrypt for simplicity\n    return await bcrypt.compare(candidatePassword, this.passwordHash);\n  } catch (error) {\n    typedLogger.error('Error comparing password', { error: (error as any).message, userId: this._id });\n    return false;\n  }\n};\n\nuserSchema.methods.updateLevel = function(): void {\n  const totalPoints = this.points.total;\n  let newLevel = UserLevel.BRONZE;\n  \n  if (totalPoints >= 50000) newLevel = UserLevel.DIAMOND;\n  else if (totalPoints >= 15000) newLevel = UserLevel.PLATINUM;\n  else if (totalPoints >= 5000) newLevel = UserLevel.GOLD;\n  else if (totalPoints >= 1000) newLevel = UserLevel.SILVER;\n  \n  if (this.level !== newLevel) {\n    const oldLevel = this.level;\n    this.level = newLevel;\n    \n    typedLogger.info('User level updated', {\n      userId: this._id,\n      oldLevel,\n      newLevel,\n      totalPoints,\n    });\n\n    // Trigger achievements (async, don't wait)\n    import('@/services/achievement').then(({ default: AchievementService }) => {\n      AchievementService.checkAchievements(this._id.toString(), 'LEVEL_UP', {\n        oldLevel,\n        newLevel,\n        totalPoints,\n      }).catch(error => {\n        typedLogger.error('Check achievements error (LEVEL_UP)', { error: (error as any).message, userId: this._id });\n      });\n    });\n  }\n};\n\nuserSchema.methods.addPoints = function(points: number): void {\n  this.points.available += points;\n  this.points.total += points;\n  this.updateLevel();\n};\n\nuserSchema.methods.spendPoints = function(points: number): boolean {\n  if (this.points.available < points) {\n    return false;\n  }\n  \n  this.points.available -= points;\n  this.points.spent += points;\n  return true;\n};\n\nuserSchema.methods.updateLocation = function(lat: number, lng: number, city: string): void {\n  this.location = {\n    lat,\n    lng,\n    city,\n    lastUpdated: new Date(),\n  };\n  \n  // Update favorite city based on frequency\n  this.updateFavoriteCity(city);\n};\n\nuserSchema.methods.updateFavoriteCity = function(city: string): void {\n  // Simple implementation - could be enhanced with more sophisticated tracking\n  if (!this.stats.favoriteCity) {\n    this.stats.favoriteCity = city;\n  }\n};\n\nuserSchema.methods.addDevice = function(\n  deviceId: string,\n  platform: Platform,\n  fcmToken?: string,\n  meta?: { model?: string; osVersion?: string; appVersion?: string; userAgent?: string }\n): void {\n  // Deactivate existing devices\n  this.devices.forEach(device => {\n    device.isActive = false;\n  });\n  \n  // Check if device already exists\n  const existingDevice = this.devices.find(device => device.deviceId === deviceId);\n  \n  if (existingDevice) {\n    existingDevice.platform = platform;\n    existingDevice.fcmToken = fcmToken;\n    existingDevice.lastUsed = new Date();\n    existingDevice.isActive = true;\n    if (meta?.model) (existingDevice as any).model = meta.model;\n    if (meta?.osVersion) (existingDevice as any).osVersion = meta.osVersion;\n    if (meta?.appVersion) (existingDevice as any).appVersion = meta.appVersion;\n    if (meta?.userAgent) (existingDevice as any).userAgent = meta.userAgent;\n  } else {\n    this.devices.push({\n      deviceId,\n      platform,\n      fcmToken,\n      model: meta?.model,\n      osVersion: meta?.osVersion,\n      appVersion: meta?.appVersion,\n      userAgent: meta?.userAgent,\n      lastUsed: new Date(),\n      isActive: true,\n    });\n  }\n\n  if (fcmToken) {\n    const platformKey = platform?.toString?.().toLowerCase?.() || '';\n    const devicePlatform =\n      platformKey === 'ios'\n        ? DevicePlatform.IOS\n        : platformKey === 'android'\n        ? DevicePlatform.ANDROID\n        : DevicePlatform.WEB;\n\n    DeviceToken.updateOne(\n      { userId: this._id, deviceId },\n      {\n        $set: {\n          fcmToken,\n          platform: devicePlatform,\n          isActive: true,\n          lastUsed: new Date(),\n        },\n        $setOnInsert: {\n          userId: this._id,\n          deviceId,\n        },\n      },\n      { upsert: true }\n    ).catch(error => {\n      typedLogger.warn('Device token sync failed', {\n        userId: this._id,\n        deviceId,\n        error: (error as any).message,\n      });\n    });\n  }\n};\n\nuserSchema.methods.removeDevice = function(deviceId: string): void {\n  this.devices = this.devices.filter(device => device.deviceId !== deviceId);\n\n  DeviceToken.updateOne(\n    { userId: this._id, deviceId },\n    { $set: { isActive: false } }\n  ).catch(error => {\n    typedLogger.warn('Device token deactivate failed', {\n      userId: this._id,\n      deviceId,\n      error: (error as any).message,\n    });\n  });\n};\n\nuserSchema.methods.updateStreak = function(): void {\n  const today = new Date();\n  const yesterday = new Date(today.getTime() - 24 * 60 * 60 * 1000);\n  const lastClaim = this.stats.lastClaimDate;\n  \n  if (!lastClaim) {\n    this.stats.currentStreak = 1;\n  } else if (lastClaim.toDateString() === yesterday.toDateString()) {\n    this.stats.currentStreak += 1;\n  } else if (lastClaim.toDateString() !== today.toDateString()) {\n    this.stats.currentStreak = 1;\n  }\n  \n  if (this.stats.currentStreak > this.stats.longestStreak) {\n    this.stats.longestStreak = this.stats.currentStreak;\n  }\n};\n\nuserSchema.methods.resetDailyClaimsIfNeeded = function(): void {\n  const today = new Date();\n  const lastClaim = this.stats.lastClaimDate;\n  \n  if (!lastClaim || lastClaim.toDateString() !== today.toDateString()) {\n    this.stats.dailyClaimsCount = 0;\n  }\n};\n\nuserSchema.methods.incrementDailyClaims = function(): void {\n  this.stats.dailyClaimsCount += 1;\n  this.stats.lastClaimDate = new Date();\n  this.updateStreak();\n};\n\nuserSchema.methods.ban = function(reason: string, duration?: number): void {\n  this.isBanned = true;\n  this.banReason = reason;\n  this.status = 'banned';\n  \n  if (duration) {\n    this.banExpiresAt = new Date(Date.now() + duration);\n  }\n  \n  typedLogger.warn('User banned', {\n    userId: this._id,\n    reason,\n    duration,\n    expiresAt: this.banExpiresAt,\n  });\n};\n\nuserSchema.methods.unban = function(): void {\n  this.isBanned = false;\n  this.banReason = undefined;\n  this.banExpiresAt = undefined;\n  this.status = 'active';\n  \n  typedLogger.info('User unbanned', { userId: this._id });\n};\n\nuserSchema.methods.softDelete = function(): void {\n  this.deletedAt = new Date();\n  this.status = 'deleted';\n  this.email = undefined;\n  this.passwordHash = undefined;\n  this.devices = [];\n  \n  typedLogger.info('User soft deleted', { userId: this._id });\n};\n\nuserSchema.methods.restore = function(): void {\n  this.deletedAt = undefined;\n  this.status = 'active';\n  \n  typedLogger.info('User restored', { userId: this._id });\n};\n\n// Static methods\nuserSchema.statics.findByEmail = function(email: string) {\n  return this.findOne({ email: email.toLowerCase(), deletedAt: { $exists: false } });\n};\n\nuserSchema.statics.findByDeviceId = function(deviceId: string) {\n  return this.findOne({ \n    'devices.deviceId': deviceId,\n    deletedAt: { $exists: false }\n  });\n};\n\nuserSchema.statics.findActiveUsers = function(days: number = 7) {\n  const cutoff = new Date(Date.now() - days * 24 * 60 * 60 * 1000);\n  return this.find({ \n    lastActive: { $gte: cutoff },\n    deletedAt: { $exists: false }\n  });\n};\n\nuserSchema.statics.getLeaderboard = function(city?: string, limit: number = 100) {\n  const query: any = { deletedAt: { $exists: false } };\n  if (city) {\n    query['location.city'] = city;\n  }\n  \n  return this.find(query)\n    .sort({ 'points.total': -1 })\n    .limit(limit)\n    .select('displayName points.total level location.city stats.prizesFound');\n};\n\nuserSchema.statics.getUserStats = async function() {\n  const stats = await this.aggregate([\n    { $match: { deletedAt: { $exists: false } } },\n    {\n      $group: {\n        _id: null,\n        totalUsers: { $sum: 1 },\n        activeUsers: {\n          $sum: {\n            $cond: [\n              { $gte: ['$lastActive', new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)] },\n              1,\n              0\n            ]\n          }\n        },\n        totalPoints: { $sum: '$points.total' },\n        averagePoints: { $avg: '$points.total' },\n        levelDistribution: {\n          $push: '$level'\n        }\n      }\n    }\n  ]);\n  \n  return stats[0] || {};\n};\n\n// Static helper: get required points for a given level\nuserSchema.statics.getPointsForLevel = function(level: UserLevel): number {\n  const levelRequirements: Record<UserLevel, number> = {\n    [UserLevel.BRONZE]: 0,\n    [UserLevel.SILVER]: 1000,\n    [UserLevel.GOLD]: 5000,\n    [UserLevel.PLATINUM]: 15000,\n    [UserLevel.DIAMOND]: 50000,\n  } as any;\n  return levelRequirements[level] ?? 0;\n};\n\n// Create and export the model\nexport const User: IUserModel = model<IUser, IUserModel>('User', userSchema);\nexport default User;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\models\\UserAchievement.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\models\\UserNotification.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'DevicePlatform' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":24}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Schema, model, Model, Types } from 'mongoose';\nimport { DevicePlatform } from './DeviceToken';\n\n// Define the UserNotification interface\nexport interface IUserNotification {\n  _id: Types.ObjectId;\n  userId: Types.ObjectId;           // Reference to user\n  notificationId: Types.ObjectId;   // Reference to global notification\n  status: 'sent' | 'delivered' | 'opened' | 'archived';\n  isRead: boolean;\n  isDelivered: boolean;\n  isArchived: boolean;\n  deliveredAt?: Date;\n  readAt?: Date;\n  archivedAt?: Date;\n  channel: 'push' | 'email' | 'inapp';\n  deliveryToken?: string;           // FCM/APNS token used for delivery\n  errorReason?: string;             // Reason for delivery failure\n  preferencesApplied: {             // Preferences at time of delivery\n    push: boolean;\n    email: boolean;\n    inApp: boolean;\n  };\n  createdAt: Date;\n  updatedAt: Date;\n}\n\n// Define the UserNotification schema\nconst userNotificationSchema = new Schema<IUserNotification>({\n  userId: {\n    type: Schema.Types.ObjectId,\n    ref: 'User',\n    required: true,\n    index: true\n  },\n  notificationId: {\n    type: Schema.Types.ObjectId,\n    ref: 'Notification',\n    required: true,\n    index: true\n  },\n  status: {\n    type: String,\n    enum: ['sent', 'delivered', 'opened', 'archived'],\n    default: 'sent',\n    required: true\n  },\n  isRead: {\n    type: Boolean,\n    default: false,\n    required: true\n  },\n  isDelivered: {\n    type: Boolean,\n    default: false,\n    required: true\n  },\n  isArchived: {\n    type: Boolean,\n    default: false,\n    required: true\n  },\n  deliveredAt: Date,\n  readAt: Date,\n  archivedAt: Date,\n  channel: {\n    type: String,\n    enum: ['push', 'email', 'inapp'],\n    required: true\n  },\n  deliveryToken: {\n    type: String,\n    // Token used for this specific delivery (FCM, APNS, etc.)\n  },\n  errorReason: {\n    type: String,\n    // If delivery failed, store the error reason\n  },\n  preferencesApplied: {\n    push: { type: Boolean, default: true },\n    email: { type: Boolean, default: true },\n    inApp: { type: Boolean, default: true }\n  }\n}, {\n  timestamps: true,\n  toJSON: { virtuals: true },\n  toObject: { virtuals: true }\n});\n\n// Create compound index for efficient queries\nuserNotificationSchema.index({ userId: 1, createdAt: -1 });\nuserNotificationSchema.index({ userId: 1, isRead: 1 });\nuserNotificationSchema.index({ notificationId: 1, userId: 1 }, { unique: true }); // Each user gets each notification only once\n\nexport const UserNotification: Model<IUserNotification> = model<IUserNotification>('UserNotification', userNotificationSchema);\nexport default UserNotification;","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\models\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\admin\\index.refactored.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\admin\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\admin\\routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\admin\\routes\\ab-testing.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":38,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1419,1422],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1419,1422],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":38,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1449,1452],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1449,1452],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":39,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1524,1527],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1524,1527],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":88,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3217,3220],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3217,3220],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":88,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3247,3250],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3247,3250],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":89,"column":83,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":89,"endColumn":86,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3343,3346],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3343,3346],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":113,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":113,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4067,4070],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4067,4070],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":113,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":113,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4097,4100],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4097,4100],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":136,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":136,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4812,4815],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4812,4815],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":136,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":136,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4842,4845],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4842,4845],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":159,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":159,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5553,5556],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5553,5556],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":159,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":159,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5583,5586],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5583,5586],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":212,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":212,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7449,7452],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7449,7452],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":212,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":212,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7479,7482],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7479,7482],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyInstance, FastifyRequest } from 'fastify';\r\nimport { authenticate, requireAdmin } from '@/middleware/auth';\r\nimport { adminRateLimit } from '@/middleware/distributed-rate-limit';\r\nimport { ABTestingService } from '../services/admin-ab-testing.service';\r\nimport { audit } from '@/lib/audit-logger';\r\nimport { z } from 'zod';\r\n\r\nconst CreateTestSchema = z.object({\r\n  name: z.string().min(3),\r\n  description: z.string().optional(),\r\n  type: z.enum(['feature', 'ui', 'mechanics', 'rewards', 'pricing']),\r\n  variants: z.array(\r\n    z.object({\r\n      name: z.string(),\r\n      trafficAllocation: z.number().min(0).max(100),\r\n      config: z.record(z.any())\r\n    })\r\n  ),\r\n  startDate: z.string().datetime(),\r\n  sampleSize: z.number().optional(),\r\n  confidenceLevel: z.number().optional()\r\n});\r\n\r\nconst UpdateTestSchema = CreateTestSchema.partial();\r\n\r\ntype CreateTestRequest = z.infer<typeof CreateTestSchema>;\r\ntype UpdateTestRequest = z.infer<typeof UpdateTestSchema>;\r\n\r\nexport default async function abTestingRoutes(fastify: FastifyInstance) {\r\n  fastify.addHook('preHandler', authenticate);\r\n  fastify.addHook('preHandler', requireAdmin);\r\n  fastify.addHook('preHandler', adminRateLimit);\r\n\r\n  // Create A/B Test\r\n  fastify.post<{ Body: CreateTestRequest }>('/ab-testing', async (request, reply) => {\r\n    try {\r\n      const data = CreateTestSchema.parse(request.body);\r\n      const userId = (request as any).user?.sub || (request as any).userId;\r\n      const test = await ABTestingService.createTest(data as any, userId);\r\n      \r\n      // Audit log\r\n      await audit.custom({\r\n        userId,\r\n        userRole: 'admin',\r\n        action: 'CREATE_AB_TEST',\r\n        resource: 'ab_test',\r\n        resourceId: test._id?.toString(),\r\n        category: 'admin',\r\n        severity: 'low',\r\n        metadata: { name: data.name, type: data.type },\r\n      });\r\n      \r\n      return reply.code(201).send({ success: true, data: test });\r\n    } catch (error) {\r\n      return reply.code(400).send({ success: false, error: (error as Error).message });\r\n    }\r\n  });\r\n\r\n  // Get all A/B Tests with filters\r\n  fastify.get('/ab-testing', async (request: FastifyRequest<{ Querystring: { status?: string; type?: string } }>, reply) => {\r\n    try {\r\n      const tests = await ABTestingService.getTests({\r\n        status: request.query.status,\r\n        type: request.query.type\r\n      });\r\n      return reply.send({ success: true, data: tests });\r\n    } catch (error) {\r\n      return reply.code(500).send({ success: false, error: (error as Error).message });\r\n    }\r\n  });\r\n\r\n  // Get A/B Test by ID\r\n  fastify.get<{ Params: { id: string } }>('/ab-testing/:id', async (request, reply) => {\r\n    try {\r\n      const test = await ABTestingService.getTestById(request.params.id);\r\n      return reply.send({ success: true, data: test });\r\n    } catch (error) {\r\n      return reply.code(404).send({ success: false, error: (error as Error).message });\r\n    }\r\n  });\r\n\r\n  // Update A/B Test\r\n  fastify.patch<{ Params: { id: string }; Body: UpdateTestRequest }>(\r\n    '/ab-testing/:id',\r\n    async (request, reply) => {\r\n      try {\r\n        const data = UpdateTestSchema.parse(request.body);\r\n        const userId = (request as any).user?.sub || (request as any).userId;\r\n        const test = await ABTestingService.updateTest(request.params.id, data as any);\r\n        \r\n        // Audit log\r\n        await audit.custom({\r\n          userId,\r\n          userRole: 'admin',\r\n          action: 'UPDATE_AB_TEST',\r\n          resource: 'ab_test',\r\n          resourceId: request.params.id,\r\n          category: 'admin',\r\n          severity: 'low',\r\n          metadata: { changes: Object.keys(data) },\r\n        });\r\n        \r\n        return reply.send({ success: true, data: test });\r\n      } catch (error) {\r\n        return reply.code(400).send({ success: false, error: (error as Error).message });\r\n      }\r\n    }\r\n  );\r\n\r\n  // Start A/B Test\r\n  fastify.post<{ Params: { id: string } }>('/ab-testing/:id/start', async (request, reply) => {\r\n    try {\r\n      const userId = (request as any).user?.sub || (request as any).userId;\r\n      const test = await ABTestingService.startTest(request.params.id);\r\n      \r\n      // Audit log\r\n      await audit.custom({\r\n        userId,\r\n        userRole: 'admin',\r\n        action: 'START_AB_TEST',\r\n        resource: 'ab_test',\r\n        resourceId: request.params.id,\r\n        category: 'admin',\r\n        severity: 'medium',\r\n      });\r\n      \r\n      return reply.send({ success: true, data: test });\r\n    } catch (error) {\r\n      return reply.code(400).send({ success: false, error: (error as Error).message });\r\n    }\r\n  });\r\n\r\n  // Pause A/B Test\r\n  fastify.post<{ Params: { id: string } }>('/ab-testing/:id/pause', async (request, reply) => {\r\n    try {\r\n      const userId = (request as any).user?.sub || (request as any).userId;\r\n      const test = await ABTestingService.pauseTest(request.params.id);\r\n      \r\n      // Audit log\r\n      await audit.custom({\r\n        userId,\r\n        userRole: 'admin',\r\n        action: 'PAUSE_AB_TEST',\r\n        resource: 'ab_test',\r\n        resourceId: request.params.id,\r\n        category: 'admin',\r\n        severity: 'medium',\r\n      });\r\n      \r\n      return reply.send({ success: true, data: test });\r\n    } catch (error) {\r\n      return reply.code(400).send({ success: false, error: (error as Error).message });\r\n    }\r\n  });\r\n\r\n  // End A/B Test\r\n  fastify.post<{ Params: { id: string } }>('/ab-testing/:id/end', async (request, reply) => {\r\n    try {\r\n      const userId = (request as any).user?.sub || (request as any).userId;\r\n      const test = await ABTestingService.endTest(request.params.id);\r\n      \r\n      // Audit log\r\n      await audit.custom({\r\n        userId,\r\n        userRole: 'admin',\r\n        action: 'END_AB_TEST',\r\n        resource: 'ab_test',\r\n        resourceId: request.params.id,\r\n        category: 'admin',\r\n        severity: 'medium',\r\n      });\r\n      \r\n      return reply.send({ success: true, data: test });\r\n    } catch (error) {\r\n      return reply.code(400).send({ success: false, error: (error as Error).message });\r\n    }\r\n  });\r\n\r\n  // Get A/B Test Metrics\r\n  fastify.get<{ Params: { id: string } }>('/ab-testing/:id/metrics', async (request, reply) => {\r\n    try {\r\n      const metrics = await ABTestingService.getMetrics(request.params.id);\r\n      return reply.send({ success: true, data: metrics });\r\n    } catch (error) {\r\n      return reply.code(500).send({ success: false, error: (error as Error).message });\r\n    }\r\n  });\r\n\r\n  // Get A/B Test Results\r\n  fastify.get<{ Params: { id: string } }>('/ab-testing/:id/results', async (request, reply) => {\r\n    try {\r\n      const results = await ABTestingService.getTestResults(request.params.id);\r\n      return reply.send({ success: true, data: results });\r\n    } catch (error) {\r\n      return reply.code(500).send({ success: false, error: (error as Error).message });\r\n    }\r\n  });\r\n\r\n  // Get Active Tests\r\n  fastify.get('/ab-testing/active/list', async (request, reply) => {\r\n    try {\r\n      const tests = await ABTestingService.getActiveTests();\r\n      return reply.send({ success: true, data: tests });\r\n    } catch (error) {\r\n      return reply.code(500).send({ success: false, error: (error as Error).message });\r\n    }\r\n  });\r\n\r\n  // Delete A/B Test\r\n  fastify.delete<{ Params: { id: string } }>('/ab-testing/:id', async (request, reply) => {\r\n    try {\r\n      const userId = (request as any).user?.sub || (request as any).userId;\r\n      await ABTestingService.deleteTest(request.params.id);\r\n      \r\n      // Audit log\r\n      await audit.custom({\r\n        userId,\r\n        userRole: 'admin',\r\n        action: 'DELETE_AB_TEST',\r\n        resource: 'ab_test',\r\n        resourceId: request.params.id,\r\n        category: 'admin',\r\n        severity: 'medium',\r\n      });\r\n      \r\n      return reply.send({ success: true, message: 'Test deleted successfully' });\r\n    } catch (error) {\r\n      return reply.code(500).send({ success: false, error: (error as Error).message });\r\n    }\r\n  });\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\admin\\routes\\analytics.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\admin\\routes\\anti-cheat.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":8,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[386,389],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[386,389],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":8,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[396,399],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[396,399],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":8,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[405,408],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[405,408],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/ban-types","severity":2,"message":"Don't use `{}` as a type. `{}` actually means \"any non-nullish value\".\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.\n- If you want a type meaning \"empty object\", you probably want `Record<string, never>` instead.\n- If you really want a type meaning \"any non-nullish value\", you probably want `NonNullable<unknown>` instead.","line":22,"column":35,"nodeType":"TSTypeLiteral","messageId":"bannedTypeMessage","endLine":22,"endColumn":37,"suggestions":[{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"object"},"fix":{"range":[848,850],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"unknown"},"fix":{"range":[848,850],"text":"unknown"},"desc":"Replace `{}` with `unknown`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"Record<string, never>"},"fix":{"range":[848,850],"text":"Record<string, never>"},"desc":"Replace `{}` with `Record<string, never>`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"NonNullable<unknown>"},"fix":{"range":[848,850],"text":"NonNullable<unknown>"},"desc":"Replace `{}` with `NonNullable<unknown>`."}]},{"ruleId":"@typescript-eslint/ban-types","severity":2,"message":"Don't use `{}` as a type. `{}` actually means \"any non-nullish value\".\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.\n- If you want a type meaning \"empty object\", you probably want `Record<string, never>` instead.\n- If you really want a type meaning \"any non-nullish value\", you probably want `NonNullable<unknown>` instead.","line":22,"column":39,"nodeType":"TSTypeLiteral","messageId":"bannedTypeMessage","endLine":22,"endColumn":41,"suggestions":[{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"object"},"fix":{"range":[852,854],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"unknown"},"fix":{"range":[852,854],"text":"unknown"},"desc":"Replace `{}` with `unknown`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"Record<string, never>"},"fix":{"range":[852,854],"text":"Record<string, never>"},"desc":"Replace `{}` with `Record<string, never>`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"NonNullable<unknown>"},"fix":{"range":[852,854],"text":"NonNullable<unknown>"},"desc":"Replace `{}` with `NonNullable<unknown>`."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":40,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1586,1589],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1586,1589],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":55,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2184,2187],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2184,2187],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":67,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2595,2598],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2595,2598],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":79,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3016,3019],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3016,3019],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/ban-types","severity":2,"message":"Don't use `{}` as a type. `{}` actually means \"any non-nullish value\".\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.\n- If you want a type meaning \"empty object\", you probably want `Record<string, never>` instead.\n- If you really want a type meaning \"any non-nullish value\", you probably want `NonNullable<unknown>` instead.","line":87,"column":35,"nodeType":"TSTypeLiteral","messageId":"bannedTypeMessage","endLine":87,"endColumn":37,"suggestions":[{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"object"},"fix":{"range":[3279,3281],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"unknown"},"fix":{"range":[3279,3281],"text":"unknown"},"desc":"Replace `{}` with `unknown`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"Record<string, never>"},"fix":{"range":[3279,3281],"text":"Record<string, never>"},"desc":"Replace `{}` with `Record<string, never>`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"NonNullable<unknown>"},"fix":{"range":[3279,3281],"text":"NonNullable<unknown>"},"desc":"Replace `{}` with `NonNullable<unknown>`."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":138,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":138,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4799,4802],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4799,4802],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":157,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":157,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5360,5363],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5360,5363],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/ban-types","severity":2,"message":"Don't use `{}` as a type. `{}` actually means \"any non-nullish value\".\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.\n- If you want a type meaning \"empty object\", you probably want `Record<string, never>` instead.\n- If you really want a type meaning \"any non-nullish value\", you probably want `NonNullable<unknown>` instead.","line":165,"column":35,"nodeType":"TSTypeLiteral","messageId":"bannedTypeMessage","endLine":165,"endColumn":37,"suggestions":[{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"object"},"fix":{"range":[5603,5605],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"unknown"},"fix":{"range":[5603,5605],"text":"unknown"},"desc":"Replace `{}` with `unknown`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"Record<string, never>"},"fix":{"range":[5603,5605],"text":"Record<string, never>"},"desc":"Replace `{}` with `Record<string, never>`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"NonNullable<unknown>"},"fix":{"range":[5603,5605],"text":"NonNullable<unknown>"},"desc":"Replace `{}` with `NonNullable<unknown>`."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":196,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":196,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6689,6692],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6689,6692],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/ban-types","severity":2,"message":"Don't use `{}` as a type. `{}` actually means \"any non-nullish value\".\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.\n- If you want a type meaning \"empty object\", you probably want `Record<string, never>` instead.\n- If you really want a type meaning \"any non-nullish value\", you probably want `NonNullable<unknown>` instead.","line":204,"column":35,"nodeType":"TSTypeLiteral","messageId":"bannedTypeMessage","endLine":204,"endColumn":37,"suggestions":[{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"object"},"fix":{"range":[6958,6960],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"unknown"},"fix":{"range":[6958,6960],"text":"unknown"},"desc":"Replace `{}` with `unknown`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"Record<string, never>"},"fix":{"range":[6958,6960],"text":"Record<string, never>"},"desc":"Replace `{}` with `Record<string, never>`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"NonNullable<unknown>"},"fix":{"range":[6958,6960],"text":"NonNullable<unknown>"},"desc":"Replace `{}` with `NonNullable<unknown>`."}]},{"ruleId":"@typescript-eslint/ban-types","severity":2,"message":"Don't use `{}` as a type. `{}` actually means \"any non-nullish value\".\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.\n- If you want a type meaning \"empty object\", you probably want `Record<string, never>` instead.\n- If you really want a type meaning \"any non-nullish value\", you probably want `NonNullable<unknown>` instead.","line":204,"column":39,"nodeType":"TSTypeLiteral","messageId":"bannedTypeMessage","endLine":204,"endColumn":41,"suggestions":[{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"object"},"fix":{"range":[6962,6964],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"unknown"},"fix":{"range":[6962,6964],"text":"unknown"},"desc":"Replace `{}` with `unknown`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"Record<string, never>"},"fix":{"range":[6962,6964],"text":"Record<string, never>"},"desc":"Replace `{}` with `Record<string, never>`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"NonNullable<unknown>"},"fix":{"range":[6962,6964],"text":"NonNullable<unknown>"},"desc":"Replace `{}` with `NonNullable<unknown>`."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":220,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":220,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7413,7416],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7413,7416],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":251,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":251,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8563,8566],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8563,8566],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":18,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyInstance, FastifyRequest } from 'fastify';\r\nimport { authenticate, requireAdmin } from '@/middleware/auth';\r\nimport { adminRateLimit } from '@/middleware/distributed-rate-limit';\r\nimport { AntiCheatMonitoringService } from '@/services/anti-cheat-monitoring';\r\nimport { audit } from '@/lib/audit-logger';\r\nimport { z } from 'zod';\r\n\r\ntype AdminRequest<P = Record<string, any>, B = any, Q = any> = FastifyRequest<{\r\n  Params: P;\r\n  Body: B;\r\n  Querystring: Q;\r\n}>;\r\n\r\n/**\r\n * Anti-Cheat Monitoring Routes\r\n * Admin endpoints for viewing, analyzing, and managing fraud detection\r\n */\r\nexport default async function antiCheatRoutes(fastify: FastifyInstance) {\r\n  // Get all flagged claims with filters\r\n  fastify.get('/flagged-claims', {\r\n    preHandler: [authenticate, requireAdmin, adminRateLimit],\r\n  }, async (request: AdminRequest<{}, {}, {\r\n    userId?: string;\r\n    riskLevel?: string;\r\n    status?: string;\r\n    limit?: string;\r\n    offset?: string;\r\n  }>, reply) => {\r\n    try {\r\n      const filters = {\r\n        userId: request.query.userId,\r\n        riskLevel: request.query.riskLevel as 'high' | 'critical' | undefined,\r\n        status: request.query.status as 'pending' | 'approved' | 'rejected' | 'overridden' | undefined,\r\n        limit: request.query.limit ? parseInt(request.query.limit as string) : 50,\r\n        offset: request.query.offset ? parseInt(request.query.offset as string) : 0,\r\n      };\r\n\r\n      const result = await AntiCheatMonitoringService.getFlaggedClaims(filters);\r\n      reply.send({ success: true, data: result });\r\n    } catch (error: any) {\r\n      reply.code(500).send({ success: false, error: error.message });\r\n    }\r\n  });\r\n\r\n  // Get user risk profile\r\n  fastify.get('/user-risk/:userId', {\r\n    preHandler: [authenticate, requireAdmin, adminRateLimit],\r\n  }, async (request: AdminRequest<{ userId: string }>, reply) => {\r\n    try {\r\n      const profile = await AntiCheatMonitoringService.getUserRiskProfile(request.params.userId);\r\n      if (!profile) {\r\n        return reply.code(404).send({ success: false, error: 'User not found' });\r\n      }\r\n      return reply.send({ success: true, data: profile });\r\n    } catch (error: any) {\r\n      return reply.code(500).send({ success: false, error: error.message });\r\n    }\r\n  });\r\n\r\n  // Get anti-cheat metrics\r\n  fastify.get('/metrics', {\r\n    preHandler: [authenticate, requireAdmin, adminRateLimit],\r\n  }, async (request, reply) => {\r\n    try {\r\n      const metrics = await AntiCheatMonitoringService.getMetrics();\r\n      reply.send({ success: true, data: metrics });\r\n    } catch (error: any) {\r\n      reply.code(500).send({ success: false, error: error.message });\r\n    }\r\n  });\r\n\r\n  // Get fraud pattern analysis\r\n  fastify.get('/patterns', {\r\n    preHandler: [authenticate, requireAdmin, adminRateLimit],\r\n  }, async (request, reply) => {\r\n    try {\r\n      const patterns = await AntiCheatMonitoringService.analyzeFraudPatterns();\r\n      reply.send({ success: true, data: patterns });\r\n    } catch (error: any) {\r\n      reply.code(500).send({ success: false, error: error.message });\r\n    }\r\n  });\r\n\r\n  // Override claim decision (approve or reject)\r\n  fastify.post('/override-claim', {\r\n    preHandler: [authenticate, requireAdmin],\r\n  }, async (request: AdminRequest<{}, {\r\n    claimId: string;\r\n    decision: 'approve' | 'reject';\r\n    notes?: string;\r\n  }>, reply) => {\r\n    try {\r\n      // Validate request body\r\n      const schema = z.object({\r\n        claimId: z.string().min(1, 'claimId is required'),\r\n        decision: z.enum(['approve', 'reject']),\r\n        notes: z.string().optional(),\r\n      });\r\n\r\n      const validation = schema.safeParse(request.body);\r\n      if (!validation.success) {\r\n        return reply.code(400).send({\r\n          success: false,\r\n          error: validation.error.errors[0].message,\r\n        });\r\n      }\r\n\r\n      const { claimId, decision, notes } = validation.data;\r\n      const result = await AntiCheatMonitoringService.overrideClaim(\r\n        claimId,\r\n        request.user.sub,\r\n        decision,\r\n        notes\r\n      );\r\n\r\n      if (!result) {\r\n        return reply.code(404).send({ success: false, error: 'Claim not found' });\r\n      }\r\n\r\n      // Audit log - this is a critical action\r\n      await audit.custom({\r\n        userId: request.user.sub,\r\n        userRole: 'admin',\r\n        action: `OVERRIDE_CLAIM_${decision.toUpperCase()}`,\r\n        resource: 'claim',\r\n        resourceId: claimId,\r\n        category: 'admin',\r\n        severity: 'high',\r\n        description: `Admin overrode claim decision: ${decision}`,\r\n        metadata: { claimId, decision, notes },\r\n      });\r\n\r\n      return reply.send({\r\n        success: true,\r\n        message: `Claim ${decision}d successfully`,\r\n        data: result,\r\n      });\r\n    } catch (error: any) {\r\n      return reply.code(500).send({ success: false, error: error.message });\r\n    }\r\n  });\r\n\r\n  // Get risk score threshold settings\r\n  fastify.get('/settings', {\r\n    preHandler: [authenticate, requireAdmin, adminRateLimit],\r\n  }, async (request, reply) => {\r\n    try {\r\n      // TODO: Get from Settings/ConfigService\r\n      const settings = {\r\n        riskThreshold: 50,\r\n        criticalThreshold: 75,\r\n        autoRejectAbove: 90,\r\n        autoApproveBelow: 20,\r\n      };\r\n\r\n      reply.send({ success: true, data: settings });\r\n    } catch (error: any) {\r\n      reply.code(500).send({ success: false, error: error.message });\r\n    }\r\n  });\r\n\r\n  // Update risk score thresholds\r\n  fastify.patch('/settings', {\r\n    preHandler: [authenticate, requireAdmin],\r\n  }, async (request: AdminRequest<{}, {\r\n    riskThreshold?: number;\r\n    criticalThreshold?: number;\r\n    autoRejectAbove?: number;\r\n    autoApproveBelow?: number;\r\n  }>, reply) => {\r\n    try {\r\n      // TODO: Update via ConfigService\r\n      const schema = z.object({\r\n        riskThreshold: z.number().min(0).max(100).optional(),\r\n        criticalThreshold: z.number().min(0).max(100).optional(),\r\n        autoRejectAbove: z.number().min(0).max(100).optional(),\r\n        autoApproveBelow: z.number().min(0).max(100).optional(),\r\n      });\r\n\r\n      const validation = schema.safeParse(request.body);\r\n      if (!validation.success) {\r\n        return reply.code(400).send({\r\n          success: false,\r\n          error: validation.error.errors[0].message,\r\n        });\r\n      }\r\n\r\n      // Audit log\r\n      await audit.settingsUpdated(request.user.sub, 'anti_cheat', { metadata: { changes: Object.keys(validation.data) } });\r\n\r\n      // TODO: Implement settings update via ConfigService\r\n      return reply.send({\r\n        success: true,\r\n        message: 'Settings updated successfully',\r\n      });\r\n    } catch (error: any) {\r\n      return reply.code(500).send({ success: false, error: error.message });\r\n    }\r\n  });\r\n\r\n  // Get recent anti-cheat alerts\r\n  fastify.get('/recent-alerts', {\r\n    preHandler: [authenticate, requireAdmin, adminRateLimit],\r\n  }, async (request: AdminRequest<{}, {}, { limit?: string }>, reply) => {\r\n    try {\r\n      const limit = request.query.limit ? parseInt(request.query.limit as string) : 20;\r\n      \r\n      const result = await AntiCheatMonitoringService.getFlaggedClaims({\r\n        riskLevel: 'critical',\r\n        limit,\r\n      });\r\n\r\n      reply.send({\r\n        success: true,\r\n        data: {\r\n          alerts: result.claims,\r\n          count: result.total,\r\n        },\r\n      });\r\n    } catch (error: any) {\r\n      reply.code(500).send({ success: false, error: error.message });\r\n    }\r\n  });\r\n\r\n  // Export anti-cheat report\r\n  fastify.get('/export-report', {\r\n    preHandler: [authenticate, requireAdmin],\r\n  }, async (request, reply) => {\r\n    try {\r\n      const metrics = await AntiCheatMonitoringService.getMetrics();\r\n      const patterns = await AntiCheatMonitoringService.analyzeFraudPatterns();\r\n\r\n      const report = {\r\n        generatedAt: new Date().toISOString(),\r\n        metrics,\r\n        patterns,\r\n        summary: {\r\n          flagRate: `${metrics.flaggedClaimsCount}/${metrics.totalClaimsAnalyzed}`,\r\n          rejectionRate: `${metrics.rejectionRate.toFixed(2)}%`,\r\n          overrideRate: `${metrics.overrideRate.toFixed(2)}%`,\r\n          topRiskFactors: metrics.topRiskFactors.slice(0, 5),\r\n          topFlaggedUsers: metrics.topFlaggedUsers.slice(0, 5),\r\n        },\r\n      };\r\n\r\n      // Set response headers for file download\r\n      reply\r\n        .header('Content-Type', 'application/json')\r\n        .header('Content-Disposition', 'attachment; filename=\"anti-cheat-report.json\"')\r\n        .send(report);\r\n    } catch (error: any) {\r\n      reply.code(500).send({ success: false, error: error.message });\r\n    }\r\n  });\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\admin\\routes\\claims.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'resolveReportSchema' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":36,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":36,"endColumn":26},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":72,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2653,2656],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2653,2656],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":72,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2683,2686],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2683,2686],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":109,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4293,4296],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4293,4296],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":109,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4323,4326],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4323,4326],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":118,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":118,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4781,4784],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4781,4784],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":118,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":118,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4811,4814],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4811,4814],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyInstance, FastifyRequest } from 'fastify';\nimport { authenticate, requireAdmin } from '@/middleware/auth';\nimport { adminRateLimit } from '@/middleware/distributed-rate-limit';\nimport { AdminClaimsService } from '../services/admin-claims.service';\nimport { z } from 'zod';\n\nconst listClaimsSchema = z.object({\n  page: z.coerce.number().min(1).default(1),\n  limit: z.coerce.number().min(1).max(100).default(20),\n  status: z.enum(['pending', 'validated', 'rejected', 'expired', 'approved', 'overridden']).optional(),\n  search: z.string().optional(),\n  userId: z.string().optional(),\n  prizeId: z.string().optional(),\n  startDate: z.string().optional(),\n  endDate: z.string().optional(),\n});\n\nconst analyticsSchema = z.object({\n  period: z.string().optional(),\n  startDate: z.string().optional(),\n  endDate: z.string().optional(),\n});\n\nconst listCaptureReportsSchema = z.object({\n  page: z.coerce.number().min(1).default(1),\n  limit: z.coerce.number().min(1).max(100).default(20),\n  status: z.string().optional(),\n  captureId: z.string().optional(),\n});\n\nconst validateClaimSchema = z.object({\n  isValid: z.boolean(),\n  reason: z.string().optional(),\n});\n\nconst resolveReportSchema = z.object({\n  action: z.enum(['resolve', 'reject']),\n  reason: z.string().optional(),\n});\n\nexport default async function claimsRoutes(fastify: FastifyInstance) {\n  // Apply middleware to all routes\n  fastify.addHook('onRequest', authenticate);\n  fastify.addHook('onRequest', requireAdmin);\n  fastify.addHook('onRequest', adminRateLimit);\n\n  // GET /claims - list claims with pagination/filters\n  fastify.get('/claims', async (request: FastifyRequest, reply) => {\n    const query = listClaimsSchema.parse(request.query);\n    const claims = await AdminClaimsService.getClaims(query);\n    return reply.send(claims);\n  });\n\n  // GET /claims/stats - get claims statistics\n  fastify.get('/claims/stats', async (request: FastifyRequest, reply) => {\n    const query = analyticsSchema.parse(request.query);\n    const stats = await AdminClaimsService.getClaimsStats(query);\n    return reply.send(stats);\n  });\n\n  // GET /claims/:id - get single claim\n  fastify.get('/claims/:id', async (request: FastifyRequest<{ Params: { id: string } }>, reply) => {\n    const { id } = request.params;\n    const claim = await AdminClaimsService.getClaim(id);\n    return reply.send(claim);\n  });\n\n  // PATCH /claims/:id/validate - validate claim\n  fastify.patch('/claims/:id/validate', async (request: FastifyRequest<{ Params: { id: string } }>, reply) => {\n    const { id } = request.params;\n    const body = validateClaimSchema.parse(request.body);\n    const adminId = (request as any).user?.sub || (request as any).userId;\n    const result = await AdminClaimsService.validateClaim(adminId, id, body.isValid, body.reason);\n    return reply.send(result);\n  });\n\n  // POST /captures - alias for listing claims (admin panel compatibility)\n  fastify.post('/captures', async (request: FastifyRequest, reply) => {\n    const query = listClaimsSchema.parse(request.body);\n    const claims = await AdminClaimsService.getClaims(query);\n    return reply.send(claims);\n  });\n\n  // GET /captures - alias for listing claims\n  fastify.get('/captures', async (request: FastifyRequest, reply) => {\n    const query = listClaimsSchema.parse(request.query);\n    const claims = await AdminClaimsService.getClaims(query);\n    return reply.send(claims);\n  });\n\n  // GET /captures/analytics - claims analytics\n  fastify.get('/captures/analytics', async (request: FastifyRequest, reply) => {\n    const query = analyticsSchema.parse(request.query);\n    const analytics = await AdminClaimsService.getClaimsAnalytics(query.period || '30d');\n    return reply.send(analytics);\n  });\n\n  // GET /captures/stats - capture stats\n  fastify.get('/captures/stats', async (request: FastifyRequest, reply) => {\n    const query = analyticsSchema.parse(request.query);\n    const stats = await AdminClaimsService.getClaimsStats(query);\n    return reply.send(stats);\n  });\n\n  // POST /captures/:id/validate - validate capture\n  fastify.post('/captures/:id/validate', async (request: FastifyRequest<{ Params: { id: string } }>, reply) => {\n    const { id } = request.params;\n    const body = validateClaimSchema.parse(request.body);\n    const adminId = (request as any).user?.sub || (request as any).userId;\n    const result = await AdminClaimsService.validateClaim(adminId, id, body.isValid, body.reason);\n    return reply.send(result);\n  });\n\n  // POST /captures/:id/reject - reject capture\n  fastify.post('/captures/:id/reject', async (request: FastifyRequest<{ Params: { id: string } }>, reply) => {\n    const { id } = request.params;\n    const body = z.object({ reason: z.string().optional() }).parse(request.body);\n    const adminId = (request as any).user?.sub || (request as any).userId;\n    const result = await AdminClaimsService.validateClaim(adminId, id, false, body.reason);\n    return reply.send(result);\n  });\n\n  // GET /captures/reports - get capture reports\n  fastify.get('/captures/reports', async (request: FastifyRequest, reply) => {\n    const query = listCaptureReportsSchema.parse(request.query);\n    const reports = await AdminClaimsService.getCaptureReports(query);\n    return reply.send(reports);\n  });\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\admin\\routes\\dashboard.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\admin\\routes\\distribution.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\admin\\routes\\extra.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ARSession' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":19},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":26,"column":112,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":115,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1285,1288],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1285,1288],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":78,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":78,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3071,3074],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3071,3074],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":108,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":108,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4149,4152],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4149,4152],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":111,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4215,4218],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4215,4218],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":111,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4244,4247],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4244,4247],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":124,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":124,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4741,4744],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4741,4744],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":132,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":132,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5040,5043],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5040,5043],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":135,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":135,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5106,5109],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5106,5109],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":135,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":135,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5135,5138],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5135,5138],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":162,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":162,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6030,6033],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6030,6033],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":162,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":162,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6059,6062],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6059,6062],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":185,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":185,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6942,6945],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6942,6945],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":185,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":185,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6971,6974],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6971,6974],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":222,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":222,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8424,8427],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8424,8427],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":265,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":265,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9959,9962],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9959,9962],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":268,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":268,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10025,10028],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10025,10028],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":268,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":268,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10054,10057],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10054,10057],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":269,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":269,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10104,10107],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10104,10107],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":298,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":298,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11382,11385],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11382,11385],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":314,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":314,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11934,11937],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11934,11937],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":317,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":317,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12000,12003],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12000,12003],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":317,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":317,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12029,12032],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12029,12032],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":321,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":321,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12234,12237],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12234,12237],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":323,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":323,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12289,12292],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12289,12292],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":350,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":350,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13192,13195],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13192,13195],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":350,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":350,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13221,13224],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13221,13224],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":375,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":375,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14193,14196],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14193,14196],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":394,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":394,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14935,14938],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14935,14938],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":394,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":394,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14964,14967],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14964,14967],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":396,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":396,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15062,15065],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15062,15065],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":455,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":455,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17329,17332],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17329,17332],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":516,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":516,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19754,19757],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19754,19757],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":548,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":548,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21024,21027],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21024,21027],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":591,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":591,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22686,22689],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22686,22689],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":591,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":591,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22715,22718],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22715,22718],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":592,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":592,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22772,22775],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22772,22775],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":592,"column":79,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":592,"endColumn":82,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22808,22811],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22808,22811],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":614,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":614,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23557,23560],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23557,23560],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":614,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":614,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23586,23589],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23586,23589],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":615,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":615,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23639,23642],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23639,23642],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":615,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":615,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23671,23674],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23671,23674],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":669,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":669,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25520,25523],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25520,25523],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":669,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":669,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25550,25553],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25550,25553],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":678,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":678,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25935,25938],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25935,25938],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":696,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":696,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26534,26537],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26534,26537],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":714,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":714,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[27173,27176],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[27173,27176],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":714,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":714,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[27203,27206],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[27203,27206],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":719,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":719,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[27512,27515],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[27512,27515],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":720,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":720,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[27570,27573],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[27570,27573],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":737,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":737,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28140,28143],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28140,28143],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":772,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":772,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[29401,29404],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[29401,29404],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":772,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":772,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[29431,29434],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[29431,29434],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":821,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":821,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31053,31056],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31053,31056],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":821,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":821,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31083,31086],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31083,31086],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":855,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":855,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32266,32269],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32266,32269],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":855,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":855,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32296,32299],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32296,32299],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":864,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":864,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32633,32636],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32633,32636],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":865,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":865,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32674,32677],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32674,32677],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":878,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":878,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[33000,33003],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[33000,33003],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":878,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":878,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[33030,33033],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[33030,33033],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":886,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":886,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[33421,33424],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[33421,33424],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":887,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":887,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[33462,33465],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[33462,33465],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":904,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":904,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[33999,34002],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[33999,34002],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":920,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":920,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[34593,34596],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[34593,34596],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":920,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":920,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[34623,34626],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[34623,34626],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":941,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":941,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[35404,35407],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[35404,35407],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":972,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":972,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[36462,36465],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[36462,36465],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":972,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":972,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[36492,36495],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[36492,36495],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":977,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":977,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[36793,36796],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[36793,36796],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":978,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":978,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[36846,36849],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[36846,36849],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":995,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":995,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[37389,37392],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[37389,37392],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1014,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1014,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[38084,38087],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[38084,38087],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1014,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1014,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[38114,38117],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[38114,38117],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1016,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1016,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[38209,38212],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[38209,38212],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1036,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1036,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[39007,39010],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[39007,39010],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1036,"column":79,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1036,"endColumn":82,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[39054,39057],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[39054,39057],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1037,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1037,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[39114,39117],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[39114,39117],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1057,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1057,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[39644,39647],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[39644,39647],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1057,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1057,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[39674,39677],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[39674,39677],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1059,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1059,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[39770,39773],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[39770,39773],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1089,"column":88,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1089,"endColumn":91,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[40929,40932],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[40929,40932],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1090,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1090,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[40983,40986],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[40983,40986],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1090,"column":79,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1090,"endColumn":82,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[41030,41033],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[41030,41033],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1091,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1091,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[41090,41093],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[41090,41093],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1112,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1112,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[41878,41881],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[41878,41881],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1135,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1135,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[42850,42853],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[42850,42853],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1139,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1139,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[43118,43121],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[43118,43121],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1142,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1142,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[43234,43237],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[43234,43237],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1211,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1211,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[45886,45889],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[45886,45889],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1241,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1241,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[47022,47025],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[47022,47025],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1242,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1242,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[47043,47046],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[47043,47046],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":92,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyInstance, FastifyRequest } from 'fastify'\nimport { Types } from 'mongoose'\nimport { authenticate, requireAdmin } from '@/middleware/auth'\nimport { adminRateLimit } from '@/middleware/distributed-rate-limit'\nimport { Achievement } from '@/models/Achievement'\nimport { UserAchievement } from '@/models/UserAchievement'\nimport { Reward } from '@/models/Reward'\nimport { Report } from '@/models/Report'\nimport { Session } from '@/models/Session'\nimport { Friendship } from '@/models/Friendship'\nimport { Code } from '@/models/Code'\nimport { ARSession } from '@/models/ARSession'\nimport { OfflineQueue } from '@/models/OfflineQueue'\nimport { DeviceToken } from '@/models/DeviceToken'\nimport { Redemption } from '@/models/Redemption'\nimport { AuditLog } from '@/models/AuditLog'\nimport { User } from '@/models/User'\nimport { CodeStatus, RedemptionStatus } from '@/types'\nimport { audit } from '@/lib/audit-logger'\nimport { broadcastAdminEvent } from '@/lib/websocket'\nimport { CacheService } from '@/services/cache'\nimport { GamificationService } from '@/modules/gamification'\nimport crypto from 'crypto'\n\n// Helper to log admin actions using unified audit logger\nasync function logAdminAction(adminId: string, action: string, resource: string, resourceId: string, details?: any) {\n  // Use unified audit logger - writes to both Pino and MongoDB\n  await audit.custom({\n    userId: adminId,\n    userRole: 'admin',\n    action: action.toUpperCase(),\n    resource,\n    resourceId,\n    category: 'admin',\n    severity: action.includes('DELETE') ? 'medium' : 'low',\n    metadata: details,\n  });\n}\n\nexport default async function extraRoutes(fastify: FastifyInstance) {\n  fastify.addHook('onRequest', authenticate)\n  fastify.addHook('onRequest', requireAdmin)\n  fastify.addHook('onRequest', adminRateLimit)\n\n  // ==================== ACHIEVEMENTS ====================\n\n  // Get achievements for a specific user (admin)\n  fastify.get('/achievements/user/:userId', async (request: FastifyRequest<{\n    Params: { userId: string }\n  }>, reply) => {\n    try {\n      const { userId } = request.params\n      if (!userId || !userId.match(/^[0-9a-fA-F]{24}$/)) {\n        return reply.status(400).send({ error: 'Invalid userId' })\n      }\n      const achievements = await GamificationService.getUserAchievements(userId)\n      return reply.send({ success: true, data: achievements })\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to fetch user achievements' })\n    }\n  })\n\n  // GET achievements with caching\n  fastify.get('/achievements', async (request: FastifyRequest<{\n    Querystring: { page?: string; limit?: string; category?: string }\n  }>, reply) => {\n    try {\n      const { page = '1', limit = '20', category } = request.query\n      const cacheKey = `admin:achievements:${page}:${limit}:${category || 'all'}`\n      \n      // Try cache first\n      const cached = await CacheService.get(cacheKey)\n      if (cached) {\n        return reply.send(cached)\n      }\n      \n      const skip = (parseInt(page) - 1) * parseInt(limit)\n      const query: any = {}\n      if (category) query.category = category\n\n      const [achievements, total] = await Promise.all([\n        Achievement.find(query).skip(skip).limit(parseInt(limit)).sort({ order: 1 }),\n        Achievement.countDocuments(query)\n      ])\n\n      const result = { achievements, total, page: parseInt(page), limit: parseInt(limit) }\n      await CacheService.set(cacheKey, result, { ttl: 300 }) // 5 min cache\n      \n      return reply.send(result)\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to fetch achievements' })\n    }\n  })\n\n  fastify.get('/achievements/:id', async (request: FastifyRequest<{\n    Params: { id: string }\n  }>, reply) => {\n    try {\n      const achievement = await Achievement.findById(request.params.id)\n      if (!achievement) return reply.status(404).send({ error: 'Achievement not found' })\n      return reply.send(achievement)\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to fetch achievement' })\n    }\n  })\n\n  fastify.post('/achievements', async (request: FastifyRequest<{\n    Body: any\n  }>, reply) => {\n    try {\n      const adminId = (request as any).user?.id || (request as any).user?._id\n      const achievement = await Achievement.create(request.body)\n      \n      // Log action\n      await logAdminAction(adminId, 'CREATE', 'achievement', achievement._id.toString(), { name: achievement.name })\n      \n      // Invalidate cache\n      await CacheService.invalidate('admin:achievements:*')\n      \n      // Broadcast event\n      broadcastAdminEvent({ type: 'achievement_created', achievement })\n      \n      return reply.status(201).send(achievement)\n    } catch (error: any) {\n      console.error('Failed to create achievement:', error?.message || error)\n      return reply.status(500).send({ error: error?.message || 'Failed to create achievement' })\n    }\n  })\n\n  fastify.put('/achievements/:id', async (request: FastifyRequest<{\n    Params: { id: string }\n    Body: any\n  }>, reply) => {\n    try {\n      const adminId = (request as any).user?.id || (request as any).user?._id\n      const achievement = await Achievement.findByIdAndUpdate(\n        request.params.id,\n        request.body,\n        { new: true }\n      )\n      if (!achievement) return reply.status(404).send({ error: 'Achievement not found' })\n      \n      // Log action\n      await logAdminAction(adminId, 'UPDATE', 'achievement', request.params.id, { changes: request.body })\n      \n      // Invalidate cache\n      await CacheService.invalidate('admin:achievements:*')\n      \n      // Broadcast event\n      broadcastAdminEvent({ type: 'achievement_updated', achievement })\n      \n      return reply.send(achievement)\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to update achievement' })\n    }\n  })\n\n  fastify.delete('/achievements/:id', async (request: FastifyRequest<{\n    Params: { id: string }\n  }>, reply) => {\n    try {\n      const adminId = (request as any).user?.id || (request as any).user?._id\n      const achievement = await Achievement.findByIdAndDelete(request.params.id)\n      if (!achievement) return reply.status(404).send({ error: 'Achievement not found' })\n      \n      // Log action\n      await logAdminAction(adminId, 'DELETE', 'achievement', request.params.id, { name: achievement.name })\n      \n      // Invalidate cache\n      await CacheService.invalidate('admin:achievements:*')\n      \n      // Broadcast event\n      broadcastAdminEvent({ type: 'achievement_deleted', achievementId: request.params.id })\n      \n      return reply.status(204).send()\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to delete achievement' })\n    }\n  })\n\n  fastify.post('/achievements/unlock', async (request: FastifyRequest<{\n    Body: { userId: string; achievementId: string }\n  }>, reply) => {\n    try {\n      const adminId = (request as any).user?.id || (request as any).user?._id\n      const { userId, achievementId } = request.body\n      const userAchievement = await UserAchievement.findOneAndUpdate(\n        { userId, achievementId },\n        { progress: 100, unlockedAt: new Date() },\n        { upsert: true, new: true }\n      )\n      \n      // Log action\n      await logAdminAction(adminId, 'UNLOCK', 'achievement', achievementId, { userId })\n      \n      // Broadcast event\n      broadcastAdminEvent({ type: 'achievement_unlocked', userId, achievementId })\n      \n      return reply.send(userAchievement)\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to unlock achievement' })\n    }\n  })\n\n  // ==================== MARKETPLACE ====================\n\n  // GET marketplace items with caching\n  fastify.get('/marketplace/items', async (request: FastifyRequest<{\n    Querystring: { page?: string; limit?: string; category?: string; isActive?: string; search?: string; partnerId?: string }\n  }>, reply) => {\n    try {\n      const { page = '1', limit = '20', category, isActive, search, partnerId } = request.query\n      const cacheKey = `admin:marketplace:${page}:${limit}:${category || 'all'}:${isActive || 'all'}:${search || 'all'}:${partnerId || 'all'}`\n      \n      // Try cache first\n      const cached = await CacheService.get(cacheKey)\n      if (cached) {\n        return reply.send(cached)\n      }\n      \n      const skip = (parseInt(page) - 1) * parseInt(limit)\n      const query: any = { 'metadata.source': 'marketplace' }\n      if (category) query.category = category\n      if (isActive !== undefined) query.isActive = isActive === 'true'\n      if (search) {\n        query.$or = [\n          { name: { $regex: search, $options: 'i' } },\n          { description: { $regex: search, $options: 'i' } },\n        ]\n      }\n      if (partnerId) {\n        if (!Types.ObjectId.isValid(partnerId)) {\n          return reply.status(400).send({ error: 'Invalid partnerId' })\n        }\n        query.partnerId = new Types.ObjectId(partnerId)\n      }\n\n      const [items, total] = await Promise.all([\n        Reward.find(query).skip(skip).limit(parseInt(limit)).sort({ createdAt: -1 }),\n        Reward.countDocuments(query)\n      ])\n\n      const result = { items, total, page: parseInt(page), limit: parseInt(limit) }\n      await CacheService.set(cacheKey, result, { ttl: 300 }) // 5 min cache\n      \n      return reply.send(result)\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to fetch marketplace items' })\n    }\n  })\n\n  fastify.get('/marketplace/items/:id', async (request: FastifyRequest<{\n    Params: { id: string }\n  }>, reply) => {\n    try {\n      const item = await Reward.findById(request.params.id)\n      if (!item) return reply.status(404).send({ error: 'Item not found' })\n      return reply.send(item)\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to fetch item' })\n    }\n  })\n\n  fastify.post('/marketplace/items', async (request: FastifyRequest<{\n    Body: any\n  }>, reply) => {\n    try {\n      const adminId = (request as any).user?.id || (request as any).user?._id\n      const body = request.body as any\n      \n      // Ensure required fields have defaults\n      const itemData = {\n        name: body.name,\n        description: body.description,\n        category: body.category,\n        pointsCost: body.pointsCost || body.points_cost || 100,\n        stockQuantity: body.stockQuantity || body.stock_quantity || body.stock || 0,\n        stockAvailable: body.stockAvailable || body.stock_available || body.stockQuantity || body.stock || 0,\n        imageUrl: body.imageUrl || body.image_url || body.image || '',\n        isActive: body.isActive !== undefined ? body.isActive : true,\n        isPopular: body.isPopular !== undefined ? body.isPopular : false,\n        partnerId: body.partnerId || body.partner_id || undefined,\n        metadata: { ...(body.metadata || {}), source: 'marketplace' },\n      }\n      \n      const item = await Reward.create(itemData)\n      \n      // Log action\n      await logAdminAction(adminId, 'CREATE', 'marketplace_item', item._id.toString(), { name: item.name })\n      \n      // Invalidate cache\n      await CacheService.invalidate('admin:marketplace:*')\n      \n      // Broadcast event\n      broadcastAdminEvent({ type: 'marketplace_item_created', item })\n      \n      return reply.status(201).send({ success: true, data: item })\n    } catch (error: any) {\n      console.error('Failed to create marketplace item:', error)\n      // Return validation errors if available\n      if (error.name === 'ValidationError') {\n        return reply.status(400).send({ \n          success: false, \n          error: 'Validation failed', \n          details: error.message \n        })\n      }\n      return reply.status(500).send({ success: false, error: error.message || 'Failed to create item' })\n    }\n  })\n\n  fastify.put('/marketplace/items/:id', async (request: FastifyRequest<{\n    Params: { id: string }\n    Body: any\n  }>, reply) => {\n    try {\n      const adminId = (request as any).user?.id || (request as any).user?._id\n      const existing = await Reward.findById(request.params.id).lean()\n      if (!existing) return reply.status(404).send({ error: 'Item not found' })\n\n      const updates = request.body as any\n      updates.metadata = {\n        ...(existing as any).metadata,\n        ...(updates?.metadata || {}),\n        source: 'marketplace',\n      }\n\n      const item = await Reward.findByIdAndUpdate(request.params.id, updates, { new: true })\n      if (!item) return reply.status(404).send({ error: 'Item not found' })\n      \n      // Log action\n      await logAdminAction(adminId, 'UPDATE', 'marketplace_item', request.params.id, { changes: request.body })\n      \n      // Invalidate cache\n      await CacheService.invalidate('admin:marketplace:*')\n      \n      // Broadcast event\n      broadcastAdminEvent({ type: 'marketplace_item_updated', item })\n      \n      return reply.send(item)\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to update item' })\n    }\n  })\n\n  fastify.delete('/marketplace/items/:id', async (request: FastifyRequest<{\n    Params: { id: string }\n  }>, reply) => {\n    try {\n      const adminId = (request as any).user?.id || (request as any).user?._id\n      const item = await Reward.findByIdAndDelete(request.params.id)\n      if (!item) return reply.status(404).send({ error: 'Item not found' })\n      \n      // Log action\n      await logAdminAction(adminId, 'DELETE', 'marketplace_item', request.params.id, { name: item.name })\n      \n      // Invalidate cache\n      await CacheService.invalidate('admin:marketplace:*')\n      \n      // Broadcast event\n      broadcastAdminEvent({ type: 'marketplace_item_deleted', itemId: request.params.id })\n      \n      return reply.status(204).send()\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to delete item' })\n    }\n  })\n\n  fastify.get('/marketplace/redemptions', async (request: FastifyRequest<{\n    Querystring: { page?: string; limit?: string; status?: string }\n  }>, reply) => {\n    try {\n      const { page = '1', limit = '20', status } = request.query\n      const skip = (parseInt(page) - 1) * parseInt(limit)\n      const query: any = { 'metadata.source': 'marketplace' }\n      if (status) query.status = status\n\n      const [redemptions, total] = await Promise.all([\n        Redemption.find(query).populate('userId rewardId').skip(skip).limit(parseInt(limit)).sort({ createdAt: -1 }),\n        Redemption.countDocuments(query)\n      ])\n\n      return reply.send({ redemptions, total, page: parseInt(page), limit: parseInt(limit) })\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to fetch redemptions' })\n    }\n  })\n\n  fastify.patch('/marketplace/redemptions/:id/validate', async (request: FastifyRequest<{\n    Params: { id: string }\n    Body: { validated: boolean; notes?: string }\n  }>, reply) => {\n    try {\n      const adminId = (request as any).user?.id || (request as any).user?._id\n      const { validated, notes } = request.body\n      const update: Record<string, any> = {\n        status: validated ? RedemptionStatus.FULFILLED : RedemptionStatus.CANCELLED,\n      }\n      if (validated) {\n        update.fulfilledAt = new Date()\n        if (adminId && Types.ObjectId.isValid(adminId)) {\n          update.redeemedBy = new Types.ObjectId(adminId)\n        }\n      }\n      if (notes) {\n        update['metadata.adminNotes'] = notes\n      }\n      const redemption = await Redemption.findByIdAndUpdate(\n        request.params.id,\n        { $set: update },\n        { new: true }\n      )\n      if (!redemption) return reply.status(404).send({ error: 'Redemption not found' })\n      \n      // Log action\n      await logAdminAction(adminId, validated ? 'VALIDATE' : 'REJECT', 'redemption', request.params.id, { notes })\n      \n      // Broadcast event\n      broadcastAdminEvent({ type: 'redemption_validated', redemption, validated })\n      broadcastAdminEvent({\n        type: validated ? 'redemption_completed' : 'redemption_cancelled',\n        redemption,\n        validated\n      })\n      \n      return reply.send(redemption)\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to validate redemption' })\n    }\n  })\n\n  fastify.get('/marketplace/stats', async (_request, reply) => {\n    try {\n      const [totalItems, activeItems, totalRedemptions, pendingRedemptions] = await Promise.all([\n        Reward.countDocuments({ 'metadata.source': 'marketplace' }),\n        Reward.countDocuments({ 'metadata.source': 'marketplace', isActive: true }),\n        Redemption.countDocuments({ 'metadata.source': 'marketplace' }),\n        Redemption.countDocuments({ 'metadata.source': 'marketplace', status: RedemptionStatus.PENDING })\n      ])\n\n      return reply.send({ totalItems, activeItems, totalRedemptions, pendingRedemptions })\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to fetch marketplace stats' })\n    }\n  })\n\n  // ==================== REPORTS ====================\n\n  fastify.get('/reports', async (request: FastifyRequest<{\n    Querystring: { page?: string; limit?: string; status?: string; type?: string }\n  }>, reply) => {\n    try {\n      const { page = '1', limit = '20', status, type } = request.query\n      const skip = (parseInt(page) - 1) * parseInt(limit)\n      const query: any = {}\n      if (status) query.status = status\n      if (type) query.type = type\n\n      const [reports, total] = await Promise.all([\n        Report.find(query)\n          .populate('userId', 'displayName email username')\n          .populate('targetUserId', 'displayName email username')\n          .populate('captureId', 'status claimedAt prizeId userId')\n          .populate('prizeId', 'name category points')\n          .skip(skip)\n          .limit(parseInt(limit))\n          .sort({ createdAt: -1 }),\n        Report.countDocuments(query)\n      ])\n\n      return reply.send({ reports, total, page: parseInt(page), limit: parseInt(limit) })\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to fetch reports' })\n    }\n  })\n\n  fastify.get('/reports/generate', async (request: FastifyRequest<{\n    Querystring: { type?: string; format?: string; startDate?: string; endDate?: string }\n  }>, reply) => {\n    try {\n      const { type = 'reports', format = 'csv' } = request.query\n      const url = `/downloads/${type}-${Date.now()}.${format}`\n      return reply.send({ success: true, data: { url, type, format, generatedAt: new Date().toISOString() } })\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to generate report' })\n    }\n  })\n\n  fastify.get('/reports/:id', async (request: FastifyRequest<{\n    Params: { id: string }\n  }>, reply) => {\n    try {\n      const report = await Report.findById(request.params.id)\n        .populate('userId', 'displayName email username')\n        .populate('targetUserId', 'displayName email username')\n        .populate('captureId', 'status claimedAt prizeId userId')\n        .populate('prizeId', 'name category points')\n      if (!report) return reply.status(404).send({ error: 'Report not found' })\n      return reply.send(report)\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to fetch report' })\n    }\n  })\n\n  fastify.get('/reports/user/:userId', async (request: FastifyRequest<{\n    Params: { userId: string };\n    Querystring: { page?: string; limit?: string; status?: string }\n  }>, reply) => {\n    try {\n      const { userId } = request.params\n      if (!Types.ObjectId.isValid(userId)) {\n        return reply.status(400).send({ error: 'Invalid userId' })\n      }\n      const { page = '1', limit = '20', status } = request.query\n      const skip = (parseInt(page) - 1) * parseInt(limit)\n      const query: any = { userId: new Types.ObjectId(userId) }\n      if (status) query.status = status\n\n      const [reports, total] = await Promise.all([\n        Report.find(query)\n          .populate('userId', 'displayName email username')\n          .populate('targetUserId', 'displayName email username')\n          .populate('captureId', 'status claimedAt prizeId userId')\n          .populate('prizeId', 'name category points')\n          .skip(skip)\n          .limit(parseInt(limit))\n          .sort({ createdAt: -1 }),\n        Report.countDocuments(query)\n      ])\n\n      return reply.send({ reports, total, page: parseInt(page), limit: parseInt(limit) })\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to fetch reports' })\n    }\n  })\n\n  fastify.get('/reports/capture/:captureId', async (request: FastifyRequest<{\n    Params: { captureId: string };\n    Querystring: { page?: string; limit?: string; status?: string }\n  }>, reply) => {\n    try {\n      const { captureId } = request.params\n      if (!Types.ObjectId.isValid(captureId)) {\n        return reply.status(400).send({ error: 'Invalid captureId' })\n      }\n      const { page = '1', limit = '20', status } = request.query\n      const skip = (parseInt(page) - 1) * parseInt(limit)\n      const query: any = { captureId: new Types.ObjectId(captureId) }\n      if (status) query.status = status\n\n      const [reports, total] = await Promise.all([\n        Report.find(query)\n          .populate('userId', 'displayName email username')\n          .populate('targetUserId', 'displayName email username')\n          .populate('captureId', 'status claimedAt prizeId userId')\n          .populate('prizeId', 'name category points')\n          .skip(skip)\n          .limit(parseInt(limit))\n          .sort({ createdAt: -1 }),\n        Report.countDocuments(query)\n      ])\n\n      return reply.send({ reports, total, page: parseInt(page), limit: parseInt(limit) })\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to fetch reports' })\n    }\n  })\n\n  fastify.get('/reports/stats', async (_request, reply) => {\n    try {\n      const [total, pending, investigating, resolved, rejected, duplicate] = await Promise.all([\n        Report.countDocuments(),\n        Report.countDocuments({ status: 'pending' }),\n        Report.countDocuments({ status: 'investigating' }),\n        Report.countDocuments({ status: 'resolved' }),\n        Report.countDocuments({ status: 'rejected' }),\n        Report.countDocuments({ status: 'duplicate' })\n      ])\n\n      return reply.send({ total, pending, investigating, resolved, rejected, duplicate })\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to fetch report stats' })\n    }\n  })\n\n  fastify.patch('/reports/:id/resolve', async (request: FastifyRequest<{\n    Params: { id: string }\n    Body: { resolution?: string; action?: string }\n  }>, reply) => {\n    try {\n      const adminId = (request as any).user?.id || (request as any).user?._id\n      const resolution = (request.body as any).resolution || (request.body as any).notes\n      const report = await Report.findByIdAndUpdate(\n        request.params.id,\n        { status: 'resolved', resolution, resolvedBy: adminId, resolvedAt: new Date() },\n        { new: true }\n      )\n      if (!report) return reply.status(404).send({ error: 'Report not found' })\n      \n      // Log action\n      await logAdminAction(adminId, 'RESOLVE', 'report', request.params.id, { resolution })\n      \n      return reply.send(report)\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to resolve report' })\n    }\n  })\n\n  fastify.patch('/reports/:id/dismiss', async (request: FastifyRequest<{\n    Params: { id: string }\n    Body: { reason?: string }\n  }>, reply) => {\n    try {\n      const adminId = (request as any).user?.id || (request as any).user?._id\n      const reason = (request.body as any).reason || (request.body as any).notes\n      const report = await Report.findByIdAndUpdate(\n        request.params.id,\n        { status: 'rejected', resolution: reason, resolvedBy: adminId, resolvedAt: new Date() },\n        { new: true }\n      )\n      if (!report) return reply.status(404).send({ error: 'Report not found' })\n      \n      // Log action\n      await logAdminAction(adminId, 'DISMISS', 'report', request.params.id, { reason })\n      \n      return reply.send(report)\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to dismiss report' })\n    }\n  })\n\n  // ==================== SESSIONS ====================\n\n  fastify.get('/sessions/active', async (request: FastifyRequest<{\n    Querystring: { page?: string; limit?: string }\n  }>, reply) => {\n    try {\n      const { page = '1', limit = '20' } = request.query\n      const skip = (parseInt(page) - 1) * parseInt(limit)\n\n      const [sessions, total] = await Promise.all([\n        Session.find({ isActive: true }).populate('userId').skip(skip).limit(parseInt(limit)).sort({ createdAt: -1 }),\n        Session.countDocuments({ isActive: true })\n      ])\n\n      return reply.send({ sessions, total, page: parseInt(page), limit: parseInt(limit) })\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to fetch active sessions' })\n    }\n  })\n\n  fastify.get('/sessions/stats', async (_request, reply) => {\n    try {\n      const [total, active] = await Promise.all([\n        Session.countDocuments(),\n        Session.countDocuments({ isActive: true })\n      ])\n\n      return reply.send({ total, active })\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to fetch session stats' })\n    }\n  })\n\n  fastify.delete('/sessions/:id', async (request: FastifyRequest<{\n    Params: { id: string }\n  }>, reply) => {\n    try {\n      const adminId = (request as any).user?.sub || (request as any).userId\n      const session = await Session.findByIdAndUpdate(\n        request.params.id,\n        { isActive: false, terminatedAt: new Date() },\n        { new: true }\n      )\n      if (!session) return reply.status(404).send({ error: 'Session not found' })\n      \n      await logAdminAction(adminId, 'TERMINATE_SESSION', 'session', request.params.id, {\n        userId: (session as any).userId?.toString(),\n        terminatedAt: new Date().toISOString()\n      })\n      \n      return reply.status(204).send()\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to terminate session' })\n    }\n  })\n\n  // ==================== FRIENDSHIPS ====================\n\n  fastify.get('/friendships', async (request: FastifyRequest<{\n    Querystring: { page?: string; limit?: string; status?: string }\n  }>, reply) => {\n    try {\n      const { page = '1', limit = '20', status } = request.query\n      const skip = (parseInt(page) - 1) * parseInt(limit)\n      const query: any = {}\n      if (status) query.status = status\n\n      const [friendships, total] = await Promise.all([\n        Friendship.find(query).populate('userId friendId').skip(skip).limit(parseInt(limit)).sort({ createdAt: -1 }),\n        Friendship.countDocuments(query)\n      ])\n\n      return reply.send({ friendships, total, page: parseInt(page), limit: parseInt(limit) })\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to fetch friendships' })\n    }\n  })\n\n  fastify.delete('/friendships/:id', async (request: FastifyRequest<{\n    Params: { id: string }\n  }>, reply) => {\n    try {\n      const adminId = (request as any).user?.sub || (request as any).userId\n      const friendship = await Friendship.findByIdAndDelete(request.params.id)\n      if (!friendship) return reply.status(404).send({ error: 'Friendship not found' })\n      \n      await logAdminAction(adminId, 'DELETE_FRIENDSHIP', 'friendship', request.params.id, {\n        userId: (friendship as any).userId?.toString(),\n        friendId: (friendship as any).friendId?.toString()\n      })\n      \n      return reply.status(204).send()\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to remove friendship' })\n    }\n  })\n\n  // ==================== CODES ====================\n\n  fastify.get('/codes', async (request: FastifyRequest<{\n    Querystring: { page?: string; limit?: string; isUsed?: string; isActive?: string }\n  }>, reply) => {\n    try {\n      const { page = '1', limit = '20', isUsed, isActive } = request.query\n      const skip = (parseInt(page) - 1) * parseInt(limit)\n      const query: any = {}\n      if (isUsed !== undefined) query.isUsed = isUsed === 'true'\n      if (isActive !== undefined) query.isActive = isActive === 'true'\n\n      const [codes, total] = await Promise.all([\n        Code.find(query).skip(skip).limit(parseInt(limit)).sort({ createdAt: -1 }),\n        Code.countDocuments(query)\n      ])\n\n      return reply.send({ codes, total, page: parseInt(page), limit: parseInt(limit) })\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to fetch codes' })\n    }\n  })\n\n  fastify.get('/codes/:id', async (request: FastifyRequest<{\n    Params: { id: string }\n  }>, reply) => {\n    try {\n      const { id } = request.params\n      if (!Types.ObjectId.isValid(id)) {\n        return reply.status(400).send({ error: 'Invalid code id' })\n      }\n      const code = await Code.findById(id)\n      if (!code) return reply.status(404).send({ error: 'Code not found' })\n      return reply.send({ code })\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to fetch code' })\n    }\n  })\n\n  fastify.post('/codes/generate', async (request: FastifyRequest<{\n    Body: { count: number; prefix?: string; pointsValue?: number; expiresAt?: string }\n  }>, reply) => {\n    try {\n      const adminId = (request as any).user?.sub || (request as any).userId\n      const { count, prefix = 'YALLA', pointsValue = 100, expiresAt } = request.body\n      const codes = []\n\n      for (let i = 0; i < count; i++) {\n        const code = `${prefix}-${crypto.randomBytes(4).toString('hex').toUpperCase()}`\n        codes.push({\n          code,\n          pointsValue,\n          isActive: true,\n          isUsed: false,\n          expiresAt: expiresAt ? new Date(expiresAt) : undefined\n        })\n      }\n\n      const createdCodes = await Code.insertMany(codes)\n      \n      await logAdminAction(adminId, 'GENERATE_CODES', 'code', 'batch', {\n        count: createdCodes.length,\n        prefix,\n        pointsValue,\n        expiresAt\n      })\n      \n      return reply.status(201).send({ codes: createdCodes, count: createdCodes.length })\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to generate codes' })\n    }\n  })\n\n  fastify.get('/codes/stats', async (_request, reply) => {\n    try {\n      const now = new Date()\n      const [total, used, active, expired] = await Promise.all([\n        Code.countDocuments(),\n        Code.countDocuments({ status: CodeStatus.USED }),\n        Code.countDocuments({ isActive: true }),\n        Code.countDocuments({ $or: [{ status: CodeStatus.EXPIRED }, { expiresAt: { $lt: now } }] }),\n      ])\n      return reply.send({ total, used, active, expired })\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to fetch code stats' })\n    }\n  })\n\n  fastify.post('/codes/validate', async (request: FastifyRequest<{\n    Body: { code: string }\n  }>, reply) => {\n    try {\n      const adminId = (request as any).user?.sub || (request as any).userId\n      const rawCode = (request.body?.code || '').toString().trim().toUpperCase()\n      if (!rawCode) {\n        return reply.status(400).send({ error: 'Code is required' })\n      }\n      const code = await Code.findOne({ code: rawCode })\n      if (!code) {\n        return reply.send({ valid: false, reason: 'CODE_NOT_FOUND' })\n      }\n      const isExpired = !!code.expiresAt && code.expiresAt < new Date()\n      const valid = code.isActive && !code.isUsed && !isExpired && code.status !== CodeStatus.EXPIRED\n\n      await logAdminAction(adminId, 'VALIDATE_CODE', 'code', code._id.toString(), {\n        code: code.code,\n        valid,\n        isActive: code.isActive,\n        isUsed: code.isUsed,\n        isExpired,\n      })\n\n      return reply.send({\n        valid,\n        reason: valid ? undefined : (isExpired ? 'CODE_EXPIRED' : code.isUsed ? 'CODE_USED' : 'CODE_INACTIVE'),\n        code,\n      })\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to validate code' })\n    }\n  })\n\n  fastify.patch('/codes/:id/deactivate', async (request: FastifyRequest<{\n    Params: { id: string }\n  }>, reply) => {\n    try {\n      const adminId = (request as any).user?.sub || (request as any).userId\n      const code = await Code.findByIdAndUpdate(\n        request.params.id,\n        { isActive: false },\n        { new: true }\n      )\n      if (!code) return reply.status(404).send({ error: 'Code not found' })\n      \n      await logAdminAction(adminId, 'DEACTIVATE_CODE', 'code', request.params.id, {\n        code: (code as any).code,\n        pointsValue: (code as any).pointsValue\n      })\n      \n      return reply.send(code)\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to deactivate code' })\n    }\n  })\n\n  fastify.delete('/codes/:id', async (request: FastifyRequest<{\n    Params: { id: string }\n  }>, reply) => {\n    try {\n      const adminId = (request as any).user?.sub || (request as any).userId\n      if (!Types.ObjectId.isValid(request.params.id)) {\n        return reply.status(400).send({ error: 'Invalid code id' })\n      }\n      const code = await Code.findByIdAndDelete(request.params.id)\n      if (!code) return reply.status(404).send({ error: 'Code not found' })\n\n      await logAdminAction(adminId, 'DELETE_CODE', 'code', request.params.id, {\n        code: (code as any).code,\n        pointsValue: (code as any).pointsValue,\n      })\n\n      return reply.status(204).send()\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to delete code' })\n    }\n  })\n\n  // ==================== OFFLINE QUEUE ====================\n\n  fastify.get('/offline-queue', async (request: FastifyRequest<{\n    Querystring: { page?: string; limit?: string; status?: string }\n  }>, reply) => {\n    try {\n      const { page = '1', limit = '20', status } = request.query\n      const skip = (parseInt(page) - 1) * parseInt(limit)\n      const query: any = {}\n      if (status) query.status = status\n\n      const [items, total] = await Promise.all([\n        OfflineQueue.find(query).populate('userId').skip(skip).limit(parseInt(limit)).sort({ createdAt: -1 }),\n        OfflineQueue.countDocuments(query)\n      ])\n\n      return reply.send({ items, total, page: parseInt(page), limit: parseInt(limit) })\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to fetch offline queue' })\n    }\n  })\n\n  fastify.delete('/offline-queue/clear', async (request: FastifyRequest, reply) => {\n    try {\n      const adminId = (request as any).user?.sub || (request as any).userId\n      const result = await OfflineQueue.deleteMany({ status: 'resolved' })\n      \n      await logAdminAction(adminId, 'CLEAR_OFFLINE_QUEUE', 'offline_queue', 'batch', {\n        deletedCount: result.deletedCount\n      })\n      \n      return reply.send({ deleted: result.deletedCount })\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to clear resolved items' })\n    }\n  })\n\n  // ==================== DEVICE TOKENS ====================\n\n  fastify.get('/device-tokens', async (request: FastifyRequest<{\n    Querystring: { page?: string; limit?: string; platform?: string }\n  }>, reply) => {\n    try {\n      const { page = '1', limit = '20', platform } = request.query\n      const skip = (parseInt(page) - 1) * parseInt(limit)\n      const query: any = {}\n      if (platform) query.platform = platform\n\n      const [tokens, total] = await Promise.all([\n        DeviceToken.find(query).populate('userId').skip(skip).limit(parseInt(limit)).sort({ createdAt: -1 }),\n        DeviceToken.countDocuments(query)\n      ])\n\n      return reply.send({ tokens, total, page: parseInt(page), limit: parseInt(limit) })\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to fetch device tokens' })\n    }\n  })\n\n  fastify.get('/device-tokens/stats', async (_request, reply) => {\n    try {\n      const stats = await DeviceToken.aggregate([\n        { $group: { _id: '$platform', count: { $sum: 1 } } }\n      ])\n\n      const total = await DeviceToken.countDocuments()\n      return reply.send({ total, byPlatform: stats })\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to fetch device token stats' })\n    }\n  })\n\n  fastify.delete('/device-tokens/:id', async (request: FastifyRequest<{\n    Params: { id: string }\n  }>, reply) => {\n    try {\n      const adminId = (request as any).user?.sub || (request as any).userId\n      const token = await DeviceToken.findByIdAndDelete(request.params.id)\n      if (!token) return reply.status(404).send({ error: 'Device token not found' })\n      \n      await logAdminAction(adminId, 'REVOKE_DEVICE_TOKEN', 'device_token', request.params.id, {\n        userId: (token as any).userId?.toString(),\n        platform: (token as any).platform\n      })\n      \n      return reply.status(204).send()\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to revoke device token' })\n    }\n  })\n\n  // ==================== REDEMPTIONS ====================\n\n  fastify.get('/redemptions', async (request: FastifyRequest<{\n    Querystring: { page?: string; limit?: string; status?: string }\n  }>, reply) => {\n    try {\n      const { page = '1', limit = '20', status } = request.query\n      const skip = (parseInt(page) - 1) * parseInt(limit)\n      const query: any = {}\n      if (status) query.status = status\n\n      const [redemptions, total] = await Promise.all([\n        Redemption.find(query).populate('userId rewardId').skip(skip).limit(parseInt(limit)).sort({ createdAt: -1 }),\n        Redemption.countDocuments(query)\n      ])\n\n      return reply.send({ redemptions, total, page: parseInt(page), limit: parseInt(limit) })\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to fetch redemptions' })\n    }\n  })\n\n  fastify.post('/redemptions/:id/validate', async (request: FastifyRequest<{\n    Params: { id: string }\n    Body: { validated: boolean; notes?: string }\n  }>, reply) => {\n    try {\n      const adminId = (request as any).user?.sub || (request as any).userId\n      const { validated, notes } = request.body\n      const update: Record<string, any> = {\n        status: validated ? RedemptionStatus.FULFILLED : RedemptionStatus.CANCELLED,\n      }\n      if (validated) {\n        update.fulfilledAt = new Date()\n        if (adminId && Types.ObjectId.isValid(adminId)) {\n          update.redeemedBy = new Types.ObjectId(adminId)\n        }\n      }\n      if (notes) {\n        update['metadata.adminNotes'] = notes\n      }\n      const redemption = await Redemption.findByIdAndUpdate(\n        request.params.id,\n        { $set: update },\n        { new: true }\n      ).populate('userId rewardId')\n      if (!redemption) return reply.status(404).send({ error: 'Redemption not found' })\n      \n      await logAdminAction(adminId, validated ? 'VALIDATE_REDEMPTION' : 'REJECT_REDEMPTION', 'redemption', request.params.id, {\n        userId: (redemption as any).userId?._id?.toString() || (redemption as any).userId?.toString(),\n        rewardName: (redemption as any).rewardId?.name,\n        notes\n      })\n\n      broadcastAdminEvent({\n        type: validated ? 'redemption_completed' : 'redemption_cancelled',\n        redemption,\n        validated\n      })\n      \n      return reply.send(redemption)\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to validate redemption' })\n    }\n  })\n\n  fastify.post('/rewards/qr-scan', async (request: FastifyRequest<{\n    Body: { qrCode: string; scannedBy: string }\n  }>, reply) => {\n    try {\n      const adminId = (request as any).user?.sub || (request as any).userId\n      const { qrCode, scannedBy } = request.body\n      const update: Record<string, any> = {\n        status: RedemptionStatus.FULFILLED,\n        fulfilledAt: new Date(),\n      }\n      const redeemedBy =\n        (scannedBy && Types.ObjectId.isValid(scannedBy) && new Types.ObjectId(scannedBy)) ||\n        (adminId && Types.ObjectId.isValid(adminId) && new Types.ObjectId(adminId))\n      if (redeemedBy) {\n        update.redeemedBy = redeemedBy\n      }\n\n      let redemption = await Redemption.findOneAndUpdate(\n        { 'metadata.redemptionCode': qrCode, status: RedemptionStatus.PENDING },\n        { $set: update },\n        { new: true }\n      ).populate('userId rewardId')\n\n      if (!redemption) {\n        const code = await Code.findOne({ code: qrCode, status: CodeStatus.AVAILABLE })\n        if (code) {\n          redemption = await Redemption.findOneAndUpdate(\n            { codeId: code._id, status: RedemptionStatus.PENDING },\n            { $set: update },\n            { new: true }\n          ).populate('userId rewardId')\n        }\n      }\n\n      if (!redemption) return reply.status(404).send({ error: 'Invalid or already used QR code' })\n      \n      await logAdminAction(adminId, 'QR_SCAN_REDEMPTION', 'redemption', (redemption as any)._id.toString(), {\n        userId: (redemption as any).userId?._id?.toString() || (redemption as any).userId?.toString(),\n        rewardName: (redemption as any).rewardId?.name,\n        scannedBy,\n        qrCode: qrCode.substring(0, 10) + '...'\n      })\n\n      broadcastAdminEvent({ type: 'redemption_completed', redemption, validated: true })\n      \n      return reply.send(redemption)\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to process QR scan' })\n    }\n  })\n\n  // ==================== ACTIVITY LOGS ====================\n\n  fastify.get('/activity-logs', async (request: FastifyRequest<{\n    Querystring: { page?: string; limit?: string; action?: string; userId?: string; startDate?: string; endDate?: string }\n  }>, reply) => {\n    try {\n      const { page = '1', limit = '50', action, userId, startDate, endDate } = request.query\n      const skip = (parseInt(page) - 1) * parseInt(limit)\n      const query: any = {}\n      if (action) query.action = action\n      if (userId) query.userId = userId\n      if (startDate || endDate) {\n        query.createdAt = {}\n        if (startDate) query.createdAt.$gte = new Date(startDate)\n        if (endDate) query.createdAt.$lte = new Date(endDate)\n      }\n\n      console.log('[ACTIVITY-LOGS] Fetching logs with query:', JSON.stringify(query), 'skip:', skip, 'limit:', limit)\n\n      const [logs, total] = await Promise.all([\n        AuditLog.find(query).skip(skip).limit(parseInt(limit)).sort({ createdAt: -1 }).lean(),\n        AuditLog.countDocuments(query)\n      ])\n\n      console.log('[ACTIVITY-LOGS] Found', logs.length, 'logs, total:', total)\n\n      // Collect unique admin user IDs to fetch their details\n      // Filter out non-ObjectId values like \"system\"\n      const isValidObjectId = (id: string) => {\n        return id && id.length === 24 && /^[0-9a-fA-F]{24}$/.test(id)\n      }\n      const adminIds = [...new Set(logs.map((log: any) => log.userId).filter(id => id && isValidObjectId(id)))]\n      const adminUsers = adminIds.length > 0\n        ? await User.find({ _id: { $in: adminIds } }).select('_id displayName email role').lean()\n        : []\n      const adminMap = new Map(adminUsers.map((u: any) => [u._id.toString(), u]))\n\n      // Enhance logs with actor details\n      const enhancedLogs = logs.map((log: any) => {\n        const admin = log.userId ? adminMap.get(log.userId.toString()) : null\n        return {\n          ...log,\n          actor: admin ? {\n            id: admin._id,\n            displayName: admin.displayName || 'Unknown Admin',\n            email: admin.email,\n            role: admin.role,\n          } : log.userEmail ? {\n            id: log.userId,\n            displayName: log.userEmail,\n            email: log.userEmail,\n            role: log.userRole || 'admin',\n          } : null,\n          displayAction: log.action?.replace(/_/g, ' ').toLowerCase().replace(/\\b\\w/g, (c: string) => c.toUpperCase()),\n          displayResource: log.resource?.replace(/_/g, ' ').toLowerCase().replace(/\\b\\w/g, (c: string) => c.toUpperCase()),\n        }\n      })\n\n      return reply.send({ logs: enhancedLogs, total, page: parseInt(page), limit: parseInt(limit) })\n    } catch (error) {\n      console.error('Failed to fetch activity logs:', error)\n      return reply.status(500).send({ error: 'Failed to fetch activity logs' })\n    }\n  })\n\n  fastify.get('/activity-logs/statistics', async (request: FastifyRequest<{\n    Querystring: { period?: string }\n  }>, reply) => {\n    try {\n      const { period = '7d' } = request.query\n      const days = parseInt(period) || 7\n      const startDate = new Date()\n      startDate.setDate(startDate.getDate() - days)\n\n      const stats = await AuditLog.aggregate([\n        { $match: { createdAt: { $gte: startDate } } },\n        { $group: { _id: '$action', count: { $sum: 1 } } },\n        { $sort: { count: -1 } }\n      ])\n\n      const total = await AuditLog.countDocuments({ createdAt: { $gte: startDate } })\n      return reply.send({ total, byAction: stats, period })\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to fetch activity log statistics' })\n    }\n  })\n\n  fastify.delete('/activity-logs/clear', async (request: FastifyRequest<{\n    Querystring: { olderThanDays?: string }\n  }>, reply) => {\n    try {\n      const { olderThanDays = '90' } = request.query\n      const cutoffDate = new Date()\n      cutoffDate.setDate(cutoffDate.getDate() - parseInt(olderThanDays))\n\n      const result = await AuditLog.deleteMany({ createdAt: { $lt: cutoffDate } })\n      return reply.send({ deleted: result.deletedCount })\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to clear old logs' })\n    }\n  })\n\n  fastify.get('/activity-logs/export', async (request: FastifyRequest<{\n    Querystring: { startDate?: string; endDate?: string; format?: string }\n  }>, reply) => {\n    try {\n      const { startDate, endDate, format = 'json' } = request.query\n      const query: any = {}\n      if (startDate || endDate) {\n        query.createdAt = {}\n        if (startDate) query.createdAt.$gte = new Date(startDate)\n        if (endDate) query.createdAt.$lte = new Date(endDate)\n      }\n\n      const logs = await AuditLog.find(query).sort({ createdAt: -1 }).limit(10000).lean()\n\n      if (format === 'csv') {\n        const csv = logs.map(log => {\n          return `${log._id},${log.action},${log.userId || ''},${log.userEmail || ''},${log.resource || ''},${log.createdAt}`\n        }).join('\\n')\n        reply.header('Content-Type', 'text/csv')\n        reply.header('Content-Disposition', 'attachment; filename=activity-logs.csv')\n        return reply.send(`id,action,userId,userEmail,resource,createdAt\\n${csv}`)\n      }\n\n      return reply.send({ logs, count: logs.length })\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to export activity logs' })\n    }\n  })\n\n  fastify.post('/activity-logs', async (request: FastifyRequest<{\n    Body: { \n      action: string; \n      type?: string;\n      message?: string;\n      actor?: { id?: string; email?: string; name?: string };\n      target?: any;\n      details?: any; \n    }\n  }>, reply) => {\n    try {\n      const body = request.body;\n      \n      // Map frontend format to AuditLog schema\n      const logData = {\n        userId: body.actor?.id,\n        userEmail: body.actor?.email,\n        userRole: 'admin' as const,\n        action: body.action,\n        resource: body.type || 'admin_action',\n        resourceId: body.target?.id,\n        category: 'admin' as const,\n        severity: 'low' as const,\n        success: true,\n        description: body.message,\n        metadata: body.details,\n      };\n\n      const log = await AuditLog.create(logData);\n      return reply.status(201).send(log);\n    } catch (error) {\n      console.error('Failed to create activity log:', error);\n      return reply.status(500).send({ error: 'Failed to create activity log' });\n    }\n  })\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\admin\\routes\\game-control.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'z' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Claim' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Prize' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":15},{"ruleId":"@typescript-eslint/ban-types","severity":2,"message":"Don't use `{}` as a type. `{}` actually means \"any non-nullish value\".\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.\n- If you want a type meaning \"empty object\", you probably want `Record<string, never>` instead.\n- If you really want a type meaning \"any non-nullish value\", you probably want `NonNullable<unknown>` instead.","line":31,"column":35,"nodeType":"TSTypeLiteral","messageId":"bannedTypeMessage","endLine":31,"endColumn":37,"suggestions":[{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"object"},"fix":{"range":[1206,1208],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"unknown"},"fix":{"range":[1206,1208],"text":"unknown"},"desc":"Replace `{}` with `unknown`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"Record<string, never>"},"fix":{"range":[1206,1208],"text":"Record<string, never>"},"desc":"Replace `{}` with `Record<string, never>`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"NonNullable<unknown>"},"fix":{"range":[1206,1208],"text":"NonNullable<unknown>"},"desc":"Replace `{}` with `NonNullable<unknown>`."}]},{"ruleId":"@typescript-eslint/ban-types","severity":2,"message":"Don't use `{}` as a type. `{}` actually means \"any non-nullish value\".\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.\n- If you want a type meaning \"empty object\", you probably want `Record<string, never>` instead.\n- If you really want a type meaning \"any non-nullish value\", you probably want `NonNullable<unknown>` instead.","line":31,"column":39,"nodeType":"TSTypeLiteral","messageId":"bannedTypeMessage","endLine":31,"endColumn":41,"suggestions":[{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"object"},"fix":{"range":[1210,1212],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"unknown"},"fix":{"range":[1210,1212],"text":"unknown"},"desc":"Replace `{}` with `unknown`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"Record<string, never>"},"fix":{"range":[1210,1212],"text":"Record<string, never>"},"desc":"Replace `{}` with `Record<string, never>`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"NonNullable<unknown>"},"fix":{"range":[1210,1212],"text":"NonNullable<unknown>"},"desc":"Replace `{}` with `NonNullable<unknown>`."}]},{"ruleId":"@typescript-eslint/ban-types","severity":2,"message":"Don't use `{}` as a type. `{}` actually means \"any non-nullish value\".\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.\n- If you want a type meaning \"empty object\", you probably want `Record<string, never>` instead.\n- If you really want a type meaning \"any non-nullish value\", you probably want `NonNullable<unknown>` instead.","line":124,"column":35,"nodeType":"TSTypeLiteral","messageId":"bannedTypeMessage","endLine":124,"endColumn":37,"suggestions":[{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"object"},"fix":{"range":[4620,4622],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"unknown"},"fix":{"range":[4620,4622],"text":"unknown"},"desc":"Replace `{}` with `unknown`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"Record<string, never>"},"fix":{"range":[4620,4622],"text":"Record<string, never>"},"desc":"Replace `{}` with `Record<string, never>`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"NonNullable<unknown>"},"fix":{"range":[4620,4622],"text":"NonNullable<unknown>"},"desc":"Replace `{}` with `NonNullable<unknown>`."}]},{"ruleId":"@typescript-eslint/ban-types","severity":2,"message":"Don't use `{}` as a type. `{}` actually means \"any non-nullish value\".\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.\n- If you want a type meaning \"empty object\", you probably want `Record<string, never>` instead.\n- If you really want a type meaning \"any non-nullish value\", you probably want `NonNullable<unknown>` instead.","line":124,"column":39,"nodeType":"TSTypeLiteral","messageId":"bannedTypeMessage","endLine":124,"endColumn":41,"suggestions":[{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"object"},"fix":{"range":[4624,4626],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"unknown"},"fix":{"range":[4624,4626],"text":"unknown"},"desc":"Replace `{}` with `unknown`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"Record<string, never>"},"fix":{"range":[4624,4626],"text":"Record<string, never>"},"desc":"Replace `{}` with `Record<string, never>`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"NonNullable<unknown>"},"fix":{"range":[4624,4626],"text":"NonNullable<unknown>"},"desc":"Replace `{}` with `NonNullable<unknown>`."}]},{"ruleId":"@typescript-eslint/ban-types","severity":2,"message":"Don't use `{}` as a type. `{}` actually means \"any non-nullish value\".\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.\n- If you want a type meaning \"empty object\", you probably want `Record<string, never>` instead.\n- If you really want a type meaning \"any non-nullish value\", you probably want `NonNullable<unknown>` instead.","line":254,"column":35,"nodeType":"TSTypeLiteral","messageId":"bannedTypeMessage","endLine":254,"endColumn":37,"suggestions":[{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"object"},"fix":{"range":[9410,9412],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"unknown"},"fix":{"range":[9410,9412],"text":"unknown"},"desc":"Replace `{}` with `unknown`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"Record<string, never>"},"fix":{"range":[9410,9412],"text":"Record<string, never>"},"desc":"Replace `{}` with `Record<string, never>`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"NonNullable<unknown>"},"fix":{"range":[9410,9412],"text":"NonNullable<unknown>"},"desc":"Replace `{}` with `NonNullable<unknown>`."}]},{"ruleId":"@typescript-eslint/ban-types","severity":2,"message":"Don't use `{}` as a type. `{}` actually means \"any non-nullish value\".\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.\n- If you want a type meaning \"empty object\", you probably want `Record<string, never>` instead.\n- If you really want a type meaning \"any non-nullish value\", you probably want `NonNullable<unknown>` instead.","line":254,"column":39,"nodeType":"TSTypeLiteral","messageId":"bannedTypeMessage","endLine":254,"endColumn":41,"suggestions":[{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"object"},"fix":{"range":[9414,9416],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"unknown"},"fix":{"range":[9414,9416],"text":"unknown"},"desc":"Replace `{}` with `unknown`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"Record<string, never>"},"fix":{"range":[9414,9416],"text":"Record<string, never>"},"desc":"Replace `{}` with `Record<string, never>`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"NonNullable<unknown>"},"fix":{"range":[9414,9416],"text":"NonNullable<unknown>"},"desc":"Replace `{}` with `NonNullable<unknown>`."}]},{"ruleId":"@typescript-eslint/ban-types","severity":2,"message":"Don't use `{}` as a type. `{}` actually means \"any non-nullish value\".\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.\n- If you want a type meaning \"empty object\", you probably want `Record<string, never>` instead.\n- If you really want a type meaning \"any non-nullish value\", you probably want `NonNullable<unknown>` instead.","line":301,"column":35,"nodeType":"TSTypeLiteral","messageId":"bannedTypeMessage","endLine":301,"endColumn":37,"suggestions":[{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"object"},"fix":{"range":[10994,10996],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"unknown"},"fix":{"range":[10994,10996],"text":"unknown"},"desc":"Replace `{}` with `unknown`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"Record<string, never>"},"fix":{"range":[10994,10996],"text":"Record<string, never>"},"desc":"Replace `{}` with `Record<string, never>`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"NonNullable<unknown>"},"fix":{"range":[10994,10996],"text":"NonNullable<unknown>"},"desc":"Replace `{}` with `NonNullable<unknown>`."}]},{"ruleId":"@typescript-eslint/ban-types","severity":2,"message":"Don't use `{}` as a type. `{}` actually means \"any non-nullish value\".\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.\n- If you want a type meaning \"empty object\", you probably want `Record<string, never>` instead.\n- If you really want a type meaning \"any non-nullish value\", you probably want `NonNullable<unknown>` instead.","line":385,"column":35,"nodeType":"TSTypeLiteral","messageId":"bannedTypeMessage","endLine":385,"endColumn":37,"suggestions":[{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"object"},"fix":{"range":[14081,14083],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"unknown"},"fix":{"range":[14081,14083],"text":"unknown"},"desc":"Replace `{}` with `unknown`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"Record<string, never>"},"fix":{"range":[14081,14083],"text":"Record<string, never>"},"desc":"Replace `{}` with `Record<string, never>`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"NonNullable<unknown>"},"fix":{"range":[14081,14083],"text":"NonNullable<unknown>"},"desc":"Replace `{}` with `NonNullable<unknown>`."}]}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyInstance, FastifyRequest } from 'fastify';\r\nimport { authenticate, requireAdmin } from '@/middleware/auth';\r\nimport { adminRateLimit } from '@/middleware/distributed-rate-limit';\r\nimport { z } from 'zod';\r\nimport { redisClient } from '@/config/redis';\r\nimport { User } from '@/models/User';\r\nimport { Session } from '@/models/Session';\nimport { Claim } from '@/models/Claim';\nimport { Prize } from '@/models/Prize';\nimport { Settings } from '@/models/Settings';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { audit } from '@/lib/audit-logger';\nimport { JSONValue, MongoQuery } from '@/types';\n\ntype AdminRequest<P = Record<string, string>, B = Record<string, JSONValue>, Q = Record<string, string>> = FastifyRequest<{\n  Params: P;\n  Body: B;\n  Querystring: Q;\n}>;\n\r\n/**\r\n * Game Control Routes\r\n * Admin endpoints for monitoring and controlling game sessions\r\n */\r\nexport default async function gameControlRoutes(fastify: FastifyInstance) {\r\n  // ==================== ACTIVE SESSIONS ====================\r\n\r\n  // Get active game sessions\r\n  fastify.get('/game/sessions/active', {\r\n    preHandler: [authenticate, requireAdmin, adminRateLimit],\r\n  }, async (request: AdminRequest<{}, {}, { page?: string; limit?: string; userId?: string; city?: string }>, reply) => {\r\n    try {\r\n      const page = parseInt(request.query.page || '1');\r\n      const limit = parseInt(request.query.limit || '20');\r\n      const skip = (page - 1) * limit;\r\n\r\n      // Get active sessions from Redis\r\n      const sessionKeys = await redisClient.keys('session:game_session_*');\r\n      const sessions: { userId: string; status: string; user?: { displayName: string; email?: string; level?: number } }[] = [];\r\n\r\n      for (const key of sessionKeys) {\r\n        const sessionData = await redisClient.get(key);\r\n        if (sessionData) {\r\n          const session = JSON.parse(sessionData);\r\n          if (session.status === 'active') {\r\n            // Filter by userId if provided\r\n            if (request.query.userId && session.userId !== request.query.userId) continue;\r\n            \r\n            // Get user info\r\n            const user = await User.findById(session.userId).select('displayName email level').lean();\r\n            sessions.push({\r\n              ...session,\r\n              user: user || { displayName: 'Unknown' }\r\n            });\r\n          }\r\n        }\r\n      }\r\n\r\n      // Paginate\r\n      const total = sessions.length;\r\n      const paginatedSessions = sessions.slice(skip, skip + limit);\r\n\r\n      reply.send({\r\n        success: true,\r\n        data: {\r\n          sessions: paginatedSessions,\r\n          pagination: {\r\n            page,\r\n            limit,\r\n            total,\r\n            pages: Math.ceil(total / limit)\r\n          }\r\n        }\r\n      });\r\n    } catch (error) {\r\n      reply.code(500).send({ success: false, error: error instanceof Error ? error.message : String(error) });\r\n    }\r\n  });\r\n\r\n  // Force end a game session (Kill Switch)\r\n  fastify.delete('/game/sessions/:sessionId', {\r\n    preHandler: [authenticate, requireAdmin, adminRateLimit],\r\n  }, async (request: AdminRequest<{ sessionId: string }>, reply) => {\r\n    try {\r\n      const { sessionId } = request.params;\r\n      const { GameService } = await import('../../game/index');\r\n\r\n      // Check if session exists in Redis\r\n      const sessionKey = `session:${sessionId}`;\r\n      const sessionData = await redisClient.get(sessionKey);\r\n      \r\n      if (!sessionData) {\r\n        return reply.code(404).send({ success: false, error: 'Session not found or already ended' });\r\n      }\r\n\r\n      const session = JSON.parse(sessionData);\r\n      \r\n      // Force end the session using GameService\r\n      try {\r\n        await GameService.endGameSession(session.userId, sessionId);\r\n      } catch (err) {\r\n        // Even if GameService fails (e.g. logic error), force delete from Redis to kill it\r\n        await redisClient.del(sessionKey);\r\n      }\r\n      \r\n      // Log this admin action\r\n      await audit.custom(\r\n        (request.user as { sub: string }).sub,\r\n        'FORCE_END_SESSION',\r\n        'session',\r\n        sessionId,\r\n        { userId: session.userId, ip: request.ip }\r\n      );\r\n\r\n      return reply.send({ success: true, message: 'Session terminated successfully' });\r\n    } catch (error) {\r\n      return reply.code(500).send({ success: false, error: error instanceof Error ? error.message : String(error) });\r\n    }\r\n  });\r\n\r\n  // Get session history from database\r\n  fastify.get('/game/sessions/history', {\r\n    preHandler: [authenticate, requireAdmin, adminRateLimit],\r\n  }, async (request: AdminRequest<{}, {}, { page?: string; limit?: string; userId?: string; startDate?: string; endDate?: string }>, reply) => {\r\n    try {\r\n      const page = parseInt(request.query.page || '1');\r\n      const limit = parseInt(request.query.limit || '20');\r\n      const skip = (page - 1) * limit;\r\n\r\n      const query: MongoQuery = {};\n      if (request.query.userId) query.userId = request.query.userId;\n      if (request.query.startDate || request.query.endDate) {\n        query.startTime = {};\n        if (request.query.startDate) (query.startTime as MongoQuery).$gte = new Date(request.query.startDate);\n        if (request.query.endDate) (query.startTime as MongoQuery).$lte = new Date(request.query.endDate);\n      }\n\r\n      const [sessions, total] = await Promise.all([\r\n        Session.find(query)\r\n          .populate('userId', 'displayName email level')\r\n          .sort({ startTime: -1 })\r\n          .skip(skip)\r\n          .limit(limit)\r\n          .lean(),\r\n        Session.countDocuments(query)\r\n      ]);\r\n\r\n      reply.send({\r\n        success: true,\r\n        data: {\r\n          sessions,\r\n          pagination: {\r\n            page,\r\n            limit,\r\n            total,\r\n            pages: Math.ceil(total / limit)\r\n          }\r\n        }\r\n      });\r\n    } catch (error) {\r\n      reply.code(500).send({ success: false, error: error instanceof Error ? error.message : String(error) });\r\n    }\r\n  });\r\n\r\n  // Get session details\r\n  fastify.get('/game/sessions/:sessionId', {\r\n    preHandler: [authenticate, requireAdmin, adminRateLimit],\r\n  }, async (request: AdminRequest<{ sessionId: string }>, reply) => {\r\n    try {\r\n      // Try Redis first (active sessions)\r\n      const redisSession = await redisClient.get(`session:${request.params.sessionId}`);\r\n      if (redisSession) {\r\n        const session = JSON.parse(redisSession);\r\n        const user = await User.findById(session.userId).select('displayName email level points').lean();\r\n        return reply.send({\r\n          success: true,\r\n          data: { ...session, user, source: 'active' }\r\n        });\r\n      }\r\n\r\n      // Try database (completed sessions)\r\n      const dbSession = await Session.findOne({ sessionId: request.params.sessionId })\r\n        .populate('userId', 'displayName email level points')\r\n        .lean();\r\n\r\n      if (!dbSession) {\r\n        return reply.code(404).send({ success: false, error: 'Session not found' });\r\n      }\r\n\r\n      return reply.send({\r\n        success: true,\r\n        data: { ...dbSession, source: 'history' }\r\n      });\r\n    } catch (error) {\r\n      return reply.code(500).send({ success: false, error: error instanceof Error ? error.message : String(error) });\r\n    }\r\n  });\r\n\r\n  // Force terminate session\r\n  fastify.post('/game/sessions/:sessionId/terminate', {\r\n    preHandler: [authenticate, requireAdmin],\r\n  }, async (request: AdminRequest<{ sessionId: string }, { reason?: string }>, reply) => {\r\n    try {\r\n      const sessionKey = `session:${request.params.sessionId}`;\r\n      const sessionData = await redisClient.get(sessionKey);\r\n\r\n      if (!sessionData) {\r\n        return reply.code(404).send({ success: false, error: 'Active session not found' });\r\n      }\r\n\r\n      const session = JSON.parse(sessionData);\r\n      session.status = 'terminated';\r\n      session.terminatedAt = new Date().toISOString();\r\n      session.terminatedBy = request.user.sub;\r\n      session.terminationReason = request.body.reason || 'Admin termination';\r\n\r\n      // Update in Redis (keep for logging)\r\n      await redisClient.setex(sessionKey, 86400, JSON.stringify(session));\r\n\r\n      // Audit log\r\n      await audit.custom({\r\n        userId: request.user.sub,\r\n        userRole: 'admin',\r\n        action: 'TERMINATE_SESSION',\r\n        resource: 'game_session',\r\n        resourceId: request.params.sessionId,\r\n        category: 'admin',\r\n        severity: 'medium',\r\n        description: `Terminated game session: ${request.body.reason || 'Admin termination'}`,\r\n        metadata: { sessionId: request.params.sessionId, userId: session.userId, reason: request.body.reason },\r\n      });\r\n\r\n      typedLogger.warn('Game session terminated by admin', {\r\n        sessionId: request.params.sessionId,\r\n        adminId: request.user.sub,\r\n        reason: request.body.reason\r\n      });\r\n\r\n      return reply.send({\r\n        success: true,\r\n        message: 'Session terminated successfully',\r\n        data: session\r\n      });\r\n    } catch (error) {\r\n      return reply.code(500).send({ success: false, error: error instanceof Error ? error.message : String(error) });\r\n    }\r\n  });\r\n\r\n  // ==================== LEADERBOARDS ====================\r\n\r\n  // Get leaderboard\r\n  fastify.get('/game/leaderboard', {\r\n    preHandler: [authenticate, requireAdmin, adminRateLimit],\r\n  }, async (request: AdminRequest<{}, {}, { type?: string; limit?: string; city?: string }>, reply) => {\r\n    try {\r\n      const type = request.query.type || 'points';\r\n      const limit = parseInt(request.query.limit || '50');\r\n\r\n      let sortField = 'points.total';\r\n      switch (type) {\r\n        case 'claims': sortField = 'stats.prizesFound'; break;\r\n        case 'distance': sortField = 'stats.totalDistance'; break;\n        case 'level': sortField = 'level'; break;\r\n        default: sortField = 'points.total';\r\n      }\r\n\r\n      const query: MongoQuery = { isBanned: false };\n      if (request.query.city) {\r\n        query['location.city'] = request.query.city;\r\n      }\r\n\r\n      const users = await User.find(query)\r\n        .select('displayName email level points stats avatar location')\r\n        .sort({ [sortField]: -1 })\r\n        .limit(limit)\r\n        .lean();\r\n\r\n      const leaderboard = users.map((user, index) => ({\r\n        rank: index + 1,\r\n        userId: user._id,\r\n        displayName: user.displayName,\r\n        email: user.email,\r\n        level: user.level,\r\n        points: user.points,\r\n        stats: user.stats,\r\n        city: user.location?.city\r\n      }));\r\n\r\n      reply.send({\r\n        success: true,\r\n        data: { leaderboard, type }\r\n      });\r\n    } catch (error) {\r\n      reply.code(500).send({ success: false, error: error instanceof Error ? error.message : String(error) });\r\n    }\r\n  });\r\n\r\n  // Reset leaderboard (clear points for specific type)\r\n  fastify.post('/game/leaderboard/reset', {\r\n    preHandler: [authenticate, requireAdmin],\r\n  }, async (request: AdminRequest<{}, { type: string; scope?: string; confirm?: boolean }>, reply) => {\r\n    try {\r\n      if (!request.body.confirm) {\r\n        return reply.code(400).send({\r\n          success: false,\r\n          error: 'Please confirm this action by setting confirm: true'\r\n        });\r\n      }\r\n\r\n      const { type, scope } = request.body;\r\n      const query: MongoQuery = {};\n      if (scope && scope !== 'global') {\r\n        query['location.city'] = scope;\r\n      }\r\n\r\n      let updateField = {};\r\n      switch (type) {\r\n        case 'points':\r\n          updateField = { 'points.available': 0, 'points.total': 0 };\r\n          break;\r\n        case 'claims':\r\n          updateField = { 'stats.prizesFound': 0 };\r\n          break;\r\n        case 'distance':\n          updateField = { 'stats.totalDistance': 0 };\n          break;\n        default:\r\n          return reply.code(400).send({ success: false, error: 'Invalid leaderboard type' });\r\n      }\r\n\r\n      const result = await User.updateMany(query, { $set: updateField });\r\n\r\n      // Audit log - this is a critical action\r\n      await audit.custom({\r\n        userId: request.user.sub,\r\n        userRole: 'admin',\r\n        action: 'RESET_LEADERBOARD',\r\n        resource: 'leaderboard',\r\n        category: 'admin',\r\n        severity: 'high',\r\n        description: `Reset ${type} leaderboard${scope && scope !== 'global' ? ` for ${scope}` : ''}`,\r\n        metadata: { type, scope, affected: result.modifiedCount },\r\n      });\r\n\r\n      typedLogger.warn('Leaderboard reset by admin', {\r\n        adminId: request.user.sub,\r\n        type,\r\n        scope,\r\n        affected: result.modifiedCount\r\n      });\r\n\r\n      return reply.send({\r\n        success: true,\r\n        message: `Leaderboard reset successfully`,\r\n        data: { affected: result.modifiedCount }\r\n      });\r\n    } catch (error) {\r\n      return reply.code(500).send({ success: false, error: error instanceof Error ? error.message : String(error) });\r\n    }\r\n  });\r\n\r\n  // ==================== DAILY CHALLENGES ====================\r\n\r\n  // Get challenge templates\r\n  fastify.get('/game/challenges', {\r\n    preHandler: [authenticate, requireAdmin, adminRateLimit],\r\n  }, async (request, reply) => {\r\n    try {\r\n      const settings = await Settings.findOne();\r\n      const challenges = settings?.custom?.dailyChallenges || [\r\n        { id: 'daily_claims', title: 'Prize Hunter', description: 'Claim 5 prizes', type: 'claims', target: 5, reward: 100 },\r\n        { id: 'distance_walker', title: 'Explorer', description: 'Walk 2km', type: 'distance', target: 2000, reward: 75 },\r\n        { id: 'category_variety', title: 'Variety Seeker', description: 'Claim from 3 categories', type: 'categories', target: 3, reward: 50 }\r\n      ];\r\n\r\n      reply.send({ success: true, data: { challenges } });\r\n    } catch (error) {\r\n      reply.code(500).send({ success: false, error: error instanceof Error ? error.message : String(error) });\r\n    }\r\n  });\r\n\r\n  // Update challenge template\r\n  fastify.post('/game/challenges', {\r\n    preHandler: [authenticate, requireAdmin],\r\n  }, async (request: AdminRequest<{}, { id: string; title: string; description: string; type: string; target: number; reward: number }>, reply) => {\r\n    try {\r\n      const challengeData = request.body;\r\n\r\n      await Settings.findOneAndUpdate(\r\n        {},\r\n        {\r\n          $set: {\r\n            [`custom.dailyChallenges`]: challengeData\r\n          }\r\n        },\r\n        { upsert: true }\r\n      );\r\n\r\n      // Audit log\r\n      await audit.custom({\r\n        userId: request.user.sub,\r\n        userRole: 'admin',\r\n        action: 'UPDATE_CHALLENGES',\r\n        resource: 'challenge',\r\n        category: 'admin',\r\n        severity: 'low',\r\n        metadata: challengeData,\r\n      });\r\n\r\n      reply.send({ success: true, message: 'Challenge updated', data: challengeData });\r\n    } catch (error) {\r\n      reply.code(500).send({ success: false, error: error instanceof Error ? error.message : String(error) });\r\n    }\r\n  });\r\n\r\n  // Delete challenge\r\n  fastify.delete('/game/challenges/:challengeId', {\r\n    preHandler: [authenticate, requireAdmin],\r\n  }, async (request: AdminRequest<{ challengeId: string }>, reply) => {\r\n    try {\r\n      await Settings.findOneAndUpdate(\r\n        {},\r\n        {\r\n          $pull: {\r\n            'custom.dailyChallenges': { id: request.params.challengeId }\r\n          }\r\n        }\r\n      );\r\n\r\n      // Audit log\r\n      await audit.custom({\r\n        userId: request.user.sub,\r\n        userRole: 'admin',\r\n        action: 'DELETE_CHALLENGE',\r\n        resource: 'challenge',\r\n        resourceId: request.params.challengeId,\r\n        category: 'admin',\r\n        severity: 'low',\r\n        metadata: { challengeId: request.params.challengeId },\r\n      });\r\n\r\n      reply.send({ success: true, message: 'Challenge deleted' });\r\n    } catch (error) {\r\n      reply.code(500).send({ success: false, error: error instanceof Error ? error.message : String(error) });\r\n    }\r\n  });\r\n\r\n  // ==================== MAINTENANCE MODE ====================\r\n\r\n  // Get maintenance status\r\n  fastify.get('/maintenance/status', {\r\n    preHandler: [authenticate, requireAdmin, adminRateLimit],\r\n  }, async (request, reply) => {\r\n    try {\r\n      const maintenanceData = await redisClient.get('system:maintenance');\r\n      if (maintenanceData) {\r\n        reply.send({ success: true, data: JSON.parse(maintenanceData) });\r\n      } else {\r\n        reply.send({ success: true, data: { active: false, message: null } });\r\n      }\r\n    } catch (error) {\r\n      reply.code(500).send({ success: false, error: error instanceof Error ? error.message : String(error) });\r\n    }\r\n  });\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\admin\\routes\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\admin\\routes\\notifications.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":96,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":96,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3854,3857],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3854,3857],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":96,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":96,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3884,3887],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3884,3887],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":97,"column":89,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":97,"endColumn":92,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3985,3988],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3985,3988],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":103,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":103,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4217,4220],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4217,4220],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":103,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":103,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4247,4250],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4247,4250],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":104,"column":94,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":104,"endColumn":97,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4353,4356],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4353,4356],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":110,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":110,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4583,4586],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4583,4586],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":110,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":110,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4613,4616],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4613,4616],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":114,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":114,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4788,4791],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4788,4791],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":126,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":126,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5262,5265],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5262,5265],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":126,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":126,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5292,5295],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5292,5295],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":127,"column":89,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":127,"endColumn":92,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5393,5396],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5393,5396],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":133,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":133,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5720,5723],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5720,5723],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":133,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":133,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5750,5753],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5750,5753],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":134,"column":115,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":134,"endColumn":118,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5877,5880],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5877,5880],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":139,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":139,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6116,6119],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6116,6119],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":139,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":139,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6146,6149],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6146,6149],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":17,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyInstance, FastifyRequest } from 'fastify';\nimport { authenticate, requireAdmin } from '@/middleware/auth';\nimport { adminRateLimit } from '@/middleware/distributed-rate-limit';\nimport { AdminNotificationsService } from '../services/admin-notifications.service';\nimport { z } from 'zod';\n\nconst normalizeType = z\n  .string()\n  .optional()\n  .transform((val) => (val ? val.toLowerCase() : undefined))\n  .refine((val) => !val || ['push', 'email', 'sms', 'in_app'].includes(val), {\n    message: 'Type must be one of: push, email, sms, in_app'\n  });\n\nconst NotificationQuerySchema = z.object({\n  page: z.coerce.number().int().positive({ message: 'Page must be a positive integer' }).default(1),\n  limit: z.coerce.number().int()\n    .min(1, { message: 'Limit must be at least 1' })\n    .max(100, { message: 'Limit cannot exceed 100' }).default(20),\n  status: z.enum(['sent', 'scheduled', 'failed', 'pending'], {\n    errorMap: () => ({ message: 'Status must be one of: sent, scheduled, failed, pending' })\n  }).optional(),\n  type: normalizeType,\n});\n\nconst SendNotificationSchema = z.object({\n  title: z.string()\n    .min(1, { message: 'Title is required' })\n    .max(200, { message: 'Title cannot exceed 200 characters' }),\n  message: z.string()\n    .min(1, { message: 'Message is required' })\n    .max(1000, { message: 'Message cannot exceed 1000 characters' }),\n  type: normalizeType,\n  data: z.record(z.any()).optional(),\n  targetUserIds: z.array(z.string())\n    .min(1, { message: 'At least one target user ID is required' }),\n});\n\nconst BroadcastNotificationSchema = z.object({\n  title: z.string()\n    .min(1, { message: 'Title is required' })\n    .max(200, { message: 'Title cannot exceed 200 characters' }),\n  message: z.string()\n    .min(1, { message: 'Message is required' })\n    .max(1000, { message: 'Message cannot exceed 1000 characters' }),\n  type: normalizeType,\n  data: z.record(z.any()).optional(),\n});\n\nconst ScheduleNotificationSchema = z.object({\n  title: z.string()\n    .min(1, { message: 'Title is required' })\n    .max(200, { message: 'Title cannot exceed 200 characters' }),\n  message: z.string()\n    .min(1, { message: 'Message is required' })\n    .max(1000, { message: 'Message cannot exceed 1000 characters' }),\n  type: normalizeType,\n  data: z.record(z.any()).optional(),\n  targetUserIds: z.array(z.string()).optional(),\n  scheduledFor: z.string().datetime({ message: 'scheduledFor must be a valid ISO 8601 datetime (e.g., 2024-01-15T10:30:00Z)' }),\n});\n\nconst StatsQuerySchema = z.object({\n  period: z.enum(['day', 'week', 'month', 'all'], {\n    errorMap: () => ({ message: 'Period must be one of: day, week, month, all' })\n  }).default('week'),\n});\n\nconst NotificationTemplateSchema = z.object({\n  id: z.string().optional(),\n  name: z.string().min(1),\n  channel: z.enum(['push', 'email', 'sms', 'in_app']),\n  variables: z.array(z.string()).default([]),\n  content: z.record(z.any()).optional(),\n});\n\nexport default async function notificationsRoutes(fastify: FastifyInstance) {\n  fastify.addHook('preHandler', authenticate);\n  fastify.addHook('preHandler', requireAdmin);\n  fastify.addHook('preHandler', adminRateLimit);\n\n  fastify.get('/notifications', async (request: FastifyRequest, reply) => {\n    const query = NotificationQuerySchema.parse(request.query);\n    const result = await AdminNotificationsService.getNotifications(query);\n    return reply.send(result);\n  });\n\n  fastify.get('/notifications/stats', async (request: FastifyRequest, reply) => {\n    const { period } = StatsQuerySchema.parse(request.query);\n    const stats = await AdminNotificationsService.getNotificationStats(period);\n    return reply.send(stats);\n  });\n\n  fastify.post('/notifications/send', async (request: FastifyRequest, reply) => {\n    const payload = SendNotificationSchema.parse(request.body);\n    const adminId = (request as any).user?.sub || (request as any).userId;\n    const result = await AdminNotificationsService.sendNotification(adminId, payload as any);\n    return reply.send(result);\n  });\n\n  fastify.post('/notifications/broadcast', async (request: FastifyRequest, reply) => {\n    const payload = BroadcastNotificationSchema.parse(request.body);\n    const adminId = (request as any).user?.sub || (request as any).userId;\n    const result = await AdminNotificationsService.broadcastNotification(adminId, payload as any);\n    return reply.send(result);\n  });\n\n  fastify.post('/notifications/schedule', async (request: FastifyRequest, reply) => {\n    const payload = ScheduleNotificationSchema.parse(request.body);\n    const adminId = (request as any).user?.sub || (request as any).userId;\n    const result = await AdminNotificationsService.scheduleNotification(adminId, {\n      ...payload,\n      scheduledFor: new Date(payload.scheduledFor),\n    } as any);\n    return reply.send(result);\n  });\n\n  // Templates CRUD\n  fastify.get('/notifications/templates', async (_request: FastifyRequest, reply) => {\n    const templates = await AdminNotificationsService.getTemplates();\n    return reply.send({ success: true, data: templates });\n  });\n\n  fastify.post('/notifications/templates', async (request: FastifyRequest, reply) => {\n    const payload = NotificationTemplateSchema.parse(request.body);\n    const adminId = (request as any).user?.sub || (request as any).userId;\n    const template = await AdminNotificationsService.createTemplate(adminId, payload as any);\n    return reply.code(201).send({ success: true, data: template });\n  });\n\n  fastify.patch('/notifications/templates/:templateId', async (request: FastifyRequest<{ Params: { templateId: string } }>, reply) => {\n    const changes = NotificationTemplateSchema.partial().parse(request.body);\n    const adminId = (request as any).user?.sub || (request as any).userId;\n    const updated = await AdminNotificationsService.updateTemplate(adminId, request.params.templateId, changes as any);\n    return reply.send({ success: true, data: updated });\n  });\n\n  fastify.delete('/notifications/templates/:templateId', async (request: FastifyRequest<{ Params: { templateId: string } }>, reply) => {\n    const adminId = (request as any).user?.sub || (request as any).userId;\n    await AdminNotificationsService.deleteTemplate(adminId, request.params.templateId);\n    return reply.status(204).send();\n  });\n\n  // Get single notification\n  fastify.get('/notifications/:id', async (request: FastifyRequest<{ Params: { id: string } }>, reply) => {\n    const notification = await AdminNotificationsService.getNotificationById(request.params.id);\n    if (!notification) {\n      return reply.status(404).send({ success: false, error: 'NOTIFICATION_NOT_FOUND' });\n    }\n    return reply.send({ success: true, data: notification });\n  });\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\admin\\routes\\partners.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":120,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":120,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5936,5939],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5936,5939],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":139,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":139,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6787,6790],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6787,6790],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":153,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":153,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7411,7414],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7411,7414],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":164,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":164,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7956,7959],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7956,7959],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":164,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":164,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7986,7989],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7986,7989],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":167,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":167,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8184,8187],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8184,8187],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":175,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":175,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8543,8546],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8543,8546],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":175,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":175,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8573,8576],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8573,8576],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":179,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":179,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8748,8751],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8748,8751],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":189,"column":99,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":189,"endColumn":102,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9114,9117],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9114,9117],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":192,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":192,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9252,9255],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9252,9255],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":192,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":192,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9282,9285],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9282,9285],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":196,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":196,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9467,9470],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9467,9470],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":209,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":209,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9952,9955],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9952,9955],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":209,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":209,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9982,9985],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9982,9985],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":232,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":232,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10909,10912],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10909,10912],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":240,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":240,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11221,11224],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11221,11224],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":248,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":248,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11483,11486],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11483,11486],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":257,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":257,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11951,11954],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11951,11954],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":266,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":266,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12231,12234],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12231,12234],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":278,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":278,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12803,12806],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12803,12806],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":21,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyInstance, FastifyRequest } from 'fastify';\nimport { Types } from 'mongoose';\nimport { authenticate, requireAdmin } from '@/middleware/auth';\nimport { adminRateLimit } from '@/middleware/distributed-rate-limit';\nimport { AdminPartnersService } from '../services/admin-partners.service';\nimport { Reward } from '@/models/Reward';\nimport { z } from 'zod';\nimport { PartnerLocationsService } from '@/services/partner-locations';\nimport { PartnerStatsService } from '@/services/partner-stats';\nimport { broadcastAdminEvent } from '@/lib/websocket';\n\nconst PartnerListSchema = z.object({\n  page: z.coerce.number().int().positive({ message: 'Page must be a positive integer' }).default(1),\n  limit: z.coerce.number().int().min(1, { message: 'Limit must be at least 1' }).max(100, { message: 'Limit cannot exceed 100' }).default(20),\n  search: z.string().optional(),\n  status: z.enum(['active', 'inactive', 'pending', 'all'], { \n    errorMap: () => ({ message: 'Status must be one of: active, inactive, pending, all' })\n  }).default('all'),\n  category: z.string().optional(),\n});\n\nconst CreatePartnerSchema = z.object({\n  name: z.string()\n    .min(1, { message: 'Partner name is required' })\n    .max(100, { message: 'Partner name cannot exceed 100 characters' }),\n  description: z.string().max(500, { message: 'Description cannot exceed 500 characters' }).optional(),\n  logoUrl: z.string().url({ message: 'Logo URL must be a valid URL (e.g., https://example.com/logo.png)' }).optional().or(z.literal('')),\n  website: z.string().url({ message: 'Website must be a valid URL (e.g., https://example.com)' }).optional().or(z.literal('')).transform(v => v === '' ? undefined : v),\n  category: z.string()\n    .min(1, { message: 'Category is required' })\n    .max(50, { message: 'Category cannot exceed 50 characters' }),\n  contactEmail: z.string().email({ message: 'Contact email must be a valid email address' }),\n  portalUsername: z.string()\n    .min(3, { message: 'Portal username must be at least 3 characters' })\n    .max(50, { message: 'Portal username cannot exceed 50 characters' })\n    .regex(/^[a-zA-Z0-9._-]+$/, { message: 'Portal username can only contain letters, numbers, dots, underscores, and dashes' })\n    .transform((value) => value.trim().toLowerCase()),\n  contactPhone: z.string().optional(),\n  features: z.array(z.string()).optional(),\n  contactPerson: z.object({\n    name: z.string().optional(),\n    email: z.string().email().optional(),\n    phone: z.string().optional(),\n    position: z.string().optional(),\n  }).optional(),\n  isActive: z.boolean().optional(),\n  status: z.enum(['active', 'inactive', 'pending'], {\n    errorMap: () => ({ message: 'Status must be one of: active, inactive, pending' })\n  }).default('pending'),\n});\n\nconst UpdatePartnerSchema = z.object({\n  name: z.string()\n    .min(1, { message: 'Partner name cannot be empty' })\n    .max(100, { message: 'Partner name cannot exceed 100 characters' }).optional(),\n  description: z.string().max(500, { message: 'Description cannot exceed 500 characters' }).optional(),\n  logoUrl: z.string().url({ message: 'Logo URL must be a valid URL (e.g., https://example.com/logo.png)' }).optional().or(z.literal('')).transform(v => v === '' ? undefined : v),\n  website: z.string().url({ message: 'Website must be a valid URL (e.g., https://example.com)' }).optional().or(z.literal('')).transform(v => v === '' ? undefined : v),\n  category: z.string()\n    .min(1, { message: 'Category cannot be empty' })\n    .max(50, { message: 'Category cannot exceed 50 characters' }).optional(),\n  contactEmail: z.string().email({ message: 'Contact email must be a valid email address' }).optional().or(z.literal('')).transform(v => v === '' ? undefined : v),\n  contactPhone: z.string().optional(),\n  features: z.array(z.string()).optional(),\n  contactPerson: z.object({\n    name: z.string().optional(),\n    email: z.string().email().optional(),\n    phone: z.string().optional(),\n    position: z.string().optional(),\n  }).optional(),\n  isActive: z.boolean().optional(),\n  status: z.enum(['active', 'inactive', 'pending'], {\n    errorMap: () => ({ message: 'Status must be one of: active, inactive, pending' })\n  }).optional(),\n});\n\nconst ResetCredentialsSchema = z.object({\n  newPassword: z.string().min(8, { message: 'Password must be at least 8 characters' }).optional(),\n});\n\nconst PartnerStatsQuerySchema = z.object({\n  limitRecent: z.coerce.number().int().min(1).max(50).optional(),\n  period: z.string().optional(),\n});\n\nexport default async function partnersRoutes(fastify: FastifyInstance) {\n  fastify.addHook('preHandler', authenticate);\n  fastify.addHook('preHandler', requireAdmin);\n  fastify.addHook('preHandler', adminRateLimit);\n\n  fastify.get('/partners', async (request: FastifyRequest, reply) => {\n    const query = PartnerListSchema.parse(request.query);\n    const result = await AdminPartnersService.getPartners({\n      page: query.page,\n      limit: query.limit,\n      status: query.status === 'all' ? undefined : query.status,\n      category: query.category,\n      search: query.search,\n    });\n    return reply.send(result);\n  });\n\n  fastify.get('/partners/:id', async (request: FastifyRequest<{ Params: { id: string } }>, reply) => {\n    const { id } = request.params;\n    const partner = await AdminPartnersService.getPartner(id);\n    if (!partner) {\n      return reply.status(404).send({ error: 'Partner not found' });\n    }\n    return reply.send(partner);\n  });\n\n  // Partner stats for admin dashboards\n  fastify.get('/partners/:id/stats', async (request: FastifyRequest<{ Params: { id: string } }>, reply) => {\n    try {\n      const { id } = request.params;\n      const query = PartnerStatsQuerySchema.parse(request.query || {});\n      const limitRecent = query.limitRecent ?? 5;\n      const stats = await PartnerStatsService.getPartnerStats(id, limitRecent);\n      return reply.send({ success: true, data: stats, stats });\n    } catch (error: any) {\n      const message = error?.message || 'PARTNER_STATS_FAILED';\n      const status = message === 'INVALID_PARTNER_ID' ? 400 : 500;\n      return reply.status(status).send({ error: message });\n    }\n  });\n\n  // Partner offers (rewards) for admin views\n  fastify.get('/partners/:id/offers', async (request: FastifyRequest<{ Params: { id: string } }>, reply) => {\n    const { id } = request.params;\n    if (!Types.ObjectId.isValid(id)) {\n      return reply.status(400).send({ error: 'INVALID_PARTNER_ID' });\n    }\n\n    const offers = await Reward.find({ partnerId: new Types.ObjectId(id) })\n      .select('name description category pointsCost stockQuantity stockAvailable stockReserved isActive isPopular imageUrl metadata partnerId createdAt updatedAt')\n      .sort({ createdAt: -1 })\n      .lean();\n\n    const enrichedOffers = offers.map((offer: any) => ({\n      ...offer,\n      source: offer?.metadata?.source || (offer?.metadata?.isSponsored ? 'sponsored' : undefined),\n    }));\n\n    return reply.send({ success: true, offers: enrichedOffers, total: enrichedOffers.length });\n  });\n\n  // Get partner portal credentials (email + username) for admins\n  fastify.get('/partners/:id/credentials', async (request: FastifyRequest<{ Params: { id: string } }>, reply) => {\n    try {\n      const { id } = request.params;\n      const credentials = await AdminPartnersService.getPartnerCredentials(id);\n      return reply.send({ success: true, credentials });\n    } catch (error: any) {\n      const status = error?.message === 'Partner not found' ? 404 : 500;\n      return reply.status(status).send({ error: error?.message || 'FAILED_TO_GET_CREDENTIALS' });\n    }\n  });\n\n  // Reset partner portal password (returns new password for delivery)\n  fastify.post('/partners/:id/reset-credentials', async (request: FastifyRequest<{ Params: { id: string } }>, reply) => {\n    try {\n      const { id } = request.params;\n      const { newPassword } = ResetCredentialsSchema.parse(request.body || {});\n      const adminId = (request as any).user?.sub || (request as any).userId;\n      const credentials = await AdminPartnersService.resetPartnerCredentials(adminId, id, { newPassword });\n      return reply.send({ success: true, credentials });\n    } catch (error: any) {\n      const status = error?.message === 'Partner not found' ? 404 : 400;\n      return reply.status(status).send({ error: error?.message || 'RESET_CREDENTIALS_FAILED' });\n    }\n  });\n\n  fastify.post('/partners', async (request: FastifyRequest, reply) => {\n    const partnerData = CreatePartnerSchema.parse(request.body);\n    const adminId = (request as any).user?.sub || (request as any).userId;\n    const { partner, credentials } = await AdminPartnersService.createPartner(adminId, {\n      ...partnerData,\n      categories: [partnerData.category],\n    } as any);\n    broadcastAdminEvent({ type: 'partner_created', partner });\n    broadcastAdminEvent({ type: 'partner_update', partner });\n    return reply.status(201).send({\n      partner,\n      credentials,\n    });\n  });\n\n  // Support both PUT and PATCH for partner updates\n  const updatePartnerHandler = async (request: FastifyRequest<{ Params: { id: string } }>, reply: any) => {\n    const { id } = request.params;\n    const updates = UpdatePartnerSchema.parse(request.body);\n    const adminId = (request as any).user?.sub || (request as any).userId;\n    const partner = await AdminPartnersService.updatePartner(adminId, id, {\n      ...updates,\n      categories: updates.category ? [updates.category] : undefined,\n    } as any);\n    if (!partner) {\n      return reply.status(404).send({ error: 'Partner not found' });\n    }\n    broadcastAdminEvent({ type: 'partner_update', partner });\n    return reply.send(partner);\n  };\n\n  fastify.put('/partners/:id', updatePartnerHandler);\n  fastify.patch('/partners/:id', updatePartnerHandler);\n\n  fastify.delete('/partners/:id', async (request: FastifyRequest<{ Params: { id: string } }>, reply) => {\n    const { id } = request.params;\n    const adminId = (request as any).user?.sub || (request as any).userId;\n    const result = await AdminPartnersService.deletePartner(adminId, id);\n    if (!result) {\n      return reply.status(404).send({ error: 'Partner not found' });\n    }\n    broadcastAdminEvent({ type: 'partner_deleted', partnerId: id });\n    return reply.status(204).send();\n  });\n\n  // GET /admin/partners/:id/locations - Get all locations for a partner\n  fastify.get('/partners/:id/locations', async (request: FastifyRequest<{ Params: { id: string } }>, reply) => {\n    const { id } = request.params;\n    const partner = await AdminPartnersService.getPartner(id);\n    if (!partner) {\n      return reply.status(404).send({ error: 'Partner not found' });\n    }\n    return reply.send({\n      success: true,\n      data: partner.locations,\n      meta: {\n        partnerId: id,\n        partnerName: partner.name,\n        totalLocations: partner.locations.length,\n        activeLocations: partner.locations.filter((loc: any) => loc.isActive).length\n      }\n    });\n  });\n\n  // POST /admin/partners/:id/locations - Add a location to a partner\n  fastify.post('/partners/:id/locations', async (request: FastifyRequest<{ Params: { id: string } }>, reply) => {\n    const { id } = request.params;\n    const locationData = request.body as any;\n    try {\n      const location = await PartnerLocationsService.addLocation(id, locationData);\n      return reply.status(201).send({\n        success: true,\n        message: 'Location added successfully',\n        data: location,\n      });\n    } catch (error: any) {\n      const status = error.message === 'PARTNER_NOT_FOUND' ? 404 : 400;\n      return reply.status(status).send({ error: error.message });\n    }\n  });\n\n  // PUT /admin/partners/:id/locations/:locationId - Update a partner location\n  fastify.put('/partners/:id/locations/:locationId', async (request: FastifyRequest<{ Params: { id: string; locationId: string } }>, reply) => {\n    const { id, locationId } = request.params;\n    const updateData = request.body as any;\n\n    try {\n      const updatedLocation = await PartnerLocationsService.updateLocation(id, locationId, updateData);\n      return reply.send({\n        success: true,\n        message: 'Location updated successfully',\n        data: updatedLocation,\n      });\n    } catch (error: any) {\n      const status = error.message === 'PARTNER_NOT_FOUND' ? 404 : 400;\n      return reply.status(status).send({ error: error.message });\n    }\n  });\n\n  // DELETE /admin/partners/:id/locations/:locationId - Remove a partner location\n  fastify.delete('/partners/:id/locations/:locationId', async (request: FastifyRequest<{ Params: { id: string; locationId: string } }>, reply) => {\n    const { id, locationId } = request.params;\n    try {\n      await PartnerLocationsService.removeLocation(id, locationId);\n      return reply.status(204).send();\n    } catch (error: any) {\n      const status = error.message === 'PARTNER_NOT_FOUND' ? 404 : 400;\n      return reply.status(status).send({ error: error.message });\n    }\n  });\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\admin\\routes\\power-ups.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":77,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":77,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3670,3673],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3670,3673],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":79,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3709,3712],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3709,3712],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":89,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":89,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4107,4110],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4107,4110],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":100,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":100,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4449,4452],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4449,4452],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":125,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":125,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5046,5049],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5046,5049],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":129,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":129,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5243,5246],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5243,5246],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":193,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":193,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7077,7080],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7077,7080],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":196,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":196,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7235,7238],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7235,7238],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":202,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":202,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7433,7436],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7433,7436],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":279,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":279,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9780,9783],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9780,9783],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":329,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":329,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11185,11188],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11185,11188],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":375,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":375,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12468,12471],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12468,12471],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":401,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":401,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13127,13130],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13127,13130],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';\r\nimport { z } from 'zod';\r\nimport PowerUpAdminService, {\r\n  CreatePowerUpDto,\r\n  UpdatePowerUpDto,\r\n} from '../services/admin-power-ups.service.js';\r\nimport { Types } from 'mongoose';\r\nimport { typedLogger } from '@/lib/typed-logger.js';\r\nimport { authenticate, requireAdmin } from '@/middleware/auth.js';\r\nimport { audit } from '@/lib/audit-logger';\r\n\r\n// Validation schemas with meaningful error messages\r\nconst CreatePowerUpSchema = z.object({\r\n  name: z.string()\r\n    .min(1, { message: 'Power-up name is required' })\r\n    .max(50, { message: 'Power-up name cannot exceed 50 characters' }),\r\n  description: z.string()\r\n    .min(1, { message: 'Description is required' })\r\n    .max(500, { message: 'Description cannot exceed 500 characters' }),\r\n  type: z.enum(['radar_boost', 'double_points', 'speed_boost', 'shield', 'time_extension'], {\r\n    errorMap: () => ({ message: 'Type must be one of: radar_boost, double_points, speed_boost, shield, time_extension' })\r\n  }),\r\n  icon: z.string().optional(),\r\n  rarity: z.enum(['common', 'rare', 'epic', 'legendary'], {\r\n    errorMap: () => ({ message: 'Rarity must be one of: common, rare, epic, legendary' })\r\n  }).optional(),\r\n  durationMs: z.number()\r\n    .min(1000, { message: 'Duration must be at least 1000ms (1 second)' })\r\n    .max(3600000, { message: 'Duration cannot exceed 3600000ms (1 hour)' }),\r\n  dropRate: z.number()\r\n    .min(0, { message: 'Drop rate must be between 0 and 100' })\r\n    .max(100, { message: 'Drop rate must be between 0 and 100' }),\r\n  maxPerSession: z.number()\r\n    .min(1, { message: 'Max per session must be at least 1' }),\r\n  maxInInventory: z.number()\r\n    .min(1, { message: 'Max in inventory must be at least 1' }),\r\n  effects: z.record(z.any(), { message: 'Effects must be a valid object' }),\r\n  notes: z.string().max(1000, { message: 'Notes cannot exceed 1000 characters' }).optional(),\r\n});\r\n\r\nconst UpdatePowerUpSchema = z.object({\r\n  name: z.string()\r\n    .min(1, { message: 'Power-up name cannot be empty' })\r\n    .max(50, { message: 'Power-up name cannot exceed 50 characters' }).optional(),\r\n  description: z.string()\r\n    .min(1, { message: 'Description cannot be empty' })\r\n    .max(500, { message: 'Description cannot exceed 500 characters' }).optional(),\r\n  icon: z.string().optional(),\r\n  rarity: z.enum(['common', 'rare', 'epic', 'legendary'], {\r\n    errorMap: () => ({ message: 'Rarity must be one of: common, rare, epic, legendary' })\r\n  }).optional(),\r\n  durationMs: z.number()\r\n    .min(1000, { message: 'Duration must be at least 1000ms (1 second)' })\r\n    .max(3600000, { message: 'Duration cannot exceed 3600000ms (1 hour)' }).optional(),\r\n  dropRate: z.number()\r\n    .min(0, { message: 'Drop rate must be between 0 and 100' })\r\n    .max(100, { message: 'Drop rate must be between 0 and 100' }).optional(),\r\n  maxPerSession: z.number()\r\n    .min(1, { message: 'Max per session must be at least 1' }).optional(),\r\n  maxInInventory: z.number()\r\n    .min(1, { message: 'Max in inventory must be at least 1' }).optional(),\r\n  effects: z.record(z.any(), { message: 'Effects must be a valid object' }).optional(),\r\n  enabled: z.boolean().optional(),\r\n  notes: z.string().max(1000, { message: 'Notes cannot exceed 1000 characters' }).optional(),\r\n});\r\n\r\nexport default async function powerUpRoutes(fastify: FastifyInstance) {\r\n  /**\r\n   * GET /\r\n   * Get all power-ups with optional filtering\r\n   */\r\n  fastify.get(\r\n    '/',\r\n    { preHandler: authenticate },\r\n    async (request: FastifyRequest, reply: FastifyReply) => {\r\n      try {\r\n        const { enabled, type, rarity } = request.query as any;\r\n        \r\n        const filters: any = {};\r\n        if (enabled !== undefined) filters.enabled = enabled === 'true';\r\n        if (type) filters.type = type;\r\n        if (rarity) filters.rarity = rarity;\r\n\r\n        const powerUps = await PowerUpAdminService.getAllPowerUps(filters);\r\n\r\n        typedLogger.info('Power-ups list retrieved', {\r\n          count: powerUps.length,\r\n          filters,\r\n          userId: (request.user as any).sub,\r\n        });\r\n\r\n        reply.code(200).send({\r\n          success: true,\r\n          data: powerUps,\r\n          count: powerUps.length,\r\n        });\r\n      } catch (err) {\r\n        typedLogger.error('Error fetching power-ups', {\r\n          error: err instanceof Error ? err.message : String(err),\r\n          userId: (request.user as any).sub,\r\n        });\r\n        reply.code(500).send({\r\n          success: false,\r\n          error: 'Failed to fetch power-ups',\r\n        });\r\n      }\r\n    }\r\n  );\r\n\r\n  /**\r\n   * GET /:id\r\n   * Get single power-up\r\n   */\r\n  fastify.get(\r\n    '/:id',\r\n    { preHandler: authenticate },\r\n    async (request: FastifyRequest<{ Params: { id: string } }>, reply: FastifyReply) => {\r\n      try {\r\n        const powerUp = await PowerUpAdminService.getPowerUpById(request.params.id);\r\n\r\n        reply.code(200).send({\r\n          success: true,\r\n          data: powerUp,\r\n        });\r\n      } catch (error: any) {\r\n        typedLogger.error('Error fetching single power-up', {\r\n          powerUpId: request.params.id,\r\n          error: error.message || String(error),\r\n          userId: (request.user as any).sub,\r\n        });\r\n        reply.code(500).send({\r\n          success: false,\r\n          error: 'Failed to fetch power-up',\r\n        });\r\n      }\r\n    }\r\n  );\r\n\r\n  /**\r\n   * POST /\r\n   * Create new power-up\r\n   */\r\n  fastify.post(\r\n    '/',\r\n    { preHandler: [authenticate, requireAdmin] },\r\n    async (\r\n      request: FastifyRequest<{ Body: CreatePowerUpDto }>,\r\n      reply: FastifyReply\r\n    ) => {\r\n      try {\r\n        // Ensure user is authenticated\r\n        if (!request.user?.sub) {\r\n          return reply.code(401).send({\r\n            success: false,\r\n            error: 'Authentication required',\r\n            code: 'AUTH_REQUIRED',\r\n          });\r\n        }\r\n\r\n        // Validate request body\r\n        const validatedData = CreatePowerUpSchema.parse(request.body);\r\n\r\n        const powerUp = await PowerUpAdminService.createPowerUp(\r\n          new Types.ObjectId(request.user.sub),\r\n          validatedData as CreatePowerUpDto\r\n        );\r\n\r\n        typedLogger.audit('Power-up created via admin API', {\r\n          powerUpId: powerUp._id.toString(),\r\n          name: powerUp.name,\r\n          type: powerUp.type,\r\n          adminId: request.user.sub,\r\n          timestamp: new Date().toISOString(),\r\n        });\r\n\r\n        // Use unified audit logger - writes to both Pino and MongoDB\r\n        await audit.custom({\r\n          userId: request.user.sub,\r\n          userRole: 'admin',\r\n          action: 'CREATE_POWERUP',\r\n          resource: 'powerup',\r\n          resourceId: powerUp._id.toString(),\r\n          category: 'admin',\r\n          severity: 'low',\r\n          metadata: { name: powerUp.name, type: powerUp.type },\r\n        });\r\n\r\n        return reply.code(201).send({\r\n          success: true,\r\n          data: powerUp,\r\n          message: 'Power-up created successfully',\r\n        });\r\n      } catch (error: any) {\r\n        typedLogger.error('Error creating power-up via API', {\r\n          error: error.message || String(error),\r\n          adminId: (request.user as any)?.sub,\r\n          body: request.body,\r\n        });\r\n        \r\n        // Handle Zod validation errors\r\n        if (error.name === 'ZodError') {\r\n          const messages = error.errors?.map((e: any) => e.message).join(', ') || 'Validation failed';\r\n          return reply.code(400).send({\r\n            success: false,\r\n            error: messages,\r\n            code: 'VALIDATION_ERROR',\r\n          });\r\n        }\r\n        \r\n        // Handle other validation errors from service\r\n        if (error.message?.includes('required') || error.message?.includes('must be')) {\r\n          return reply.code(400).send({\r\n            success: false,\r\n            error: error.message,\r\n            code: 'VALIDATION_ERROR',\r\n          });\r\n        }\r\n        \r\n        return reply.code(500).send({\r\n          success: false,\r\n          error: error.message || 'Failed to create power-up',\r\n        });\r\n      }\r\n    }\r\n  );\r\n\r\n  /**\r\n   * PATCH /:id\r\n   * Update power-up\r\n   */\r\n  fastify.patch(\r\n    '/:id',\r\n    { preHandler: [authenticate, requireAdmin] },\r\n    async (\r\n      request: FastifyRequest<{ Params: { id: string }; Body: UpdatePowerUpDto }>,\r\n      reply: FastifyReply\r\n    ) => {\r\n      try {\r\n        if (!request.user?.sub) {\r\n          return reply.code(401).send({\r\n            success: false,\r\n            error: 'Authentication required',\r\n            code: 'AUTH_REQUIRED',\r\n          });\r\n        }\r\n\r\n        const validatedData = UpdatePowerUpSchema.parse(request.body);\r\n\r\n        const powerUp = await PowerUpAdminService.updatePowerUp(\r\n          request.params.id,\r\n          new Types.ObjectId(request.user.sub),\r\n          validatedData as UpdatePowerUpDto\r\n        );\r\n\r\n        typedLogger.audit('Power-up updated via admin API', {\r\n          powerUpId: request.params.id,\r\n          changes: Object.keys(validatedData),\r\n          adminId: request.user.sub,\r\n          timestamp: new Date().toISOString(),\r\n        });\r\n\r\n        // Use unified audit logger - writes to both Pino and MongoDB\r\n        await audit.custom({\r\n          userId: request.user.sub,\r\n          userRole: 'admin',\r\n          action: 'UPDATE_POWERUP',\r\n          resource: 'powerup',\r\n          resourceId: request.params.id,\r\n          category: 'admin',\r\n          severity: 'low',\r\n          metadata: { changes: Object.keys(validatedData) },\r\n        });\r\n\r\n        return reply.code(200).send({\r\n          success: true,\r\n          data: powerUp,\r\n          message: 'Power-up updated successfully',\r\n        });\r\n      } catch (error: any) {\r\n        const statusCode = error.message?.includes('validation') ? 400 : 500;\r\n        return reply.code(statusCode).send({\r\n          success: false,\r\n          error: error.message || 'Failed to update power-up',\r\n        });\r\n      }\r\n    }\r\n  );\r\n\r\n  /**\r\n   * PATCH /:id/drop-rate\r\n   * Update power-up drop rate\r\n   */\r\n  fastify.patch(\r\n    '/:id/drop-rate',\r\n    { preHandler: [authenticate, requireAdmin] },\r\n    async (\r\n      request: FastifyRequest<{ Params: { id: string }; Body: { dropRate: number } }>,\r\n      reply: FastifyReply\r\n    ) => {\r\n      try {\r\n        if (!request.user?.sub) {\r\n          return reply.code(401).send({\r\n            success: false,\r\n            error: 'Authentication required',\r\n            code: 'AUTH_REQUIRED',\r\n          });\r\n        }\r\n\r\n        const { dropRate } = request.body;\r\n\r\n        if (dropRate < 0 || dropRate > 100) {\r\n          return reply.code(400).send({\r\n            success: false,\r\n            error: 'Drop rate must be between 0 and 100',\r\n          });\r\n        }\r\n\r\n        const powerUp = await PowerUpAdminService.updateDropRate(\r\n          request.params.id,\r\n          new Types.ObjectId(request.user.sub),\r\n          dropRate\r\n        );\r\n\r\n        return reply.code(200).send({\r\n          success: true,\r\n          data: powerUp,\r\n          message: 'Drop rate updated successfully',\r\n        });\r\n      } catch (error: any) {\r\n        return reply.code(500).send({\r\n          success: false,\r\n          error: error.message || 'Failed to update drop rate',\r\n        });\r\n      }\r\n    }\r\n  );\r\n\r\n  /**\r\n   * DELETE /:id\r\n   * Delete power-up\r\n   */\r\n  fastify.delete(\r\n    '/:id',\r\n    { preHandler: [authenticate, requireAdmin] },\r\n    async (request: FastifyRequest<{ Params: { id: string } }>, reply: FastifyReply) => {\r\n      try {\r\n        if (!request.user?.sub) {\r\n          return reply.code(401).send({\r\n            success: false,\r\n            error: 'Authentication required',\r\n            code: 'AUTH_REQUIRED',\r\n          });\r\n        }\r\n\r\n        await PowerUpAdminService.deletePowerUp(\r\n          request.params.id,\r\n          new Types.ObjectId(request.user.sub)\r\n        );\r\n\r\n        // Use unified audit logger - writes to both Pino and MongoDB\r\n        await audit.custom({\r\n          userId: request.user.sub,\r\n          userRole: 'admin',\r\n          action: 'DELETE_POWERUP',\r\n          resource: 'powerup',\r\n          resourceId: request.params.id,\r\n          category: 'admin',\r\n          severity: 'medium',\r\n        });\r\n\r\n        return reply.code(200).send({\r\n          success: true,\r\n          message: 'Power-up deleted successfully',\r\n        });\r\n      } catch (error: any) {\r\n        return reply.code(500).send({\r\n          success: false,\r\n          error: error.message || 'Failed to delete power-up',\r\n        });\r\n      }\r\n    }\r\n  );\r\n\r\n  /**\r\n   * GET /:id/analytics\r\n   * Get power-up analytics\r\n   */\r\n  fastify.get(\r\n    '/:id/analytics',\r\n    { preHandler: authenticate },\r\n    async (request: FastifyRequest<{ Params: { id: string } }>, reply: FastifyReply) => {\r\n      try {\r\n        const analytics = await PowerUpAdminService.getPowerUpAnalytics(\r\n          request.params.id\r\n        );\r\n\r\n        reply.code(200).send({\r\n          success: true,\r\n          data: analytics,\r\n        });\r\n      } catch (error: any) {\r\n        reply.code(500).send({\r\n          success: false,\r\n          error: error.message || 'Failed to fetch analytics',\r\n        });\r\n      }\r\n    }\r\n  );\r\n\r\n  /**\r\n   * GET /power-ups/analytics/all\r\n   * Get all power-ups analytics\r\n   */\r\n  fastify.get(\r\n    '/analytics/all',\r\n    { preHandler: authenticate },\r\n    async (request: FastifyRequest, reply: FastifyReply) => {\r\n      try {\r\n        const analytics = await PowerUpAdminService.getAllPowerUpsAnalytics();\r\n\r\n        reply.code(200).send({\r\n          success: true,\r\n          data: analytics,\r\n        });\r\n      } catch (error) {\r\n        reply.code(500).send({\r\n          success: false,\r\n          error: 'Failed to fetch analytics',\r\n        });\r\n      }\r\n    }\r\n  );\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\admin\\routes\\prizes.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\admin\\routes\\rewards.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\admin\\routes\\settings.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":71,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2698,2701],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2698,2701],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":71,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2708,2711],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2708,2711],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":71,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2717,2720],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2717,2720],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":85,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":85,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3155,3158],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3155,3158],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/ban-types","severity":2,"message":"Don't use `{}` as a type. `{}` actually means \"any non-nullish value\".\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.\n- If you want a type meaning \"empty object\", you probably want `Record<string, never>` instead.\n- If you really want a type meaning \"any non-nullish value\", you probably want `NonNullable<unknown>` instead.","line":93,"column":35,"nodeType":"TSTypeLiteral","messageId":"bannedTypeMessage","endLine":93,"endColumn":37,"suggestions":[{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"object"},"fix":{"range":[3403,3405],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"unknown"},"fix":{"range":[3403,3405],"text":"unknown"},"desc":"Replace `{}` with `unknown`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"Record<string, never>"},"fix":{"range":[3403,3405],"text":"Record<string, never>"},"desc":"Replace `{}` with `Record<string, never>`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"NonNullable<unknown>"},"fix":{"range":[3403,3405],"text":"NonNullable<unknown>"},"desc":"Replace `{}` with `NonNullable<unknown>`."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":93,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":93,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3407,3410],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3407,3410],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":97,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":97,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3606,3609],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3606,3609],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":109,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4012,4015],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4012,4015],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/ban-types","severity":2,"message":"Don't use `{}` as a type. `{}` actually means \"any non-nullish value\".\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.\n- If you want a type meaning \"empty object\", you probably want `Record<string, never>` instead.\n- If you really want a type meaning \"any non-nullish value\", you probably want `NonNullable<unknown>` instead.","line":117,"column":35,"nodeType":"TSTypeLiteral","messageId":"bannedTypeMessage","endLine":117,"endColumn":37,"suggestions":[{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"object"},"fix":{"range":[4290,4292],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"unknown"},"fix":{"range":[4290,4292],"text":"unknown"},"desc":"Replace `{}` with `unknown`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"Record<string, never>"},"fix":{"range":[4290,4292],"text":"Record<string, never>"},"desc":"Replace `{}` with `Record<string, never>`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"NonNullable<unknown>"},"fix":{"range":[4290,4292],"text":"NonNullable<unknown>"},"desc":"Replace `{}` with `NonNullable<unknown>`."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":121,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":121,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4539,4542],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4539,4542],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":133,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":133,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4941,4944],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4941,4944],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/ban-types","severity":2,"message":"Don't use `{}` as a type. `{}` actually means \"any non-nullish value\".\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.\n- If you want a type meaning \"empty object\", you probably want `Record<string, never>` instead.\n- If you really want a type meaning \"any non-nullish value\", you probably want `NonNullable<unknown>` instead.","line":141,"column":35,"nodeType":"TSTypeLiteral","messageId":"bannedTypeMessage","endLine":141,"endColumn":37,"suggestions":[{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"object"},"fix":{"range":[5216,5218],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"unknown"},"fix":{"range":[5216,5218],"text":"unknown"},"desc":"Replace `{}` with `unknown`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"Record<string, never>"},"fix":{"range":[5216,5218],"text":"Record<string, never>"},"desc":"Replace `{}` with `Record<string, never>`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"NonNullable<unknown>"},"fix":{"range":[5216,5218],"text":"NonNullable<unknown>"},"desc":"Replace `{}` with `NonNullable<unknown>`."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":145,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":145,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5461,5464],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5461,5464],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":157,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":157,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5846,5849],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5846,5849],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/ban-types","severity":2,"message":"Don't use `{}` as a type. `{}` actually means \"any non-nullish value\".\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.\n- If you want a type meaning \"empty object\", you probably want `Record<string, never>` instead.\n- If you really want a type meaning \"any non-nullish value\", you probably want `NonNullable<unknown>` instead.","line":165,"column":35,"nodeType":"TSTypeLiteral","messageId":"bannedTypeMessage","endLine":165,"endColumn":37,"suggestions":[{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"object"},"fix":{"range":[6110,6112],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"unknown"},"fix":{"range":[6110,6112],"text":"unknown"},"desc":"Replace `{}` with `unknown`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"Record<string, never>"},"fix":{"range":[6110,6112],"text":"Record<string, never>"},"desc":"Replace `{}` with `Record<string, never>`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"NonNullable<unknown>"},"fix":{"range":[6110,6112],"text":"NonNullable<unknown>"},"desc":"Replace `{}` with `NonNullable<unknown>`."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":169,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":169,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6345,6348],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6345,6348],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":181,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":181,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6739,6742],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6739,6742],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/ban-types","severity":2,"message":"Don't use `{}` as a type. `{}` actually means \"any non-nullish value\".\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.\n- If you want a type meaning \"empty object\", you probably want `Record<string, never>` instead.\n- If you really want a type meaning \"any non-nullish value\", you probably want `NonNullable<unknown>` instead.","line":189,"column":35,"nodeType":"TSTypeLiteral","messageId":"bannedTypeMessage","endLine":189,"endColumn":37,"suggestions":[{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"object"},"fix":{"range":[7009,7011],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"unknown"},"fix":{"range":[7009,7011],"text":"unknown"},"desc":"Replace `{}` with `unknown`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"Record<string, never>"},"fix":{"range":[7009,7011],"text":"Record<string, never>"},"desc":"Replace `{}` with `Record<string, never>`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"NonNullable<unknown>"},"fix":{"range":[7009,7011],"text":"NonNullable<unknown>"},"desc":"Replace `{}` with `NonNullable<unknown>`."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":193,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":193,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7250,7253],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7250,7253],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/ban-types","severity":2,"message":"Don't use `{}` as a type. `{}` actually means \"any non-nullish value\".\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.\n- If you want a type meaning \"empty object\", you probably want `Record<string, never>` instead.\n- If you really want a type meaning \"any non-nullish value\", you probably want `NonNullable<unknown>` instead.","line":201,"column":35,"nodeType":"TSTypeLiteral","messageId":"bannedTypeMessage","endLine":201,"endColumn":37,"suggestions":[{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"object"},"fix":{"range":[7481,7483],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"unknown"},"fix":{"range":[7481,7483],"text":"unknown"},"desc":"Replace `{}` with `unknown`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"Record<string, never>"},"fix":{"range":[7481,7483],"text":"Record<string, never>"},"desc":"Replace `{}` with `Record<string, never>`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"NonNullable<unknown>"},"fix":{"range":[7481,7483],"text":"NonNullable<unknown>"},"desc":"Replace `{}` with `NonNullable<unknown>`."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":205,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":205,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7708,7711],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7708,7711],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":216,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":216,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8079,8082],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8079,8082],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":230,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":230,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8545,8548],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8545,8548],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":249,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":249,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9181,9184],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9181,9184],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/ban-types","severity":2,"message":"Don't use `{}` as a type. `{}` actually means \"any non-nullish value\".\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.\n- If you want a type meaning \"empty object\", you probably want `Record<string, never>` instead.\n- If you really want a type meaning \"any non-nullish value\", you probably want `NonNullable<unknown>` instead.","line":257,"column":35,"nodeType":"TSTypeLiteral","messageId":"bannedTypeMessage","endLine":257,"endColumn":37,"suggestions":[{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"object"},"fix":{"range":[9426,9428],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"unknown"},"fix":{"range":[9426,9428],"text":"unknown"},"desc":"Replace `{}` with `unknown`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"Record<string, never>"},"fix":{"range":[9426,9428],"text":"Record<string, never>"},"desc":"Replace `{}` with `Record<string, never>`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"NonNullable<unknown>"},"fix":{"range":[9426,9428],"text":"NonNullable<unknown>"},"desc":"Replace `{}` with `NonNullable<unknown>`."}]},{"ruleId":"@typescript-eslint/ban-types","severity":2,"message":"Don't use `{}` as a type. `{}` actually means \"any non-nullish value\".\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.\n- If you want a type meaning \"empty object\", you probably want `Record<string, never>` instead.\n- If you really want a type meaning \"any non-nullish value\", you probably want `NonNullable<unknown>` instead.","line":257,"column":39,"nodeType":"TSTypeLiteral","messageId":"bannedTypeMessage","endLine":257,"endColumn":41,"suggestions":[{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"object"},"fix":{"range":[9430,9432],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"unknown"},"fix":{"range":[9430,9432],"text":"unknown"},"desc":"Replace `{}` with `unknown`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"Record<string, never>"},"fix":{"range":[9430,9432],"text":"Record<string, never>"},"desc":"Replace `{}` with `Record<string, never>`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"NonNullable<unknown>"},"fix":{"range":[9430,9432],"text":"NonNullable<unknown>"},"desc":"Replace `{}` with `NonNullable<unknown>`."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":262,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":262,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9745,9748],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9745,9748],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":274,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":274,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10145,10148],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10145,10148],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/ban-types","severity":2,"message":"Don't use `{}` as a type. `{}` actually means \"any non-nullish value\".\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.\n- If you want a type meaning \"empty object\", you probably want `Record<string, never>` instead.\n- If you really want a type meaning \"any non-nullish value\", you probably want `NonNullable<unknown>` instead.","line":282,"column":35,"nodeType":"TSTypeLiteral","messageId":"bannedTypeMessage","endLine":282,"endColumn":37,"suggestions":[{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"object"},"fix":{"range":[10413,10415],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"unknown"},"fix":{"range":[10413,10415],"text":"unknown"},"desc":"Replace `{}` with `unknown`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"Record<string, never>"},"fix":{"range":[10413,10415],"text":"Record<string, never>"},"desc":"Replace `{}` with `Record<string, never>`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"NonNullable<unknown>"},"fix":{"range":[10413,10415],"text":"NonNullable<unknown>"},"desc":"Replace `{}` with `NonNullable<unknown>`."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":282,"column":82,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":282,"endColumn":85,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10460,10463],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10460,10463],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":289,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":289,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10693,10696],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10693,10696],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":301,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":301,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11164,11167],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11164,11167],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":309,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":309,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11436,11439],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11436,11439],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":317,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":317,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11688,11691],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11688,11691],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":329,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":329,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12146,12149],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12146,12149],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":35,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyInstance, FastifyRequest } from 'fastify';\nimport { authenticate, requireAdmin } from '@/middleware/auth';\nimport { adminRateLimit } from '@/middleware/distributed-rate-limit';\nimport { AdminSettingsService } from '../services/admin-settings.service';\nimport { configService } from '@/services/config';\nimport { audit } from '@/lib/audit-logger';\nimport { z } from 'zod';\n\nconst ProgressionSettingsSchema = z.object({\n  levels: z.array(z.object({\n    name: z.string({ required_error: 'Level name is required' }),\n    threshold: z.number().min(0, { message: 'Threshold must be 0 or greater' }),\n  })).min(1, { message: 'At least one level is required' }),\n});\n\nconst AntiCheatSettingsSchema = z.object({\n  captureFrequencyPerMinute: z.number()\n    .min(1, { message: 'Capture frequency must be at least 1 per minute' })\n    .default(10),\n  maxSpeedMps: z.number()\n    .min(1, { message: 'Max speed must be at least 1 m/s' })\n    .default(50),\n  validationScoreFloor: z.number()\n    .min(0, { message: 'Validation score floor must be between 0 and 1' })\n    .max(1, { message: 'Validation score floor must be between 0 and 1' })\n    .default(0.3),\n  gpsAccuracyThreshold: z.number()\n    .min(1, { message: 'GPS accuracy threshold must be at least 1 meter' })\n    .default(50),\n  penalties: z.object({\n    deviceChange: z.number().min(0).max(1).default(0.1),\n    trackingNotTracking: z.number().min(0).max(1).default(0.2),\n    lowLight: z.number().min(0).max(1).default(0.1),\n    lowAccuracy: z.number().min(0).max(1).default(0.1),\n  }).default({}),\n});\n\nconst GameSettingsSchema = z.object({\n  claimRadiusMeters: z.number()\n    .min(1, { message: 'Claim radius must be at least 1 meter' })\n    .default(50),\n  maxDailyClaims: z.number()\n    .min(1, { message: 'Max daily claims must be at least 1' })\n    .default(50),\n  speedLimitKmh: z.number()\n    .min(1, { message: 'Speed limit must be at least 1 km/h' })\n    .default(120),\n  cooldownSeconds: z.number()\n    .min(0, { message: 'Cooldown cannot be negative' })\n    .default(60),\n  levelUpMultiplier: z.number()\n    .min(0.1, { message: 'Level up multiplier must be at least 0.1' })\n    .default(1.5),\n});\n\nconst OfflineSettingsSchema = z.object({\n  maxQueueAgeMinutes: z.number()\n    .min(1, { message: 'Max queue age must be at least 1 minute' })\n    .default(1440),\n  maxBatchSize: z.number()\n    .min(1, { message: 'Max batch size must be at least 1' })\n    .default(100),\n  retryLimit: z.number()\n    .min(0, { message: 'Retry limit cannot be negative' })\n    .default(5),\n  retryBackoffMs: z.number()\n    .min(0, { message: 'Retry backoff cannot be negative' })\n    .default(2000),\n});\n\ntype AdminRequest<P = Record<string, any>, B = any, Q = any> = FastifyRequest<{\n  Params: P;\n  Body: B;\n  Querystring: Q;\n}>;\n\nexport default async function settingsRoutes(fastify: FastifyInstance) {\n  // Get all settings\n  fastify.get('/settings', {\n    preHandler: [authenticate, requireAdmin, adminRateLimit],\n  }, async (request, reply) => {\n    try {\n      const settings = await AdminSettingsService.getSettings();\n      reply.send({ success: true, data: settings });\n    } catch (error: any) {\n      reply.code(500).send({ success: false, error: error.message });\n    }\n  });\n\n  // Update settings (partial)\n  fastify.patch('/settings', {\n    preHandler: [authenticate, requireAdmin, adminRateLimit],\n  }, async (request: AdminRequest<{}, any>, reply) => {\n    try {\n      const settings = await AdminSettingsService.updateSettings(request.user.sub, request.body);\n      reply.send({ success: true, data: settings });\n    } catch (error: any) {\n      reply.code(500).send({ success: false, error: error.message });\n    }\n  });\n\n  // Progression settings\n  fastify.get('/settings/progression', {\n    preHandler: [authenticate, requireAdmin, adminRateLimit],\n  }, async (request, reply) => {\n    try {\n      const data = await AdminSettingsService.getSettingsSection('progression');\n      reply.send({ success: true, data });\n    } catch (error: any) {\n      reply.code(500).send({ success: false, error: error.message });\n    }\n  });\n\n  fastify.patch('/settings/progression', {\n    preHandler: [authenticate, requireAdmin, adminRateLimit],\n    schema: { body: ProgressionSettingsSchema },\n  }, async (request: AdminRequest<{}, z.infer<typeof ProgressionSettingsSchema>>, reply) => {\n    try {\n      const data = await AdminSettingsService.updateSettingsSection(request.user.sub, 'progression', request.body);\n      reply.send({ success: true, data });\n    } catch (error: any) {\n      reply.code(500).send({ success: false, error: error.message });\n    }\n  });\n\n  // Anti-cheat settings\n  fastify.get('/settings/anti-cheat', {\n    preHandler: [authenticate, requireAdmin, adminRateLimit],\n  }, async (request, reply) => {\n    try {\n      const data = await AdminSettingsService.getSettingsSection('antiCheat');\n      reply.send({ success: true, data });\n    } catch (error: any) {\n      reply.code(500).send({ success: false, error: error.message });\n    }\n  });\n\n  fastify.patch('/settings/anti-cheat', {\n    preHandler: [authenticate, requireAdmin, adminRateLimit],\n    schema: { body: AntiCheatSettingsSchema },\n  }, async (request: AdminRequest<{}, z.infer<typeof AntiCheatSettingsSchema>>, reply) => {\n    try {\n      const data = await AdminSettingsService.updateSettingsSection(request.user.sub, 'antiCheat', request.body);\n      reply.send({ success: true, data });\n    } catch (error: any) {\n      reply.code(500).send({ success: false, error: error.message });\n    }\n  });\n\n  // Game settings\n  fastify.get('/settings/game', {\n    preHandler: [authenticate, requireAdmin, adminRateLimit],\n  }, async (request, reply) => {\n    try {\n      const data = await AdminSettingsService.getSettingsSection('game');\n      reply.send({ success: true, data });\n    } catch (error: any) {\n      reply.code(500).send({ success: false, error: error.message });\n    }\n  });\n\n  fastify.patch('/settings/game', {\n    preHandler: [authenticate, requireAdmin, adminRateLimit],\n    schema: { body: GameSettingsSchema },\n  }, async (request: AdminRequest<{}, z.infer<typeof GameSettingsSchema>>, reply) => {\n    try {\n      const data = await AdminSettingsService.updateSettingsSection(request.user.sub, 'game', request.body);\n      reply.send({ success: true, data });\n    } catch (error: any) {\n      reply.code(500).send({ success: false, error: error.message });\n    }\n  });\n\n  // Offline settings\n  fastify.get('/settings/offline', {\n    preHandler: [authenticate, requireAdmin, adminRateLimit],\n  }, async (request, reply) => {\n    try {\n      const data = await AdminSettingsService.getSettingsSection('offline');\n      reply.send({ success: true, data });\n    } catch (error: any) {\n      reply.code(500).send({ success: false, error: error.message });\n    }\n  });\n\n  fastify.patch('/settings/offline', {\n    preHandler: [authenticate, requireAdmin, adminRateLimit],\n    schema: { body: OfflineSettingsSchema },\n  }, async (request: AdminRequest<{}, z.infer<typeof OfflineSettingsSchema>>, reply) => {\n    try {\n      const data = await AdminSettingsService.updateSettingsSection(request.user.sub, 'offline', request.body);\n      reply.send({ success: true, data });\n    } catch (error: any) {\n      reply.code(500).send({ success: false, error: error.message });\n    }\n  });\n\n  // Maintenance mode\n  fastify.post('/maintenance/start', {\n    preHandler: [authenticate, requireAdmin],\n  }, async (request: AdminRequest<{}, { message?: string }>, reply) => {\n    try {\n      const result = await AdminSettingsService.startMaintenance(request.user.sub, request.body?.message);\n      reply.send({ success: true, data: result });\n    } catch (error: any) {\n      reply.code(500).send({ success: false, error: error.message });\n    }\n  });\n\n  fastify.post('/maintenance/stop', {\n    preHandler: [authenticate, requireAdmin],\n  }, async (request, reply) => {\n    try {\n      const result = await AdminSettingsService.stopMaintenance(request.user.sub);\n      reply.send({ success: true, data: result });\n    } catch (error: any) {\n      reply.code(500).send({ success: false, error: error.message });\n    }\n  });\n\n  // ===== NEW REAL-TIME CONFIG ENDPOINTS =====\n\n  // Get config version (for checking if config has changed)\n  fastify.get('/config/version', {\n    preHandler: [authenticate, requireAdmin, adminRateLimit],\n  }, async (request, reply) => {\n    try {\n      const version = configService.getVersion();\n      reply.send({ success: true, data: { version } });\n    } catch (error: any) {\n      reply.code(500).send({ success: false, error: error.message });\n    }\n  });\n\n  // Force reload config from database\n  fastify.post('/config/reload', {\n    preHandler: [authenticate, requireAdmin],\n  }, async (request: AdminRequest, reply) => {\n    try {\n      const adminId = request.user?.sub || 'system';\n      await configService.reload();\n      \n      // Audit log for config reload\n      await audit.custom(adminId, 'RELOAD_CONFIG', 'settings', undefined, {\n        timestamp: new Date().toISOString(),\n      });\n      \n      reply.send({ success: true, message: 'Config reloaded successfully' });\n    } catch (error: any) {\n      reply.code(500).send({ success: false, error: error.message });\n    }\n  });\n\n  // Get config history\n  fastify.get('/config/history', {\n    preHandler: [authenticate, requireAdmin, adminRateLimit],\n  }, async (request: AdminRequest<{}, {}, { section?: string; limit?: string }>, reply) => {\n    try {\n      const limit = request.query.limit ? parseInt(request.query.limit as string) : 50;\n      const history = await configService.getConfigHistory(request.query.section, limit);\n      reply.send({ success: true, data: history });\n    } catch (error: any) {\n      reply.code(500).send({ success: false, error: error.message });\n    }\n  });\n\n  // Get current active config (all sections)\n  fastify.get('/config/active', {\n    preHandler: [authenticate, requireAdmin, adminRateLimit],\n  }, async (request, reply) => {\n    try {\n      const config = await configService.getConfig();\n      reply.send({ success: true, data: config });\n    } catch (error: any) {\n      reply.code(500).send({ success: false, error: error.message });\n    }\n  });\n\n  // Validate config changes before applying\n  fastify.post('/config/validate', {\n    preHandler: [authenticate, requireAdmin, adminRateLimit],\n  }, async (request: AdminRequest<{}, { section: string; changes: Record<string, any> }>, reply) => {\n    try {\n      const result = await configService.validateConfigUpdate(\n        request.body.section,\n        request.body.changes\n      );\n      reply.send({ success: true, data: result });\n    } catch (error: any) {\n      reply.code(500).send({ success: false, error: error.message });\n    }\n  });\n\n  // Get specific config value (dot notation support)\n  fastify.get('/config/value/:path', {\n    preHandler: [authenticate, requireAdmin, adminRateLimit],\n  }, async (request: AdminRequest<{ path: string }>, reply) => {\n    try {\n      const value = await configService.getConfigValue(request.params.path);\n      reply.send({ success: true, data: { value } });\n    } catch (error: any) {\n      reply.code(500).send({ success: false, error: error.message });\n    }\n  });\n\n  // Update specific config value\n  fastify.patch('/config/value/:path', {\n    preHandler: [authenticate, requireAdmin],\n  }, async (request: AdminRequest<{ path: string }, { value: any }>, reply) => {\n    try {\n      const result = await configService.updateConfigValue(\n        request.params.path,\n        request.body.value,\n        request.user.sub\n      );\n      reply.send({ success: true, data: result });\n    } catch (error: any) {\n      reply.code(500).send({ success: false, error: error.message });\n    }\n  });\n\n  // Check if feature is enabled\n  fastify.get('/config/feature/:name', {\n    preHandler: [authenticate, requireAdmin, adminRateLimit],\n  }, async (request: AdminRequest<{ name: string }>, reply) => {\n    try {\n      const enabled = await configService.isFeatureEnabled(request.params.name);\n      reply.send({ success: true, data: { enabled } });\n    } catch (error: any) {\n      reply.code(500).send({ success: false, error: error.message });\n    }\n  });\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\admin\\routes\\system.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":28,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1256,1259],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1256,1259],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":29,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1313,1316],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1313,1316],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":42,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1744,1747],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1744,1747],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":42,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1774,1777],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1774,1777],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":61,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2297,2300],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2297,2300],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":61,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2327,2330],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2327,2330],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":61,"column":92,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":95,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2356,2359],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2356,2359],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":82,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":82,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2977,2980],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2977,2980],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":82,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":82,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3007,3010],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3007,3010],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":82,"column":92,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":82,"endColumn":95,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3036,3039],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3036,3039],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":103,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":103,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3649,3652],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3649,3652],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":103,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":103,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3679,3682],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3679,3682],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":103,"column":92,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":103,"endColumn":95,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3708,3711],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3708,3711],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":124,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":124,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4311,4314],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4311,4314],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":125,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":125,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4368,4371],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4368,4371],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":132,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":132,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4594,4597],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4594,4597],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":132,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":132,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4624,4627],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4624,4627],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":132,"column":92,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":132,"endColumn":95,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4653,4656],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4653,4656],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":18,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyInstance, FastifyRequest } from 'fastify';\nimport { authenticate, requireAdmin } from '@/middleware/auth';\nimport { adminRateLimit } from '@/middleware/distributed-rate-limit';\nimport { AdminSystemService } from '../services/admin-system.service';\nimport { audit } from '@/lib/audit-logger';\nimport { Metadata, MetadataValue } from '@/types';\n\nexport default async function systemRoutes(fastify: FastifyInstance) {\n  fastify.addHook('preHandler', authenticate);\n  fastify.addHook('preHandler', requireAdmin);\n  fastify.addHook('preHandler', adminRateLimit);\n\n  // GET /system/health - get health status\n  fastify.get('/system/health', async (request: FastifyRequest, reply) => {\n    const health = await AdminSystemService.getHealthStatus();\n    return reply.send(health);\n  });\n\n  // GET /system/metrics - get system metrics\n  fastify.get('/system/metrics', async (request: FastifyRequest, reply) => {\n    const metrics = await AdminSystemService.getSystemMetrics();\n    return reply.send(metrics);\n  });\n\n  // GET /system/logs - get system logs (alias to audit logs)\n  fastify.get('/system/logs', async (request: FastifyRequest, reply) => {\n    const logs = await AdminSystemService.getSystemLogs({\n      page: parseInt((request.query as any).page) || 1,\n      limit: parseInt((request.query as any).limit) || 50\n    });\n    return reply.send(logs);\n  });\n\n  // GET /system/stats - aggregate system statistics\n  fastify.get('/system/stats', async (_request, reply) => {\n    const stats = await AdminSystemService.getSystemStats();\n    return reply.send(stats);\n  });\n\n  // POST /system/cache/clear - clear cache\n  fastify.post('/system/cache/clear', async (request: FastifyRequest, reply) => {\n    const adminId = (request as any).user?.sub || (request as any).user?.id;\n    const result = await AdminSystemService.clearCache();\n    \n    // Audit log\n    await audit.custom({\n      userId: adminId,\n      userRole: 'admin',\n      action: 'CLEAR_CACHE',\n      resource: 'system',\n      category: 'admin',\n      severity: 'medium',\n      description: 'Cleared system cache',\n    });\n    \n    return reply.send(result);\n  });\n\n  // POST /system/backup - create backup stub\n  fastify.post('/system/backup', async (request: FastifyRequest, reply) => {\n    const adminId = (request as any).user?.sub || (request as any).user?.id || (request as any).userId;\n    const result = await AdminSystemService.createBackup(adminId);\n    \n    // Audit log\n    await audit.custom({\n      userId: adminId,\n      userRole: 'admin',\n      action: 'CREATE_BACKUP',\n      resource: 'system',\n      category: 'admin',\n      severity: 'high',\n      description: 'Created system backup',\n      metadata: result,\n    });\n    \n    return reply.send(result);\n  });\n\n  // POST /system/restore - restore backup stub\n  fastify.post('/system/restore', async (request: FastifyRequest, reply) => {\n    const { backupId } = request.body as { backupId: string };\n    const adminId = (request as any).user?.sub || (request as any).user?.id || (request as any).userId;\n    const result = await AdminSystemService.restoreBackup(adminId, backupId);\n    \n    // Audit log\n    await audit.custom({\n      userId: adminId,\n      userRole: 'admin',\n      action: 'RESTORE_BACKUP',\n      resource: 'system',\n      resourceId: backupId,\n      category: 'admin',\n      severity: 'high',\n      description: `Restored backup: ${backupId}`,\n      metadata: { backupId },\n    });\n    \n    return reply.send(result);\n  });\n\n  // POST /backup/create - alias for create backup\n  fastify.post('/backup/create', async (request: FastifyRequest, reply) => {\n    const adminId = (request as any).user?.sub || (request as any).user?.id || (request as any).userId;\n    const result = await AdminSystemService.createBackup(adminId);\n    \n    // Audit log\n    await audit.custom({\n      userId: adminId,\n      userRole: 'admin',\n      action: 'CREATE_BACKUP',\n      resource: 'system',\n      category: 'admin',\n      severity: 'high',\n      description: 'Created system backup',\n      metadata: result,\n    });\n    \n    return reply.send(result);\n  });\n\n  // GET /logs - alias for system logs\n  fastify.get('/logs', async (request: FastifyRequest, reply) => {\n    const logs = await AdminSystemService.getSystemLogs({\n      page: parseInt((request.query as any).page) || 1,\n      limit: parseInt((request.query as any).limit) || 50\n    });\n    return reply.send(logs);\n  });\n\n  // POST /bulk-operations - admin bulk actions stub\n  fastify.post('/bulk-operations', async (request: FastifyRequest, reply) => {\n    const adminId = (request as any).user?.sub || (request as any).user?.id || (request as any).userId;\n    const { operation, data } = (request.body || {}) as { operation?: string; data?: unknown };\n\n    if (!operation) {\n      return reply.status(400).send({ success: false, error: 'Operation is required' });\n    }\n\n    const metadata: Metadata = { operation };\n    if (data !== undefined) {\n      metadata.data = data as MetadataValue;\n    }\n\n    await audit.custom({\n      userId: adminId,\n      userRole: 'admin',\n      action: 'BULK_OPERATION',\n      resource: 'system',\n      category: 'admin',\n      severity: 'medium',\n      description: `Bulk operation: ${operation}`,\n      metadata,\n    });\n\n    return reply.send({\n      success: true,\n      data: {\n        operation,\n        processed: Array.isArray(data) ? data.length : 0,\n      },\n    });\n  });\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\admin\\routes\\users.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":65,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":65,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2601,2604],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2601,2604],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":65,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":65,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2630,2633],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2630,2633],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":75,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":75,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3063,3066],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3063,3066],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":76,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":76,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3100,3103],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3100,3103],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":76,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":76,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3129,3132],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3129,3132],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":85,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":85,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3582,3585],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3582,3585],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":85,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":85,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3611,3614],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3611,3614],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":96,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":96,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4124,4127],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4124,4127],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":96,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":96,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4153,4156],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4153,4156],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":106,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":106,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4589,4592],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4589,4592],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":106,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":106,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4618,4621],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4618,4621],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":141,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":141,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6088,6091],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6088,6091],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":179,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":179,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7332,7335],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7332,7335],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyInstance, FastifyRequest } from 'fastify';\nimport { authenticate, requireAdmin } from '@/middleware/auth';\nimport { adminRateLimit } from '@/middleware/distributed-rate-limit';\nimport { AdminUsersService } from '../services/admin-users.service';\nimport { AuditLog } from '@/models/AuditLog';\nimport { PointsHistoryService } from '@/services/points-history';\nimport { z } from 'zod';\n\nconst UserManagementSchema = z.object({\n  page: z.coerce.number().int().positive().default(1),\n  limit: z.coerce.number().int().min(1).max(100).default(20),\n  search: z.string().optional(),\n  status: z.enum(['active', 'banned', 'suspended', 'inactive', 'all']).default('all'),\n  level: z.coerce.number().int().positive().optional(),\n});\n\nconst BanUserSchema = z.object({\n  reason: z.string().min(1).max(500),\n  duration: z.number().int().positive().optional(),\n  notifyUser: z.boolean().optional().default(true),\n});\n\nconst UpdateUserSchema = z.object({\n  displayName: z.string().min(1).max(50).optional(),\n  email: z.string().email().optional(),\n  level: z.enum(['bronze', 'silver', 'gold', 'platinum', 'diamond']).optional(),\n  status: z.enum(['active', 'suspended']).optional(),\n});\n\nconst AdjustPointsSchema = z.object({\n  amount: z.number().int(),\n  reason: z.string().min(1).max(500),\n});\n\nconst PointsHistorySchema = z.object({\n  page: z.coerce.number().int().min(1).default(1),\n  limit: z.coerce.number().int().min(1).max(100).default(50),\n  includeZero: z.coerce.boolean().optional(),\n  filter: z.enum(['all', 'credit', 'debit', 'achievement', 'claim']).optional(),\n});\n\nexport default async function usersRoutes(fastify: FastifyInstance) {\n  fastify.addHook('preHandler', authenticate);\n  fastify.addHook('preHandler', requireAdmin);\n  fastify.addHook('preHandler', adminRateLimit);\n\n  fastify.get('/users', async (request: FastifyRequest, reply) => {\n    const query = UserManagementSchema.parse(request.query);\n    const result = await AdminUsersService.getUsers(query);\n    return reply.send(result);\n  });\n\n  fastify.get('/users/:userId', async (request: FastifyRequest<{ Params: { userId: string } }>, reply) => {\n    const { userId } = request.params;\n    const user = await AdminUsersService.getUserProfile(userId);\n    if (!user) {\n      return reply.status(404).send({ error: 'User not found' });\n    }\n    return reply.send({ user });\n  });\n\n  fastify.patch('/users/:userId', async (request: FastifyRequest<{ Params: { userId: string } }>, reply) => {\n    const { userId } = request.params;\n    const updates = UpdateUserSchema.parse(request.body);\n    const adminId = (request as any).user?.id || (request as any).userId;\n    const user = await AdminUsersService.updateUserProfile(userId, updates, adminId);\n    if (!user) {\n      return reply.status(404).send({ error: 'User not found' });\n    }\n    return reply.send(user);\n  });\n\n  fastify.post('/users/:userId/ban', async (request: FastifyRequest<{ Params: { userId: string } }>, reply) => {\n    const { userId } = request.params;\n    const banData = BanUserSchema.parse(request.body) as any;\n    const adminId = (request as any).user?.id || (request as any).userId;\n    const result = await AdminUsersService.banUser(userId, banData, adminId);\n    if (!result) {\n      return reply.status(404).send({ error: 'User not found' });\n    }\n    return reply.send({ success: true, message: 'User banned successfully' });\n  });\n  fastify.post('/users/:userId/unban', async (request: FastifyRequest<{ Params: { userId: string } }>, reply) => {\n    const { userId } = request.params;\n    const adminId = (request as any).user?.id || (request as any).userId;\n    const result = await AdminUsersService.unbanUser(userId, adminId);\n    if (!result) {\n      return reply.status(404).send({ error: 'User not found' });\n    }\n    return reply.send({ success: true, message: 'User unbanned successfully' });\n  });\n\n  fastify.post('/users/:userId/points', async (request: FastifyRequest<{ Params: { userId: string } }>, reply) => {\n    const { userId } = request.params;\n    const pointsData = AdjustPointsSchema.parse(request.body);\n    const adminId = (request as any).user?.id || (request as any).userId;\n    const result = await AdminUsersService.adjustPoints(userId, pointsData.amount, pointsData.reason, adminId);\n    if (!result) {\n      return reply.status(404).send({ error: 'User not found' });\n    }\n    return reply.send(result);\n  });\n\n  fastify.delete('/users/:userId', async (request: FastifyRequest<{ Params: { userId: string } }>, reply) => {\n    const { userId } = request.params;\n    const adminId = (request as any).user?.id || (request as any).userId;\n    const result = await AdminUsersService.deleteUser(userId, adminId);\n    if (!result) {\n      return reply.status(404).send({ error: 'User not found' });\n    }\n    return reply.status(204).send();\n  });\n\n  fastify.get('/users/:userId/points/history', async (request: FastifyRequest<{\n    Params: { userId: string };\n    Querystring: { page?: string; limit?: string; includeZero?: string; filter?: string };\n  }>, reply) => {\n    const { userId } = request.params;\n    const query = PointsHistorySchema.parse(request.query || {});\n    const result = await PointsHistoryService.getUserHistory(userId, query);\n    return reply.send({\n      success: true,\n      data: result,\n    });\n  });\n\n  // GET /users/:userId/activity - Get activity logs for a specific user\n  // Returns all audit entries where this user is either the actor (performed action) or the target (action performed on them)\n  fastify.get('/users/:userId/activity', async (request: FastifyRequest<{\n    Params: { userId: string };\n    Querystring: { page?: string; limit?: string; type?: 'actor' | 'target' | 'all' };\n  }>, reply) => {\n    const { userId } = request.params;\n    const { page = '1', limit = '50', type = 'all' } = request.query;\n    const pageNum = Math.max(1, parseInt(page, 10) || 1);\n    const limitNum = Math.min(100, Math.max(1, parseInt(limit, 10) || 50));\n    const skip = (pageNum - 1) * limitNum;\n\n    try {\n      // Build query based on type filter\n      let query: any;\n      if (type === 'actor') {\n        // Only logs where user performed the action\n        query = { userId };\n      } else if (type === 'target') {\n        // Only logs where user was affected by an action\n        query = {\n          $or: [\n            { resourceId: userId },\n            { resource: 'user', resourceId: userId },\n            { 'metadata.userId': userId },\n            { 'metadata.targetUserId': userId },\n          ],\n        };\n      } else {\n        // Both actor and target logs\n        query = {\n          $or: [\n            { userId },\n            { resourceId: userId },\n            { resource: 'user', resourceId: userId },\n            { 'metadata.userId': userId },\n            { 'metadata.targetUserId': userId },\n          ],\n        };\n      }\n\n      const [logs, total] = await Promise.all([\n        AuditLog.find(query)\n          .select('userId userRole action resource resourceId description category severity metadata success timestamp createdAt')\n          .sort({ timestamp: -1 })\n          .skip(skip)\n          .limit(limitNum)\n          .lean(),\n        AuditLog.countDocuments(query),\n      ]);\n\n      // Enhance logs with role indicator (actor vs target)\n      const enhancedLogs = logs.map((log: any) => ({\n        ...log,\n        role: log.userId === userId ? 'actor' : 'target',\n        displayAction: formatAction(log.action),\n        displayResource: formatResource(log.resource),\n      }));\n\n      return reply.send({\n        success: true,\n        data: enhancedLogs,\n        pagination: {\n          page: pageNum,\n          limit: limitNum,\n          total,\n          pages: Math.ceil(total / limitNum),\n          hasMore: skip + logs.length < total,\n        },\n      });\n    } catch (error) {\n      return reply.status(500).send({ error: 'Failed to fetch user activity logs' });\n    }\n  });\n}\n\n// Helper function to format action for display\nfunction formatAction(action: string): string {\n  return action\n    .replace(/_/g, ' ')\n    .toLowerCase()\n    .replace(/\\b\\w/g, (c) => c.toUpperCase());\n}\n\n// Helper function to format resource for display\nfunction formatResource(resource: string): string {\n  return resource\n    .replace(/_/g, ' ')\n    .toLowerCase()\n    .replace(/\\b\\w/g, (c) => c.toUpperCase());\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\admin\\services\\admin-ab-testing.service.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":40,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1391,1394],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1391,1394],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":231,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":231,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7375,7378],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7375,7378],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":231,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":231,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7390,7393],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7390,7393],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ABTest, IABTest } from '@/models/ABTest';\r\nimport { typedLogger } from '@/lib/typed-logger';\r\n\r\nexport class ABTestingService {\r\n  static async createTest(testData: Partial<IABTest>, userId: string) {\r\n    try {\r\n      // Validate traffic allocation sums to 100\r\n      const totalTraffic = testData.variants?.reduce((sum, v) => sum + (v.trafficAllocation || 0), 0) || 0;\r\n      if (testData.variants && totalTraffic !== 100) {\r\n        throw new Error(`Traffic allocation must sum to 100%, got ${totalTraffic}%`);\r\n      }\r\n\r\n      // Ensure variants have default values for conversions and impressions\r\n      const variants = (testData.variants || []).map(v => ({\r\n        name: v.name || 'variant',\r\n        trafficAllocation: v.trafficAllocation || 0,\r\n        config: v.config || {},\r\n        conversions: v.conversions || 0,\r\n        impressions: v.impressions || 0\r\n      }));\r\n\r\n      const test = new ABTest({\r\n        ...testData,\r\n        variants,\r\n        createdBy: userId,\r\n        status: 'draft'\r\n      });\r\n\r\n      await test.save();\r\n      typedLogger.info('A/B test created', { testId: test._id, name: test.name });\r\n      return test;\r\n    } catch (error) {\r\n      typedLogger.error('Failed to create A/B test', { error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  static async getTests(filters?: { status?: string; type?: string }) {\r\n    try {\r\n      const query: any = {};\r\n      if (filters?.status) query.status = filters.status;\r\n      if (filters?.type) query.type = filters.type;\r\n\r\n      const tests = await ABTest.find(query).sort({ startDate: -1 }).populate('createdBy', 'username email');\r\n      return tests;\r\n    } catch (error) {\r\n      typedLogger.error('Failed to fetch A/B tests', { error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  static async getTestById(testId: string) {\r\n    try {\r\n      const test = await ABTest.findById(testId).populate('createdBy', 'username email');\r\n      if (!test) throw new Error('Test not found');\r\n      return test;\r\n    } catch (error) {\r\n      typedLogger.error('Failed to fetch A/B test', { testId, error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  static async updateTest(testId: string, updates: Partial<IABTest>) {\r\n    try {\r\n      // If updating variants, validate traffic allocation\r\n      if (updates.variants) {\r\n        const totalTraffic = updates.variants.reduce((sum, v) => sum + v.trafficAllocation, 0);\r\n        if (totalTraffic !== 100) {\r\n          throw new Error(`Traffic allocation must sum to 100%, got ${totalTraffic}%`);\r\n        }\r\n      }\r\n\r\n      const test = await ABTest.findByIdAndUpdate(testId, { ...updates, updatedAt: new Date() }, { new: true });\r\n      typedLogger.info('A/B test updated', { testId });\r\n      return test;\r\n    } catch (error) {\r\n      typedLogger.error('Failed to update A/B test', { testId, error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  static async startTest(testId: string) {\r\n    try {\r\n      const test = await ABTest.findByIdAndUpdate(\r\n        testId,\r\n        { status: 'active', startDate: new Date() },\r\n        { new: true }\r\n      );\r\n      typedLogger.info('A/B test started', { testId });\r\n      return test;\r\n    } catch (error) {\r\n      typedLogger.error('Failed to start A/B test', { testId, error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  static async pauseTest(testId: string) {\r\n    try {\r\n      const test = await ABTest.findByIdAndUpdate(testId, { status: 'paused' }, { new: true });\r\n      typedLogger.info('A/B test paused', { testId });\r\n      return test;\r\n    } catch (error) {\r\n      typedLogger.error('Failed to pause A/B test', { testId, error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  static async endTest(testId: string) {\r\n    try {\r\n      // Calculate winner based on statistical significance\r\n      const test = await this.getTestById(testId);\r\n      const winnerVariant = await this.selectWinner(test);\r\n\r\n      const updated = await ABTest.findByIdAndUpdate(\r\n        testId,\r\n        { status: 'ended', endDate: new Date(), winnerVariant },\r\n        { new: true }\r\n      );\r\n\r\n      typedLogger.info('A/B test ended', { testId, winner: winnerVariant });\r\n      return updated;\r\n    } catch (error) {\r\n      typedLogger.error('Failed to end A/B test', { testId, error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  static async deleteTest(testId: string) {\r\n    try {\r\n      await ABTest.findByIdAndDelete(testId);\r\n      typedLogger.info('A/B test deleted', { testId });\r\n    } catch (error) {\r\n      typedLogger.error('Failed to delete A/B test', { testId, error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  static async recordConversion(testId: string, variantName: string, conversionValue: number = 1) {\r\n    try {\r\n      await ABTest.findByIdAndUpdate(\r\n        testId,\r\n        {\r\n          $inc: {\r\n            'variants.$[elem].conversions': conversionValue\r\n          }\r\n        },\r\n        {\r\n          arrayFilters: [{ 'elem.name': variantName }],\r\n          new: true\r\n        }\r\n      );\r\n    } catch (error) {\r\n      typedLogger.error('Failed to record conversion', { testId, variantName, error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  static async recordImpression(testId: string, variantName: string) {\r\n    try {\r\n      await ABTest.findByIdAndUpdate(\r\n        testId,\r\n        {\r\n          $inc: {\r\n            'variants.$[elem].impressions': 1\r\n          }\r\n        },\r\n        {\r\n          arrayFilters: [{ 'elem.name': variantName }],\r\n          new: true\r\n        }\r\n      );\r\n    } catch (error) {\r\n      typedLogger.error('Failed to record impression', { testId, variantName, error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  static async getMetrics(testId: string) {\r\n    try {\r\n      const test = await this.getTestById(testId);\r\n      if (!test) throw new Error('Test not found');\r\n\r\n      const metricsData = test.variants.map(v => ({\r\n        name: v.name,\r\n        traffic: v.trafficAllocation,\r\n        impressions: v.impressions,\r\n        conversions: v.conversions,\r\n        conversionRate: v.impressions > 0 ? (v.conversions / v.impressions * 100).toFixed(2) : '0.00'\r\n      }));\r\n\r\n      return {\r\n        testName: test.name,\r\n        status: test.status,\r\n        variants: metricsData,\r\n        winner: test.winnerVariant,\r\n        confidence: test.confidenceLevel\r\n      };\r\n    } catch (error) {\r\n      typedLogger.error('Failed to get metrics', { testId, error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  static async selectWinner(test: IABTest): Promise<string | undefined> {\r\n    try {\r\n      if (test.variants.length === 0) return undefined;\r\n\r\n      // Calculate significance using chi-square test\r\n      const controlVariant = test.variants[0];\r\n      let winner = controlVariant.name;\r\n      let highestSignificance = 0;\r\n\r\n      for (let i = 1; i < test.variants.length; i++) {\r\n        const testVariant = test.variants[i];\r\n        const chisquare = this.calculateChiSquare(controlVariant, testVariant);\r\n        const significance = this.getSignificanceLevel(chisquare);\r\n\r\n        if (significance > test.confidenceLevel && significance > highestSignificance) {\r\n          winner = testVariant.name;\r\n          highestSignificance = significance;\r\n        }\r\n      }\r\n\r\n      return winner;\r\n    } catch (error) {\r\n      typedLogger.error('Failed to select winner', { error });\r\n      return test.variants[0]?.name;\r\n    }\r\n  }\r\n\r\n  private static calculateChiSquare(variant1: any, variant2: any): number {\r\n    const control = {\r\n      conversions: variant1.conversions,\r\n      nonConversions: variant1.impressions - variant1.conversions\r\n    };\r\n\r\n    const test = {\r\n      conversions: variant2.conversions,\r\n      nonConversions: variant2.impressions - variant2.conversions\r\n    };\r\n\r\n    const totalConversions = control.conversions + test.conversions;\r\n    const totalNonConversions = control.nonConversions + test.nonConversions;\r\n    const totalSamples = totalConversions + totalNonConversions;\r\n\r\n    if (totalSamples === 0) return 0;\r\n\r\n    const expectedControl = (control.conversions + control.nonConversions) * (totalConversions / totalSamples);\r\n    const expectedTest = (test.conversions + test.nonConversions) * (totalConversions / totalSamples);\r\n\r\n    const chi2 = \r\n      Math.pow(control.conversions - expectedControl, 2) / (expectedControl || 1) +\r\n      Math.pow(test.conversions - expectedTest, 2) / (expectedTest || 1);\r\n\r\n    return chi2;\r\n  }\r\n\r\n  private static getSignificanceLevel(chiSquare: number): number {\r\n    // Simple mapping of chi-square to significance level\r\n    // 3.84 = 95% confidence, 6.64 = 99% confidence\r\n    if (chiSquare > 6.64) return 0.99;\r\n    if (chiSquare > 3.84) return 0.95;\r\n    return chiSquare / 3.84 * 0.95;\r\n  }\r\n\r\n  static async getActiveTests() {\r\n    try {\r\n      return await ABTest.find({ status: 'active' }).sort({ startDate: -1 });\r\n    } catch (error) {\r\n      typedLogger.error('Failed to fetch active tests', { error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  static async getTestResults(testId: string) {\r\n    try {\r\n      const test = await this.getTestById(testId);\r\n      const metrics = test.variants.map(v => ({\r\n        name: v.name,\r\n        traffic: v.trafficAllocation,\r\n        conversions: v.conversions,\r\n        conversionRate: v.impressions > 0 ? (v.conversions / v.impressions) : 0,\r\n        winningChance: 0 // Will be calculated based on statistical significance\r\n      }));\r\n\r\n      return {\r\n        test: {\r\n          id: test._id,\r\n          name: test.name,\r\n          status: test.status,\r\n          type: test.type,\r\n          startDate: test.startDate,\r\n          endDate: test.endDate,\r\n          winner: test.winnerVariant\r\n        },\r\n        metrics,\r\n        recommendation: test.winnerVariant ? `Winner: ${test.winnerVariant}` : 'Test still running'\r\n      };\r\n    } catch (error) {\r\n      typedLogger.error('Failed to get test results', { testId, error });\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\admin\\services\\admin-analytics.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Types' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Reward' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'AuditLog' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":18},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":10,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[463,466],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[463,466],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":175,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":175,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5528,5531],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5528,5531],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":176,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":176,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5587,5590],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5587,5590],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Types } from 'mongoose';\nimport { User, Prize, Claim, Reward, Redemption } from '@/models';\nimport { Analytics } from '@/models/Analytics';\nimport { AuditLog } from '@/models/AuditLog';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { PartnerMarketplaceAnalyticsService } from '@/services/partner-marketplace-analytics';\n\nexport class AdminAnalyticsService {\n  static async getAnalytics(startDate?: string, endDate?: string) {\n    const query: any = {};\n    \n    if (startDate || endDate) {\n      query.date = {};\n      if (startDate) query.date.$gte = new Date(startDate);\n      if (endDate) query.date.$lte = new Date(endDate);\n    }\n\n    return Analytics.find(query).sort({ date: -1 });\n  }\n\n  static async generateDailyAnalytics(date: Date = new Date()) {\n    const startOfDay = new Date(date);\n    startOfDay.setHours(0, 0, 0, 0);\n    const endOfDay = new Date(date);\n    endOfDay.setHours(23, 59, 59, 999);\n\n    const [totalUsers, newUsers, totalClaims, totalRedemptions, claimsToday] = await Promise.all([\n      User.countDocuments(),\n      User.countDocuments({ createdAt: { $gte: startOfDay, $lte: endOfDay } }),\n      Claim.countDocuments(),\n      Redemption.countDocuments(),\n      Claim.countDocuments({ claimedAt: { $gte: startOfDay, $lte: endOfDay } })\n    ]);\n\n    const activeUsers = await User.countDocuments({\n      lastActive: { $gte: startOfDay, $lte: endOfDay }\n    });\n\n    const analytics = await Analytics.findOneAndUpdate(\n      { date: startOfDay },\n      {\n        date: startOfDay,\n        totalUsers,\n        newUsers,\n        activeUsers,\n        totalClaims,\n        claimsToday,\n        totalRedemptions,\n        updatedAt: new Date()\n      },\n      { upsert: true, new: true }\n    );\n\n    typedLogger.info('Daily analytics generated', { date: startOfDay });\n    return analytics;\n  }\n\n  static async getOverview(period: string) {\n    const { startDate, endDate } = this.parseTimeframe(period);\n\n    const [\n      activeUsers,\n      totalCaptures,\n      totalRedemptions,\n      userGrowth,\n      dailyActivity\n    ] = await Promise.all([\n      User.countDocuments({ lastActive: { $gte: startDate } }),\n      Claim.countDocuments({ claimedAt: { $gte: startDate, $lte: endDate } }),\n      Redemption.countDocuments({ redeemedAt: { $gte: startDate, $lte: endDate } }),\n      this.getUserGrowthData(startDate, endDate),\n      this.getDailyActivityData(startDate, endDate)\n    ]);\n\n    const conversionRate = totalCaptures > 0 \n      ? ((totalRedemptions / totalCaptures) * 100).toFixed(2) \n      : '0.00';\n\n    const revenueData = await Redemption.aggregate([\n      { $match: { redeemedAt: { $gte: startDate, $lte: endDate } } },\n      { $group: { _id: null, total: { $sum: '$pointsSpent' } } }\n    ]);\n\n    return {\n      activeUsers,\n      totalCaptures,\n      conversionRate: parseFloat(conversionRate),\n      revenue: revenueData[0]?.total || 0,\n      dailyActivity,\n      userGrowth\n    };\n  }\n\n  static async getUsersAnalytics(period: string) {\n    const { startDate, endDate } = this.parseTimeframe(period);\n\n    const [totalUsers, newUsers, activeUsers, topUsers, userGrowth] = await Promise.all([\n      User.countDocuments(),\n      User.countDocuments({ createdAt: { $gte: startDate, $lte: endDate } }),\n      User.countDocuments({ lastActive: { $gte: startDate } }),\n      this.getTopUsers(10),\n      this.getUserGrowthData(startDate, endDate)\n    ]);\n\n    const retentionRate = totalUsers > 0 \n      ? ((activeUsers / totalUsers) * 100).toFixed(2) \n      : '0.00';\n\n    return {\n      totalUsers,\n      newUsers,\n      activeUsers,\n      retentionRate: parseFloat(retentionRate),\n      topUsers,\n      userGrowth\n    };\n  }\n\n  static async getPrizesAnalytics(period: string) {\n    const { startDate, endDate } = this.parseTimeframe(period);\n\n    const [totalPrizes, activePrizes, claimsByCategory, topPrizes] = await Promise.all([\n      Prize.countDocuments(),\n      Prize.countDocuments({ isActive: true }),\n      this.getClaimsByCategory(startDate, endDate),\n      this.getTopPrizes(startDate, endDate, 10)\n    ]);\n\n    const totalClaims = await Claim.countDocuments({\n      claimedAt: { $gte: startDate, $lte: endDate }\n    });\n\n    return {\n      totalPrizes,\n      activePrizes,\n      totalClaims,\n      claimsByCategory,\n      topPrizes\n    };\n  }\n\n  static async getBusinessAnalytics(period: string) {\n    const { startDate, endDate } = this.parseTimeframe(period);\n\n    const [totalRedemptions, revenueByPartner, redemptionTrend, marketplace] = await Promise.all([\n      Redemption.countDocuments({ redeemedAt: { $gte: startDate, $lte: endDate } }),\n      this.getRevenueByPartner(startDate, endDate),\n      this.getRedemptionTrend(startDate, endDate),\n      PartnerMarketplaceAnalyticsService.getMarketplaceSummary({ startDate, endDate })\n    ]);\n\n    const totalRevenue = await Redemption.aggregate([\n      { $match: { redeemedAt: { $gte: startDate, $lte: endDate } } },\n      { $group: { _id: null, total: { $sum: '$pointsSpent' } } }\n    ]);\n\n    return {\n      totalRedemptions,\n      totalRevenue: totalRevenue[0]?.total || 0,\n      revenueByPartner,\n      redemptionTrend,\n      marketplace\n    };\n  }\n\n  static async getHeatmapData(period: string) {\n    const { startDate, endDate } = this.parseTimeframe(period);\n\n    const claims = await Claim.find({\n      claimedAt: { $gte: startDate, $lte: endDate },\n      'location.coordinates': { $exists: true }\n    }).select('location claimedAt').lean();\n\n    return claims.map(claim => ({\n      lat: (claim as any).location?.coordinates?.[1] || 0,\n      lng: (claim as any).location?.coordinates?.[0] || 0,\n      weight: 1,\n      timestamp: claim.claimedAt\n    }));\n  }\n\n  static async getRealTimeStats() {\n    const now = new Date();\n    const twentyFourHoursAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);\n    const fifteenMinutesAgo = new Date(now.getTime() - 15 * 60 * 1000);\n\n    const [\n      totalUsers,\n      active24h,\n      new24h,\n      claims24h,\n      pointsData,\n      activeSessions\n    ] = await Promise.all([\n      User.countDocuments(),\n      User.countDocuments({ lastActive: { $gte: twentyFourHoursAgo } }),\n      User.countDocuments({ createdAt: { $gte: twentyFourHoursAgo } }),\n      Claim.countDocuments({ claimedAt: { $gte: twentyFourHoursAgo } }),\n      Claim.aggregate([\n        { $match: { claimedAt: { $gte: twentyFourHoursAgo } } },\n        { $group: { _id: null, total: { $sum: '$points' } } }\n      ]),\n      User.countDocuments({ lastActive: { $gte: fifteenMinutesAgo } })\n    ]);\n\n    return {\n      users: totalUsers,\n      active24h,\n      new24h,\n      claims24h,\n      points24h: pointsData[0]?.total || 0,\n      activeSessions\n    };\n  }\n\n  private static async getUserGrowthData(startDate: Date, endDate: Date) {\n    return User.aggregate([\n      { $match: { createdAt: { $gte: startDate, $lte: endDate } } },\n      {\n        $group: {\n          _id: { $dateToString: { format: '%Y-%m-%d', date: '$createdAt' } },\n          count: { $sum: 1 }\n        }\n      },\n      { $sort: { _id: 1 } },\n      { $project: { date: '$_id', count: 1, _id: 0 } }\n    ]);\n  }\n\n  private static async getClaimsByCategory(startDate: Date, endDate: Date) {\n    return Claim.aggregate([\n      { $match: { claimedAt: { $gte: startDate, $lte: endDate } } },\n      {\n        $lookup: {\n          from: 'prizes',\n          localField: 'prizeId',\n          foreignField: '_id',\n          as: 'prize'\n        }\n      },\n      { $unwind: { path: '$prize', preserveNullAndEmptyArrays: true } },\n      {\n        $group: {\n          _id: '$prize.category',\n          count: { $sum: 1 }\n        }\n      },\n      { $project: { category: '$_id', count: 1, _id: 0 } }\n    ]);\n  }\n\n  private static async getTopUsers(limit: number) {\n    return User.find()\n      .sort({ totalPoints: -1 })\n      .limit(limit)\n      .select('username email totalPoints claimsCount')\n      .lean();\n  }\n\n  private static async getTopPrizes(startDate: Date, endDate: Date, limit: number) {\n    return Claim.aggregate([\n      { $match: { claimedAt: { $gte: startDate, $lte: endDate } } },\n      { $group: { _id: '$prizeId', claimCount: { $sum: 1 } } },\n      { $sort: { claimCount: -1 } },\n      { $limit: limit },\n      {\n        $lookup: {\n          from: 'prizes',\n          localField: '_id',\n          foreignField: '_id',\n          as: 'prize'\n        }\n      },\n      { $unwind: '$prize' },\n      {\n        $project: {\n          _id: 0,\n          prizeId: '$_id',\n          name: '$prize.name',\n          category: '$prize.category',\n          claimCount: 1\n        }\n      }\n    ]);\n  }\n\n  private static async getRevenueByPartner(startDate: Date, endDate: Date) {\n    return Redemption.aggregate([\n      { $match: { redeemedAt: { $gte: startDate, $lte: endDate } } },\n      {\n        $group: {\n          _id: '$partnerId',\n          totalRevenue: { $sum: '$pointsSpent' },\n          redemptionCount: { $sum: 1 }\n        }\n      },\n      { $sort: { totalRevenue: -1 } }\n    ]);\n  }\n\n  private static async getRedemptionTrend(startDate: Date, endDate: Date) {\n    return Redemption.aggregate([\n      { $match: { redeemedAt: { $gte: startDate, $lte: endDate } } },\n      {\n        $group: {\n          _id: { $dateToString: { format: '%Y-%m-%d', date: '$redeemedAt' } },\n          count: { $sum: 1 },\n          revenue: { $sum: '$pointsSpent' }\n        }\n      },\n      { $sort: { _id: 1 } },\n      { $project: { date: '$_id', count: 1, revenue: 1, _id: 0 } }\n    ]);\n  }\n\n  private static async getDailyActivityData(startDate: Date, endDate: Date) {\n    // Get claims data by day\n    const claimsData = await Claim.aggregate([\n      { $match: { claimedAt: { $gte: startDate, $lte: endDate } } },\n      {\n        $group: {\n          _id: { $dateToString: { format: '%Y-%m-%d', date: '$claimedAt' } },\n          claims: { $sum: 1 },\n          points: { $sum: '$points' }\n        }\n      },\n      { $sort: { _id: 1 } }\n    ]);\n\n    // Get redemptions data by day\n    const redemptionsData = await Redemption.aggregate([\n      { $match: { redeemedAt: { $gte: startDate, $lte: endDate } } },\n      {\n        $group: {\n          _id: { $dateToString: { format: '%Y-%m-%d', date: '$redeemedAt' } },\n          redemptions: { $sum: 1 }\n        }\n      },\n      { $sort: { _id: 1 } }\n    ]);\n\n    // Create a map of dates with all data\n    const dateMap = new Map<string, { date: string; claims: number; redemptions: number; points: number }>();\n\n    // Initialize dates in range\n    const current = new Date(startDate);\n    while (current <= endDate) {\n      const dateStr = current.toISOString().split('T')[0];\n      dateMap.set(dateStr, { date: dateStr, claims: 0, redemptions: 0, points: 0 });\n      current.setDate(current.getDate() + 1);\n    }\n\n    // Merge claims data\n    for (const item of claimsData) {\n      const existing = dateMap.get(item._id) || { date: item._id, claims: 0, redemptions: 0, points: 0 };\n      existing.claims = item.claims;\n      existing.points = item.points || 0;\n      dateMap.set(item._id, existing);\n    }\n\n    // Merge redemptions data\n    for (const item of redemptionsData) {\n      const existing = dateMap.get(item._id) || { date: item._id, claims: 0, redemptions: 0, points: 0 };\n      existing.redemptions = item.redemptions;\n      dateMap.set(item._id, existing);\n    }\n\n    // Convert map to sorted array (uses \"captures\" key for frontend compatibility)\n    return Array.from(dateMap.values())\n      .sort((a, b) => a.date.localeCompare(b.date))\n      .map(d => ({\n        date: d.date,\n        captures: d.claims,\n        redemptions: d.redemptions,\n        points: d.points\n      }));\n  }\n\n  private static parseTimeframe(period: string): { startDate: Date; endDate: Date } {\n    const endDate = new Date();\n    const startDate = new Date();\n\n    switch (period) {\n      case '24h':\n      case 'day':\n        startDate.setHours(startDate.getHours() - 24);\n        break;\n      case '7d':\n      case 'week':\n        startDate.setDate(startDate.getDate() - 7);\n        break;\n      case '30d':\n      case 'month':\n        startDate.setDate(startDate.getDate() - 30);\n        break;\n      case '90d':\n      case 'year':\n        startDate.setDate(startDate.getDate() - 90);\n        break;\n      case '1y':\n        startDate.setFullYear(startDate.getFullYear() - 1);\n        break;\n      default:\n        startDate.setDate(startDate.getDate() - 30);\n    }\n\n    return { startDate, endDate };\n  }\n}\n\nexport default AdminAnalyticsService;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\admin\\services\\admin-claims.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\admin\\services\\admin-core.service.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":104,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":104,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3428,3431],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3428,3431],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":158,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":158,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5366,5369],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5366,5369],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":212,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":212,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6740,6743],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6740,6743],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ip' is defined but never used. Allowed unused args must match /^_/u.","line":213,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":213,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'userAgent' is defined but never used. Allowed unused args must match /^_/u.","line":214,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":214,"endColumn":23}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Types } from 'mongoose';\nimport { User } from '@/models/User';\nimport { Prize } from '@/models/Prize';\nimport { Claim } from '@/models/Claim';\nimport { Reward } from '@/models/Reward';\nimport { Redemption } from '@/models/Redemption';\nimport { AuditLog } from '@/models/AuditLog';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { audit } from '@/lib/audit-logger';\nimport { RedemptionStatus } from '@/types';\n\ninterface AuditLogOptions {\n  page?: number;\n  limit?: number;\n  adminId?: string;\n  action?: string;\n  resource?: string;\n  startDate?: Date;\n  endDate?: Date;\n}\n\ninterface DashboardStats {\n  users: { total: number; active: number; new: number };\n  prizes: { total: number; active: number; captured: number };\n  claims: { total: number; pending: number; approved: number; rejected: number };\n  rewards: { total: number; active: number };\n  redemptions: {\n    total: number;\n    pending: number;\n    fulfilled: number;\n    completed: number;\n    core: number;\n    marketplace: number;\n  };\n  purchases: { total: number; unredeemed: number; redeemed: number };\n}\n\nexport class AdminService {\n  static async getDashboardStats(): Promise<DashboardStats> {\n    try {\n      const now = new Date();\n      const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\n\n      const [\n        users,\n        prizes,\n        claims,\n        rewards,\n        redemptions,\n        marketplaceTotal,\n        marketplacePending,\n        marketplaceFulfilled\n      ] = await Promise.all([\n        User.aggregate([\n          {\n            $facet: {\n              total: [{ $count: 'count' }],\n              active: [{ $match: { isActive: true } }, { $count: 'count' }],\n              new: [{ $match: { createdAt: { $gte: thirtyDaysAgo } } }, { $count: 'count' }],\n            },\n          },\n        ]),\n        Prize.aggregate([\n          {\n            $facet: {\n              total: [{ $count: 'count' }],\n              active: [{ $match: { status: 'active' } }, { $count: 'count' }],\n              captured: [{ $match: { status: 'captured' } }, { $count: 'count' }],\n            },\n          },\n        ]),\n        Claim.aggregate([\n          {\n            $facet: {\n              total: [{ $count: 'count' }],\n              pending: [{ $match: { status: 'pending' } }, { $count: 'count' }],\n              approved: [{ $match: { status: 'approved' } }, { $count: 'count' }],\n              rejected: [{ $match: { status: 'rejected' } }, { $count: 'count' }],\n            },\n          },\n        ]),\n        Reward.aggregate([\n          {\n            $facet: {\n              total: [{ $count: 'count' }],\n              active: [{ $match: { isActive: true } }, { $count: 'count' }],\n            },\n          },\n        ]),\n        Redemption.aggregate([\n          {\n            $facet: {\n              total: [{ $count: 'count' }],\n              pending: [{ $match: { status: RedemptionStatus.PENDING } }, { $count: 'count' }],\n              fulfilled: [{ $match: { status: RedemptionStatus.FULFILLED } }, { $count: 'count' }],\n            },\n          },\n        ]),\n        Redemption.countDocuments({ 'metadata.source': 'marketplace' }),\n        Redemption.countDocuments({ 'metadata.source': 'marketplace', status: RedemptionStatus.PENDING }),\n        Redemption.countDocuments({ 'metadata.source': 'marketplace', status: RedemptionStatus.FULFILLED })\n      ]);\n\n      const extractCount = (result: any[], key: string): number =>\n        result[0]?.[key]?.[0]?.count ?? 0;\n\n      const totalRedemptions = extractCount(redemptions, 'total');\n      const pendingRedemptions = extractCount(redemptions, 'pending');\n      const fulfilledRedemptions = extractCount(redemptions, 'fulfilled');\n      const marketplaceRedemptions = marketplaceTotal || 0;\n      const coreRedemptions = Math.max(0, totalRedemptions - marketplaceRedemptions);\n\n      return {\n        users: {\n          total: extractCount(users, 'total'),\n          active: extractCount(users, 'active'),\n          new: extractCount(users, 'new'),\n        },\n        prizes: {\n          total: extractCount(prizes, 'total'),\n          active: extractCount(prizes, 'active'),\n          captured: extractCount(prizes, 'captured'),\n        },\n        claims: {\n          total: extractCount(claims, 'total'),\n          pending: extractCount(claims, 'pending'),\n          approved: extractCount(claims, 'approved'),\n          rejected: extractCount(claims, 'rejected'),\n        },\n        rewards: {\n          total: extractCount(rewards, 'total'),\n          active: extractCount(rewards, 'active'),\n        },\n        redemptions: {\n          total: totalRedemptions,\n          pending: pendingRedemptions,\n          fulfilled: fulfilledRedemptions,\n          completed: fulfilledRedemptions,\n          core: coreRedemptions,\n          marketplace: marketplaceRedemptions,\n        },\n        purchases: {\n          total: marketplaceRedemptions,\n          unredeemed: marketplacePending || 0,\n          redeemed: marketplaceFulfilled || 0,\n        },\n      };\n    } catch (error) {\n      typedLogger.error('Failed to get dashboard stats', { error });\n      throw error;\n    }\n  }\n\n  static async getAuditLogs(options: AuditLogOptions = {}) {\n    try {\n      const { page = 1, limit = 20, adminId, action, resource, startDate, endDate } = options;\n\n      const filter: Record<string, any> = {};\n\n      // AuditLog schema uses userId, not adminId\n      if (adminId) {\n        filter.userId = adminId;\n      }\n      if (action) {\n        filter.action = action;\n      }\n      if (resource) {\n        filter.resource = resource;\n      }\n      if (startDate || endDate) {\n        filter.createdAt = {};\n        if (startDate) filter.createdAt.$gte = startDate;\n        if (endDate) filter.createdAt.$lte = endDate;\n      }\n\n      const skip = (page - 1) * limit;\n\n      const [logs, total] = await Promise.all([\n        AuditLog.find(filter)\n          .sort({ createdAt: -1 })\n          .skip(skip)\n          .limit(limit)\n          .lean(),\n        AuditLog.countDocuments(filter),\n      ]);\n\n      return {\n        logs,\n        pagination: {\n          page,\n          limit,\n          total,\n          pages: Math.ceil(total / limit),\n        },\n      };\n    } catch (error) {\n      typedLogger.error('Failed to get audit logs', { error });\n      throw error;\n    }\n  }\n\n  /**\n   * @deprecated Use audit.custom() from '@/lib/audit-logger' instead.\n   * This method is kept for backwards compatibility only.\n   * The unified audit logger writes to BOTH Pino and MongoDB.\n   */\n  static async logAdminAction(\n    adminId: string | Types.ObjectId,\n    action: string,\n    resource: string,\n    resourceId?: string | Types.ObjectId,\n    metadata?: Record<string, any>,\n    ip?: string,\n    userAgent?: string\n  ) {\n    // Delegate to the unified audit logger\n    return audit.custom(adminId.toString(), action, resource, resourceId?.toString(), metadata);\n  }\n}\n\nexport default AdminService;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\admin\\services\\admin-distribution.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'User' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":14},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":24,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[847,850],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[847,850],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":29,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[933,936],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[933,936],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":111,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3118,3121],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3118,3121],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":121,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":121,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3407,3410],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3407,3410],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":146,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":146,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4221,4224],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4221,4224],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":153,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":153,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4515,4518],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4515,4518],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":190,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":190,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6077,6080],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6077,6080],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":218,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":218,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7183,7186],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7183,7186],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":219,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":219,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7234,7237],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7234,7237],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":224,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":224,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7405,7408],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7405,7408],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":224,"column":86,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":224,"endColumn":89,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7451,7454],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7451,7454],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":237,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":237,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7880,7883],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7880,7883],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":239,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":239,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8018,8021],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8018,8021],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":249,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":249,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8418,8421],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8418,8421],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":249,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":249,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8448,8451],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8448,8451],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":250,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":250,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8516,8519],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8516,8519],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":250,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":250,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8546,8549],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8546,8549],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":253,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":253,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8660,8663],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8660,8663],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":253,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":253,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8691,8694],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8691,8694],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":254,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":254,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8763,8766],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8763,8766],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":258,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":258,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8941,8944],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8941,8944],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":259,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":259,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9043,9046],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9043,9046],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":262,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":262,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9132,9135],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9132,9135],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":262,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":262,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9163,9166],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9163,9166],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":263,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":263,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9230,9233],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9230,9233],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":264,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":264,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9305,9308],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9305,9308],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":265,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":265,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9375,9378],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9375,9378],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":266,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":266,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9452,9455],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9452,9455],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":266,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":266,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9493,9496],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9493,9496],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":267,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":267,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9578,9581],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9578,9581],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":268,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":268,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9650,9653],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9650,9653],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":268,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":268,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9681,9684],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9681,9684],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":311,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":311,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11188,11191],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11188,11191],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":329,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":329,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11970,11973],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11970,11973],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":331,"column":79,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":331,"endColumn":82,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12055,12058],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12055,12058],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":391,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":391,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14047,14050],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14047,14050],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":393,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":393,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14148,14151],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14148,14151],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":409,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":409,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14753,14756],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14753,14756],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":464,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":464,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16683,16686],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16683,16686],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":471,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":471,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16968,16971],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16968,16971],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":475,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":475,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17111,17114],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17111,17114],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":484,"column":83,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":484,"endColumn":86,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17558,17561],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17558,17561],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":485,"column":82,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":485,"endColumn":85,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17678,17681],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17678,17681],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":515,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":515,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18409,18412],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18409,18412],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":523,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":523,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18627,18630],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18627,18630],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":528,"column":96,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":528,"endColumn":99,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18872,18875],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18872,18875],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":540,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":540,"endColumn":54},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":551,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":551,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19652,19655],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19652,19655],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":573,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":573,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20272,20275],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20272,20275],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":629,"column":85,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":629,"endColumn":88,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21751,21754],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21751,21754],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":641,"column":96,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":641,"endColumn":99,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22217,22220],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22217,22220],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":658,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":658,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22788,22791],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22788,22791],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'location' is defined but never used. Allowed unused args must match /^_/u.","line":689,"column":40,"nodeType":"Identifier","messageId":"unusedVar","endLine":689,"endColumn":80},{"ruleId":"prefer-const","severity":2,"message":"'startDate' is never reassigned. Use 'const' instead.","line":746,"column":9,"nodeType":"Identifier","messageId":"useConst","endLine":746,"endColumn":18,"fix":{"range":[25888,25915],"text":"const startDate = new Date();"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":768,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":768,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26453,26456],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26453,26456],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":56,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import { Types } from 'mongoose';\nimport { User, Prize, Claim, Distribution } from '@/models';\nimport { DistributionStatus, PrizeCategory, PrizeRarity, PrizeType, LocationType } from '@/types';\nimport { PrizeService } from '@/modules/prizes';\nimport { findNearestCity, clampToTunisia } from '@/utils/geo';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { redisClient } from '@/config/redis';\n\ninterface DistributionData {\n  prizeType?: string;\n  title?: string;\n  description?: string;\n  value?: number;\n  points?: number;\n  category?: PrizeCategory;\n  rarity?: PrizeRarity;\n  type?: PrizeType;\n  image?: string;\n  quantity?: number;\n  status?: string;\n  location?: { lat?: number; lng?: number; latitude?: number; longitude?: number; city?: string; address?: string };\n  radius?: number;\n  expiresAt?: Date;\n  metadata?: Record<string, any>;\n}\n\ninterface BulkDistributionData {\n  prizes?: DistributionData[];\n  template?: any;\n  locations?: Array<{ latitude: number; longitude: number; city?: string; address?: string; radius?: number }>;\n  distributionMode?: string;\n  region?: string;\n  scheduledAt?: Date;\n}\n\ninterface AutoDistributionData {\n  prizeType?: string;\n  totalValue?: number;\n  count?: number;\n  region?: { center: { lat: number; lng: number }; radius: number };\n  densityBased?: boolean;\n  duration?: number;\n}\n\ninterface DistributionAnalytics {\n  totalDistributed: number;\n  totalClaimed: number;\n  totalExpired: number;\n  claimRate: number;\n  averageClaimTime: number;\n  byPrizeType: Record<string, number>;\n  byRegion: Record<string, number>;\n}\n\nconst toPrizePayload = (\n  adminId: string,\n  payload: DistributionData & { city?: string }\n) => {\n  const rawLat =\n    payload.location?.lat ??\n    payload.location?.latitude ??\n    36.8065;\n  const rawLng =\n    payload.location?.lng ??\n    payload.location?.longitude ??\n    10.1815;\n  \n  // Clamp coordinates to Tunisia bounds to prevent out-of-bounds errors\n  const clamped = clampToTunisia({ lat: rawLat, lng: rawLng });\n  const lat = clamped.lat;\n  const lng = clamped.lng;\n  \n  const city =\n    payload.location?.city ||\n    payload.city ||\n    findNearestCity({ lat, lng }) ||\n    'Tunis';\n\n  const points =\n    payload.value ??\n    payload.points ??\n    payload.metadata?.prizeConfig?.content?.points ??\n    payload.metadata?.prizeConfig?.points ??\n    1;\n  const safePoints = Math.max(1, Number(points) || 1);\n  const quantity =\n    payload.quantity ??\n    payload.metadata?.distribution?.maxClaims ??\n    1;\n\n  return {\n    name:\n      payload.title ||\n      payload.metadata?.prizeConfig?.title ||\n      payload.prizeType ||\n      'Spot Prize',\n    description:\n      payload.description ||\n      payload.metadata?.prizeConfig?.description ||\n      'Distribution prize',\n    type: (payload.type as PrizeType) || PrizeType.PHYSICAL,\n    category:\n      (payload.category as PrizeCategory) || PrizeCategory.LIFESTYLE,\n    rarity:\n      (payload.rarity as PrizeRarity) || PrizeRarity.COMMON,\n    points: safePoints,\n    quantity,\n    status: payload.status || 'active',\n    imageUrl:\n      payload.image ||\n      (payload.metadata as any)?.prizeConfig?.image,\n    location: {\n      type: LocationType.GPS,\n      coordinates: [lng, lat],\n      radius: payload.radius ?? 50,\n      city,\n      address: payload.location?.address,\n    },\n    metadata: payload.metadata || {},\n    createdBy: new Types.ObjectId(adminId),\n  } as any;\n};\n\nexport class DistributionService {\n  // Backward-compatible aliases used by some callers/routes\n  static placeSinglePrize(adminId: string, body: DistributionData) {\n    return this.distributeSinglePrize(adminId, body);\n  }\n\n  static bulkDistribute(adminId: string, body: BulkDistributionData) {\n    return this.distributeBulkPrizes(adminId, body);\n  }\n\n  static autoDistribute(adminId: string, body: AutoDistributionData) {\n    return this.autoDistributePrizes(adminId, body);\n  }\n\n  static getAnalytics(adminId: string, timeframe: string, range?: { startDate?: string; endDate?: string }) {\n    return this.getDistributionAnalytics(adminId, timeframe, range);\n  }\n\n  static getSettings() {\n    return this.getDistributionSettings();\n  }\n\n  static updateSettings(adminId: string, settings: Record<string, any>) {\n    return this.updateDistributionSettings(adminId, settings);\n  }\n\n  // Alias used by routes (placeSinglePrize)\n  static async distributeSinglePrize(adminId: string, distributionData: DistributionData) {\n    try {\n      const prizePayload = toPrizePayload(adminId, distributionData as any);\n      const prize = await PrizeService.createPrize(adminId, prizePayload);\n\n      const lat = distributionData.location?.lat ?? distributionData.location?.latitude ?? 36.8065;\n      const lng = distributionData.location?.lng ?? distributionData.location?.longitude ?? 10.1815;\n      const city = distributionData.location?.city || findNearestCity({ lat, lng });\n\n      const distribution = await Distribution.create({\n        name: distributionData.title || 'Single Prize Distribution',\n        description: distributionData.description || 'Manual single prize placement',\n        targetArea: {\n          type: 'circle',\n          coordinates: [[lng, lat]],\n          city: city,\n          radius: distributionData.radius || 50,\n        },\n        prizeTemplate: {\n          name: distributionData.title || 'Prize',\n          description: distributionData.description || 'Prize description',\n          type: distributionData.type || 'physical',\n          category: distributionData.category || 'lifestyle',\n          points: distributionData.points || distributionData.value || 0,\n          rarity: distributionData.rarity || 'common',\n          imageUrl: distributionData.image,\n        },\n        quantity: 1,\n        spacing: 50,\n        prizes: [prize._id],\n        createdBy: new Types.ObjectId(adminId),\n        status: 'active',\n        metadata: {\n          totalValue: distributionData.value,\n          region: `${lat},${lng}`,\n          ...(distributionData.metadata || {}),\n        },\n      });\n\n      await this.cachePrizeForProximity(prize as any);\n      await this.trackDistributionMetrics(adminId, 'single', 1, distributionData.value);\n\n      typedLogger.info('Single prize distributed', { adminId, prizeId: prize._id });\n\n      return {\n        success: true,\n        distribution,\n        prize,\n        estimatedDiscoveryTime: this.estimateDiscoveryTime(distributionData.location),\n      };\n    } catch (error) {\n      typedLogger.error('Failed to distribute single prize', { adminId, error });\n      throw error;\n    }\n  }\n\n  // Alias used by routes (bulkDistribute)\n  static async distributeBulkPrizes(adminId: string, bulkData: BulkDistributionData) {\n    try {\n      // Support both legacy { prizes: [] } and new { template, locations } payloads\n      let prizeInputs: DistributionData[] = [];\n      if (Array.isArray(bulkData.prizes) && bulkData.prizes.length > 0) {\n        prizeInputs = bulkData.prizes as DistributionData[];\n      } else if (bulkData.template && Array.isArray(bulkData.locations)) {\n        prizeInputs = bulkData.locations.map((loc) => ({\n          ...bulkData.template,\n          location: {\n            lat: (loc as any).lat ?? loc.latitude,\n            lng: (loc as any).lng ?? loc.longitude,\n            city: loc.city,\n            address: loc.address,\n          },\n          radius: loc.radius,\n          value: (bulkData.template as any).content?.points ?? (bulkData.template as any).points,\n          metadata: {\n            prizeConfig: bulkData.template,\n            distribution: { mode: bulkData.distributionMode },\n          },\n        }));\n      }\n\n      const prizes = await Promise.all(\n        prizeInputs.map(async (prizeData) => {\n          const prizePayload = toPrizePayload(adminId, {\n            ...prizeData,\n            status: bulkData.scheduledAt ? 'scheduled' : 'active',\n          } as any);\n          const prize = await PrizeService.createPrize(adminId, prizePayload);\n          await this.cachePrizeForProximity(prize as any);\n          return prize;\n        })\n      );\n\n      const totalValue = prizeInputs.reduce((sum, p) => sum + (p.value ?? p.points ?? 0), 0);\n\n      // Extract template info for Distribution record\n      const templateInfo = bulkData.template || prizeInputs[0] || {};\n      const firstLocation = bulkData.locations?.[0] || prizeInputs[0]?.location || {};\n      const centerLat = (firstLocation as any).lat ?? (firstLocation as any).latitude ?? 36.8065;\n      const centerLng = (firstLocation as any).lng ?? (firstLocation as any).longitude ?? 10.1815;\n\n      const distribution = await Distribution.create({\n        name: (templateInfo as any).title || (templateInfo as any).name || 'Bulk Distribution',\n        description: (templateInfo as any).description || 'Bulk prize distribution',\n        targetArea: {\n          type: 'circle',\n          coordinates: [[centerLng, centerLat]],\n          city: (firstLocation as any).city || findNearestCity({ lat: centerLat, lng: centerLng }),\n          radius: (firstLocation as any).radius || 500,\n        },\n        prizeTemplate: {\n          name: (templateInfo as any).title || (templateInfo as any).name || 'Bulk Prize',\n          description: (templateInfo as any).description || 'Distribution prize',\n          type: (templateInfo as any).type || PrizeType.PHYSICAL,\n          category: (templateInfo as any).category || PrizeCategory.LIFESTYLE,\n          points: (templateInfo as any).content?.points || (templateInfo as any).points || totalValue / prizes.length || 100,\n          rarity: (templateInfo as any).rarity || PrizeRarity.COMMON,\n          imageUrl: (templateInfo as any).image || (templateInfo as any).imageUrl,\n        },\n        quantity: prizes.length,\n        spacing: 50, // Default spacing between prizes\n        createdBy: new Types.ObjectId(adminId),\n        status: bulkData.scheduledAt ? 'scheduled' : 'active',\n        metadata: {\n          scheduledAt: bulkData.scheduledAt,\n          totalValue,\n          region: bulkData.region || 'global',\n          prizeIds: prizes.map((p) => p._id),\n          distributionMode: bulkData.distributionMode,\n        },\n      });\n\n      await this.trackDistributionMetrics(adminId, 'bulk', prizes.length, totalValue);\n\n      typedLogger.info('Bulk prizes distributed', { adminId, count: prizes.length });\n\n      return {\n        success: true,\n        distribution,\n        prizes,\n        summary: this.generateDistributionSummary(prizes),\n      };\n    } catch (error) {\n      typedLogger.error('Failed to distribute bulk prizes', { adminId, error });\n      throw error;\n    }\n  }\n\n  // Alias used by routes (autoDistribute)\n  static async autoDistributePrizes(adminId: string, autoData: AutoDistributionData) {\n    try {\n      const safeAuto = {\n        prizeType: autoData.prizeType || 'generic',\n        totalValue: autoData.totalValue ?? 0,\n        count: autoData.count ?? 1,\n        region: autoData.region || { center: { lat: 0, lng: 0 }, radius: 1 },\n        densityBased: autoData.densityBased,\n        duration: autoData.duration,\n      };\n      const optimalDistribution = await this.calculateOptimalDistribution(safeAuto);\n      const prizes: any[] = [];\n\n      for (const location of optimalDistribution.locations) {\n        const baseValue = safeAuto.totalValue / (safeAuto.count || 1);\n        const prizeValue = safeAuto.densityBased\n          ? this.scaleByDensity(baseValue, location.density)\n          : baseValue;\n\n        const prizePayload = toPrizePayload(adminId, {\n          title: `Auto ${safeAuto.prizeType}`,\n          description: 'Auto-distributed prize',\n          value: this.applyRandomVariation(prizeValue, 0.1),\n          location: { lat: location.lat, lng: location.lng },\n          radius: 50,\n          rarity: PrizeRarity.COMMON,\n          category: PrizeCategory.LIFESTYLE,\n          type: PrizeType.PHYSICAL,\n          metadata: { autoDistributed: true, density: location.density },\n        } as any);\n\n        const prize = await PrizeService.createPrize(adminId, prizePayload as any);\n\n        await this.cachePrizeForProximity(prize);\n        prizes.push(prize);\n      }\n\n      const distribution = await Distribution.create({\n        name: `Auto ${safeAuto.prizeType} Distribution`,\n        description: `Automated distribution of ${prizes.length} prizes`,\n        targetArea: {\n          type: 'circle',\n          coordinates: [[safeAuto.region.center.lng, safeAuto.region.center.lat]],\n          city: 'Auto Region',\n          radius: safeAuto.region.radius * 1000 // Convert km to meters\n        },\n        prizeTemplate: {\n          name: `Auto ${safeAuto.prizeType}`,\n          description: 'Auto-distributed prize',\n          type: PrizeType.PHYSICAL,\n          category: PrizeCategory.LIFESTYLE,\n          points: Math.round(safeAuto.totalValue / (safeAuto.count || 1)),\n          rarity: PrizeRarity.COMMON\n        },\n        quantity: prizes.length,\n        spacing: 50,\n        prizes: prizes.map((p) => p._id),\n        createdBy: new Types.ObjectId(adminId),\n        status: 'active',\n        metadata: { \n          autoConfig: autoData,\n          totalValue: autoData.totalValue,\n          region: `${autoData.region.center.lat},${autoData.region.center.lng}`,\n          prizeCount: prizes.length\n        },\n      });\n\n      await this.trackDistributionMetrics(adminId, 'auto', prizes.length, autoData.totalValue);\n\n      typedLogger.info('Auto distribution completed', { adminId, count: prizes.length });\n\n      return {\n        success: true,\n        distribution,\n        prizes,\n        coverage: optimalDistribution.coverage,\n      };\n    } catch (error) {\n      typedLogger.error('Failed to auto distribute prizes', { adminId, error });\n      throw error;\n    }\n  }\n\n  static async getDistributionAnalytics(\n    adminId: string,\n    timeframe: string,\n    _range?: { startDate?: string; endDate?: string }\n  ): Promise<DistributionAnalytics> {\n    try {\n      const { startDate, endDate } = this.parseTimeframe(timeframe);\n\n      const distributions: any[] = await Distribution.find({\n        createdAt: { $gte: startDate, $lte: endDate },\n      }) as any;\n\n      const prizeIds = distributions.flatMap((d) => d.prizes || []);\n      const prizes = await Prize.find({ _id: { $in: prizeIds } });\n      const claims = await Claim.find({\n        prizeId: { $in: prizeIds },\n        createdAt: { $gte: startDate, $lte: endDate },\n      });\n\n      const totalDistributed = prizes.length;\n      const totalClaimed = claims.length;\n      const totalExpired = prizes.filter((p) => p.status === 'expired').length;\n\n      const claimTimes = claims\n        .filter((c) => c.claimedAt)\n        .map((c) => {\n          const prize = prizes.find((p) => p._id.equals((c as any).prizeId));\n          return prize ? new Date(c.claimedAt).getTime() - new Date(prize.createdAt).getTime() : 0;\n        })\n        .filter((t) => t > 0);\n\n      const byPrizeType: Record<string, number> = {};\n      const byRegion: Record<string, number> = {};\n\n      prizes.forEach((prize) => {\n        byPrizeType[prize.type] = (byPrizeType[prize.type] || 0) + 1;\n      });\n\n      distributions.forEach((dist) => {\n        const region = dist.region || 'unknown';\n        const prizeCount = dist.prizeCount || 0;\n        byRegion[region] = (byRegion[region] || 0) + prizeCount;\n      });\n\n      return {\n        totalDistributed,\n        totalClaimed,\n        totalExpired,\n        claimRate: totalDistributed > 0 ? (totalClaimed / totalDistributed) * 100 : 0,\n        averageClaimTime: claimTimes.length > 0 ? claimTimes.reduce((a, b) => a + b, 0) / claimTimes.length : 0,\n        byPrizeType,\n        byRegion,\n      };\n    } catch (error) {\n      typedLogger.error('Failed to get distribution analytics', { adminId, error });\n      throw error;\n    }\n  }\n\n  static async getActiveDistributions(adminId: string, opts?: { page?: number; limit?: number }) {\n    try {\n      const page = opts?.page || 1;\n      const limit = opts?.limit || 20;\n      const skip = (page - 1) * limit;\n\n      // Ensure Distribution model is available\n      if (!Distribution || typeof Distribution.find !== 'function') {\n        typedLogger.error('Distribution model not available');\n        return {\n          items: [],\n          pagination: { page, limit, total: 0, pages: 0 },\n        };\n      }\n\n      const [distributionsResult, total] = await Promise.all([\n        Distribution.find({ status: DistributionStatus.ACTIVE })\n          .populate('createdBy', 'name email')\n          .sort({ createdAt: -1 })\n          .skip(skip)\n          .limit(limit),\n        Distribution.countDocuments({ status: DistributionStatus.ACTIVE }),\n      ] as any);\n\n      // Defensive: ensure distributions is an array\n      const distributions = Array.isArray(distributionsResult) ? distributionsResult : [];\n\n      const enrichedDistributions = await Promise.all(\n        distributions.map(async (dist) => {\n          const distAny = dist as any;\n          const prizeIds = distAny.prizes || [];\n          \n          // Defensive: ensure Prize model is available\n          let prizes: any[] = [];\n          if (Prize && typeof Prize.find === 'function' && prizeIds.length > 0) {\n            try {\n              prizes = await Prize.find({ _id: { $in: prizeIds } }) || [];\n            } catch (err) {\n              typedLogger.warn('Failed to fetch prizes for distribution', { distributionId: distAny._id, err });\n            }\n          }\n          \n          const claimedCount = Array.isArray(prizes) ? prizes.filter((p) => (p as any).status === 'claimed').length : 0;\n          const activeCount = Array.isArray(prizes) ? prizes.filter((p) => (p as any).status === 'active').length : 0;\n\n          return {\n            ...distAny.toObject?.() ?? distAny,\n            claimedCount,\n            activeCount,\n            claimRate: prizes.length > 0 ? (claimedCount / prizes.length) * 100 : 0,\n          };\n        })\n      );\n\n      return {\n        items: enrichedDistributions,\n        pagination: {\n          page,\n          limit,\n          total,\n          pages: Math.ceil(total / limit),\n        },\n      };\n    } catch (error) {\n      typedLogger.error('Failed to get active distributions', { adminId, error });\n      throw error;\n    }\n  }\n\n  static async manageDistribution(\n    adminId: string,\n    distributionId: string,\n    action: string,\n    params?: Record<string, any>\n  ) {\n    try {\n      const distribution = await Distribution.findById(distributionId);\n      if (!distribution) {\n        throw new Error('Distribution not found');\n      }\n\n      const distAny = distribution as any;\n\n      switch (action) {\n        case 'pause':\n          distAny.status = DistributionStatus.ACTIVE; // keep enum; flag prizes paused separately\n          await Prize.updateMany({ _id: { $in: distAny.prizes || [] } }, { status: 'paused' as any });\n          break;\n\n        case 'resume':\n          distAny.status = DistributionStatus.ACTIVE;\n          await Prize.updateMany(\n            { _id: { $in: distAny.prizes || [] }, status: 'paused' },\n            { status: 'active' }\n          );\n          break;\n\n        case 'extend':\n          const extensionHours = params?.hours || 24;\n          await Prize.updateMany(\n            { _id: { $in: distAny.prizes || [] } },\n            { $inc: { expiresAt: extensionHours * 60 * 60 * 1000 } }\n          );\n          break;\n\n        case 'terminate':\n          distAny.status = DistributionStatus.CANCELLED;\n          await Prize.updateMany(\n            { _id: { $in: distAny.prizes || [] }, status: { $in: ['active', 'paused'] } },\n            { status: 'terminated' as any }\n          );\n          break;\n\n        default:\n          throw new Error(`Unknown action: ${action}`);\n      }\n\n      await (distAny.save?.() ?? distAny);\n\n      typedLogger.info('Distribution managed', { adminId, distributionId, action });\n\n      return { success: true, distribution, action };\n    } catch (error) {\n      typedLogger.error('Failed to manage distribution', { adminId, distributionId, action, error });\n      throw error;\n    }\n  }\n\n  static async getDistributionHistory(page: number = 1, limit: number = 20, status?: string) {\n    try {\n      const skip = (page - 1) * limit;\n      const query: any = {};\n      if (status) query.status = status;\n\n      const [distributions, total] = await Promise.all([\n        Distribution.find(query)\n          .populate('createdBy', 'name email')\n          .sort({ createdAt: -1 })\n          .skip(skip)\n          .limit(limit),\n        Distribution.countDocuments(query),\n      ]);\n\n      return {\n        distributions,\n        pagination: {\n          page,\n          limit,\n          total,\n          pages: Math.ceil(total / limit),\n        },\n      };\n    } catch (error) {\n      typedLogger.error('Failed to get distribution history', { error });\n      throw error;\n    }\n  }\n\n  static async getDistributionSettings() {\n    try {\n      const cacheKey = 'distribution:settings';\n      const cached = await redisClient.get(cacheKey);\n\n      if (cached) {\n        return JSON.parse(cached);\n      }\n\n      const settings = {\n        defaultRadius: 50,\n        defaultExpiration: 24,\n        maxPrizesPerDistribution: 1000,\n        minPrizeValue: 1,\n        maxPrizeValue: 10000,\n        densityThresholds: { low: 0.3, medium: 0.6, high: 1.0 },\n        autoDistributionEnabled: true,\n        schedulingEnabled: true,\n      };\n\n      await redisClient.setex(cacheKey, 3600, JSON.stringify(settings));\n\n      return settings;\n    } catch (error) {\n      typedLogger.error('Failed to get distribution settings', { error });\n      throw error;\n    }\n  }\n\n  static async updateDistributionSettings(adminId: string, settings: Record<string, any>) {\n    try {\n      const cacheKey = 'distribution:settings';\n      await redisClient.setex(cacheKey, 3600, JSON.stringify(settings));\n      typedLogger.info('Distribution settings updated', { adminId });\n      return settings;\n    } catch (error) {\n      typedLogger.error('Failed to update distribution settings', { adminId, error });\n      throw error;\n    }\n  }\n\n  static async triggerManualDistribution(adminId: string, type: string, config: Record<string, any>) {\n    try {\n      const distribution = await Distribution.create({\n        type,\n        createdBy: new Types.ObjectId(adminId),\n        status: 'pending',\n        metadata: config || {},\n        prizes: [],\n      });\n      typedLogger.info('Manual distribution trigger created', { adminId, distributionId: distribution._id });\n      return { success: true, distribution };\n    } catch (error) {\n      typedLogger.error('Failed to trigger manual distribution', { adminId, error });\n      throw error;\n    }\n  }\n\n  private static async cachePrizeForProximity(prize: any) {\n    try {\n      const geoKey = 'prizes:geo';\n      const [lng, lat] = prize.location.coordinates;\n      await redisClient.geoadd(geoKey, lng, lat, prize._id.toString());\n      await redisClient.setex(`prize:${prize._id}`, 3600, JSON.stringify(prize.toObject()));\n    } catch (error) {\n      typedLogger.warn('Failed to cache prize for proximity', { prizeId: prize._id, error });\n    }\n  }\n\n  private static async trackDistributionMetrics(\n    adminId: string,\n    type: string,\n    count: number,\n    value: number\n  ) {\n    try {\n      const today = new Date().toISOString().split('T')[0];\n      const metricsKey = `metrics:distribution:${today}`;\n\n      await redisClient.hincrby(metricsKey, `${type}:count`, count);\n      await redisClient.hincrby(metricsKey, `${type}:value`, Math.round(value));\n      await redisClient.hincrby(metricsKey, 'total:count', count);\n      await redisClient.hincrby(metricsKey, 'total:value', Math.round(value));\n      await redisClient.expire(metricsKey, 7 * 24 * 60 * 60);\n    } catch (error) {\n      typedLogger.warn('Failed to track distribution metrics', { adminId, error });\n    }\n  }\n\n  private static estimateDiscoveryTime(location: { lat?: number; lng?: number }): number {\n    const baseTime = 30;\n    const variation = Math.random() * 60;\n    return Math.round(baseTime + variation);\n  }\n\n  private static applyRandomVariation(value: number, percentage: number): number {\n    const variation = value * percentage * (Math.random() * 2 - 1);\n    return Math.round(value + variation);\n  }\n\n  private static scaleByDensity(baseValue: number, density: number): number {\n    const scaleFactor = 0.5 + density * 0.5;\n    return Math.round(baseValue * scaleFactor);\n  }\n\n  private static async calculateOptimalDistribution(autoData: AutoDistributionData) {\n    const locations: Array<{ lat: number; lng: number; density: number }> = [];\n    const { center, radius } = autoData.region;\n\n    for (let i = 0; i < autoData.count; i++) {\n      const angle = (2 * Math.PI * i) / autoData.count;\n      const r = radius * Math.sqrt(Math.random());\n      const lat = center.lat + (r / 111000) * Math.cos(angle);\n      const lng = center.lng + (r / (111000 * Math.cos((center.lat * Math.PI) / 180))) * Math.sin(angle);\n      const density = Math.random();\n\n      locations.push({ lat, lng, density });\n    }\n\n    return {\n      locations,\n      coverage: (locations.length / autoData.count) * 100,\n    };\n  }\n\n  private static calculateDistance(\n    lat1: number,\n    lng1: number,\n    lat2: number,\n    lng2: number\n  ): number {\n    const R = 6371000;\n    const dLat = ((lat2 - lat1) * Math.PI) / 180;\n    const dLng = ((lng2 - lng1) * Math.PI) / 180;\n    const a =\n      Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n      Math.cos((lat1 * Math.PI) / 180) *\n        Math.cos((lat2 * Math.PI) / 180) *\n        Math.sin(dLng / 2) *\n        Math.sin(dLng / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    return R * c;\n  }\n\n  private static parseTimeframe(timeframe: string): { startDate: Date; endDate: Date } {\n    const endDate = new Date();\n    let startDate = new Date();\n\n    switch (timeframe) {\n      case '24h':\n        startDate.setHours(startDate.getHours() - 24);\n        break;\n      case '7d':\n        startDate.setDate(startDate.getDate() - 7);\n        break;\n      case '30d':\n        startDate.setDate(startDate.getDate() - 30);\n        break;\n      case '90d':\n        startDate.setDate(startDate.getDate() - 90);\n        break;\n      default:\n        startDate.setDate(startDate.getDate() - 7);\n    }\n\n    return { startDate, endDate };\n  }\n\n  private static generateDistributionSummary(prizes: any[]) {\n    const byType: Record<string, { count: number; totalValue: number }> = {};\n\n    prizes.forEach((prize) => {\n      if (!byType[prize.type]) {\n        byType[prize.type] = { count: 0, totalValue: 0 };\n      }\n      byType[prize.type].count++;\n      byType[prize.type].totalValue += prize.value;\n    });\n\n    return {\n      totalPrizes: prizes.length,\n      totalValue: prizes.reduce((sum, p) => sum + p.value, 0),\n      byType,\n    };\n  }\n}\n\nexport { DistributionService as AdminDistributionService };\nexport default DistributionService;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\admin\\services\\admin-notifications.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'User' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Types' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":15},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":21,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[663,666],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[663,666],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":22,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[692,695],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[692,695],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":48,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1343,1346],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1343,1346],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":73,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1932,1935],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1932,1935],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":103,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":103,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3111,3114],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3111,3114],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":125,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":125,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3784,3787],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3784,3787],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":148,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":148,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4736,4739],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4736,4739],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":162,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":162,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5137,5140],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5137,5140],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":196,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":196,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6540,6543],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6540,6543],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":201,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":201,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6680,6683],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6680,6683],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":217,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":217,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7131,7134],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7131,7134],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":220,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":220,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7243,7246],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7243,7246],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'period' is defined but never used. Allowed unused args must match /^_/u.","line":227,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":227,"endColumn":51},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":258,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":258,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8487,8490],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8487,8490],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":270,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":270,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9211,9214],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9211,9214],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":279,"column":136,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":279,"endColumn":139,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9546,9549],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9546,9549],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":296,"column":148,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":296,"endColumn":151,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10264,10267],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10264,10267],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":298,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":298,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10363,10366],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10363,10366],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":315,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":315,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10974,10977],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10974,10977],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":316,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":316,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11046,11049],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11046,11049],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":332,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":332,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11528,11531],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11528,11531],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":23,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { User } from '@/models';\nimport { Notification } from '@/models/Notification';\nimport UnifiedNotificationService from '@/services/notification-service';\nimport { NotificationStatus, NotificationType, NotificationTargetType } from '@/types';\nimport { Types } from 'mongoose';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { audit } from '@/lib/audit-logger';\nimport { Settings } from '@/models/Settings';\nimport { randomUUID } from 'crypto';\n\ninterface NotificationQuery {\n  page?: number;\n  limit?: number;\n  status?: NotificationStatus | string;\n  type?: string;\n}\n\ninterface NotificationPayload {\n  title: string;\n  message: string;\n  type?: any;\n  data?: Record<string, any>;\n  targetUserIds?: string[];\n}\n\ninterface ScheduledNotificationPayload extends NotificationPayload {\n  scheduledFor: Date;\n}\n\ninterface NotificationStats {\n  totalSent: number;\n  sentToday: number;\n  sentThisWeek: number;\n  scheduled: number;\n  failed: number;\n}\n\nexport class AdminNotificationsService {\n  static async getNotificationById(id: string) {\n    const notification = await Notification.findById(id).lean();\n    return notification || null;\n  }\n\n  static async getNotifications(query: NotificationQuery) {\n    const { page = 1, limit = 20, status, type } = query;\n    const skip = (page - 1) * limit;\n\n    const filter: Record<string, any> = {};\n    if (status) filter.status = status;\n    if (type) filter.type = type;\n\n    const [notifications, total] = await Promise.all([\n      Notification.find(filter)\n        .sort({ createdAt: -1 })\n        .skip(skip)\n        .limit(limit)\n        .lean(),\n      Notification.countDocuments(filter),\n    ]);\n\n    return {\n      notifications,\n      pagination: {\n        page,\n        limit,\n        total,\n        pages: Math.ceil(total / limit),\n      },\n    };\n  }\n\n  static async sendNotification(adminId: string, payload: NotificationPayload) {\n    const normalizeType = (t?: any) => {\n      if (!t) return NotificationType.PUSH;\n      const val = (t as string).toLowerCase();\n      return (Object.values(NotificationType) as string[]).includes(val) ? (val as NotificationType) : NotificationType.PUSH;\n    };\n    const resolveDeliveryMethod = (type: NotificationType): 'push' | 'email' | 'inapp' | 'all' => {\n      if (type === NotificationType.IN_APP) return 'inapp';\n      if (type === NotificationType.PUSH || type === NotificationType.EMAIL) return type;\n      return 'all';\n    };\n\n    const { title, message, data, targetUserIds } = payload;\n    const type = normalizeType(payload.type);\n\n    if (!targetUserIds || targetUserIds.length === 0) {\n      throw new Error('Target user IDs are required');\n    }\n\n    const results = await Promise.all(\n      targetUserIds.map(async (userId) => {\n        try {\n          await UnifiedNotificationService.sendNotification({\n            createdBy: adminId,\n            title,\n            message,\n            type,\n            deliveryMethod: resolveDeliveryMethod(type),\n            targetType: NotificationTargetType.USER,\n            targetValue: userId,\n            metadata: data || {},\n          } as any);\n          return { userId, success: true };\n        } catch (error) {\n          typedLogger.error('Failed to send notification', { userId, error });\n          return { userId, success: false, error };\n        }\n      })\n    );\n\n    await this.logAdminAction(adminId, 'SEND_NOTIFICATION', {\n      targetCount: targetUserIds.length,\n      successCount: results.filter((r) => r.success).length,\n    });\n\n    return {\n      sent: results.filter((r) => r.success).length,\n      failed: results.filter((r) => !r.success).length,\n      results,\n    };\n  }\n\n  static async broadcastNotification(adminId: string, payload: NotificationPayload) {\n    const normalizeType = (t?: any) => {\n      if (!t) return NotificationType.PUSH;\n      const val = (t as string).toLowerCase();\n      return (Object.values(NotificationType) as string[]).includes(val) ? (val as NotificationType) : NotificationType.PUSH;\n    };\n    const resolveDeliveryMethod = (type: NotificationType): 'push' | 'email' | 'inapp' | 'all' => {\n      if (type === NotificationType.IN_APP) return 'inapp';\n      if (type === NotificationType.PUSH || type === NotificationType.EMAIL) return type;\n      return 'all';\n    };\n\n    const { title, message, data } = payload;\n    const type = normalizeType(payload.type);\n\n    // Single notification targeted to ALL users (UnifiedNotificationService will fan-out)\n    await UnifiedNotificationService.sendNotification({\n      createdBy: adminId,\n      title,\n      message,\n      type,\n      deliveryMethod: resolveDeliveryMethod(type),\n      targetType: NotificationTargetType.ALL,\n      metadata: data || {},\n    } as any);\n\n    await this.logAdminAction(adminId, 'BROADCAST_NOTIFICATION', {\n      totalUsers: 'ALL',\n      sent: 'ALL',\n      failed: 0,\n    });\n\n    typedLogger.info('Broadcast notification created (ALL users)');\n\n    return { totalUsers: 'ALL', sent: 'ALL', failed: 0 };\n  }\n\n  static async scheduleNotification(adminId: string, payload: ScheduledNotificationPayload) {\n    const normalizeType = (t?: any) => {\n      if (!t) return NotificationType.PUSH;\n      const val = (t as string).toLowerCase();\n      return (Object.values(NotificationType) as string[]).includes(val) ? (val as NotificationType) : NotificationType.PUSH;\n    };\n    const resolveDeliveryMethod = (type: NotificationType): 'push' | 'email' | 'inapp' | 'all' => {\n      if (type === NotificationType.IN_APP) return 'inapp';\n      if (type === NotificationType.PUSH || type === NotificationType.EMAIL) return type;\n      return 'all';\n    };\n\n    const { title, message, data, targetUserIds, scheduledFor } = payload;\n    const type = normalizeType(payload.type);\n\n    const scheduledDate = new Date(scheduledFor);\n    if (scheduledDate <= new Date()) {\n      throw new Error('Scheduled time must be in the future');\n    }\n\n    const targetIds = targetUserIds && targetUserIds.length > 0 ? targetUserIds : null;\n\n    if (targetIds) {\n      const notifications = await Promise.all(\n        targetIds.map((userId) =>\n          UnifiedNotificationService.sendNotification({\n            createdBy: adminId,\n            title,\n            message,\n            type: type as NotificationType,\n            deliveryMethod: resolveDeliveryMethod(type),\n            targetType: NotificationTargetType.USER,\n            targetValue: userId,\n            scheduledFor: scheduledDate.toISOString(),\n            metadata: data || {},\n          } as any)\n        )\n      );\n\n      await this.logAdminAction(adminId, 'SCHEDULE_NOTIFICATION', {\n        notificationIds: notifications.map((n: any) => n._id),\n        scheduledFor: scheduledDate,\n      });\n\n      return notifications;\n    }\n\n    const notification = await UnifiedNotificationService.sendNotification({\n      createdBy: adminId,\n      title,\n      message,\n      type: type as NotificationType,\n      deliveryMethod: resolveDeliveryMethod(type),\n      targetType: NotificationTargetType.ALL,\n      scheduledFor: scheduledDate.toISOString(),\n      metadata: data || {},\n    } as any);\n\n    await this.logAdminAction(adminId, 'SCHEDULE_NOTIFICATION', {\n      notificationId: (notification as any)._id,\n      scheduledFor: scheduledDate,\n    });\n\n    return notification;\n  }\n\n  static async getNotificationStats(period: string): Promise<NotificationStats> {\n    const now = new Date();\n    const todayStart = new Date(now.setHours(0, 0, 0, 0));\n    const weekStart = new Date(now);\n    weekStart.setDate(weekStart.getDate() - 7);\n\n    const [totalSent, sentToday, sentThisWeek, scheduled, failed] = await Promise.all([\n      Notification.countDocuments({ status: NotificationStatus.SENT || 'sent' }),\n      Notification.countDocuments({\n        status: NotificationStatus.SENT || 'sent',\n        createdAt: { $gte: todayStart },\n      }),\n      Notification.countDocuments({\n        status: NotificationStatus.SENT || 'sent',\n        createdAt: { $gte: weekStart },\n      }),\n      Notification.countDocuments({ status: NotificationStatus.SCHEDULED || 'scheduled' }),\n      Notification.countDocuments({ status: NotificationStatus.FAILED || 'failed' }),\n    ]);\n\n    return {\n      totalSent,\n      sentToday,\n      sentThisWeek,\n      scheduled,\n      failed,\n    };\n  }\n\n  static async getTemplates() {\n    const settings = await Settings.findOne({}, { 'custom.notificationsTemplates': 1 }).lean();\n    const templates = (settings as any)?.custom?.notificationsTemplates;\n    if (templates && Array.isArray(templates)) return templates;\n\n    return [\n      { id: 'prize_nearby', channel: 'push', name: 'Prize Nearby Alert', variables: ['prizeName', 'distance'] },\n      { id: 'prize_claimed', channel: 'push', name: 'Prize Claimed', variables: ['prizeName', 'points'] },\n      { id: 'level_up', channel: 'push', name: 'Level Up Notification', variables: ['newLevel', 'rewards'] },\n      { id: 'welcome_email', channel: 'email', name: 'Welcome Email', variables: ['userName', 'verificationLink'] },\n      { id: 'password_reset', channel: 'email', name: 'Password Reset', variables: ['resetLink'] },\n    ];\n  }\n\n  private static async saveTemplates(templates: any[]) {\n    await Settings.findOneAndUpdate(\n      {},\n      { $set: { 'custom.notificationsTemplates': templates, updatedAt: new Date() } },\n      { upsert: true }\n    );\n    return templates;\n  }\n\n  static async createTemplate(adminId: string, template: { id?: string; name: string; channel: string; variables?: string[]; content?: any }) {\n    const templates = await this.getTemplates();\n    const id = template.id || randomUUID();\n    const entry = { id, name: template.name, channel: template.channel, variables: template.variables || [], content: template.content || {} };\n    const updated = [...templates, entry];\n    await this.saveTemplates(updated);\n    \n    // Audit log for template creation\n    await this.logAdminAction(adminId, 'CREATE_NOTIFICATION_TEMPLATE', {\n      templateId: id,\n      templateName: template.name,\n      channel: template.channel,\n    });\n    \n    return entry;\n  }\n\n  static async updateTemplate(adminId: string, templateId: string, changes: Partial<{ name: string; channel: string; variables: string[]; content: any }>) {\n    const templates = await this.getTemplates();\n    const idx = templates.findIndex((t: any) => t.id === templateId);\n    if (idx === -1) throw new Error('TEMPLATE_NOT_FOUND');\n    const updatedTemplate = { ...templates[idx], ...changes };\n    templates[idx] = updatedTemplate;\n    await this.saveTemplates(templates);\n    \n    // Audit log for template update\n    await this.logAdminAction(adminId, 'UPDATE_NOTIFICATION_TEMPLATE', {\n      templateId,\n      changedFields: Object.keys(changes),\n    });\n    \n    return updatedTemplate;\n  }\n\n  static async deleteTemplate(adminId: string, templateId: string) {\n    const templates = await this.getTemplates();\n    const template = templates.find((t: any) => t.id === templateId);\n    const filtered = templates.filter((t: any) => t.id !== templateId);\n    if (filtered.length === templates.length) throw new Error('TEMPLATE_NOT_FOUND');\n    await this.saveTemplates(filtered);\n    \n    // Audit log for template deletion\n    await this.logAdminAction(adminId, 'DELETE_NOTIFICATION_TEMPLATE', {\n      templateId,\n      templateName: template?.name,\n    });\n    \n    return { success: true };\n  }\n\n  private static async logAdminAction(\n    adminId: string,\n    action: string,\n    details: Record<string, any>\n  ): Promise<void> {\n    // Use unified audit logger - writes to both Pino and MongoDB\n    await audit.custom({\n      userId: adminId,\n      userRole: 'admin',\n      action,\n      resource: 'notification',\n      category: 'admin',\n      severity: 'low',\n      metadata: details,\n    });\n  }\n}\n\nexport default AdminNotificationsService;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\admin\\services\\admin-partners.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\admin\\services\\admin-power-ups.service.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":17,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[608,611],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[608,611],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":30,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[869,872],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[869,872],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":117,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":117,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3348,3351],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3348,3351],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":197,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":197,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5795,5798],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5795,5798],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-useless-catch","severity":2,"message":"Unnecessary try/catch wrapper.","line":293,"column":5,"nodeType":"TryStatement","messageId":"unnecessaryCatch","endLine":332,"endColumn":6},{"ruleId":"no-useless-catch","severity":2,"message":"Unnecessary try/catch wrapper.","line":339,"column":5,"nodeType":"TryStatement","messageId":"unnecessaryCatch","endLine":379,"endColumn":6},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":385,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":385,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11809,11812],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11809,11812],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import PowerUpModel, { IPowerUp } from '@/models/PowerUp.js';\r\nimport { Types } from 'mongoose';\r\nimport { CacheService } from '@/services/cache.js';\r\nimport { configService } from '@/services/config.js';\r\nimport { typedLogger } from '@/lib/typed-logger.js';\r\n\r\nexport interface CreatePowerUpDto {\r\n  name: string;\r\n  description: string;\r\n  type: 'radar_boost' | 'double_points' | 'speed_boost' | 'shield' | 'time_extension';\r\n  icon?: string;\r\n  rarity?: 'common' | 'rare' | 'epic' | 'legendary';\r\n  durationMs: number;\r\n  dropRate: number;\r\n  maxPerSession: number;\r\n  maxInInventory: number;\r\n  effects: any;\r\n  notes?: string;\r\n}\r\n\r\nexport interface UpdatePowerUpDto {\r\n  name?: string;\r\n  description?: string;\r\n  icon?: string;\r\n  rarity?: string;\r\n  durationMs?: number;\r\n  dropRate?: number;\r\n  maxPerSession?: number;\r\n  maxInInventory?: number;\r\n  effects?: any;\r\n  enabled?: boolean;\r\n  notes?: string;\r\n}\r\n\r\nexport class PowerUpAdminService {\r\n  private static readonly CACHE_TTL = 600; // 10 minutes\r\n  private static readonly POWER_UPS_CACHE_KEY = 'power-ups:list';\r\n  private static readonly POWER_UP_CACHE_KEY = (id: string) => `power-up:${id}`;\r\n\r\n  /**\r\n   * Create a new power-up\r\n   */\r\n  static async createPowerUp(\r\n    adminId: Types.ObjectId,\r\n    data: CreatePowerUpDto\r\n  ): Promise<IPowerUp> {\r\n    try {\r\n      // Validate drop rate\r\n      if (data.dropRate < 0 || data.dropRate > 100) {\r\n        throw new Error('Drop rate must be between 0 and 100');\r\n      }\r\n\r\n      // Validate effects based on type\r\n      this.validateEffects(data.type, data.effects);\r\n\r\n      const powerUp = new PowerUpModel({\r\n        ...data,\r\n        enabled: true, // Explicitly set enabled to true for new power-ups\r\n        createdBy: adminId,\r\n        lastModifiedBy: adminId,\r\n        totalCreated: 0,\r\n        totalClaimed: 0,\r\n        activeInstances: 0,\r\n        usageCount: 0,\r\n      });\r\n\r\n      await powerUp.save();\r\n\r\n      // Update config\r\n      await configService.updateConfigSection(\r\n        'powerUps',\r\n        { enabled: true },\r\n        adminId.toString()\r\n      );\r\n\r\n      // Clear ALL power-up related caches (list and individual)\r\n      await CacheService.invalidate('power-ups:*');\r\n      await CacheService.invalidate('power-up:*');\r\n\r\n      typedLogger.audit('PowerUp created successfully', {\r\n        powerUpId: powerUp._id.toString(),\r\n        name: powerUp.name,\r\n        type: powerUp.type,\r\n        rarity: powerUp.rarity,\r\n        adminId: adminId.toString(),\r\n        timestamp: new Date().toISOString(),\r\n      });\r\n\r\n      return powerUp;\r\n    } catch (error) {\r\n      typedLogger.error('Error creating power-up', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n        adminId: adminId.toString(),\r\n        data: { name: data.name, type: data.type },\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all power-ups with optional filtering\r\n   */\r\n  static async getAllPowerUps(filters?: {\r\n    enabled?: boolean;\r\n    type?: string;\r\n    rarity?: string;\r\n  }): Promise<IPowerUp[]> {\r\n    try {\r\n      const cacheKey = `${this.POWER_UPS_CACHE_KEY}:${JSON.stringify(filters || {})}`;\r\n      \r\n      // Try cache first\r\n      const cached = await CacheService.get(cacheKey);\r\n      if (cached) {\r\n        return JSON.parse(cached);\r\n      }\r\n\r\n      const query: any = {};\r\n      if (filters?.enabled !== undefined) query.enabled = filters.enabled;\r\n      if (filters?.type) query.type = filters.type;\r\n      if (filters?.rarity) query.rarity = filters.rarity;\r\n\r\n      const powerUps = await PowerUpModel.find(query).sort({ createdAt: -1 });\r\n\r\n      // Cache results\r\n      await CacheService.set(cacheKey, JSON.stringify(powerUps), { ttl: this.CACHE_TTL });\r\n\r\n      typedLogger.debug('Power-ups fetched from database', {\r\n        count: powerUps.length,\r\n        filters: filters || {},\r\n      });\r\n\r\n      return powerUps;\r\n    } catch (error) {\r\n      typedLogger.error('Error fetching power-ups', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n        filters: filters || {},\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get single power-up by ID\r\n   */\r\n  static async getPowerUpById(powerUpId: string | Types.ObjectId): Promise<IPowerUp> {\r\n    try {\r\n      const cacheKey = this.POWER_UP_CACHE_KEY(powerUpId.toString());\r\n      \r\n      // Try cache first\r\n      const cached = await CacheService.get(cacheKey);\r\n      if (cached) {\r\n        return JSON.parse(cached);\r\n      }\r\n\r\n      const powerUp = await PowerUpModel.findById(powerUpId);\r\n      if (!powerUp) {\r\n        throw new Error(`PowerUp not found: ${powerUpId}`);\r\n      }\r\n\r\n      // Cache result\r\n      await CacheService.set(cacheKey, JSON.stringify(powerUp), { ttl: this.CACHE_TTL });\r\n\r\n      typedLogger.debug('Power-up retrieved', {\r\n        powerUpId: powerUpId.toString(),\r\n        name: powerUp.name,\r\n      });\r\n\r\n      return powerUp;\r\n    } catch (error) {\r\n      typedLogger.error('Error fetching power-up by ID', {\r\n        powerUpId: powerUpId.toString(),\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update power-up\r\n   */\r\n  static async updatePowerUp(\r\n    powerUpId: string | Types.ObjectId,\r\n    adminId: Types.ObjectId,\r\n    data: UpdatePowerUpDto\r\n  ): Promise<IPowerUp> {\r\n    try {\r\n      // Validate drop rate if provided\r\n      if (data.dropRate !== undefined) {\r\n        if (data.dropRate < 0 || data.dropRate > 100) {\r\n          throw new Error('Drop rate must be between 0 and 100');\r\n        }\r\n      }\r\n\r\n      // Validate effects if provided\r\n      const existingPowerUp = await this.getPowerUpById(powerUpId);\r\n      if (data.effects) {\r\n        const typeToValidate = (data as any).type || existingPowerUp.type;\r\n        this.validateEffects(typeToValidate, data.effects);\r\n      }\r\n\r\n      const powerUp = await PowerUpModel.findByIdAndUpdate(\r\n        powerUpId,\r\n        {\r\n          ...data,\r\n          lastModifiedBy: adminId,\r\n        },\r\n        { new: true, runValidators: true }\r\n      );\r\n\r\n      if (!powerUp) {\r\n        throw new Error(`PowerUp not found: ${powerUpId}`);\r\n      }\r\n\r\n      // Clear cache\r\n      await CacheService.invalidate(`power-up:${powerUpId}`, 'power-ups');\r\n\r\n      typedLogger.audit('PowerUp updated via API', {\r\n        powerUpId: powerUpId.toString(),\r\n        adminId: adminId.toString(),\r\n        changedFields: Object.keys(data),\r\n        timestamp: new Date().toISOString(),\r\n      });\r\n\r\n      return powerUp;\r\n    } catch (error) {\r\n      typedLogger.error('Error updating power-up', {\r\n        powerUpId: powerUpId.toString(),\r\n        adminId: adminId.toString(),\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update power-up drop rate\r\n   */\r\n  static async updateDropRate(\r\n    powerUpId: string | Types.ObjectId,\r\n    adminId: Types.ObjectId,\r\n    dropRate: number\r\n  ): Promise<IPowerUp> {\r\n    if (dropRate < 0 || dropRate > 100) {\r\n      typedLogger.warn('Invalid drop rate provided', {\r\n        powerUpId: powerUpId.toString(),\r\n        dropRate,\r\n        adminId: adminId.toString(),\r\n      });\r\n      throw new Error('Drop rate must be between 0 and 100');\r\n    }\r\n\r\n    return this.updatePowerUp(powerUpId, adminId, { dropRate });\r\n  }\r\n\r\n  /**\r\n   * Delete power-up\r\n   */\r\n  static async deletePowerUp(\r\n    powerUpId: string | Types.ObjectId,\r\n    adminId: Types.ObjectId\r\n  ): Promise<void> {\r\n    try {\r\n      const result = await PowerUpModel.findByIdAndDelete(powerUpId);\r\n      \r\n      if (!result) {\r\n        throw new Error(`PowerUp not found: ${powerUpId}`);\r\n      }\r\n\r\n      // Clear cache\r\n      await CacheService.invalidate(`power-up:${powerUpId}`, 'power-ups');\r\n\r\n      typedLogger.audit('PowerUp deleted', {\r\n        powerUpId: powerUpId.toString(),\r\n        adminId: adminId.toString(),\r\n        deletedName: result.name,\r\n        timestamp: new Date().toISOString(),\r\n      });\r\n    } catch (error) {\r\n      typedLogger.error('Error deleting power-up', {\r\n        powerUpId: powerUpId.toString(),\r\n        adminId: adminId.toString(),\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n      throw error;\r\n    \r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get power-up analytics\r\n   */\r\n  static async getPowerUpAnalytics(powerUpId: string | Types.ObjectId) {\r\n    try {\r\n      const powerUp = await this.getPowerUpById(powerUpId);\r\n\r\n      // Calculate metrics\r\n      const claimRate =\r\n        powerUp.totalCreated > 0\r\n          ? (powerUp.totalClaimed / powerUp.totalCreated) * 100\r\n          : 0;\r\n      const adoptionRate = \r\n        powerUp.totalClaimed > 0 \r\n          ? (powerUp.activeInstances / powerUp.totalClaimed) * 100 \r\n          : 0;\r\n\r\n      return {\r\n        powerUpId: powerUp._id,\r\n        name: powerUp.name,\r\n        type: powerUp.type,\r\n        rarity: powerUp.rarity,\r\n        stats: {\r\n          totalCreated: powerUp.totalCreated,\r\n          totalClaimed: powerUp.totalClaimed,\r\n          activeInstances: powerUp.activeInstances,\r\n          usageCount: powerUp.usageCount,\r\n        },\r\n        metrics: {\r\n          claimRate: Math.round(claimRate * 100) / 100,\r\n          adoptionRate: Math.round(adoptionRate * 100) / 100,\r\n          averageUsagePerSession: Math.round(powerUp.averageUsagePerSession * 100) / 100,\r\n        },\r\n        configuration: {\r\n          enabled: powerUp.enabled,\r\n          dropRate: powerUp.dropRate,\r\n          durationMs: powerUp.durationMs,\r\n          maxPerSession: powerUp.maxPerSession,\r\n          maxInInventory: powerUp.maxInInventory,\r\n        },\r\n      };\r\n    } catch (error) {\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all power-ups analytics\r\n   */\r\n  static async getAllPowerUpsAnalytics() {\r\n    try {\r\n      const powerUps = await this.getAllPowerUps({ enabled: true });\r\n      \r\n      const analytics = await Promise.all(\r\n        powerUps.map(pu => this.getPowerUpAnalytics(pu._id))\r\n      );\r\n\r\n      const summary = {\r\n        totalPowerUps: analytics.length,\r\n        totalCreated: analytics.reduce((sum, a) => sum + a.stats.totalCreated, 0),\r\n        totalClaimed: analytics.reduce((sum, a) => sum + a.stats.totalClaimed, 0),\r\n        totalActiveInstances: analytics.reduce((sum, a) => sum + a.stats.activeInstances, 0),\r\n        totalUsageCount: analytics.reduce((sum, a) => sum + a.stats.usageCount, 0),\r\n        averageClaimRate: Math.round(\r\n          analytics.reduce((sum, a) => sum + a.metrics.claimRate, 0) / analytics.length * 100\r\n        ) / 100,\r\n        averageAdoptionRate: Math.round(\r\n          analytics.reduce((sum, a) => sum + a.metrics.adoptionRate, 0) / analytics.length * 100\r\n        ) / 100,\r\n        byRarity: {\r\n          common: analytics.filter(a => a.rarity === 'common').length,\r\n          rare: analytics.filter(a => a.rarity === 'rare').length,\r\n          epic: analytics.filter(a => a.rarity === 'epic').length,\r\n          legendary: analytics.filter(a => a.rarity === 'legendary').length,\r\n        },\r\n        byType: {\r\n          radar_boost: analytics.filter(a => a.type === 'radar_boost').length,\r\n          double_points: analytics.filter(a => a.type === 'double_points').length,\r\n          speed_boost: analytics.filter(a => a.type === 'speed_boost').length,\r\n          shield: analytics.filter(a => a.type === 'shield').length,\r\n          time_extension: analytics.filter(a => a.type === 'time_extension').length,\r\n        },\r\n      };\r\n\r\n      return {\r\n        summary,\r\n        powerUps: analytics,\r\n      };\r\n    } catch (error) {\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate power-up effects based on type\r\n   */\r\n  private static validateEffects(type: string, effects: any) {\r\n    if (!effects) {\r\n      throw new Error('Effects are required');\r\n    }\r\n\r\n    switch (type) {\r\n      case 'radar_boost':\r\n        if (!effects.radarBoost?.radiusMultiplier) {\r\n          throw new Error('radarBoost.radiusMultiplier required for radar_boost type');\r\n        }\r\n        if (effects.radarBoost.radiusMultiplier < 1 || effects.radarBoost.radiusMultiplier > 5) {\r\n          throw new Error('radiusMultiplier must be between 1 and 5');\r\n        }\r\n        break;\r\n\r\n      case 'double_points':\r\n        if (!effects.doublePoints?.pointsMultiplier) {\r\n          throw new Error('doublePoints.pointsMultiplier required for double_points type');\r\n        }\r\n        if (effects.doublePoints.pointsMultiplier < 1.5 || effects.doublePoints.pointsMultiplier > 10) {\r\n          throw new Error('pointsMultiplier must be between 1.5 and 10');\r\n        }\r\n        break;\r\n\r\n      case 'speed_boost':\r\n        if (!effects.speedBoost?.speedMultiplier) {\r\n          throw new Error('speedBoost.speedMultiplier required for speed_boost type');\r\n        }\r\n        if (effects.speedBoost.speedMultiplier < 1.1 || effects.speedBoost.speedMultiplier > 3) {\r\n          throw new Error('speedMultiplier must be between 1.1 and 3');\r\n        }\r\n        break;\r\n\r\n      case 'shield':\r\n        if (!effects.shield?.damageMitigation) {\r\n          throw new Error('shield.damageMitigation required for shield type');\r\n        }\r\n        if (effects.shield.damageMitigation < 0 || effects.shield.damageMitigation > 1) {\r\n          throw new Error('damageMitigation must be between 0 and 1');\r\n        }\r\n        break;\r\n\r\n      case 'time_extension':\r\n        if (!effects.timeExtension?.additionalTimeMs) {\r\n          throw new Error('timeExtension.additionalTimeMs required for time_extension type');\r\n        }\r\n        if (effects.timeExtension.additionalTimeMs < 1000 || effects.timeExtension.additionalTimeMs > 600000) {\r\n          throw new Error('additionalTimeMs must be between 1000 and 600000');\r\n        }\r\n        break;\r\n\r\n      default:\r\n        throw new Error(`Unknown power-up type: ${type}`);\r\n    }\r\n  }\r\n}\r\n\r\nexport default PowerUpAdminService;\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\admin\\services\\admin-prizes.service.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":88,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2045,2048],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2045,2048],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":121,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":121,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2695,2698],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2695,2698],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":170,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":170,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5068,5071],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5068,5071],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":239,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":239,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6751,6754],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6751,6754],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":292,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":292,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8070,8073],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8070,8073],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Types } from 'mongoose';\nimport { Prize } from '@/models';\nimport { PrizeService } from '@/modules/prizes';\nimport { audit } from '@/lib/audit-logger';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { LocationType, Metadata, PrizeCategory, PrizeRarity, PrizeStatus, PrizeType } from '@/types';\nimport { findNearestCity } from '@/utils/geo';\n\ninterface GetPrizesOptions {\n  page?: number;\n  limit?: number;\n  status?: string;\n  category?: string;\n  rarity?: string;\n  city?: string;\n  search?: string;\n}\n\nexport class AdminPrizesService {\n  static async getPrizes(options: GetPrizesOptions) {\n    const {\n      page = 1,\n      limit = 20,\n      status,\n      category,\n      rarity,\n      city,\n      search,\n    } = options;\n\n    const query: Record<string, unknown> = {};\n\n    if (status) {\n      query.status = status === 'claimed' ? 'captured' : status;\n    }\n\n    if (category) {\n      query.category = category;\n    }\n\n    if (rarity) {\n      query.rarity = rarity;\n    }\n\n    if (city) {\n      query['location.city'] = city;\n    }\n\n    if (search) {\n      query.$or = [\n        { name: { $regex: search, $options: 'i' } },\n        { description: { $regex: search, $options: 'i' } },\n        { 'location.city': { $regex: search, $options: 'i' } },\n      ];\n    }\n\n    const skip = (page - 1) * limit;\n\n    const [prizes, total, statsAggregation] = await Promise.all([\n      Prize.find(query)\n        .sort({ createdAt: -1 })\n        .skip(skip)\n        .limit(limit)\n        .lean(),\n      Prize.countDocuments(query),\n      // Get stats for ALL prizes (not filtered)\n      Prize.aggregate([\n        {\n          $group: {\n            _id: '$status',\n            count: { $sum: 1 }\n          }\n        }\n      ])\n    ]);\n\n    // Transform aggregation to stats object\n    const stats = {\n      active: 0,\n      captured: 0,\n      expired: 0,\n      inactive: 0,\n      revoked: 0,\n      total: 0\n    };\n    statsAggregation.forEach((item: { _id: string; count: number }) => {\n      if (item._id in stats) {\n        (stats as any)[item._id] = item.count;\n      }\n      stats.total += item.count;\n    });\n\n    return {\n      prizes,\n      pagination: {\n        page,\n        limit,\n        total,\n        pages: Math.ceil(total / limit),\n      },\n      stats,\n    };\n  }\n\n  static async getPrize(prizeId: string) {\n    if (!Types.ObjectId.isValid(prizeId)) {\n      throw new Error('Invalid prize ID');\n    }\n\n    const prize = await Prize.findById(prizeId).lean();\n\n    if (!prize) {\n      throw new Error('Prize not found');\n    }\n\n    return prize;\n  }\n\n  static async createPrize(prizeData: Record<string, unknown>, adminId: string) {\n    try {\n      const p = prizeData as any;\n      const lat = typeof p.latitude === 'number' ? p.latitude : 36.8065;\n      const lng = typeof p.longitude === 'number' ? p.longitude : 10.1815;\n      const city = p.city || findNearestCity({ lat, lng });\n      const rewardId = p.directReward?.rewardId || p.metadata?.rewardId;\n      const probability = p.directReward?.probability ?? p.metadata?.probability ?? (p.contentType === 'hybrid' ? 0.5 : 1);\n      const safePoints = Math.max(1, Number(p.value ?? p.points ?? p.pointsReward?.amount ?? 0) || 1);\n\n      const normalizedStatus =\n        p.status === 'claimed' ? 'captured' : (p.status as string) || 'active';\n\n      const mappedData = {\n        name: p.name as string,\n        description: (p.description as string) || 'Reward to discover on the map',\n        type: (p.type as string) || PrizeType.PHYSICAL,\n        displayType: (p.displayType as string) || 'standard',\n        contentType: (p.contentType as string) || 'points',\n        category: ([...Object.values(PrizeCategory)].includes(p.category) ? p.category : PrizeCategory.LIFESTYLE) as PrizeCategory,\n        rarity: ([...Object.values(PrizeRarity)].includes(p.rarity) ? p.rarity : PrizeRarity.COMMON) as PrizeRarity,\n        points: safePoints,\n        pointsReward: {\n          amount: safePoints,\n          bonusMultiplier: (p.metadata?.bonusMultiplier as number) || 1,\n        },\n        directReward: rewardId ? {\n          rewardId: new Types.ObjectId(rewardId as string),\n          autoRedeem: true,\n          probability: probability,\n        } : undefined,\n        quantity: (p.quantity as number) ?? 1,\n        createdBy: new Types.ObjectId(adminId),\n        location: {\n          type: LocationType.GPS,\n          coordinates: [lng, lat],\n          radius: (p.radius as number) ?? 50,\n          city,\n          address: p.address as string | undefined,\n          markerUrl: p.markerUrl as string | undefined,\n          confidenceThreshold: (p.confidenceThreshold as number) ?? 0.8\n        },\n        visibility: p.visibility,\n        expiresAt: p.expiresAt as Date | undefined,\n        imageUrl: p.imageUrl as string | undefined,\n        value: (p.value as number) ?? 0,\n        tags: (p.tags as string[]) || [],\n        status: normalizedStatus,\n        metadata: p.metadata as Metadata | undefined,\n      };\n\n      const prize = await PrizeService.createPrize(adminId, mappedData as any);\n\n      await this.logAction(adminId, 'CREATE_PRIZE', prize._id.toString(), {\n        prizeName: prize.name,\n      });\n\n      typedLogger.info('Admin created prize', {\n        adminId,\n        prizeId: prize._id,\n        prizeName: prize.name,\n      });\n\n      return prize;\n    } catch (error) {\n      typedLogger.error('Failed to create prize', { adminId, error });\n      throw error;\n    }\n  }\n\n  static async updatePrize(\n    updateData: Record<string, unknown>,\n    prizeId: string,\n    adminId: string\n  ) {\n    if (!Types.ObjectId.isValid(prizeId)) {\n      throw new Error('Invalid prize ID');\n    }\n\n    try {\n      const mappedUpdate = { ...updateData };\n      if (mappedUpdate.status === 'claimed') {\n        mappedUpdate.status = 'captured';\n      }\n\n      const prize = await PrizeService.updatePrize(adminId, prizeId, mappedUpdate);\n\n      if (!prize) {\n        throw new Error('Prize not found');\n      }\n\n      await this.logAction(adminId, 'UPDATE_PRIZE', prizeId, {\n        updatedFields: Object.keys(mappedUpdate),\n      });\n\n      typedLogger.info('Admin updated prize', {\n        adminId,\n        prizeId,\n        updatedFields: Object.keys(mappedUpdate),\n      });\n\n      return prize;\n    } catch (error) {\n      typedLogger.error('Failed to update prize', { adminId, prizeId, error });\n      throw error;\n    }\n  }\n\n  static async deletePrize(prizeId: string, adminId: string) {\n    if (!Types.ObjectId.isValid(prizeId)) {\n      throw new Error('Invalid prize ID');\n    }\n\n    try {\n      const prize = await Prize.findById(prizeId);\n\n      if (!prize) {\n        throw new Error('Prize not found');\n      }\n      if (!prize.createdBy) {\n        (prize as any).createdBy = new Types.ObjectId(adminId);\n      }\n\n      const prizeName = prize.name;\n\n      await PrizeService.deletePrize(adminId, prizeId);\n\n      await this.logAction(adminId, 'DELETE_PRIZE', prizeId, {\n        prizeName,\n      });\n\n      typedLogger.info('Admin deleted prize', {\n        adminId,\n        prizeId,\n        prizeName,\n      });\n\n      return { success: true, deletedPrizeId: prizeId };\n    } catch (error) {\n      typedLogger.error('Failed to delete prize', { adminId, prizeId, error });\n      throw error;\n    }\n  }\n\n  private static async logAction(\n    adminId: string,\n    action: string,\n    prizeId: string,\n    details: Metadata\n  ) {\n    // Use unified audit logger - writes to both Pino and MongoDB\n    await audit.custom({\n      userId: adminId,\n      userRole: 'admin',\n      action,\n      resource: 'prize',\n      resourceId: prizeId,\n      category: 'admin',\n      severity: action.includes('DELETE') ? 'medium' : 'low',\n      metadata: details,\n    });\n  }\n\n  // Find nearby prizes for admin map/debug\n  static async getNearbyPrizes(lat: number, lng: number, radius: number = 5000) {\n    const point = {\n      type: 'Point',\n      coordinates: [lng, lat]\n    };\n\n    const prizes = await Prize.find({\n      'location.coordinates': {\n        $near: {\n          $geometry: point as any,\n          $maxDistance: radius\n        }\n      },\n      status: PrizeStatus.ACTIVE\n    })\n      .limit(50)\n      .lean();\n\n    return prizes;\n  }\n}\n\nexport default AdminPrizesService;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\admin\\services\\admin-rewards.service.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":26,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[749,752],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[749,752],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":65,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":65,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2028,2031],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2028,2031],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":86,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":86,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2590,2593],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2590,2593],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":94,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":94,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2735,2738],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2735,2738],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":121,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":121,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3538,3541],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3538,3541],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":129,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":129,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3712,3715],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3712,3715],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":143,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":143,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4231,4234],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4231,4234],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":188,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":188,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5894,5897],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5894,5897],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":219,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":219,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6806,6809],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6806,6809],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":251,"column":79,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":251,"endColumn":82,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7794,7797],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7794,7797],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":270,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":270,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8392,8395],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8392,8395],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":275,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":275,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8613,8616],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8613,8616],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":282,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":282,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8835,8838],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8835,8838],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":290,"column":96,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":290,"endColumn":99,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9035,9038],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9035,9038],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Reward } from '@/models/Reward';\nimport { audit } from '@/lib/audit-logger';\nimport { Types } from 'mongoose';\nimport { typedLogger } from '@/lib/typed-logger';\n\nexport interface RewardQueryOptions {\n  page?: number;\n  limit?: number;\n  category?: string;\n  status?: string;\n  minCost?: number;\n  maxCost?: number;\n  search?: string;\n}\n\nexport class AdminRewardsService {\n  /**\n   * Get rewards with admin capabilities (all rewards regardless of availability)\n   */\n  static async getRewards(query: RewardQueryOptions = {}) {\n    try {\n      const page = parseInt(String(query.page)) || 1;\n      const limit = Math.min(100, Math.max(1, parseInt(String(query.limit)) || 50));\n      const skip = (page - 1) * limit;\n\n      const filterQuery: any = {};\n\n      if (query.category) filterQuery.category = query.category;\n      if (query.status && query.status !== 'all') {\n        filterQuery.isActive = query.status === 'active';\n      }\n      if (query.minCost) filterQuery.pointsCost = { $gte: parseInt(String(query.minCost)) };\n      if (query.maxCost) {\n        filterQuery.pointsCost = { ...filterQuery.pointsCost, $lte: parseInt(String(query.maxCost)) };\n      }\n      if (query.search) {\n        filterQuery.$or = [\n          { name: { $regex: query.search, $options: 'i' } },\n          { description: { $regex: query.search, $options: 'i' } },\n        ];\n      }\n\n      const [rewards, total] = await Promise.all([\n        Reward.find(filterQuery)\n          .populate('partnerId', 'name logo')\n          .sort({ createdAt: -1 })\n          .skip(skip)\n          .limit(limit),\n        Reward.countDocuments(filterQuery),\n      ]);\n\n      return {\n        rewards: rewards.map(reward => reward.toJSON()),\n        pagination: {\n          page,\n          limit,\n          total,\n          pages: Math.ceil(total / limit),\n          hasNext: skip + limit < total,\n          hasPrev: page > 1,\n        },\n        total,\n      };\n    } catch (error) {\n      typedLogger.error('Admin get rewards error', { error: (error as any).message, query });\n      throw error;\n    }\n  }\n\n  /**\n   * Get single reward by ID\n   */\n  static async getReward(rewardId: string) {\n    try {\n      // Validate ObjectId\n      if (!Types.ObjectId.isValid(rewardId)) {\n        throw new Error('REWARD_NOT_FOUND');\n      }\n\n      const reward = await Reward.findById(rewardId).populate('partnerId', 'name logo');\n      if (!reward) {\n        throw new Error('REWARD_NOT_FOUND');\n      }\n      return reward.toJSON();\n    } catch (error) {\n      typedLogger.error('Admin get reward error', { error: (error as any).message, rewardId });\n      throw error;\n    }\n  }\n\n  /**\n   * Create a new reward\n   */\n  static async createReward(adminId: string, data: any) {\n    try {\n      const { name, description, category, pointsCost, stockQuantity, ...rest } = data;\n\n      const reward = new Reward({\n        name,\n        description,\n        category,\n        pointsCost,\n        stockQuantity,\n        stockAvailable: stockQuantity,\n        stockReserved: 0,\n        ...rest,\n        createdBy: new Types.ObjectId(adminId),\n      });\n\n      await reward.save();\n      await this.logAction(adminId, 'create_reward', reward._id.toString(), {\n        rewardId: reward._id,\n        name: reward.name,\n        pointsCost: reward.pointsCost,\n      });\n\n      typedLogger.info('Admin reward created', { adminId, rewardId: reward._id, name });\n\n      return reward.toJSON();\n    } catch (error) {\n      typedLogger.error('Admin create reward error', { error: (error as any).message, adminId, data });\n      throw error;\n    }\n  }\n\n  /**\n   * Update an existing reward\n   */\n  static async updateReward(adminId: string, rewardId: string, data: any) {\n    try {\n      // Validate ObjectId\n      if (!Types.ObjectId.isValid(rewardId)) {\n        throw new Error('REWARD_NOT_FOUND');\n      }\n\n      const existing =\n        data.stockQuantity !== undefined\n          ? await Reward.findById(rewardId).select('stockQuantity stockAvailable stockReserved')\n          : null;\n\n      // Build update object with allowed fields only\n      const allowedFields = ['name', 'description', 'category', 'pointsCost', 'imageUrl', 'isActive', 'isPopular'];\n      const updateData: any = {};\n      \n      Object.keys(data).forEach(key => {\n        if (allowedFields.includes(key) && data[key] !== undefined) {\n          updateData[key] = data[key];\n        }\n      });\n\n      // Handle stockQuantity separately (update stockAvailable accordingly)\n      if (data.stockQuantity !== undefined) {\n        updateData.stockQuantity = data.stockQuantity;\n        if (existing) {\n          const diff = data.stockQuantity - (existing.stockQuantity || 0);\n          const reserved = existing.stockReserved || 0;\n          const maxAvailable = Math.max(0, data.stockQuantity - reserved);\n          const nextAvailable = Math.max(0, (existing.stockAvailable || 0) + diff);\n          updateData.stockAvailable = Math.min(nextAvailable, maxAvailable);\n        }\n      }\n\n      // Only set updatedBy if adminId is a valid ObjectId\n      if (Types.ObjectId.isValid(adminId)) {\n        updateData.updatedBy = new Types.ObjectId(adminId);\n      }\n\n      // Use findByIdAndUpdate to avoid triggering full validation on legacy documents\n      const reward = await Reward.findByIdAndUpdate(\n        rewardId,\n        { $set: updateData },\n        { new: true, runValidators: false } // Don't run validators on update\n      );\n\n      if (!reward) {\n        throw new Error('REWARD_NOT_FOUND');\n      }\n\n      await this.logAction(adminId, 'update_reward', reward._id.toString(), {\n        rewardId: reward._id,\n        updates: Object.keys(data),\n      });\n\n      typedLogger.info('Admin reward updated', { adminId, rewardId: reward._id });\n\n      return reward.toJSON();\n    } catch (error) {\n      typedLogger.error('Admin update reward error', { error: (error as any).message, adminId, rewardId, data });\n      throw error;\n    }\n  }\n\n  /**\n   * Delete a reward (soft delete)\n   */\n  static async deleteReward(adminId: string, rewardId: string) {\n    try {\n      // Validate ObjectId\n      if (!Types.ObjectId.isValid(rewardId)) {\n        throw new Error('REWARD_NOT_FOUND');\n      }\n\n      // Use updateOne to avoid triggering full validation on legacy documents\n      const result = await Reward.updateOne(\n        { _id: rewardId },\n        { $set: { isActive: false } }\n      );\n\n      if (result.matchedCount === 0) {\n        throw new Error('REWARD_NOT_FOUND');\n      }\n\n      await this.logAction(adminId, 'delete_reward', rewardId, { rewardId });\n\n      typedLogger.info('Admin reward deleted', { adminId, rewardId });\n\n      return { success: true, deletedId: rewardId };\n    } catch (error) {\n      typedLogger.error('Admin delete reward error', { error: (error as any).message, adminId, rewardId });\n      throw error;\n    }\n  }\n\n  /**\n   * Update reward stock\n   */\n  static async updateRewardStock(adminId: string, rewardId: string, quantity: number) {\n    try {\n      const reward = await Reward.findById(rewardId);\n      if (!reward) {\n        throw new Error('REWARD_NOT_FOUND');\n      }\n\n      const previousQuantity = reward.stockQuantity;\n      const diff = quantity - reward.stockQuantity;\n      reward.stockQuantity = quantity;\n      reward.stockAvailable = Math.max(0, reward.stockAvailable + diff);\n\n      await reward.save();\n\n      await this.logAction(adminId, 'update_reward_stock', reward._id.toString(), {\n        rewardId: reward._id,\n        quantity,\n        previousQuantity,\n      });\n\n      typedLogger.info('Admin reward stock updated', { adminId, rewardId: reward._id, newQuantity: quantity });\n\n      return reward.toJSON();\n    } catch (error) {\n      typedLogger.error('Admin update reward stock error', { error: (error as any).message, adminId, rewardId, quantity });\n      throw error;\n    }\n  }\n\n  /**\n   * Get rewards analytics\n   */\n  static async getRewardAnalytics(period: string = '30d') {\n    try {\n      const days = parseInt(String(period).replace('d', '')) || 30;\n      const start = new Date();\n      start.setDate(start.getDate() - days);\n\n      const [byCategory, lowStock] = await Promise.all([\n        Reward.aggregate([\n          { $match: { createdAt: { $gte: start } } },\n          { $group: { _id: '$category', count: { $sum: 1 }, avgCost: { $avg: '$pointsCost' } } },\n        ]),\n        (Reward as any).getLowStockRewards?.(10) || Reward.find({ isActive: true, stockAvailable: { $lte: 10, $gt: 0 } }).limit(10),\n      ]);\n\n      return {\n        byCategory,\n        lowStock: Array.isArray(lowStock) ? lowStock.map((r: any) => ({\n          id: r._id,\n          name: r.name,\n          stockAvailable: r.stockAvailable,\n        })) : [],\n      };\n    } catch (error) {\n      typedLogger.error('Get reward analytics error', { error: (error as any).message, period });\n      throw error;\n    }\n  }\n\n  /**\n   * Log admin action for audit trail\n   */\n  private static async logAction(adminId: string, action: string, resourceId: string, details: any) {\n    // Use unified audit logger - writes to both Pino and MongoDB\n    await audit.custom({\n      userId: adminId,\n      userRole: 'admin',\n      action: action.toUpperCase(),\n      resource: 'reward',\n      resourceId,\n      category: 'admin',\n      severity: action.includes('delete') ? 'medium' : 'low',\n      metadata: details,\n    });\n  }\n}\n\nexport default AdminRewardsService;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\admin\\services\\admin-settings.service.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":14,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[477,480],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[477,480],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":39,"column":78,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1269,1272],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1269,1272],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":98,"column":81,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":98,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3133,3136],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3133,3136],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":132,"column":87,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":132,"endColumn":90,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4025,4028],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4025,4028],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Types } from 'mongoose';\nimport { Settings } from '@/models/Settings';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { configService } from '@/services/config';\nimport { audit } from '@/lib/audit-logger';\nimport { redisClient } from '@/config/redis';\n\nexport class AdminSettingsService {\n  static async getSettings() {\n    typedLogger.info('Fetching all settings');\n    return Settings.findOne();\n  }\n\n  static async updateSettings(adminId: string, update: any) {\n    typedLogger.info('Updating settings', { adminId });\n    const updated = await Settings.findOneAndUpdate(\n      {},\n      { ...update, updatedBy: new Types.ObjectId(adminId) },\n      { new: true, upsert: true }\n    );\n    \n    // Broadcast config change\n    if (updated) {\n      await configService.reload();\n    }\n    \n    // Audit log\n    await audit.settingsUpdated(adminId, 'global', { metadata: { changes: Object.keys(update) } });\n    \n    return updated;\n  }\n\n  static async getSettingsSection(section: string) {\n    typedLogger.info('Fetching settings section', { section });\n    // Use ConfigService for better caching and pub/sub support\n    return configService.getConfigSection(section);\n  }\n\n  static async updateSettingsSection(adminId: string, section: string, data: any) {\n    typedLogger.info('Updating settings section', { adminId, section });\n    \n    // Validate before updating\n    const validation = await configService.validateConfigUpdate(section, data);\n    if (!validation.valid) {\n      throw new Error(`Validation failed: ${validation.errors.join(', ')}`);\n    }\n    \n    // Use ConfigService for hot-reload support\n    return configService.updateConfigSection(section, data, adminId);\n  }\n\n  static async getMaintenanceStatus() {\n    typedLogger.info('Fetching maintenance status');\n    const settings = await Settings.findOne();\n    return {\n      enabled: settings?.maintenance?.maintenanceMode ?? false,\n      message: settings?.maintenance?.maintenanceMessage ?? null\n    };\n  }\n\n  static async startMaintenance(adminId: string, message?: string) {\n    typedLogger.info('Starting maintenance mode', { adminId });\n    const result = await Settings.findOneAndUpdate(\n      {},\n      {\n        $set: {\n          'maintenance.maintenanceMode': true,\n          'maintenance.maintenanceMessage': message || 'System is under maintenance',\n          updatedBy: new Types.ObjectId(adminId),\n        },\n      },\n      { new: true, upsert: true }\n    );\n    \n    // Audit log\n    await audit.custom({\n      userId: adminId,\n      userRole: 'admin',\n      action: 'START_MAINTENANCE',\n      resource: 'settings',\n      category: 'admin',\n      severity: 'high',\n      description: 'Started maintenance mode',\n      metadata: { message },\n    });\n\n    try {\n      await redisClient.set(\n        'system:maintenance',\n        JSON.stringify({\n          active: true,\n          message: message || 'System is under maintenance',\n          updatedBy: adminId,\n          updatedAt: new Date().toISOString(),\n        })\n      );\n    } catch (error) {\n      typedLogger.warn('Failed to cache maintenance status', { error: (error as any).message });\n    }\n    \n    return result;\n  }\n\n  static async stopMaintenance(adminId: string) {\n    typedLogger.info('Stopping maintenance mode', { adminId });\n    const result = await Settings.findOneAndUpdate(\n      {},\n      {\n        $set: {\n          'maintenance.maintenanceMode': false,\n          'maintenance.maintenanceMessage': null,\n          updatedBy: new Types.ObjectId(adminId),\n        },\n      },\n      { new: true, upsert: true }\n    );\n    \n    // Audit log\n    await audit.custom({\n      userId: adminId,\n      userRole: 'admin',\n      action: 'STOP_MAINTENANCE',\n      resource: 'settings',\n      category: 'admin',\n      severity: 'high',\n      description: 'Stopped maintenance mode',\n    });\n\n    try {\n      await redisClient.del('system:maintenance');\n    } catch (error) {\n      typedLogger.warn('Failed to clear maintenance status cache', { error: (error as any).message });\n    }\n    \n    return result;\n  }\n}\n\nexport default AdminSettingsService;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\admin\\services\\admin-system.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\admin\\services\\admin-users.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'UsersService' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":22},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":165,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":165,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4512,4515],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4512,4515],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":165,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":165,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4527,4530],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4527,4530],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":176,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":176,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5016,5019],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5016,5019],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":177,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":177,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5065,5068],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5065,5068],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":180,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":180,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5140,5143],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5140,5143],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":182,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":182,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5196,5199],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5196,5199],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":183,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":183,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5244,5247],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5244,5247],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":186,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":186,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5382,5385],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5382,5385],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":192,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":192,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5672,5675],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5672,5675],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":193,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":193,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5746,5749],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5746,5749],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":198,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":198,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5922,5925],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5922,5925],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":199,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":199,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5964,5967],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5964,5967],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":199,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":199,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5991,5994],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5991,5994],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":200,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":200,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6048,6051],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6048,6051],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":200,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":200,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6077,6080],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6077,6080],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":200,"column":90,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":200,"endColumn":93,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6107,6110],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6107,6110],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":201,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":201,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6159,6162],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6159,6162],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":203,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":203,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6218,6221],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6218,6221],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":203,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":203,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6242,6245],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6242,6245],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":204,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":204,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6298,6301],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6298,6301],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":315,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":315,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9420,9423],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9420,9423],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":22,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Types } from 'mongoose';\nimport { User } from '@/models';\nimport { Claim } from '@/models/Claim';\nimport { audit } from '@/lib/audit-logger';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { redisClient } from '@/config/redis';\nimport { UsersService } from '@/modules/users';\nimport { UserLevel } from '@/types';\n\ninterface GetUsersOptions {\n  page?: number;\n  limit?: number;\n  search?: string;\n  status?: string;\n  level?: number;\n}\n\ninterface BanData {\n  reason: string;\n  duration?: number;\n  notifyUser?: boolean;\n}\n\nclass AdminUsersService {\n  static async getUsers(options: GetUsersOptions = {}) {\n    const { page = 1, limit = 20, search, status, level } = options;\n    const skip = (page - 1) * limit;\n\n    const query: Record<string, unknown> = {};\n    const andFilters: Record<string, unknown>[] = [];\n\n    if (search) {\n      andFilters.push({\n        $or: [\n          { username: { $regex: search, $options: 'i' } },\n          { email: { $regex: search, $options: 'i' } },\n          { phoneNumber: { $regex: search, $options: 'i' } },\n          { phone: { $regex: search, $options: 'i' } },\n        ],\n      });\n    }\n\n    if (status && status !== 'all') {\n      switch (status) {\n        case 'banned':\n          andFilters.push({ $or: [{ status: 'banned' }, { isBanned: true }] });\n          break;\n        case 'active':\n          andFilters.push({\n            $and: [\n              { isBanned: { $ne: true } },\n              { deletedAt: { $exists: false } },\n              { $or: [{ status: 'active' }, { status: { $exists: false } }, { status: null }] },\n            ],\n          });\n          break;\n        case 'suspended':\n          andFilters.push({ status: 'suspended' });\n          break;\n        case 'inactive':\n          andFilters.push({\n            $or: [\n              { status: 'inactive' },\n              { status: 'deleted' },\n              { deletedAt: { $exists: true } },\n            ],\n          });\n          break;\n      }\n    }\n\n    if (level !== undefined) {\n      const levelMap: Record<number, UserLevel> = {\n        1: UserLevel.BRONZE,\n        2: UserLevel.SILVER,\n        3: UserLevel.GOLD,\n        4: UserLevel.PLATINUM,\n        5: UserLevel.DIAMOND,\n      };\n      const mappedLevel = levelMap[level];\n      if (mappedLevel) {\n        andFilters.push({ level: mappedLevel });\n      }\n    }\n\n    if (andFilters.length) {\n      query.$and = andFilters;\n    }\n\n    const [users, total] = await Promise.all([\n      User.find(query)\n        .select('-password -refreshTokens')\n        .sort({ createdAt: -1 })\n        .skip(skip)\n        .limit(limit)\n        .lean(),\n      User.countDocuments(query),\n    ]);\n\n    return {\n      users,\n      total,\n      page,\n      limit,\n      hasMore: skip + users.length < total,\n      pagination: {\n        page,\n        limit,\n        total,\n        pages: Math.ceil(total / limit),\n      },\n    };\n  }\n\n  static async getUserProfile(userId: string) {\n    try {\n      const user = await User.findById(userId).select('-password -refreshTokens');\n      if (!user) {\n        throw new Error('USER_NOT_FOUND');\n      }\n\n      // Claim stats + recent activity (similar to UsersService but returned directly for admin)\n      const claimStatsAgg = await Claim.aggregate([\n        { $match: { userId: new Types.ObjectId(userId) } },\n        {\n          $group: {\n            _id: null,\n            totalClaims: { $sum: 1 },\n            totalPoints: { $sum: '$pointsAwarded' },\n            averageDistance: { $avg: '$distance' },\n            validClaims: {\n              $sum: {\n                $cond: [\n                  {\n                    $and: [\n                      '$validationChecks.distanceValid',\n                      '$validationChecks.timeValid',\n                      '$validationChecks.speedValid',\n                      '$validationChecks.cooldownValid',\n                      '$validationChecks.dailyLimitValid',\n                    ],\n                  },\n                  1,\n                  0,\n                ],\n              },\n            },\n          },\n        },\n      ]);\n\n      const claimStats = claimStatsAgg[0] || {\n        totalClaims: 0,\n        totalPoints: 0,\n        averageDistance: 0,\n        validClaims: 0,\n      };\n\n      const recentActivity = await Claim.find({ userId: new Types.ObjectId(userId) })\n        .populate('prizeId', 'name category points')\n        .sort({ claimedAt: -1 })\n        .limit(5);\n\n      // Normalize points shape for UI\n      const rawPoints: any = (user as any).points;\n      const numericPoints = typeof rawPoints === 'number' ? rawPoints : null;\n      const pointsObj = typeof rawPoints === 'object' && rawPoints !== null ? rawPoints : {};\n      const points = {\n        available: numericPoints ?? pointsObj.available ?? pointsObj.total ?? 0,\n        total: numericPoints ?? pointsObj.total ?? pointsObj.available ?? 0,\n        spent: pointsObj.spent ?? 0,\n      };\n\n      const result = {\n        ...user.toJSON(),\n        location: (user as any).location || null,\n        devices: (user as any).devices || [],\n        points,\n        stats: {\n          ...(user as any).stats,\n          totalClaims:\n            (user as any).stats?.totalClaims ||\n            (user as any).stats?.prizesFound ||\n            claimStats.totalClaims ||\n            0,\n          totalPoints: claimStats.totalPoints || (user as any).stats?.totalPoints || points.total || 0,\n          averageDistance: claimStats.averageDistance || 0,\n          validClaims: claimStats.validClaims || 0,\n        },\n        recentActivity: recentActivity.map((claim) => ({\n          id: claim._id,\n          prizeName: (claim.prizeId as any)?.name || 'Unknown Prize',\n          prizeCategory: (claim.prizeId as any)?.category || 'General',\n          pointsAwarded: claim.pointsAwarded,\n          claimedAt: claim.claimedAt,\n        })),\n        banInfo: {\n          isBanned: !!(user as any).isBanned,\n          reason: (user as any).banReason || (user as any).bannedReason || null,\n          expiresAt: (user as any).bannedUntil || (user as any).banExpiresAt || (user as any).banUntil || null,\n          bannedAt: (user as any).bannedAt || null,\n        },\n        lastIp: (user as any).lastIp || (user as any).ipAddress || null,\n        lastUserAgent: (user as any).lastUserAgent || null,\n      };\n\n      return result;\n    } catch (error) {\n      typedLogger.error('Admin get user profile error', { userId, error });\n      throw error;\n    }\n  }\n\n  static async updateUserProfile(userId: string, payload: Record<string, unknown>, adminId: string) {\n    // For admin updates, we can update more fields than regular users\n    const allowedFields = ['displayName', 'email', 'level', 'status'];\n    const updates: Record<string, unknown> = {};\n    \n    for (const field of allowedFields) {\n      if (payload[field] !== undefined) {\n        updates[field] = payload[field];\n      }\n    }\n    \n    if (Object.keys(updates).length === 0) {\n      throw new Error('No valid fields to update');\n    }\n    \n    const user = await User.findByIdAndUpdate(\n      userId,\n      { $set: updates },\n      { new: true, runValidators: true }\n    ).select('-password -refreshTokens');\n    \n    if (!user) {\n      throw new Error('User not found');\n    }\n    \n    // Invalidate cache\n    await redisClient.del(`user:profile:${userId}`);\n    \n    // Audit log for user profile update\n    await audit.custom(adminId, 'UPDATE_USER_PROFILE', 'user', userId, {\n      updatedFields: Object.keys(updates),\n      changes: updates,\n      displayName: user.displayName,\n    });\n    \n    return user;\n  }\n\n  static async banUser(userId: string, banData: BanData, adminId: string) {\n    const { reason, duration, notifyUser } = banData;\n\n    // duration is in hours from UI; store as absolute date if provided\n    const bannedUntil = typeof duration === 'number'\n      ? new Date(Date.now() + duration * 60 * 60 * 1000)\n      : null;\n\n    const user = await User.findByIdAndUpdate(\n      userId,\n      {\n        status: 'banned',\n        isBanned: true,\n        bannedAt: new Date(),\n        bannedUntil,\n        banReason: reason,\n      },\n      { new: true }\n    ).select('-password -refreshTokens');\n\n    if (!user) {\n      throw new Error('User not found');\n    }\n\n    await redisClient.del(`user:sessions:${userId}`);\n    await redisClient.del(`user:tokens:${userId}`);\n\n    // Use unified audit logger - writes to both Pino and MongoDB\n    await audit.userBanned(adminId, userId, { reason, duration, bannedUntil, notifyUser });\n\n    return user;\n  }\n\n  static async unbanUser(userId: string, adminId: string) {\n    const user = await User.findByIdAndUpdate(\n      userId,\n      {\n        status: 'active',\n        isBanned: false,\n        $unset: { bannedAt: 1, bannedUntil: 1, banReason: 1 },\n      },\n      { new: true }\n    ).select('-password -refreshTokens');\n\n    if (!user) {\n      throw new Error('User not found');\n    }\n\n    // Use unified audit logger - writes to both Pino and MongoDB\n    await audit.userUnbanned(adminId, userId);\n\n    return user;\n  }\n\n  static async adjustPoints(userId: string, points: number, reason: string, adminId: string) {\n    try {\n      const user = await User.findById(userId).select('-password -refreshTokens');\n\n      if (!user) {\n        throw new Error('User not found');\n      }\n\n      // Support legacy numeric points field\n      const currentPoints = (user as any).points;\n      const available = typeof currentPoints === 'number'\n        ? currentPoints\n        : currentPoints?.available ?? 0;\n      const total = typeof currentPoints === 'number'\n        ? currentPoints\n        : currentPoints?.total ?? 0;\n      const spent = typeof currentPoints === 'number'\n        ? 0\n        : currentPoints?.spent ?? 0;\n\n      const newAvailable = available + points;\n      if (newAvailable < 0) {\n        throw new Error('INSUFFICIENT_POINTS');\n      }\n\n      const newPoints = {\n        available: newAvailable,\n        total: total + Math.max(points, 0),\n        spent: spent + Math.max(-points, 0),\n      };\n\n      // Use findByIdAndUpdate for reliable nested field updates\n      const updated = await User.findByIdAndUpdate(\n        userId,\n        {\n          $set: {\n            'points.available': newPoints.available,\n            'points.total': newPoints.total,\n            'points.spent': newPoints.spent,\n          },\n        },\n        { new: true, runValidators: false }\n      ).select('-password -refreshTokens');\n\n      if (!updated) {\n        throw new Error('Failed to update user points');\n      }\n\n      typedLogger.info('Points adjusted for user', {\n        userId,\n        oldAvailable: available,\n        newAvailable: newPoints.available,\n        adjustment: points,\n        reason,\n      });\n\n      // Use unified audit logger - writes to both Pino and MongoDB\n      await audit.pointsAdjusted(adminId, userId, { points, reason, newBalance: newPoints.available });\n\n      return updated;\n    } catch (error) {\n      typedLogger.error('Failed to adjust user points', { userId, points, error });\n      throw error;\n    }\n  }\n\n  static async deleteUser(userId: string, adminId: string) {\n    try {\n      const user = await User.findByIdAndUpdate(\n        userId,\n        {\n          status: 'deleted',\n          deletedAt: new Date(),\n        },\n        { new: true }\n      ).select('-password -refreshTokens');\n\n      if (!user) {\n        throw new Error('User not found');\n      }\n\n      await redisClient.del(`user:sessions:${userId}`);\n      await redisClient.del(`user:tokens:${userId}`);\n\n      // Audit log for user deletion\n      await audit.custom(adminId, 'DELETE_USER', 'user', userId, {\n        displayName: user.displayName,\n        email: user.email,\n        deletedAt: new Date().toISOString(),\n      });\n\n      return user;\n    } catch (error) {\n      typedLogger.error('Failed to delete user', { userId, error });\n      throw error;\n    }\n  }\n}\n\nexport { AdminUsersService };\nexport default AdminUsersService;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\admin\\services\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\admob\\index.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":48,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2846,2849],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2846,2849],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":72,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4379,4382],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4379,4382],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":72,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4424,4427],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4424,4427],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":89,"column":87,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":89,"endColumn":90,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5005,5008],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5005,5008],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":189,"column":79,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":189,"endColumn":82,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8190,8193],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8190,8193],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":330,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":330,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12257,12260],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12257,12260],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":394,"column":82,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":394,"endColumn":85,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14092,14095],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14092,14095],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":478,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":478,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16397,16400],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16397,16400],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'groupBy' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":498,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":498,"endColumn":42},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":615,"column":79,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":615,"endColumn":82,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20041,20044],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20041,20044],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":630,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":630,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20499,20502],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20499,20502],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":632,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":632,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20600,20603],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20600,20603],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":637,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":637,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20922,20925],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20922,20925],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';\nimport mongoose from 'mongoose';\nimport { Types } from 'mongoose';\nimport { z } from 'zod';\nimport AdMobView from '../../models/AdMobView';\nimport User from '../../models/User';\nimport { typedLogger } from '../../lib/typed-logger';\nimport { broadcastAdminEvent } from '../../lib/websocket';\nimport { redisClient } from '../../config/redis';\nimport { authenticate, requireAdmin } from '../../middleware/auth';\nimport { Settings } from '../../models/Settings';\n\n// Default AdMob configuration (camelCase)\nconst DEFAULT_ADMOB_CONFIG = {\n  maxRewardedAdsPerDay: 10,\n  maxInterstitialAdsPerDay: 20,\n  rewardedVideoPoints: 100,\n  interstitialPoints: 20,\n  rewardedVideoEcpm: 8.0, // $8 per 1000 views\n  interstitialEcpm: 3.0, // $3 per 1000 views\n  bannerEcpm: 0.5, // $0.50 per 1000 impressions\n  rewardedCooldown: 300, // seconds\n  interstitialCooldown: 180, // seconds\n};\n\nconst AD_CONFIG_CACHE_TTL = 5 * 60 * 1000; // 5 minutes\nlet admobConfigCache = { ...DEFAULT_ADMOB_CONFIG };\nlet admobConfigFetchedAt = 0;\n\nconst AdmobConfigSchema = z.object({\n  // maxRewardedAdsPerDay: Min 0 allows disabling rewarded ads; default 10 means at most 10 per day\n  maxRewardedAdsPerDay: z.number().int().min(0, { message: 'maxRewardedAdsPerDay must be 0 or greater (0 to disable)' }).optional(),\n  // maxInterstitialAdsPerDay: Min 0 allows disabling interstitials; default 20 means at most 20 per day\n  maxInterstitialAdsPerDay: z.number().int().min(0, { message: 'maxInterstitialAdsPerDay must be 0 or greater (0 to disable)' }).optional(),\n  // Points awarded per rewarded video watched (can be 0 for no reward)\n  rewardedVideoPoints: z.number().int().nonnegative({ message: 'rewardedVideoPoints must be 0 or greater' }).optional(),\n  // Points awarded per interstitial watched (can be 0 for no reward)\n  interstitialPoints: z.number().int().nonnegative({ message: 'interstitialPoints must be 0 or greater' }).optional(),\n  // Effective cost per mille (revenue per 1000 views) - must be non-negative\n  rewardedVideoEcpm: z.number().nonnegative({ message: 'rewardedVideoEcpm must be 0 or greater (e.g., 8.0 for $8/1000 views)' }).optional(),\n  interstitialEcpm: z.number().nonnegative({ message: 'interstitialEcpm must be 0 or greater (e.g., 3.0 for $3/1000 views)' }).optional(),\n  bannerEcpm: z.number().nonnegative({ message: 'bannerEcpm must be 0 or greater (e.g., 0.5 for $0.50/1000 impressions)' }).optional(),\n  // Cooldown in seconds before user can watch next ad (0 = no cooldown)\n  rewardedCooldown: z.number().int().nonnegative({ message: 'rewardedCooldown must be 0 or greater (in seconds)' }).optional(),\n  interstitialCooldown: z.number().int().nonnegative({ message: 'interstitialCooldown must be 0 or greater (in seconds)' }).optional(),\n});\n\nconst normalizeConfig = (cfg: any) => {\n  if (!cfg) return { ...DEFAULT_ADMOB_CONFIG };\n  // Accept legacy UPPER_SNAKE keys while normalizing to camelCase\n  return {\n    maxRewardedAdsPerDay: cfg.maxRewardedAdsPerDay ?? cfg.MAX_REWARDED_ADS_PER_DAY ?? DEFAULT_ADMOB_CONFIG.maxRewardedAdsPerDay,\n    maxInterstitialAdsPerDay: cfg.maxInterstitialAdsPerDay ?? cfg.MAX_INTERSTITIAL_ADS_PER_DAY ?? DEFAULT_ADMOB_CONFIG.maxInterstitialAdsPerDay,\n    rewardedVideoPoints: cfg.rewardedVideoPoints ?? cfg.REWARDED_VIDEO_POINTS ?? DEFAULT_ADMOB_CONFIG.rewardedVideoPoints,\n    interstitialPoints: cfg.interstitialPoints ?? cfg.INTERSTITIAL_POINTS ?? DEFAULT_ADMOB_CONFIG.interstitialPoints,\n    rewardedVideoEcpm: cfg.rewardedVideoEcpm ?? cfg.REWARDED_VIDEO_ECPM ?? DEFAULT_ADMOB_CONFIG.rewardedVideoEcpm,\n    interstitialEcpm: cfg.interstitialEcpm ?? cfg.INTERSTITIAL_ECPM ?? DEFAULT_ADMOB_CONFIG.interstitialEcpm,\n    bannerEcpm: cfg.bannerEcpm ?? cfg.BANNER_ECPM ?? DEFAULT_ADMOB_CONFIG.bannerEcpm,\n    rewardedCooldown: cfg.rewardedCooldown ?? cfg.REWARDED_COOLDOWN ?? DEFAULT_ADMOB_CONFIG.rewardedCooldown,\n    interstitialCooldown: cfg.interstitialCooldown ?? cfg.INTERSTITIAL_COOLDOWN ?? DEFAULT_ADMOB_CONFIG.interstitialCooldown,\n  };\n};\n\nasync function getAdmobConfig(): Promise<typeof DEFAULT_ADMOB_CONFIG> {\n  const now = Date.now();\n  if (now - admobConfigFetchedAt < AD_CONFIG_CACHE_TTL && admobConfigCache) {\n    return admobConfigCache;\n  }\n\n  try {\n    const settings = await Settings.findOne({}, { 'custom.admob': 1 }).lean();\n    const cfg = (settings as any)?.custom?.get?.('admob') || (settings as any)?.custom?.admob;\n    if (cfg) {\n      admobConfigCache = normalizeConfig(cfg);\n      admobConfigFetchedAt = now;\n      return admobConfigCache;\n    }\n\n    // No config stored yet: persist defaults once\n    await Settings.findOneAndUpdate(\n      {},\n      { $set: { 'custom.admob': DEFAULT_ADMOB_CONFIG, updatedBy: 'system' } },\n      { upsert: true }\n    );\n    admobConfigCache = { ...DEFAULT_ADMOB_CONFIG };\n    admobConfigFetchedAt = now;\n    return admobConfigCache;\n  } catch (error) {\n    typedLogger.warn('AdMob settings load failed, using defaults', { error: (error as any).message });\n    admobConfigCache = { ...DEFAULT_ADMOB_CONFIG };\n    admobConfigFetchedAt = now;\n    return admobConfigCache;\n  }\n}\n\nasync function saveAdmobConfig(update: Partial<typeof DEFAULT_ADMOB_CONFIG>, adminId: string) {\n  const current = await getAdmobConfig();\n  const merged = { ...current, ...update };\n  await Settings.findOneAndUpdate(\n    {},\n    { $set: { 'custom.admob': merged, updatedBy: adminId } },\n    { upsert: true }\n  );\n  admobConfigCache = merged;\n  admobConfigFetchedAt = Date.now();\n  return merged;\n}\n\ninterface AdMobRequestBody {\n  adType: 'rewarded' | 'interstitial' | 'banner';\n  adUnitId: string;\n  completed: boolean;\n  deviceInfo?: {\n    platform: string;\n    version: string;\n    model?: string;\n  };\n  location?: {\n    city?: string;\n    country?: string;\n  };\n  metadata?: {\n    sessionId?: string;\n    placementId?: string;\n  };\n}\n\nexport default async function admobRoutes(fastify: FastifyInstance) {\n  // Check if user can watch an ad\n  fastify.get('/available', {\n    preHandler: [authenticate]\n  }, async (request: FastifyRequest, reply: FastifyReply) => {\n    try {\n      const config = await getAdmobConfig();\n      const userId = request.user.sub;\n      const today = new Date();\n      today.setHours(0, 0, 0, 0);\n\n      // Count ads watched today\n      const [rewardedCount, interstitialCount] = await Promise.all([\n        AdMobView.countDocuments({\n          userId,\n          adType: 'rewarded',\n          completed: true,\n          viewedAt: { $gte: today }\n        }),\n        AdMobView.countDocuments({\n          userId,\n          adType: 'interstitial',\n          completed: true,\n          viewedAt: { $gte: today }\n        })\n      ]);\n\n      // Check cooldowns\n      const rewardedCooldownKey = `admob:cooldown:rewarded:${userId}`;\n      const interstitialCooldownKey = `admob:cooldown:interstitial:${userId}`;\n\n      const [rewardedCooldown, interstitialCooldown] = await Promise.all([\n        redisClient.get(rewardedCooldownKey),\n        redisClient.get(interstitialCooldownKey)\n      ]);\n\n      const canWatchRewarded = rewardedCount < config.maxRewardedAdsPerDay && !rewardedCooldown;\n      const canWatchInterstitial = interstitialCount < config.maxInterstitialAdsPerDay && !interstitialCooldown;\n\n      return reply.send({\n        success: true,\n        data: {\n          rewarded: {\n            available: canWatchRewarded,\n            remaining: Math.max(0, config.maxRewardedAdsPerDay - rewardedCount),\n            cooldownSeconds: rewardedCooldown ? parseInt(rewardedCooldown) : 0,\n            rewardAmount: config.rewardedVideoPoints\n          },\n          interstitial: {\n            available: canWatchInterstitial,\n            remaining: Math.max(0, config.maxInterstitialAdsPerDay - interstitialCount),\n            cooldownSeconds: interstitialCooldown ? parseInt(interstitialCooldown) : 0,\n            rewardAmount: config.interstitialPoints\n          },\n          todayStats: {\n            rewardedWatched: rewardedCount,\n            interstitialWatched: interstitialCount\n          }\n        }\n      });\n    } catch (error) {\n      typedLogger.error('Error checking ad availability:', { error: (error as any).message });\n      return reply.status(500).send({\n        success: false,\n        error: 'INTERNAL_ERROR',\n        message: 'Failed to check ad availability'\n      });\n    }\n  });\n\n  // Record ad view and give reward\n  fastify.post('/reward', {\n    preHandler: [authenticate]\n  }, async (request: FastifyRequest<{ Body: AdMobRequestBody }>, reply: FastifyReply) => {\n    try {\n      const config = await getAdmobConfig();\n      const userId = request.user.sub;\n      const { adType, adUnitId, completed, deviceInfo, location, metadata } = request.body;\n\n      // Validate ad type\n      if (!['rewarded', 'interstitial'].includes(adType)) {\n        return reply.status(400).send({\n          success: false,\n          error: 'INVALID_AD_TYPE',\n          message: 'Only rewarded and interstitial ads can give rewards'\n        });\n      }\n\n      // Check if ad was completed\n      if (!completed) {\n        return reply.status(400).send({\n          success: false,\n          error: 'AD_NOT_COMPLETED',\n          message: 'Ad must be completed to receive reward'\n        });\n      }\n\n      // Check daily limit\n      const today = new Date();\n      today.setHours(0, 0, 0, 0);\n\n      const todayCount = await AdMobView.countDocuments({\n        userId,\n        adType,\n        completed: true,\n        viewedAt: { $gte: today }\n      });\n\n      const maxAds = adType === 'rewarded'\n        ? config.maxRewardedAdsPerDay\n        : config.maxInterstitialAdsPerDay;\n\n      if (todayCount >= maxAds) {\n        return reply.status(429).send({\n          success: false,\n          error: 'DAILY_LIMIT_REACHED',\n          message: `You have reached the daily limit of ${maxAds} ${adType} ads`\n        });\n      }\n\n      // Check cooldown\n      const cooldownKey = `admob:cooldown:${adType}:${userId}`;\n      const cooldown = await redisClient.get(cooldownKey);\n\n      if (cooldown) {\n        return reply.status(429).send({\n          success: false,\n          error: 'COOLDOWN_ACTIVE',\n          message: `Please wait ${cooldown} seconds before watching another ad`,\n          retryAfter: parseInt(cooldown)\n        });\n      }\n\n      // Calculate reward and revenue\n      const rewardAmount = adType === 'rewarded'\n        ? config.rewardedVideoPoints\n        : config.interstitialPoints;\n\n      const ecpm = adType === 'rewarded'\n        ? config.rewardedVideoEcpm\n        : config.interstitialEcpm;\n\n      const revenue = ecpm / 1000; // Revenue per view\n\n      // Create ad view record\n      const adView = await AdMobView.create({\n        userId,\n        adType,\n        adUnitId,\n        rewardAmount,\n        rewardType: 'points',\n        completed: true,\n        revenue,\n        ecpm,\n        deviceInfo: deviceInfo || { platform: 'unknown', version: 'unknown' },\n        location,\n        viewedAt: new Date(),\n        rewardedAt: new Date(),\n        metadata\n      });\n\n      // Give reward to user\n      const user = await User.findByIdAndUpdate(\n        userId,\n        {\n          $inc: {\n            'points.available': rewardAmount,\n            'points.total': rewardAmount\n          }\n        },\n        { new: true }\n      );\n\n      if (!user) {\n        return reply.status(404).send({\n          success: false,\n          error: 'USER_NOT_FOUND'\n        });\n      }\n\n      // Set cooldown\n      const cooldownSeconds = adType === 'rewarded'\n        ? config.rewardedCooldown\n        : config.interstitialCooldown;\n\n      await redisClient.setex(cooldownKey, cooldownSeconds, cooldownSeconds.toString());\n\n      typedLogger.info(`User ${userId} watched ${adType} ad and earned ${rewardAmount} points`);\n\n      broadcastAdminEvent({ type: 'ad_impression', data: { adViewId: adView._id, adType, rewardAmount } });\n\n      return reply.send({\n        success: true,\n        data: {\n          rewardAmount,\n          rewardType: 'points',\n          newBalance: user.points?.available ?? 0,\n          adViewId: adView._id,\n          cooldownSeconds\n        }\n      });\n    } catch (error) {\n      typedLogger.error('Error processing ad reward:', { error: (error as any).message });\n      return reply.status(500).send({\n        success: false,\n        error: 'INTERNAL_ERROR',\n        message: 'Failed to process ad reward'\n      });\n    }\n  });\n\n  // Record banner impression (no reward)\n  fastify.post('/impression', {\n    preHandler: [authenticate]\n  }, async (request: FastifyRequest<{ Body: Partial<AdMobRequestBody> }>, reply: FastifyReply) => {\n    try {\n      const config = await getAdmobConfig();\n      const userId = request.user.sub;\n      const { adType, adUnitId, deviceInfo, location, metadata } = request.body || {};\n\n      if (!adUnitId) {\n        return reply.status(400).send({\n          success: false,\n          error: 'AD_UNIT_ID_REQUIRED',\n          message: 'adUnitId is required'\n        });\n      }\n\n      if (adType && adType !== 'banner') {\n        return reply.status(400).send({\n          success: false,\n          error: 'INVALID_AD_TYPE',\n          message: 'Only banner impressions are accepted on this endpoint'\n        });\n      }\n\n      const ecpm = config.bannerEcpm;\n      const revenue = ecpm / 1000;\n\n      const adView = await AdMobView.create({\n        userId,\n        adType: 'banner',\n        adUnitId,\n        rewardAmount: 0,\n        rewardType: 'points',\n        completed: true,\n        revenue,\n        ecpm,\n        deviceInfo: deviceInfo || { platform: 'unknown', version: 'unknown' },\n        location,\n        viewedAt: new Date(),\n        metadata\n      });\n\n      broadcastAdminEvent({ type: 'ad_impression', data: { adViewId: adView._id, adType: 'banner' } });\n\n      return reply.send({\n        success: true,\n        data: {\n          adViewId: adView._id,\n          adType: 'banner',\n          revenue,\n          ecpm\n        }\n      });\n    } catch (error) {\n      typedLogger.error('Error recording banner impression:', { error: (error as any).message });\n      return reply.status(500).send({\n        success: false,\n        error: 'INTERNAL_ERROR',\n        message: 'Failed to record banner impression'\n      });\n    }\n  });\n\n  // Get user's ad stats\n  fastify.get('/stats', {\n    preHandler: [authenticate]\n  }, async (request: FastifyRequest, reply: FastifyReply) => {\n    try {\n      const userId = request.user.sub;\n      const today = new Date();\n      today.setHours(0, 0, 0, 0);\n\n      const [todayStats, allTimeStats, last7Days] = await Promise.all([\n        // Today's stats\n        AdMobView.aggregate([\n          {\n            $match: {\n              userId: new Types.ObjectId(userId),\n              viewedAt: { $gte: today }\n            }\n          },\n          {\n            $group: {\n              _id: '$adType',\n              count: { $sum: 1 },\n              completed: { $sum: { $cond: ['$completed', 1, 0] } },\n              totalReward: { $sum: '$rewardAmount' }\n            }\n          }\n        ]),\n\n        // All-time stats\n        AdMobView.aggregate([\n          {\n            $match: {\n              userId: new Types.ObjectId(userId)\n            }\n          },\n          {\n            $group: {\n              _id: null,\n              totalViews: { $sum: 1 },\n              totalCompleted: { $sum: { $cond: ['$completed', 1, 0] } },\n              totalRewards: { $sum: '$rewardAmount' }\n            }\n          }\n        ]),\n\n        // Last 7 days trend\n        AdMobView.aggregate([\n          {\n            $match: {\n              userId: new mongoose.Types.ObjectId(userId),\n              viewedAt: { $gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) }\n            }\n          },\n          {\n            $group: {\n              _id: {\n                $dateToString: { format: '%Y-%m-%d', date: '$viewedAt' }\n              },\n              count: { $sum: 1 },\n              rewards: { $sum: '$rewardAmount' }\n            }\n          },\n          { $sort: { _id: 1 } }\n        ])\n      ]);\n\n      return reply.send({\n        success: true,\n        data: {\n          today: todayStats,\n          allTime: allTimeStats[0] || { totalViews: 0, totalCompleted: 0, totalRewards: 0 },\n          last7Days\n        }\n      });\n    } catch (error) {\n      typedLogger.error('Error fetching ad stats:', { error: (error as any).message });\n      return reply.status(500).send({\n        success: false,\n        error: 'INTERNAL_ERROR',\n        message: 'Failed to fetch ad stats'\n      });\n    }\n  });\n\n  // Admin: Get AdMob analytics\n  fastify.get('/analytics', {\n    preHandler: [authenticate, requireAdmin]\n  }, async (request: FastifyRequest<{\n    Querystring: {\n      startDate?: string;\n      endDate?: string;\n      groupBy?: 'day' | 'week' | 'month';\n    }\n  }>, reply: FastifyReply) => {\n    try {\n      const { startDate, endDate, groupBy = 'day' } = request.query;\n\n      const start = startDate ? new Date(startDate) : new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);\n      const end = endDate ? new Date(endDate) : new Date();\n\n      // Overall stats\n      const [overallStats, adTypeStats, dailyTrend] = await Promise.all([\n        AdMobView.aggregate([\n          {\n            $match: {\n              viewedAt: { $gte: start, $lte: end }\n            }\n          },\n          {\n            $group: {\n              _id: null,\n              totalViews: { $sum: 1 },\n              totalCompleted: { $sum: { $cond: ['$completed', 1, 0] } },\n              totalRevenue: { $sum: '$revenue' },\n              totalRewards: { $sum: '$rewardAmount' },\n              avgEcpm: { $avg: '$ecpm' }\n            }\n          }\n        ]),\n\n        // Stats by ad type\n        AdMobView.aggregate([\n          {\n            $match: {\n              viewedAt: { $gte: start, $lte: end }\n            }\n          },\n          {\n            $group: {\n              _id: '$adType',\n              views: { $sum: 1 },\n              completed: { $sum: { $cond: ['$completed', 1, 0] } },\n              revenue: { $sum: '$revenue' },\n              rewards: { $sum: '$rewardAmount' }\n            }\n          }\n        ]),\n\n        // Daily trend\n        AdMobView.aggregate([\n          {\n            $match: {\n              viewedAt: { $gte: start, $lte: end }\n            }\n          },\n          {\n            $group: {\n              _id: {\n                $dateToString: { format: '%Y-%m-%d', date: '$viewedAt' }\n              },\n              views: { $sum: 1 },\n              completed: { $sum: { $cond: ['$completed', 1, 0] } },\n              revenue: { $sum: '$revenue' },\n              rewards: { $sum: '$rewardAmount' }\n            }\n          },\n          { $sort: { _id: 1 } }\n        ])\n      ]);\n\n      // Top users\n      const topUsers = await AdMobView.aggregate([\n        {\n          $match: {\n            viewedAt: { $gte: start, $lte: end },\n            completed: true\n          }\n        },\n        {\n          $group: {\n            _id: '$userId',\n            views: { $sum: 1 },\n            rewards: { $sum: '$rewardAmount' }\n          }\n        },\n        { $sort: { views: -1 } },\n        { $limit: 10 },\n        {\n          $lookup: {\n            from: 'users',\n            localField: '_id',\n            foreignField: '_id',\n            as: 'user'\n          }\n        },\n        {\n          $project: {\n            userId: '$_id',\n            username: { $arrayElemAt: ['$user.username', 0] },\n            views: 1,\n            rewards: 1\n          }\n        }\n      ]);\n\n      return reply.send({\n        success: true,\n        data: {\n          overall: overallStats[0] || {\n            totalViews: 0,\n            totalCompleted: 0,\n            totalRevenue: 0,\n            totalRewards: 0,\n            avgEcpm: 0\n          },\n          byAdType: adTypeStats,\n          dailyTrend,\n          topUsers,\n          dateRange: { start, end }\n        }\n      });\n    } catch (error) {\n      typedLogger.error('Error fetching AdMob analytics:', { error: (error as any).message });\n      return reply.status(500).send({\n        success: false,\n        error: 'INTERNAL_ERROR',\n        message: 'Failed to fetch AdMob analytics'\n      });\n    }\n  });\n\n  // Admin: Update AdMob configuration\n  fastify.patch('/config', {\n    preHandler: [authenticate, requireAdmin],\n    schema: { body: AdmobConfigSchema.partial() }\n  }, async (request: FastifyRequest, reply: FastifyReply) => {\n    try {\n      const body = request.body as any;\n      const parsed = AdmobConfigSchema.partial().parse(body);\n      const adminId = (request as any).user?.sub || 'admin';\n      const updated = await saveAdmobConfig(parsed, adminId);\n      typedLogger.info('AdMob configuration updated by admin', { adminId });\n      return reply.send({ success: true, data: updated });\n    } catch (error) {\n      typedLogger.error('Error updating AdMob config:', { error: (error as any).message });\n      return reply.status(500).send({\n        success: false,\n        error: 'INTERNAL_ERROR',\n        message: 'Failed to update AdMob configuration'\n      });\n    }\n  });\n\n  // Admin: Get current configuration\n  fastify.get('/config', {\n    preHandler: [authenticate, requireAdmin]\n  }, async (request: FastifyRequest, reply: FastifyReply) => {\n    const [config, settings] = await Promise.all([\n      getAdmobConfig(),\n      Settings.findOne({}, { updatedAt: 1, updatedBy: 1 }).lean()\n    ]);\n    return reply.send({\n      success: true,\n      data: {\n        ...config,\n        updatedAt: settings?.updatedAt?.toISOString?.() || (admobConfigFetchedAt ? new Date(admobConfigFetchedAt).toISOString() : undefined),\n        updatedBy: settings?.updatedBy || 'unknown',\n      }\n    });\n  });\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\ar\\index.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'User' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":14},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":92,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":92,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2747,2750],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2747,2750],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":94,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":94,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2856,2859],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2856,2859],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":97,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":97,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2953,2956],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2953,2956],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":149,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":149,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4262,4265],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4262,4265],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":152,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":152,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4367,4370],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4367,4370],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":196,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":196,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5435,5438],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5435,5438],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":199,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":199,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5533,5536],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5533,5536],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":225,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":225,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6044,6047],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6044,6047],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":228,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":228,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6141,6144],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6141,6144],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":286,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":286,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7787,7790],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7787,7790],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":287,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":287,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7814,7817],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7814,7817],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":290,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":290,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7975,7978],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7975,7978],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":321,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":321,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8989,8992],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8989,8992],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":322,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":322,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9016,9019],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9016,9019],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":325,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":325,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9192,9195],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9192,9195],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":357,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":357,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10194,10197],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10194,10197],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":358,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":358,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10221,10224],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10221,10224],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":361,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":361,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10397,10400],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10397,10400],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":405,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":405,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11887,11890],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11887,11890],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":406,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":406,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11914,11917],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11914,11917],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":21,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';\nimport { authenticate } from '@/middleware/auth';\nimport { z } from 'zod';\nimport { Types } from 'mongoose';\nimport { ARSession, ARSessionStatus } from '@/models/ARSession';\nimport { Prize } from '@/models/Prize';\nimport { User } from '@/models/User';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { v4 as uuidv4 } from 'uuid';\n\n// Validation schemas\nconst startARViewSchema = z.object({\n  prizeId: z.string().regex(/^[0-9a-fA-F]{24}$/, 'Invalid prize ID'),\n  metadata: z.object({\n    deviceModel: z.string().optional(),\n    osVersion: z.string().optional(),\n    arKitVersion: z.string().optional(),\n    arCoreVersion: z.string().optional(),\n    cameraPermission: z.boolean(),\n    locationPermission: z.boolean()})});\n\nconst captureARScreenshotSchema = z.object({\n  sessionId: z.string().uuid(),\n  screenshot: z.object({\n    base64: z.string().min(1), // Base64 encoded image\n    location: z.object({\n      lat: z.number().min(-90).max(90),\n      lng: z.number().min(-180).max(180)}).optional()})});\n\nconst endARSessionSchema = z.object({\n  sessionId: z.string().uuid(),\n  duration: z.number().min(0), // seconds\n});\n\n/**\n * AR Service\n */\nexport class ARService {\n  /**\n   * Start AR view session\n   */\n  static async startARView(\n    userId: string,\n    data: z.infer<typeof startARViewSchema>\n  ) {\n    try {\n      // Validate prize exists\n      const prize = await Prize.findById(data.prizeId);\n      if (!prize) {\n        throw new Error('PRIZE_NOT_FOUND');\n      }\n\n      if (prize.status !== 'active' || prize.claimedCount >= prize.quantity) {\n        throw new Error('PRIZE_NOT_AVAILABLE');\n      }\n\n      // Check if user has active AR session\n      const activeSession = await ARSession.findOne({\n        userId: new Types.ObjectId(userId),\n        status: ARSessionStatus.ACTIVE});\n\n      if (activeSession) {\n        // Return existing session\n        return {\n          sessionId: activeSession.sessionId,\n          prizeId: activeSession.prizeId,\n          startedAt: activeSession.startedAt};\n      }\n\n      // Create new AR session\n      const sessionId = uuidv4();\n      const session = new ARSession({\n        userId: new Types.ObjectId(userId),\n        prizeId: new Types.ObjectId(data.prizeId),\n        sessionId,\n        status: ARSessionStatus.ACTIVE,\n        startedAt: new Date(),\n        metadata: data.metadata,\n        screenshots: []});\n\n      await session.save();\n\n      typedLogger.info('AR session started', {\n        userId,\n        prizeId: data.prizeId,\n        sessionId});\n\n      return {\n        sessionId: session.sessionId,\n        prizeId: session.prizeId,\n        startedAt: session.startedAt,\n        arModel: (prize as any).arModel || null}; // TODO: Define proper type for arModel in Prize interface\n      \n    } catch (error: any) {\n      typedLogger.error('Start AR view error', {\n        userId,\n        error: (error as any).message});\n      throw error;\n    }\n  }\n\n  /**\n   * Capture AR screenshot\n   */\n  static async captureARScreenshot(\n    userId: string,\n    data: z.infer<typeof captureARScreenshotSchema>\n  ) {\n    try {\n      // Find AR session\n      const session = await ARSession.findOne({\n        sessionId: data.sessionId,\n        userId: new Types.ObjectId(userId)});\n\n      if (!session) {\n        throw new Error('AR_SESSION_NOT_FOUND');\n      }\n\n      if (session.status !== ARSessionStatus.ACTIVE) {\n        throw new Error('AR_SESSION_NOT_ACTIVE');\n      }\n\n      // Upload screenshot to S3 (simulated - would use AWS SDK in production)\n      const screenshotUrl = await this.uploadScreenshotToS3(\n        data.screenshot.base64,\n        session.sessionId\n      );\n\n      // Add screenshot to session\n      session.screenshots.push({\n        url: screenshotUrl,\n        timestamp: new Date(),\n        location: data.screenshot.location ? {\n          lat: data.screenshot.location.lat,\n          lng: data.screenshot.location.lng\n        } : undefined});\n\n      await session.save();\n\n      typedLogger.info('AR screenshot captured', {\n        userId,\n        sessionId: data.sessionId,\n        screenshotUrl});\n\n      return {\n        screenshotUrl,\n        timestamp: new Date()};\n      \n    } catch (error: any) {\n      typedLogger.error('Capture AR screenshot error', {\n        userId,\n        error: (error as any).message});\n      throw error;\n    }\n  }\n\n  /**\n   * End AR session\n   */\n  static async endARSession(\n    userId: string,\n    data: z.infer<typeof endARSessionSchema>\n  ) {\n    try {\n      // Find AR session\n      const session = await ARSession.findOne({\n        sessionId: data.sessionId,\n        userId: new Types.ObjectId(userId)});\n\n      if (!session) {\n        throw new Error('AR_SESSION_NOT_FOUND');\n      }\n\n      if (session.status !== ARSessionStatus.ACTIVE) {\n        throw new Error('AR_SESSION_NOT_ACTIVE');\n      }\n\n      // Update session\n      session.status = ARSessionStatus.COMPLETED;\n      session.completedAt = new Date();\n      session.duration = data.duration;\n\n      await session.save();\n\n      typedLogger.info('AR session ended', {\n        userId,\n        sessionId: data.sessionId,\n        duration: data.duration,\n        screenshots: session.screenshots.length});\n\n      return {\n        sessionId: session.sessionId,\n        duration: session.duration,\n        screenshots: session.screenshots.length};\n      \n    } catch (error: any) {\n      typedLogger.error('End AR session error', {\n        userId,\n        error: (error as any).message});\n      throw error;\n    }\n  }\n\n  /**\n   * Get AR model for prize\n   */\n  static async getARModel(prizeId: string) {\n    try {\n      const prize = await Prize.findById(prizeId);\n      \n      if (!prize) {\n        throw new Error('PRIZE_NOT_FOUND');\n      }\n\n      const arModel = prize.model || {\n        modelUrl: null,\n        textureUrl: null,\n        scale: 1.0,\n        rotation: { x: 0, y: 0, z: 0 }};\n\n      return {\n        prizeId: prize._id,\n        arModel};\n      \n    } catch (error: any) {\n      typedLogger.error('Get AR model error', {\n        prizeId,\n        error: (error as any).message});\n      throw error;\n    }\n  }\n\n  /**\n   * Upload screenshot to S3 (simulated)\n   * In production, use AWS SDK\n   */\n  private static async uploadScreenshotToS3(\n    base64Image: string,\n    sessionId: string\n  ): Promise<string> {\n    // Simulated S3 upload\n    // In production:\n    // 1. Decode base64\n    // 2. Upload to S3 bucket\n    // 3. Return public URL\n    \n    const timestamp = Date.now();\n    const filename = `ar-screenshots/${sessionId}/${timestamp}.jpg`;\n    \n    // Simulated URL\n    return `https://yallacatch-ar-assets.s3.amazonaws.com/${filename}`;\n  }\n}\n\n/**\n * AR Routes\n */\nexport default async function arRoutes(fastify: FastifyInstance) {\n  // POST /api/ar/view - Start AR view session\n  fastify.post<{ Body: z.infer<typeof startARViewSchema> }>(\n    '/view',\n    {\n      preHandler: [authenticate],\n      schema: {\n        description: 'Start AR view session for a prize',\n        tags: ['AR'],\n        body: startARViewSchema,\n        response: {\n          200: {\n            type: 'object',\n            properties: {\n              sessionId: { type: 'string' },\n              prizeId: { type: 'string' },\n              startedAt: { type: 'string' },\n              arModel: {\n                type: 'object',\n                nullable: true}}}}}\n    },\n    async (request: FastifyRequest<{ Body: z.infer<typeof startARViewSchema> }>, reply: FastifyReply) => {\n    try {\n      const userId = request.user.sub;\n      // Schema validation is now handled by the route schema\n      const result = await ARService.startARView(userId, request.body);\n\n      return reply.code(200).send(result);\n    } catch (error: any) {\n      if ((error as any).message === 'PRIZE_NOT_FOUND') {\n        return reply.code(404).send({ error: 'PRIZE_NOT_FOUND', message: 'Prize not found' });\n      }\n      if ((error as any).message === 'PRIZE_NOT_AVAILABLE') {\n        return reply.code(400).send({ error: 'PRIZE_NOT_AVAILABLE', message: 'Prize is not available' });\n      }\n      throw error;\n    }\n  });\n\n  // POST /api/ar/capture - Capture AR screenshot\n  fastify.post<{ Body: z.infer<typeof captureARScreenshotSchema> }>(\n    '/capture',\n    {\n      preHandler: [authenticate],\n      schema: {\n        description: 'Capture AR screenshot during session',\n        tags: ['AR'],\n        body: captureARScreenshotSchema,\n        response: {\n          200: {\n            type: 'object',\n            properties: {\n              screenshotUrl: { type: 'string' },\n              timestamp: { type: 'string' }}}}\n      }\n    },\n    async (request: FastifyRequest<{ Body: z.infer<typeof captureARScreenshotSchema> }>, reply: FastifyReply) => {\n    try {\n      const userId = request.user.sub;\n\n      const result = await ARService.captureARScreenshot(userId, request.body);\n\n      return reply.code(200).send(result);\n    } catch (error: any) {\n      if ((error as any).message === 'AR_SESSION_NOT_FOUND') {\n        return reply.code(404).send({ error: 'AR_SESSION_NOT_FOUND', message: 'AR session not found' });\n      }\n      if ((error as any).message === 'AR_SESSION_NOT_ACTIVE') {\n        return reply.code(400).send({ error: 'AR_SESSION_NOT_ACTIVE', message: 'AR session is not active' });\n      }\n      throw error;\n    }\n  });\n\n  // POST /api/ar/end - End AR session\n  fastify.post<{ Body: z.infer<typeof endARSessionSchema> }>(\n    '/end',\n    {\n      preHandler: [authenticate],\n      schema: {\n        description: 'End AR view session',\n        tags: ['AR'],\n        body: endARSessionSchema,\n        response: {\n          200: {\n            type: 'object',\n            properties: {\n              sessionId: { type: 'string' },\n              duration: { type: 'number' },\n              screenshots: { type: 'number' }}}}\n      }\n    },\n    async (request: FastifyRequest<{ Body: z.infer<typeof endARSessionSchema> }>, reply: FastifyReply) => {\n    try {\n      const userId = request.user.sub;\n\n      const result = await ARService.endARSession(userId, request.body);\n\n      return reply.code(200).send(result);\n    } catch (error: any) {\n      if ((error as any).message === 'AR_SESSION_NOT_FOUND') {\n        return reply.code(404).send({ error: 'AR_SESSION_NOT_FOUND', message: 'AR session not found' });\n      }\n      if ((error as any).message === 'AR_SESSION_NOT_ACTIVE') {\n        return reply.code(400).send({ error: 'AR_SESSION_NOT_ACTIVE', message: 'AR session is not active' });\n      }\n      throw error;\n    }\n  });\n\n  // GET /api/ar/model/:prizeId - Get AR model for prize\n  fastify.get<{ Params: { prizeId: string } }>(\n    '/model/:prizeId',\n    {\n      preHandler: [authenticate],\n      schema: {\n        description: 'Get AR 3D model for a prize',\n        tags: ['AR'],\n        params: z.object({\n          prizeId: z.string().regex(/^[0-9a-fA-F]{24}$/, 'Invalid prize ID')\n        }),\n        response: {\n          200: {\n            type: 'object',\n            properties: {\n              prizeId: { type: 'string' },\n              arModel: {\n                type: 'object',\n                properties: {\n                  modelUrl: { type: 'string', nullable: true },\n                  textureUrl: { type: 'string', nullable: true },\n                  scale: { type: 'number' },\n                  rotation: {\n                    type: 'object',\n                    properties: {\n                      x: { type: 'number' },\n                      y: { type: 'number' },\n                      z: { type: 'number' }}}}}}}}\n      }\n    },\n    async (request: FastifyRequest<{ Params: { prizeId: string } }>, reply: FastifyReply) => {\n    try {\n      const { prizeId } = request.params;\n\n      const result = await ARService.getARModel(prizeId);\n\n      return reply.code(200).send(result);\n    } catch (error: any) {\n      if ((error as any).message === 'PRIZE_NOT_FOUND') {\n        return reply.code(404).send({ error: 'PRIZE_NOT_FOUND', message: 'Prize not found' });\n      }\n      throw error;\n    }\n  });\n}\n\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\ar\\routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\auth\\auth-extended.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'logger' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'logSecurity' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":29},{"ruleId":"no-self-assign","severity":2,"message":"'user.email' is assigned to itself.","line":35,"column":20,"nodeType":"MemberExpression","messageId":"selfAssignment","endLine":35,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'avatar' is defined but never used. Allowed unused args must match /^_/u.","line":282,"column":45,"nodeType":"Identifier","messageId":"unusedVar","endLine":282,"endColumn":59}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { User } from '@/models/User';\nimport { logger, logSecurity } from '@/lib/logger';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { config } from '@/config';\nimport { RedisCache } from '@/config/redis';\nimport * as bcrypt from 'bcryptjs';\n\n/**\n * Extended authentication services\n */\nexport class AuthExtendedService {\n  private static readonly PHONE_VERIFICATION_TTL_SEC = 10 * 60;\n\n  private static buildPhoneVerificationPayload(userId: string, code: string) {\n    return { userId, code, attempts: 0 };\n  }\n  /**\n   * Verify email with token\n   */\n  static async verifyEmail(token: string) {\n    try {\n      // In a real implementation, this would verify the token against a stored verification token\n      // For now, returning a placeholder implementation\n      const userId = await RedisCache.get(`email_verification:${token}`);\n      \n      if (!userId) {\n        throw new Error('INVALID_TOKEN');\n      }\n\n      const user = await User.findById(userId);\n      if (!user) {\n        throw new Error('USER_NOT_FOUND');\n      }\n\n      user.email = user.email; // This would mark email as verified in real implementation\n      await user.save();\n\n      await RedisCache.del(`email_verification:${token}`);\n\n      return {\n        success: true,\n        message: 'Email verified successfully',\n        data: { userId: user._id }\n      };\n    } catch (error) {\n      typedLogger.error('Email verification error', { error: error instanceof Error ? error.message : 'Unknown error' });\n      throw error;\n    }\n  }\n\n  /**\n   * Resend email verification\n   */\n  static async resendEmailVerification(email: string) {\n    try {\n      const user = await User.findByEmail(email);\n      if (!user) {\n        throw new Error('USER_NOT_FOUND');\n      }\n\n      // In real implementation, generate a new verification token and send email\n      const verificationToken = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);\n\n      // Store token in Redis with expiration (24 hours)\n      await RedisCache.set(`email_verification:${verificationToken}`, user._id.toString(), 24 * 60 * 60);\n\n      // In real implementation, send email here\n      typedLogger.info('Email verification sent', { userId: user._id, email });\n\n      return {\n        success: true,\n        message: 'Verification email sent',\n        data: { sentTo: email }\n      };\n    } catch (error) {\n      typedLogger.error('Resend email verification error', { error: (error as Error).message, email });\n      throw error;\n    }\n  }\n\n  /**\n   * Send phone verification code\n   */\n  static async sendPhoneVerification(phoneNumber: string, userId: string) {\n    try {\n      const user = await User.findById(userId);\n      if (!user) {\n        throw new Error('USER_NOT_FOUND');\n      }\n\n      // Generate verification code\n      const verificationCode = Math.floor(100000 + Math.random() * 900000).toString();\n      \n      // Store code in Redis with expiration (10 minutes)\n      const payload = AuthExtendedService.buildPhoneVerificationPayload(userId, verificationCode);\n      await RedisCache.set(`phone_verification:${phoneNumber}`, payload, AuthExtendedService.PHONE_VERIFICATION_TTL_SEC);\n\n      // In real implementation, send SMS via Twilio or similar service\n      typedLogger.info('Phone verification sent', { userId, phoneNumber });\n\n      return {\n        success: true,\n        message: 'Verification code sent',\n        data: { phoneNumber }\n      };\n    } catch (error) {\n      typedLogger.error('Send phone verification error', { error: (error as Error).message, userId, phoneNumber });\n      throw error;\n    }\n  }\n\n  /**\n   * Verify phone number with code\n   */\n  static async verifyPhone(phoneNumber: string, code: string, userId: string) {\n    try {\n      const user = await User.findById(userId);\n      if (!user) {\n        throw new Error('USER_NOT_FOUND');\n      }\n\n      const storedData = await RedisCache.get<{ userId: string; code: string; attempts: number }>(\n        `phone_verification:${phoneNumber}`\n      );\n      if (!storedData || storedData.code !== code) {\n        throw new Error('INVALID_CODE');\n      }\n\n      // Check if code has expired (Redis handles this, but we can add additional checks)\n      if (storedData.attempts >= 3) {\n        throw new Error('TOO_MANY_ATTEMPTS');\n      }\n\n      // Update user with phone number\n      user.phoneNumber = phoneNumber;\n      await user.save();\n\n      // Remove verification code\n      await RedisCache.del(`phone_verification:${phoneNumber}`);\n\n      typedLogger.info('Phone number verified', { userId, phoneNumber });\n\n      return {\n        success: true,\n        message: 'Phone number verified successfully',\n        data: { userId }\n      };\n    } catch (error) {\n      typedLogger.error('Verify phone error', { error: (error as Error).message, userId, phoneNumber });\n\n      // Increment attempts counter if invalid code\n      if (error instanceof Error && error.message === 'INVALID_CODE') {\n        const storedData = await RedisCache.get<{ userId: string; code: string; attempts: number }>(\n          `phone_verification:${phoneNumber}`\n        );\n        if (storedData) {\n          storedData.attempts = (storedData.attempts || 0) + 1;\n          await RedisCache.set(`phone_verification:${phoneNumber}`, storedData, AuthExtendedService.PHONE_VERIFICATION_TTL_SEC);\n        }\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Change user password\n   */\n  static async changePassword(userId: string, currentPassword: string, newPassword: string) {\n    try {\n      const user = await User.findById(userId);\n      if (!user) {\n        throw new Error('USER_NOT_FOUND');\n      }\n\n      // Check if password field exists\n      if (!user.passwordHash) {\n        throw new Error('PASSWORD_NOT_SET');\n      }\n\n      // Verify current password\n      const isValidPassword = await user.comparePassword(currentPassword);\n      if (!isValidPassword) {\n        throw new Error('INVALID_CURRENT_PASSWORD');\n      }\n\n      // Validate new password\n      if (newPassword.length < 8) {\n        throw new Error('PASSWORD_TOO_SHORT');\n      }\n\n      // Hash new password - use bcrypt for portability\n      user.passwordHash = await bcrypt.hash(newPassword, config.BCRYPT_ROUNDS || 12);\n\n      await user.save();\n\n      typedLogger.info('Password changed', { userId });\n\n      return {\n        success: true,\n        message: 'Password changed successfully'\n      };\n    } catch (error) {\n      typedLogger.error('Change password error', { error: (error as Error).message, userId });\n      throw error;\n    }\n  }\n\n  /**\n   * Delete user account\n   */\n  static async deleteAccount(userId: string, password: string) {\n    try {\n      const user = await User.findById(userId);\n      if (!user) {\n        throw new Error('USER_NOT_FOUND');\n      }\n\n      // Verify password\n      if (user.passwordHash) {\n        const isValidPassword = await user.comparePassword(password);\n        if (!isValidPassword) {\n          throw new Error('INVALID_PASSWORD');\n        }\n      }\n\n      // Soft delete the user\n      user.softDelete();\n      await user.save();\n\n      typedLogger.info('User account deleted', { userId });\n\n      return {\n        success: true,\n        message: 'Account deleted successfully'\n      };\n    } catch (error) {\n      typedLogger.error('Delete account error', { error: (error as Error).message, userId });\n      throw error;\n    }\n  }\n}\n\n/**\n * Extended user services\n */\nexport class UserExtendedService {\n  /**\n   * Get user statistics\n   */\n  static async getUserStats(userId: string) {\n    try {\n      const user = await User.findById(userId);\n      if (!user) {\n        throw new Error('USER_NOT_FOUND');\n      }\n\n      return {\n        id: user._id,\n        level: user.level,\n        points: user.points,\n        stats: user.stats,\n        levelProgress: {\n          progress: user.levelProgress?.progress || 0,\n          pointsToNext: user.levelProgress?.pointsToNext || 0,\n          nextLevel: user.levelProgress?.nextLevel || null,\n          currentLevel: user.level,\n          pointsForNext: (user.levelProgress?.pointsToNext || 0) + user.points.total\n        },\n        createdAt: user.createdAt,\n        lastActive: user.lastActive\n      };\n    } catch (error) {\n      typedLogger.error('Get user stats error', { error: (error as Error).message, userId });\n      throw error;\n    }\n  }\n\n  /**\n   * Upload user avatar\n   */\n  static async uploadAvatar(userId: string, avatar: string) {\n    try {\n      const user = await User.findById(userId);\n      if (!user) {\n        throw new Error('USER_NOT_FOUND');\n      }\n\n      // In real implementation, upload avatar to cloud storage service (e.g., S3, Cloudinary)\n      // For now, we'll generate a placeholder filename\n\n      // Generate unique avatar filename\n      const avatarFilename = `avatar_${userId}_${Date.now()}.jpg`;\n      const avatarUrl = `/uploads/avatars/${avatarFilename}`;\n\n      // Update user with avatar URL\n      user.avatar = avatarUrl;\n      await user.save();\n\n      typedLogger.info('Avatar uploaded', { userId, avatar: avatarUrl });\n\n      return {\n        success: true,\n        message: 'Avatar uploaded successfully',\n        data: { avatarUrl }\n      };\n    } catch (error) {\n      typedLogger.error('Upload avatar error', { error: (error as Error).message, userId });\n      throw error;\n    }\n  }\n\n  /**\n   * Get user achievements\n   */\n  static async getUserAchievements(userId: string) {\n    try {\n      const user = await User.findById(userId);\n      if (!user) {\n        throw new Error('USER_NOT_FOUND');\n      }\n\n      // In a real implementation, this would fetch user-specific achievements from a separate collection\n      // For now, returning placeholder achievements based on user stats\n      const achievements = [];\n\n      // Example achievements based on user activity\n      if (user.stats.prizesFound >= 1) {\n        achievements.push({ id: 'first_prize', name: 'First Prize', description: 'Found your first prize', earned: true });\n      }\n      if (user.stats.prizesFound >= 10) {\n        achievements.push({ id: 'ten_prizes', name: 'Treasure Hunter', description: 'Found 10 prizes', earned: true });\n      }\n      if (user.points.total >= 1000) {\n        achievements.push({ id: 'point_collector', name: 'Point Collector', description: 'Earned 1000 points', earned: true });\n      }\n      if (user.stats.currentStreak >= 7) {\n        achievements.push({ id: 'streak_master', name: 'Streak Master', description: 'Maintained 7-day streak', earned: true });\n      }\n\n      return {\n        achievements,\n        totalEarned: achievements.filter(a => a.earned).length,\n        userId\n      };\n    } catch (error) {\n      typedLogger.error('Get user achievements error', { error: (error as Error).message, userId });\n      throw error;\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\auth\\index.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'AuditLog' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'logger' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'validateAntiCheat' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":27},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":114,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":114,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4041,4044],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4041,4044],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":123,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":123,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4529,4532],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4529,4532],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":131,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":131,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4820,4823],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4820,4823],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":147,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":147,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5341,5344],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5341,5344],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":148,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":148,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5375,5378],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5375,5378],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":149,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":149,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5406,5409],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5406,5409],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":214,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":214,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7642,7645],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7642,7645],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":215,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":215,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7707,7710],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7707,7710],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":237,"column":15,"nodeType":"BlockStatement","messageId":"unexpected","endLine":237,"endColumn":17,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[8391,8391],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":250,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":250,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8725,8728],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8725,8728],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":252,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":252,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8810,8813],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8810,8813],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":281,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":281,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9723,9726],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9723,9726],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":282,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":282,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9790,9793],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9790,9793],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":305,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":305,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10610,10613],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10610,10613],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":306,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":306,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10677,10680],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10677,10680],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":335,"column":15,"nodeType":"BlockStatement","messageId":"unexpected","endLine":335,"endColumn":17,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[11512,11512],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":377,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":377,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12791,12794],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12791,12794],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":432,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":432,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14572,14575],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14572,14575],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":433,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":433,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14637,14640],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14637,14640],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":458,"column":15,"nodeType":"BlockStatement","messageId":"unexpected","endLine":458,"endColumn":17,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[15360,15360],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":478,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":478,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15889,15892],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15889,15892],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":481,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":481,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15981,15984],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15981,15984],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":539,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":539,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17813,17816],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17813,17816],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":540,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":540,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17878,17881],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17878,17881],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":564,"column":15,"nodeType":"BlockStatement","messageId":"unexpected","endLine":564,"endColumn":17,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[18594,18594],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":638,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":638,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20860,20863],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20860,20863],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":639,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":639,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20936,20939],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20936,20939],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":643,"column":15,"nodeType":"BlockStatement","messageId":"unexpected","endLine":643,"endColumn":17,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[21033,21033],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":675,"column":72,"nodeType":"BlockStatement","messageId":"unexpected","endLine":675,"endColumn":74,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[21994,21994],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":735,"column":82,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":735,"endColumn":85,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23647,23650],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23647,23650],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":751,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":751,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24353,24356],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24353,24356],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":766,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":766,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24948,24951],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24948,24951],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":769,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":769,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25033,25036],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25033,25036],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":895,"column":15,"nodeType":"BlockStatement","messageId":"unexpected","endLine":895,"endColumn":17,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[28930,28930],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":915,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":915,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[29482,29485],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[29482,29485],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":949,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":949,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[30676,30679],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[30676,30679],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":960,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":960,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31027,31030],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31027,31030],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":972,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":972,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31381,31384],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31381,31384],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":996,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":996,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32099,32102],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32099,32102],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1016,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1016,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32671,32674],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32671,32674],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1040,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1040,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[33338,33341],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[33338,33341],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1066,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1066,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[34086,34089],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[34086,34089],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1092,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1092,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[34873,34876],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[34873,34876],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1116,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1116,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[35497,35500],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[35497,35500],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1129,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1129,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[35979,35982],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[35979,35982],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1148,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1148,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[36582,36585],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[36582,36585],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1159,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1159,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[36959,36962],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[36959,36962],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":50,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyInstance, FastifyRequest } from 'fastify';\nimport { z } from 'zod';\nimport bcrypt from 'bcryptjs';\nimport { User } from '@/models/User';\nimport { AuditLog } from '@/models/AuditLog';\nimport { signTokenPair, generateSessionId, getTokenRemainingLifetime } from '@/lib/jwt';\nimport { logger, logSecurity } from '@/lib/logger';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { config, isProduction } from '@/config';\nimport { UserRole, Platform } from '@/types';\nimport { RedisSession } from '@/config/redis';\nimport { validateAntiCheat } from '@/utils/anti-cheat';\nimport { authenticate } from '@/middleware/auth';\nimport { authRateLimit } from '@/middleware/distributed-rate-limit';\nimport { AuthExtendedService, UserExtendedService } from './auth-extended';\nimport { UsersService } from '@/modules/users/index';\nimport { normalizeError } from '@/utils/api-errors';\nimport { parseCookies, serializeCookie } from '@/utils/cookies';\nimport { broadcastAdminEvent } from '@/lib/websocket';\n\nconst buildSessionPayload = (payload: {\n  userId: string;\n  deviceId: string;\n  platform: Platform;\n  email?: string;\n}) => ({\n  userId: payload.userId,\n  deviceId: payload.deviceId,\n  platform: payload.platform,\n  ...(payload.email ? { email: payload.email } : {}),\n  createdAt: new Date().toISOString(),\n});\n\n// Validation schemas\nconst guestLoginSchema = z.object({\n  deviceId: z.string().min(1).max(100),\n  platform: z.enum([Platform.IOS, Platform.ANDROID, Platform.WEB]),\n  fcmToken: z.string().optional(),\n  deviceModel: z.string().optional(),\n  osVersion: z.string().optional(),\n  appVersion: z.string().optional(),\n  location: z.object({\n    lat: z.number().min(-90).max(90),\n    lng: z.number().min(-180).max(180),\n    city: z.string().min(1).max(50)}).optional()});\n\nconst emailRegisterSchema = z.object({\n  email: z.string().email().max(255),\n  password: z.string().min(8).max(128),\n  displayName: z.string().min(2).max(50),\n  deviceId: z.string().min(1).max(100),\n  platform: z.enum([Platform.IOS, Platform.ANDROID, Platform.WEB]),\n  fcmToken: z.string().optional(),\n  deviceModel: z.string().optional(),\n  osVersion: z.string().optional(),\n  appVersion: z.string().optional(),\n  location: z.object({\n    lat: z.number().min(-90).max(90),\n    lng: z.number().min(-180).max(180),\n    city: z.string().min(1).max(50)}).optional()});\n\nconst emailLoginSchema = z.object({\n  email: z.string().email(),\n  password: z.string().min(1),\n  deviceId: z.string().min(1).max(100),\n  platform: z.enum([Platform.IOS, Platform.ANDROID, Platform.WEB]),\n  fcmToken: z.string().optional(),\n  deviceModel: z.string().optional(),\n  osVersion: z.string().optional(),\n  appVersion: z.string().optional(),\n  location: z.object({\n    lat: z.number().min(-90).max(90),\n    lng: z.number().min(-180).max(180),\n    city: z.string().min(1).max(50)}).optional()});\n\n// Partner login schema (email or username)\nconst partnerLoginSchema = z.object({\n  email: z.string().email().optional(),\n  username: z.string().min(3).max(50).optional(),\n  password: z.string().min(1),\n  deviceId: z.string().min(1).max(100),\n  platform: z.enum([Platform.IOS, Platform.ANDROID, Platform.WEB]),\n  fcmToken: z.string().optional(),\n  deviceModel: z.string().optional(),\n  osVersion: z.string().optional(),\n  appVersion: z.string().optional(),\n  location: z.object({\n    lat: z.number().min(-90).max(90),\n    lng: z.number().min(-180).max(180),\n    city: z.string().min(1).max(50)}).optional()\n}).refine(data => !!(data.email || data.username), {\n  message: 'IDENTIFIER_REQUIRED',\n  path: ['email'],\n});\n\nconst refreshTokenSchema = z.object({\n  refreshToken: z.string().min(1).optional()});\n\nconst logoutSchema = z.object({\n  refreshToken: z.string().optional(),\n  deviceId: z.string().optional()});\n\nconst ACCESS_COOKIE_NAME = 'access_token';\nconst REFRESH_COOKIE_NAME = 'refresh_token';\n\nconst buildCookieOptions = (maxAge: number) => ({\n  httpOnly: true,\n  secure: isProduction,\n  sameSite: 'lax' as const,\n  path: '/',\n  maxAge,\n});\n\nconst setAuthCookies = (reply: any, tokens: { accessToken: string; refreshToken: string }) => {\n  const accessTtl = Math.max(0, getTokenRemainingLifetime(tokens.accessToken));\n  const refreshTtl = Math.max(0, getTokenRemainingLifetime(tokens.refreshToken));\n  reply.header('Set-Cookie', [\n    serializeCookie(ACCESS_COOKIE_NAME, tokens.accessToken, buildCookieOptions(accessTtl)),\n    serializeCookie(REFRESH_COOKIE_NAME, tokens.refreshToken, buildCookieOptions(refreshTtl)),\n  ]);\n};\n\nconst clearAuthCookies = (reply: any) => {\n  reply.header('Set-Cookie', [\n    serializeCookie(ACCESS_COOKIE_NAME, '', buildCookieOptions(0)),\n    serializeCookie(REFRESH_COOKIE_NAME, '', buildCookieOptions(0)),\n  ]);\n};\n\nconst getRefreshTokenFromRequest = (request: FastifyRequest) => {\n  const bodyToken = (request.body as any)?.refreshToken as string | undefined;\n  if (bodyToken) return bodyToken;\n  const cookies = parseCookies(request.headers.cookie as string | undefined);\n  return cookies[REFRESH_COOKIE_NAME];\n};\n\n/**\n * Authentication service\n */\nexport class AuthService {\n  /**\n   * Partner login - only for users with role 'partner' and valid partnerId\n   */\n  static async partnerLogin(data: z.infer<typeof partnerLoginSchema>, context?: { ip?: string; userAgent?: string }) {\n    try {\n      const identifierRaw =\n        (data as any).username ||\n        (data as any).login ||\n        (data as any).email ||\n        '';\n      const identifier = identifierRaw.toString().trim().toLowerCase();\n\n      // Find partner portal user by email or username\n      const user = await User.findOne({\n        $or: [\n          { email: identifier },\n          { username: identifier },\n        ],\n      }).select('+passwordHash');\n\n      if (!user) {\n        await new Promise(resolve => setTimeout(resolve, 1000));\n        throw new Error('NOT_A_PARTNER');\n      }\n\n      // Must be partner\n      if (user.role !== UserRole.PARTNER || !user.partnerId) {\n        throw new Error('NOT_A_PARTNER');\n      }\n      // Check if user is banned\n      if (user.isBanned) {\n        if (user.banExpiresAt && user.banExpiresAt > new Date()) {\n          logSecurity('banned_partner_login_attempt', 'medium', {\n            userId: user._id,\n            email: identifier,\n            banReason: user.banReason});\n          throw new Error('ACCOUNT_BANNED');\n        } else {\n          user.unban();\n          await user.save();\n        }\n      }\n      // Verify password\n      let isValidPassword = false;\n      try {\n        isValidPassword = await user.comparePassword(data.password);\n      } catch (err) {\n        isValidPassword = false;\n      }\n      if (!isValidPassword) {\n        logSecurity('invalid_partner_password_attempt', 'low', {\n          userId: user._id,\n          email: identifier});\n        throw new Error('INVALID_CREDENTIALS');\n      }\n      // Normalize platform for devices\n      const platformInput = (data.platform as string)?.toString().toLowerCase();\n      const platform =\n        platformInput === 'web' ? Platform.WEB\n        : platformInput === 'android' ? Platform.ANDROID\n        : platformInput === 'ios' ? Platform.IOS\n        : data.platform;\n      // Update device and location\n      user.addDevice(data.deviceId || 'partner-portal', platform as Platform, data.fcmToken, {\n        model: data.deviceModel,\n        osVersion: data.osVersion,\n        appVersion: data.appVersion,\n        userAgent: context?.userAgent,\n      });\n      if (data.location) {\n        user.updateLocation(data.location.lat, data.location.lng, data.location.city);\n      }\n      user.lastActive = new Date();\n      if (context?.ip) (user as any).lastIp = context.ip;\n      if (context?.userAgent) (user as any).lastUserAgent = context.userAgent;\n      await user.save();\n      // Generate session and tokens\n      const sessionId = generateSessionId();\n      const tokens = signTokenPair({\n        sub: user._id.toString(),\n        email: user.email,\n        role: user.role,\n        deviceId: data.deviceId,\n        sessionId});\n      // Store session in Redis (best-effort)\n      try {\n        await RedisSession.create(\n          sessionId,\n          buildSessionPayload({\n            userId: user._id.toString(),\n            deviceId: data.deviceId,\n            platform: data.platform,\n            email: user.email,\n          }),\n          30 * 24 * 60 * 60\n        );\n      } catch {}\n      return {\n        user: {\n          id: user._id,\n          email: user.email,\n          displayName: user.displayName,\n          role: user.role,\n          partnerId: user.partnerId,\n          level: user.level,\n          points: user.points,\n          isGuest: false},\n        tokens,\n        sessionId};\n    } catch (error: any) {\n      typedLogger.error('partner_login_unexpected', {\n        email: (data as any)?.email,\n        error: error?.message,\n        stack: error?.stack,\n      });\n      throw error;\n    }\n  }\n  /**\n   * Guest login - create anonymous user\n   */\n  static async guestLogin(data: z.infer<typeof guestLoginSchema>, context?: { ip?: string; userAgent?: string }) {\n    try {\n      // Check if user already exists with this device\n      let user = await User.findByDeviceId(data.deviceId);\n      \n      if (user) {\n        // Update existing user\n        user.addDevice(data.deviceId, data.platform, data.fcmToken, {\n          model: data.deviceModel,\n          osVersion: data.osVersion,\n          appVersion: data.appVersion,\n          userAgent: context?.userAgent,\n        });\n        \n        if (data.location) {\n          user.updateLocation(data.location.lat, data.location.lng, data.location.city);\n        }\n        \n        user.lastActive = new Date();\n        if (context?.ip) (user as any).lastIp = context.ip;\n        if (context?.userAgent) (user as any).lastUserAgent = context.userAgent;\n        await user.save();\n      } else {\n        // Create new guest user\n        const displayName = `Player_${Math.random().toString(36).substring(2, 8)}`;\n        \n        user = new User({\n          displayName,\n          role: UserRole.PLAYER,\n          devices: [{\n            deviceId: data.deviceId,\n            platform: data.platform,\n            fcmToken: data.fcmToken,\n            model: data.deviceModel,\n            osVersion: data.osVersion,\n            appVersion: data.appVersion,\n            userAgent: context?.userAgent,\n            lastUsed: new Date(),\n            isActive: true}]});\n        \n        if (data.location) {\n          user.updateLocation(data.location.lat, data.location.lng, data.location.city);\n        }\n        if (context?.ip) (user as any).lastIp = context.ip;\n        if (context?.userAgent) (user as any).lastUserAgent = context.userAgent;\n        \n        await user.save();\n        \n        typedLogger.info('Guest user created', {\n          userId: user._id,\n          deviceId: data.deviceId,\n          platform: data.platform});\n      }\n      \n      // Generate session and tokens\n      const sessionId = generateSessionId();\n      const tokens = signTokenPair({\n        sub: user._id.toString(),\n        role: user.role,\n        deviceId: data.deviceId,\n        sessionId});\n      \n      // Store session in Redis (standardized API, best-effort)\n      try {\n        await RedisSession.create(\n          sessionId,\n          buildSessionPayload({\n            userId: user._id.toString(),\n            deviceId: data.deviceId,\n            platform: data.platform,\n          }),\n          30 * 24 * 60 * 60\n        );\n      } catch {}\n      \n      return {\n        user: {\n          id: user._id,\n          displayName: user.displayName,\n          role: user.role,\n          level: user.level,\n          points: user.points,\n          isGuest: user.isGuest},\n        tokens,\n        sessionId};\n      \n    } catch (error) {\n      const normalized = normalizeError(error, 'Guest login failed');\n      typedLogger.error('Guest login error', {\n        error: normalized.message,\n        deviceId: data.deviceId});\n      throw new Error(normalized.code);\n    }\n  }\n  \n  /**\n   * Email registration\n   */\n  static async emailRegister(data: z.infer<typeof emailRegisterSchema>, context?: { ip?: string; userAgent?: string }) {\n    try {\n      // Check if email already exists\n      const existingUser = await User.findByEmail(data.email);\n      if (existingUser) {\n        throw new Error('EMAIL_ALREADY_EXISTS');\n      }\n      \n      // Check if device is already associated with another account\n      const existingDevice = await User.findByDeviceId(data.deviceId);\n      if (existingDevice && existingDevice.email) {\n        throw new Error('DEVICE_ALREADY_REGISTERED');\n      }\n      \n      // Hash password\n      const passwordHash = await bcrypt.hash(data.password, config.BCRYPT_ROUNDS);\n      \n      let user: any;\n      \n      if (existingDevice) {\n        // Convert guest account to registered account\n        user = existingDevice;\n        user.email = data.email;\n        user.passwordHash = passwordHash;\n        user.displayName = data.displayName;\n        user.addDevice(data.deviceId, data.platform, data.fcmToken, {\n          model: data.deviceModel,\n          osVersion: data.osVersion,\n          appVersion: data.appVersion,\n          userAgent: context?.userAgent,\n        });\n        \n        typedLogger.info('Guest account converted to registered', {\n          userId: user._id,\n          email: data.email});\n      } else {\n        // Create new registered user\n        user = new User({\n          email: data.email,\n          passwordHash,\n          displayName: data.displayName,\n          role: UserRole.PLAYER,\n          devices: [{\n            deviceId: data.deviceId,\n            platform: data.platform,\n            fcmToken: data.fcmToken,\n            model: data.deviceModel,\n            osVersion: data.osVersion,\n            appVersion: data.appVersion,\n            userAgent: context?.userAgent,\n            lastUsed: new Date(),\n            isActive: true}]});\n        \n        typedLogger.info('New user registered', {\n          email: data.email,\n          deviceId: data.deviceId});\n        \n        // Broadcast to admin dashboard for real-time updates\n        broadcastAdminEvent({\n          type: 'user_update',\n          data: {\n            type: 'new_user',\n            email: data.email,\n            platform: data.platform,\n            timestamp: new Date()\n          }\n        });\n      }\n      \n      if (data.location) {\n        user.updateLocation(data.location.lat, data.location.lng, data.location.city);\n      }\n      if (context?.ip) (user as any).lastIp = context.ip;\n      if (context?.userAgent) (user as any).lastUserAgent = context.userAgent;\n      \n      await user.save();\n      \n      // Generate session and tokens\n      const sessionId = generateSessionId();\n      const tokens = signTokenPair({\n        sub: user._id.toString(),\n        email: user.email,\n        role: user.role,\n        deviceId: data.deviceId,\n        sessionId});\n      \n      // Store session in Redis (standardized API, best-effort)\n      try {\n        await RedisSession.create(\n          sessionId,\n          buildSessionPayload({\n            userId: user._id.toString(),\n            deviceId: data.deviceId,\n            platform: data.platform,\n            email: user.email,\n          }),\n          30 * 24 * 60 * 60\n        );\n      } catch {}\n      \n      return {\n        user: {\n          id: user._id,\n          email: user.email,\n          displayName: user.displayName,\n          role: user.role,\n          level: user.level,\n          points: user.points,\n          isGuest: false},\n        tokens,\n        sessionId};\n      \n    } catch (error) {\n      const normalized = normalizeError(error, 'Registration failed');\n      typedLogger.error('Email registration error', {\n        error: normalized.message,\n        email: data.email});\n      \n      if ((error as any).message === 'EMAIL_ALREADY_EXISTS') {\n        throw error;\n      }\n      if ((error as any).message === 'DEVICE_ALREADY_REGISTERED') {\n        throw error;\n      }\n      \n      throw new Error(normalized.code);\n    }\n  }\n  \n  /**\n   * Email login\n   */\n  static async emailLogin(data: z.infer<typeof emailLoginSchema>, context?: { ip?: string; userAgent?: string }) {\n    try {\n      // Find user by email\n      const user = await User.findOne({ email: data.email }).select('+passwordHash');\n      if (!user) {\n        // Don't reveal if email exists or not\n        await new Promise(resolve => setTimeout(resolve, 1000));\n        throw new Error('INVALID_CREDENTIALS');\n      }\n      \n      // Check if user is banned\n      if (user.isBanned) {\n        if (user.banExpiresAt && user.banExpiresAt > new Date()) {\n          logSecurity('banned_user_login_attempt', 'medium', {\n            userId: user._id,\n            email: data.email,\n            banReason: user.banReason});\n          throw new Error('ACCOUNT_BANNED');\n        } else {\n          // Unban expired bans\n          user.unban();\n          await user.save();\n        }\n      }\n      \n      // Verify password\n      const isValidPassword = await user.comparePassword(data.password);\n      if (!isValidPassword) {\n        logSecurity('invalid_password_attempt', 'low', {\n          userId: user._id,\n          email: data.email});\n        throw new Error('INVALID_CREDENTIALS');\n      }\n      \n      // Update device and location\n      user.addDevice(data.deviceId, data.platform, data.fcmToken, {\n        model: data.deviceModel,\n        osVersion: data.osVersion,\n        appVersion: data.appVersion,\n        userAgent: context?.userAgent,\n      });\n      \n      if (data.location) {\n        user.updateLocation(data.location.lat, data.location.lng, data.location.city);\n      }\n      \n      user.lastActive = new Date();\n      if (context?.ip) (user as any).lastIp = context.ip;\n      if (context?.userAgent) (user as any).lastUserAgent = context.userAgent;\n      await user.save();\n      \n      // Generate session and tokens\n      const sessionId = generateSessionId();\n      const tokens = signTokenPair({\n        sub: user._id.toString(),\n        email: user.email,\n        role: user.role,\n        deviceId: data.deviceId,\n        sessionId});\n      \n      // Store session in Redis (standardized API, best-effort)\n      try {\n        await RedisSession.create(\n          sessionId,\n          buildSessionPayload({\n            userId: user._id.toString(),\n            deviceId: data.deviceId,\n            platform: data.platform,\n            email: user.email,\n          }),\n          30 * 24 * 60 * 60\n        );\n      } catch {}\n      \n      typedLogger.info('User logged in', {\n        userId: user._id,\n        email: user.email,\n        deviceId: data.deviceId});\n      \n      // Log admin login to audit log\n      if (['admin', 'super_admin', 'moderator'].includes(user.role)) {\n        try {\n          // Use unified audit logger - writes to both Pino and MongoDB\n          const { audit } = await import('@/lib/audit-logger');\n          await audit.adminLogin(user._id.toString(), user.email, {\n            ipAddress: context?.ip,\n            userAgent: context?.userAgent,\n            metadata: {\n              deviceId: data.deviceId,\n              platform: data.platform,\n            },\n          });\n        } catch (auditError) {\n          typedLogger.error('Failed to log admin login', { error: auditError });\n        }\n      }\n      \n      return {\n        user: {\n          id: user._id,\n          email: user.email,\n          displayName: user.displayName,\n          role: user.role,\n          level: user.level,\n          points: user.points,\n          isGuest: false},\n        tokens,\n        sessionId};\n      \n    } catch (error) {\n      const normalized = normalizeError(error, 'Login failed');\n      typedLogger.error('Email login error', {\n        error: normalized.message,\n        email: data.email});\n\n      if (error instanceof Error && ['INVALID_CREDENTIALS', 'ACCOUNT_BANNED'].includes(error.message)) {\n        throw error;\n      }\n\n      throw new Error(normalized.code);\n    }\n  }\n\n\n  /**\n   * Refresh access token\n   */\n  static async refreshToken(data: z.infer<typeof refreshTokenSchema>) {\n    try {\n      if (!data.refreshToken) {\n        throw new Error('MISSING_REFRESH_TOKEN');\n      }\n      const { refreshAccessToken } = await import('@/lib/jwt');\n      const newTokens = await refreshAccessToken(data.refreshToken);\n      \n      if (!newTokens) {\n        throw new Error('INVALID_REFRESH_TOKEN');\n      }\n\n      // Best-effort: update lastIp / lastUserAgent from the refresh token payload\n      try {\n        const { decodeToken } = await import('@/lib/jwt');\n        const decoded = decodeToken(data.refreshToken);\n        if (decoded?.sub) {\n          await User.findByIdAndUpdate(decoded.sub, {\n            $set: {\n              lastIp: (global as any).currentRequestIp || undefined,\n              lastUserAgent: (global as any).currentRequestUserAgent || undefined,\n            },\n          });\n        }\n      } catch {}\n      \n      return { tokens: newTokens };\n      \n    } catch (error) {\n      const normalized = normalizeError(error, 'Token refresh failed');\n      typedLogger.error('Token refresh error', { error: normalized.message });\n      throw new Error(normalized.code);\n    }\n  }\n  \n  /**\n   * Logout user\n   */\n  static async logout(\n    userId: string,\n    data: z.infer<typeof logoutSchema>\n  ) {\n    try {\n      const { revokeToken, revokeSessionTokens } = await import('@/lib/jwt');\n      \n      if (data.refreshToken) {\n        // Revoke specific refresh token\n        const { decodeToken } = await import('@/lib/jwt');\n        const decoded = decodeToken(data.refreshToken);\n        if (decoded?.jti) {\n          await revokeToken(decoded.jti);\n        }\n        \n        // Revoke session tokens\n        if (decoded?.sessionId) {\n          await revokeSessionTokens(decoded.sessionId);\n          try { await RedisSession.destroy(decoded.sessionId); } catch {}\n        }\n      }\n      \n      if (data.deviceId) {\n        // Deactivate device\n        const user = await User.findById(userId);\n        if (user) {\n          const device = user.devices.find(d => d.deviceId === data.deviceId);\n          if (device) {\n            device.isActive = false;\n            device.fcmToken = undefined;\n            await user.save();\n          }\n        }\n      }\n      \n      typedLogger.info('User logged out', { userId, deviceId: data.deviceId });\n      \n      return { success: true };\n      \n    } catch (error) {\n      const normalized = normalizeError(error, 'Logout failed');\n      typedLogger.error('Logout error', { error: normalized.message, userId });\n      throw new Error(normalized.code);\n    }\n  }\n  \n  /**\n   * Get current user profile\n   */\n  // (removed) getProfile ÔÇö consolidated in UsersService\n  \n  /**\n   * Update user profile\n   */\n  // (removed) updateProfile ÔÇö consolidated in UsersService\n}\n\n/**\n * Auth routes\n */\nexport default async function authRoutes(fastify: FastifyInstance) {\n  // Partner login endpoint\n  fastify.post('/partner-login', {\n    preHandler: [authRateLimit]\n  }, async (request, reply) => {\n    try {\n      const result = await AuthService.partnerLogin(request.body, {\n        ip: request.ip,\n        userAgent: (request.headers['user-agent'] as string) || undefined,\n      });\n      if (result?.tokens) {\n        setAuthCookies(reply, result.tokens);\n      }\n      reply.send({\n        success: true,\n        data: result,\n        timestamp: new Date().toISOString()});\n    } catch (error) {\n      typedLogger.error('Partner login failed', { error, email: (request.body as any)?.email });\n      const normalized = normalizeError(error, 'Partner login failed');\n      const code = normalized.code as string;\n      let statusCode = 401;\n      if (code === 'ACCOUNT_BANNED') statusCode = 403;\n      if (code === 'NOT_A_PARTNER') statusCode = 403;\n      const noPartnerMessage = 'There is no partner to be YallaCatch partner. Contact support.';\n      const message =\n        code === 'INVALID_CREDENTIALS'\n          ? 'Invalid credentials'\n          : code === 'NOT_A_PARTNER'\n          ? noPartnerMessage\n          : normalized.message;\n      reply.code(statusCode).send({\n        success: false,\n        error: code || 'PARTNER_LOGIN_FAILED',\n        message: message || (error as any)?.message || 'Partner login failed',\n        timestamp: new Date().toISOString()});\n    }\n  });\n  // Alias for current user profile (deprecated ÔÇö use /api/v1/users/profile)\n  fastify.get('/me', {\n    preHandler: [authenticate]}, async (request, reply) => {\n    try {\n      const result = await UsersService.getProfile(request.user.sub);\n      reply.header('Deprecation', 'true');\n      reply.header('Link', '</api/v1/users/profile>; rel=\"successor-version\"');\n      reply.send({\n        success: true,\n        data: result,\n        timestamp: new Date().toISOString()});\n    } catch (error: any) {\n      reply.code(404).send({\n        success: false,\n        error: (error as any).message,\n        timestamp: new Date().toISOString()});\n    }\n  });\n  // Guest login\n  fastify.post('/guest', {\n      preHandler: [authRateLimit],\n      schema: {\n        response: {\n          200: {\n            type: 'object',\n            properties: {\n              success: { type: 'boolean' },\n              data: {\n                type: 'object',\n                properties: {\n                  user: { type: 'object' },\n                  tokens: { type: 'object' },\n                  sessionId: { type: 'string' }}}}}}}}, async (request, reply) => {\n    try {\n      const result = await AuthService.guestLogin(request.body, {\n        ip: request.ip,\n        userAgent: (request.headers['user-agent'] as string) || undefined,\n      });\n      if (result?.tokens) {\n        setAuthCookies(reply, result.tokens);\n      }\n      \n      reply.send({\n        success: true,\n        data: result,\n        timestamp: new Date().toISOString()});\n    } catch (error) {\n      const normalized = normalizeError(error, 'Guest login failed');\n      reply.code(400).send({\n        success: false,\n        error: normalized.code,\n        message: normalized.message,\n        timestamp: new Date().toISOString()});\n    }\n  });\n  \n  // Email registration\n  fastify.post('/register', {\n    preHandler: [authRateLimit]\n  }, async (request, reply) => {\n    try {\n      const result = await AuthService.emailRegister(request.body, {\n        ip: request.ip,\n        userAgent: (request.headers['user-agent'] as string) || undefined,\n      });\n      if (result?.tokens) {\n        setAuthCookies(reply, result.tokens);\n      }\n      \n      reply.send({\n        success: true,\n        data: result,\n        timestamp: new Date().toISOString()});\n    } catch (error) {\n      const normalized = normalizeError(error, 'Registration failed');\n      const statusCode = normalized.code === 'EMAIL_ALREADY_EXISTS' ? 409 : 400;\n      \n      reply.code(statusCode).send({\n        success: false,\n        error: normalized.code,\n        message: normalized.message,\n        timestamp: new Date().toISOString()});\n    }\n  });\n  \n  // Email login\n  fastify.post('/login', {\n    preHandler: [authRateLimit]\n  }, async (request, reply) => {\n    try {\n      const result = await AuthService.emailLogin(request.body, {\n        ip: request.ip,\n        userAgent: (request.headers['user-agent'] as string) || undefined,\n      });\n      if (result?.tokens) {\n        setAuthCookies(reply, result.tokens);\n      }\n      \n      reply.send({\n        success: true,\n        data: result,\n        timestamp: new Date().toISOString()});\n    } catch (error) {\n      const normalized = normalizeError(error, 'Login failed');\n      const code = normalized.code as string;\n      const statusCode = code === 'ACCOUNT_BANNED' ? 403 : 401;\n      const message = code === 'INVALID_CREDENTIALS' ? 'Invalid credentials' : normalized.message;\n      \n      reply.code(statusCode).send({\n        success: false,\n        error: code,\n        message,\n        timestamp: new Date().toISOString()});\n    }\n  });\n  \n  // Refresh token\n  fastify.post('/refresh', {\n  }, async (request, reply) => {\n    try {\n      const refreshToken = getRefreshTokenFromRequest(request);\n      const result = await AuthService.refreshToken({ refreshToken });\n      if (result?.tokens) {\n        setAuthCookies(reply, result.tokens);\n      }\n\n      // Best-effort: update lastIp/lastUserAgent using refresh token payload\n      try {\n        const { decodeToken } = await import('@/lib/jwt');\n        if (refreshToken) {\n          const decoded = decodeToken(refreshToken);\n          if (decoded?.sub) {\n            await User.findByIdAndUpdate(decoded.sub, {\n              $set: {\n                lastIp: request.ip,\n                lastUserAgent: (request.headers['user-agent'] as string) || undefined,\n              },\n            });\n          }\n        }\n      } catch {}\n      \n      reply.send({\n        success: true,\n        data: result,\n        timestamp: new Date().toISOString()});\n    } catch (error) {\n      const normalized = normalizeError(error, 'Token refresh failed');\n      reply.code(401).send({\n        success: false,\n        error: normalized.code,\n        message: normalized.message,\n        timestamp: new Date().toISOString()});\n    }\n  });\n  \n  // Logout\n  fastify.post('/logout', {\n    preHandler: [authenticate]}, async (request, reply) => {\n    try {\n      const body = (request.body || {}) as any;\n      const refreshToken = body.refreshToken || getRefreshTokenFromRequest(request);\n      const result = await AuthService.logout(request.user.sub, { ...body, refreshToken });\n      clearAuthCookies(reply);\n      reply.send({\n        success: true,\n        data: result,\n        timestamp: new Date().toISOString()});\n    } catch (error) {\n      const normalized = normalizeError(error, 'Logout failed');\n      clearAuthCookies(reply);\n      reply.code(400).send({\n        success: false,\n        error: normalized.code,\n        message: normalized.message,\n        timestamp: new Date().toISOString()});\n    }\n  });\n  \n  // Get profile (deprecated ÔÇö use /api/v1/users/profile)\n  fastify.get('/profile', {\n    preHandler: [authenticate]}, async (request, reply) => {\n    try {\n      const result = await UsersService.getProfile(request.user.sub);\n      reply.header('Deprecation', 'true');\n      reply.header('Link', '</api/v1/users/profile>; rel=\"successor-version\"');\n      \n      reply.send({\n        success: true,\n        data: result,\n        timestamp: new Date().toISOString()});\n    } catch (error) {\n      reply.code(404).send({\n        success: false,\n        error: (error as any).message,\n        timestamp: new Date().toISOString()});\n    }\n  });\n  \n  // Update profile (deprecated ÔÇö use /api/v1/users/profile [PATCH])\n  fastify.patch('/profile', {\n    preHandler: [authenticate]}, async (request, reply) => {\n    try {\n      const result = await UsersService.updateProfile(\n        request.user.sub,\n        request.body as any\n      );\n      reply.header('Deprecation', 'true');\n      reply.header('Link', '</api/v1/users/profile>; rel=\"successor-version\"');\n      \n      reply.send({\n        success: true,\n        data: result,\n        timestamp: new Date().toISOString()});\n    } catch (error) {\n      reply.code(400).send({\n        success: false,\n        error: (error as any).message,\n        timestamp: new Date().toISOString()});\n    }\n  });\n\n  // ========================================\n  // Routes from auth-extended.ts (9 routes)\n  // ========================================\n  // Verify email\n  fastify.post('/verify-email', {\n    schema: {\n      body: {\n        type: 'object',\n        required: ['token'],\n        properties: {\n          token: { type: 'string', minLength: 1 }\n        }\n      }\n    }\n  }, async (request: FastifyRequest<{ Body: { token: string } }>, reply) => {\n    try {\n      const result = await AuthExtendedService.verifyEmail(request.body.token);\n      reply.send(result);\n    } catch (error) {\n      reply.code(400).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Resend email verification\n  fastify.post('/resend-verification', {\n    schema: {\n      body: {\n        type: 'object',\n        required: ['email'],\n        properties: {\n          email: { type: 'string', format: 'email' }\n        }\n      }\n    }\n  }, async (request: FastifyRequest<{ Body: { email: string } }>, reply) => {\n    try {\n      const result = await AuthExtendedService.resendEmailVerification(request.body.email);\n      reply.send(result);\n    } catch (error) {\n      reply.code(400).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Send phone verification\n  fastify.post('/send-phone-verification', {\n    preHandler: [authenticate],\n    schema: {\n      body: {\n        type: 'object',\n        required: ['phoneNumber'],\n        properties: {\n          phoneNumber: { type: 'string', minLength: 8 }\n        }\n      }\n    }\n  }, async (request: FastifyRequest<{ Body: { phoneNumber: string } }>, reply) => {\n    try {\n      const result = await AuthExtendedService.sendPhoneVerification(\n        request.body.phoneNumber,\n        request.user.sub\n      );\n      reply.send(result);\n    } catch (error) {\n      reply.code(400).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Verify phone\n  fastify.post('/verify-phone', {\n    preHandler: [authenticate],\n    schema: {\n      body: {\n        type: 'object',\n        required: ['phoneNumber', 'code'],\n        properties: {\n          phoneNumber: { type: 'string', minLength: 8 },\n          code: { type: 'string', minLength: 6, maxLength: 6 }\n        }\n      }\n    }\n  }, async (request: FastifyRequest<{ Body: { phoneNumber: string; code: string } }>, reply) => {\n    try {\n      const result = await AuthExtendedService.verifyPhone(\n        request.body.phoneNumber,\n        request.body.code,\n        request.user.sub\n      );\n      reply.send(result);\n    } catch (error) {\n      reply.code(400).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Change password\n  fastify.post('/change-password', {\n    preHandler: [authenticate],\n    schema: {\n      body: {\n        type: 'object',\n        required: ['currentPassword', 'newPassword'],\n        properties: {\n          currentPassword: { type: 'string', minLength: 1 },\n          newPassword: { type: 'string', minLength: 8 }\n        }\n      }\n    }\n  }, async (request: FastifyRequest<{ Body: { currentPassword: string; newPassword: string } }>, reply) => {\n    try {\n      const result = await AuthExtendedService.changePassword(\n        request.user.sub,\n        request.body.currentPassword,\n        request.body.newPassword\n      );\n      reply.send(result);\n    } catch (error) {\n      reply.code(400).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Delete account\n  fastify.delete('/account', {\n    preHandler: [authenticate],\n    schema: {\n      body: {\n        type: 'object',\n        required: ['password'],\n        properties: {\n          password: { type: 'string', minLength: 6 }\n        }\n      }\n    }\n  }, async (request: FastifyRequest<{ Body: { password: string } }>, reply) => {\n    try {\n      const result = await AuthExtendedService.deleteAccount(\n        request.user.sub,\n        request.body.password\n      );\n      reply.send(result);\n    } catch (error) {\n      reply.code(400).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Get user stats\n  fastify.get('/stats', {\n    preHandler: [authenticate]}, async (request, reply) => {\n    try {\n      const result = await UserExtendedService.getUserStats(request.user.sub);\n      reply.header('Deprecation', 'true');\n      reply.header('Link', '</api/v1/users/stats>; rel=\"successor-version\"');\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      reply.code(500).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Upload avatar\n  fastify.post('/avatar', {\n    preHandler: [authenticate],\n    schema: {\n      // For file uploads, we can't validate the avatar field properly with Zod\n      // So we'll just validate the structure\n    }\n  }, async (request: FastifyRequest<{ Body: { avatar: string } }>, reply) => {\n    try {\n      const result = await UserExtendedService.uploadAvatar(\n        request.user.sub,\n        request.body.avatar\n      );\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      reply.code(400).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Get achievements\n  fastify.get('/achievements', {\n    preHandler: [authenticate]}, async (request, reply) => {\n    try {\n      const result = await UserExtendedService.getUserAchievements(request.user.sub);\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      reply.code(500).send({ success: false, error: (error as any).message });\n    }\n  });\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\auth\\routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\capture\\routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'adminRateLimit' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Report' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Types' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":15},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":68,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":68,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2503,2506],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2503,2506],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":69,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":69,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2529,2532],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2529,2532],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":84,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":84,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2843,2846],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2843,2846],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CaptureData' is defined but never used. Allowed unused vars must match /^_/u.","line":152,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":152,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ValidationData' is defined but never used. Allowed unused vars must match /^_/u.","line":160,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":160,"endColumn":25},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":168,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":168,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4525,4528],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4525,4528],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'safeLocation' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":182,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":182,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'antiCheatLocation' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":219,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":219,"endColumn":30},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":281,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":281,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8391,8394],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8391,8394],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":293,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":293,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8742,8745],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8742,8745],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'safeLocation' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":304,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":304,"endColumn":25},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":339,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":339,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10219,10222],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10219,10222],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":359,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":359,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10876,10879],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10876,10879],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":369,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":369,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11081,11084],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11081,11084],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":370,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":370,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11148,11151],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11148,11151],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'message' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":521,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":521,"endColumn":20},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":529,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":529,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16845,16848],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16845,16848],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":530,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":530,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16909,16912],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16909,16912],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":530,"column":101,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":530,"endColumn":104,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16978,16981],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16978,16981],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":534,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":534,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17161,17164],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17161,17164],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":537,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":537,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17356,17359],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17356,17359],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":550,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":550,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18010,18013],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18010,18013],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":560,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":560,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18242,18245],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18242,18245],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":561,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":561,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18295,18298],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18295,18298],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":562,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":562,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18344,18347],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18344,18347],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":563,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":563,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18398,18401],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18398,18401],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":655,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":655,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22025,22028],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22025,22028],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":663,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":663,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22249,22252],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22249,22252],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":668,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":668,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22462,22465],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22462,22465],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":676,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":676,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22728,22731],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22728,22731],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":676,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":676,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22740,22743],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22740,22743],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":676,"column":91,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":676,"endColumn":94,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22754,22757],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22754,22757],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":726,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":726,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24243,24246],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24243,24246],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":734,"column":83,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":734,"endColumn":86,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24449,24452],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24449,24452],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":780,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":780,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26089,26092],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26089,26092],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":780,"column":109,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":780,"endColumn":112,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26151,26154],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26151,26154],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":825,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":825,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[27446,27449],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[27446,27449],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":825,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":825,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[27460,27463],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[27460,27463],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":838,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":838,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[27834,27837],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[27834,27837],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":884,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":884,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[29309,29312],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[29309,29312],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":885,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":885,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[29339,29342],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[29339,29342],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":944,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":944,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[30925,30928],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[30925,30928],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":944,"column":81,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":944,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[30974,30977],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[30974,30977],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":962,"column":94,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":962,"endColumn":97,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32029,32032],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32029,32032],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":997,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":997,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[33327,33330],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[33327,33330],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1012,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1012,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[33872,33875],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[33872,33875],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1029,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1029,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[34422,34425],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[34422,34425],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":50,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyInstance, FastifyRequest } from 'fastify';\r\nimport { authenticate } from '@/middleware/auth';\r\nimport { claimsRateLimit, adminRateLimit } from '@/middleware/distributed-rate-limit';\r\nimport { z } from 'zod';\r\nimport { Prize } from '@/models/Prize';\r\nimport { User } from '@/models/User';\r\nimport { Claim } from '@/models/Claim';\r\nimport { Report } from '@/models/Report';\r\nimport { typedLogger } from '@/lib/typed-logger';\r\nimport { redisClient } from '@/config/redis';\r\nimport ProximityService from '@/services/proximity';\r\nimport { Settings } from '@/models/Settings';\r\nimport { ProgressionService } from '@/services/progression';\r\nimport mongoose from 'mongoose';\r\nimport { Types } from 'mongoose';\r\n\r\n/**\r\n * AR Capture Module\r\n * Core Feature 2: Utilisateur capture ├óÔÇáÔÇÖ Gagne les points + d├â┬®couvre contenu\r\n * Handles the AR capture experience with animations, validation, and rewards\r\n */\r\n\r\n// Schemas for capture system\r\nconst CaptureAttemptSchema = z.object({\r\n  prizeId: z.string(),\r\n  location: z.object({\r\n    latitude: z.number().min(-90).max(90),\r\n    longitude: z.number().min(-180).max(180),\r\n    accuracy: z.number().min(0).max(1000).optional(),\r\n    altitude: z.number().optional()}),\r\n  deviceInfo: z.object({\r\n    platform: z.enum(['iOS', 'Android']),\r\n    deviceModel: z.string(),\r\n    osVersion: z.string(),\r\n    appVersion: z.string(),\r\n    timestamp: z.string().datetime()}),\r\n  arData: z.object({\r\n    cameraPosition: z.object({\r\n      x: z.number(),\r\n      y: z.number(),\r\n      z: z.number()}).optional(),\r\n    cameraRotation: z.object({\r\n      x: z.number(),\r\n      y: z.number(),\r\n      z: z.number(),\r\n      w: z.number()}).optional(),\r\n    lightEstimation: z.number().min(0).max(1).optional(),\r\n    trackingState: z.enum(['tracking', 'limited', 'not_tracking']).optional()}).optional(),\r\n  captureMethod: z.enum(['tap', 'gesture', 'voice']).default('tap')});\r\n\r\nconst CaptureValidationSchema = z.object({\r\n  prizeId: z.string(),\r\n  location: z.object({\r\n    latitude: z.number(),\r\n    longitude: z.number()}),\r\n  preValidate: z.boolean().default(false)});\r\n\r\nexport interface CaptureResult {\r\n  success: boolean;\r\n  prizeId: string;\r\n  claimId?: string;\r\n  content: {\r\n    type: 'mystery_box' | 'direct_points' | 'power_up' | 'special_item';\r\n    animation: 'standard' | 'rare' | 'epic' | 'legendary';\r\n    displayType?: 'standard' | 'mystery_box' | 'treasure' | 'bonus' | 'special';\r\n    points: number;\r\n    bonusMultiplier: number;\r\n    directReward?: any;\r\n    specialReward?: any;\r\n    message: string;\r\n  };\r\n  userProgress: {\r\n    totalPoints: number;\r\n    newLevel?: number;\r\n    levelProgress: number;\r\n    nextLevelPoints: number;\r\n  };\r\n  effects: {\r\n    visualEffects: string[];\r\n    soundEffects: string[];\r\n    hapticPattern: string;\r\n    duration: number;\r\n  };\r\n  achievements?: any[];\r\n  metadata: {\r\n    captureTime: string;\r\n    distance: number;\r\n    validationScore: number;\r\n    contentType?: string;\r\n    rewardGranted?: boolean;\r\n  };\r\n}\r\n\r\nexport interface BoxAnimation {\r\n  type: 'mystery_box' | 'treasure_chest' | 'gift_box' | 'energy_orb';\r\n  rarity: 'common' | 'uncommon' | 'rare' | 'epic' | 'legendary';\r\n  animation: {\r\n    approach: string;\r\n    idle: string;\r\n    opening: string;\r\n    reveal: string;\r\n    celebration: string;\r\n  };\r\n  effects: {\r\n    particles: string[];\r\n    lighting: string;\r\n    sound: string;\r\n  };\r\n  duration: {\r\n    total: number;\r\n    phases: number[];\r\n  };\r\n}\r\n\r\n// Define interfaces for request types\r\ninterface CaptureLocation {\r\n  latitude: number;\r\n  longitude: number;\r\n  accuracy?: number;\r\n  altitude?: number;\r\n}\r\n\r\ninterface DeviceInfo {\r\n  platform: 'iOS' | 'Android';\r\n  deviceModel: string;\r\n  osVersion: string;\r\n  appVersion: string;\r\n  timestamp: string;\r\n}\r\n\r\n\r\ninterface CameraPosition {\r\n  x: number;\r\n  y: number;\r\n  z: number;\r\n}\r\n\r\ninterface CameraRotation {\r\n  x: number;\r\n  y: number;\r\n  z: number;\r\n  w: number;\r\n}\r\n\r\ninterface ArData {\r\n  cameraPosition?: CameraPosition;\r\n  cameraRotation?: CameraRotation;\r\n  lightEstimation?: number;\r\n  trackingState?: 'tracking' | 'limited' | 'not_tracking';\r\n}\r\n\r\ninterface CaptureData {\r\n  prizeId: string;\r\n  location: CaptureLocation;\r\n  deviceInfo: DeviceInfo;\r\n  arData?: ArData;\r\n  captureMethod: 'tap' | 'gesture' | 'voice';\r\n}\r\n\r\ninterface ValidationData {\r\n  prizeId: string;\r\n  location: CaptureLocation;\r\n  preValidate?: boolean;\r\n}\r\n\r\nexport class CaptureService {\r\n  private static redis = redisClient;\r\n  private static antiCheatCache: any = null;\r\n  private static antiCheatFetchedAt = 0;\r\n  private static readonly ANTICHEAT_CACHE_TTL_MS = 60_000;\r\n\r\n  /**\r\n   * Attempt to capture a prize with full AR validation\r\n   */\r\n  static async attemptCapture(userId: string, captureData: z.infer<typeof CaptureAttemptSchema>): Promise<CaptureResult> {\r\n    try {\r\n      const { prizeId, location, deviceInfo, arData, captureMethod } = captureData;\r\n      // Since Zod validation ensures required fields are present, we can safely assert non-null values\r\n\r\n      // Step 1: Validate capture attempt\r\n      // Ensure required location fields are present (Zod validation ensures this)\r\n      const safeLocation = {\r\n        latitude: location.latitude,\r\n        longitude: location.longitude,\r\n        accuracy: location.accuracy,\r\n        altitude: location.altitude\r\n      };\r\n\r\n      // Type assertion to ensure required fields exist based on Zod validation\r\n      const typedLocationForValidation: CaptureLocation = {\r\n        latitude: location.latitude!,\r\n        longitude: location.longitude!,\r\n        accuracy: location.accuracy,\r\n        altitude: location.altitude\r\n      };\r\n\r\n      const validation = await ProximityService.validateCatchAttempt(\r\n        userId,\r\n        prizeId,\r\n        typedLocationForValidation,\r\n        deviceInfo\r\n      );\r\n\r\n      if (!validation.canCatch) {\r\n        throw new Error(`CAPTURE_FAILED: ${validation.reason}`);\r\n      }\r\n\r\n      // Step 2: Get prize and user data\r\n      const [prize, user] = await Promise.all([\r\n        Prize.findById(prizeId),\r\n        User.findById(userId)]);\r\n\r\n      if (!prize || !user) {\r\n        throw new Error('PRIZE_OR_USER_NOT_FOUND');\r\n      }\r\n\r\n      // Step 3: Additional anti-cheat validation\r\n      // Ensure required location fields are present for anti-cheat\r\n      const antiCheatLocation = {\r\n        latitude: location.latitude,\r\n        longitude: location.longitude,\r\n        accuracy: location.accuracy,\r\n        altitude: location.altitude\r\n      };\r\n\r\n      // Type assertion to ensure required fields exist based on Zod validation\r\n      const typedLocationForAntiCheat: CaptureLocation = {\r\n        latitude: location.latitude!,\r\n        longitude: location.longitude!,\r\n        accuracy: location.accuracy,\r\n        altitude: location.altitude\r\n      };\r\n\r\n      const antiCheatResult = await this.performAdvancedAntiCheat(\r\n        userId,\r\n        typedLocationForAntiCheat,\r\n        prize,\r\n        deviceInfo,\r\n        arData\r\n      );\r\n\r\n      if (!antiCheatResult.valid) {\r\n        throw new Error(`ANTI_CHEAT_FAILED: ${antiCheatResult.reason}`);\r\n      }\r\n\r\n      // Step 4: Process the capture\r\n      // Type assertion to ensure required fields exist based on Zod validation\r\n      const typedLocationForProcessing: CaptureLocation = {\r\n        latitude: location.latitude!,\r\n        longitude: location.longitude!,\r\n        accuracy: location.accuracy,\r\n        altitude: location.altitude\r\n      };\r\n\r\n      const captureResult = await this.processCaptureSuccess(\r\n        userId,\r\n        prize,\r\n        user,\r\n        typedLocationForProcessing,\r\n        validation.distance || 0,\r\n        captureMethod,\r\n        antiCheatResult.validationScore\r\n      );\r\n\r\n      // Step 5: Update prize claims counter\r\n      await Prize.findByIdAndUpdate(prizeId, {\r\n        $inc: { 'distribution.currentClaims': 1 },\r\n        $set: { 'metadata.lastClaimed': new Date() }});\r\n\r\n      // Step 6: Log capture event\r\n      typedLogger.info('Prize captured successfully', {\r\n        userId,\r\n        prizeId,\r\n        points: captureResult.content.points,\r\n        distance: validation.distance,\r\n        method: captureMethod,\r\n        validationScore: antiCheatResult.validationScore});\r\n\r\n      return captureResult;\r\n    } catch (error) {\r\n      typedLogger.error('Capture attempt error', { error: (error as any).message, userId, captureData });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Pre-validate capture possibility (for UI feedback)\r\n   */\r\n  static async preValidateCapture(userId: string, validationData: z.infer<typeof CaptureValidationSchema>): Promise<{\r\n    canCapture: boolean;\r\n    reason?: string;\r\n    distance?: number;\r\n    animation?: any;\r\n    estimatedReward?: {\r\n      minPoints: number;\r\n      maxPoints: number;\r\n      rarity: string;\r\n    };\r\n  }> {\r\n    try {\r\n      const { prizeId, location } = validationData;\r\n\r\n      // Ensure required location fields are present (Zod validation ensures this)\r\n      const safeLocation = {\r\n        latitude: location.latitude,\r\n        longitude: location.longitude\r\n      };\r\n\r\n      // Type assertion to ensure required fields exist based on Zod validation\r\n      const typedLocation: CaptureLocation = {\r\n        latitude: location.latitude!,\r\n        longitude: location.longitude!\r\n      };\r\n\r\n      const validation = await ProximityService.validateCatchAttempt(\r\n        userId,\r\n        prizeId,\r\n        typedLocation\r\n      );\r\n\r\n      const prize = await Prize.findById(prizeId);\r\n      if (!prize) {\r\n        return { canCapture: false, reason: 'PRIZE_NOT_FOUND' };\r\n      }\r\n\r\n      // Get capture animation info for UI preparation\r\n      const animationInfo = await this.getCaptureAnimationInfo(prize);\r\n\r\n      return {\r\n        canCapture: validation.canCatch,\r\n        reason: validation.reason,\r\n        distance: validation.distance,\r\n        animation: animationInfo,\r\n        estimatedReward: {\r\n          minPoints: prize.points,\r\n          maxPoints: prize.points * (prize.pointsReward?.bonusMultiplier || 1),\r\n          rarity: prize.rarity}};\r\n    } catch (error) {\r\n      typedLogger.error('Pre-validate capture error', { error: (error as any).message, userId, validationData });\r\n      return { canCapture: false, reason: 'VALIDATION_ERROR' };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get box animation configuration for Unity\r\n   */\r\n  static async getBoxAnimation(prizeId: string): Promise<BoxAnimation> {\r\n    try {\r\n      const prize = await Prize.findById(prizeId);\r\n      if (!prize) {\r\n        throw new Error('PRIZE_NOT_FOUND');\r\n      }\r\n\r\n      const animationType = this.determineBoxType(prize);\r\n      const animation = this.generateBoxAnimation(animationType, prize.rarity);\r\n\r\n      return animation;\r\n    } catch (error) {\r\n      typedLogger.error('Get box animation error', { error: (error as any).message, prizeId });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Process capture success and generate rewards\r\n   */\r\n  private static async processCaptureSuccess(\r\n    userId: string,\r\n    prize: any, // Keeping 'any' for prize since it can be complex\r\n    user: any, // Keeping 'any' for user since it has dynamic methods\r\n    location: CaptureLocation,\r\n    distance: number,\r\n    captureMethod: 'tap' | 'gesture' | 'voice',\r\n    validationScore: number\r\n  ): Promise<CaptureResult> {\r\n    try {\r\n      // Import Redemption and Reward models\r\n      const Redemption = mongoose.models.Redemption || mongoose.model('Redemption');\r\n      const Reward = mongoose.models.Reward || mongoose.model('Reward');\r\n\r\n      // Determine content type (with backward compatibility)\r\n      const contentType = prize.contentType || 'points';\r\n\r\n      // Calculate final points with bonuses (for points-based rewards)\r\n      const basePoints = prize.pointsReward?.amount || prize.points || 0;\r\n      let finalPoints = basePoints;\r\n      let bonusMultiplier = prize.pointsReward?.bonusMultiplier || 1;\r\n\r\n      // Distance bonus (closer = better)\r\n      if (distance < 2) {\r\n        bonusMultiplier *= 1.2; // 20% bonus for very close captures\r\n      } else if (distance < 1) {\r\n        bonusMultiplier *= 1.5; // 50% bonus for perfect captures\r\n      }\r\n\r\n      // Capture method bonus\r\n      if (captureMethod === 'gesture') {\r\n        bonusMultiplier *= 1.1; // 10% bonus for gesture captures\r\n      }\r\n\r\n      // Validation score bonus\r\n      if (validationScore > 0.9) {\r\n        bonusMultiplier *= 1.1; // 10% bonus for high validation scores\r\n      }\r\n\r\n      finalPoints = Math.round(basePoints * bonusMultiplier);\r\n\r\n      // Variables for reward handling\r\n      let directRedemption = null;\r\n      let rewardGranted = false;\r\n      let rewardDetails = null;\r\n\r\n      // Handle different content types\r\n      if (contentType === 'reward' || contentType === 'hybrid') {\r\n        // Check if we should grant a direct reward\r\n        const shouldGrantReward = contentType === 'reward' ||\r\n          (contentType === 'hybrid' && Math.random() < (prize.directReward?.probability || 0));\r\n\r\n        if (shouldGrantReward && prize.directReward?.rewardId) {\r\n          // Get reward details\r\n          const reward = await Reward.findById(prize.directReward.rewardId);\r\n\r\n          if (reward && reward.isAvailable) {\r\n            // Reserve stock\r\n            const stockReserved = reward.reserveStock(1);\r\n\r\n            if (stockReserved) {\r\n              await reward.save();\r\n\r\n              // Create automatic redemption\r\n              directRedemption = new Redemption({\r\n                userId,\r\n                rewardId: reward._id,\r\n                pointsSpent: 0, // Free reward from prize capture\r\n                status: 'fulfilled',\r\n                redeemedAt: new Date(),\r\n                fulfilledAt: new Date(),\r\n                idempotencyKey: `capture_${prize._id}_${userId}_${Date.now()}`,\r\n                metadata: {\r\n                  source: 'prize_capture',\r\n                  prizeId: prize._id,\r\n                  autoRedeemed: true}});\r\n\r\n              await directRedemption.save();\r\n\r\n              // Confirm stock redemption\r\n              reward.confirmRedemption(1);\r\n              await reward.save();\r\n\r\n              rewardGranted = true;\r\n              rewardDetails = {\r\n                id: reward._id,\r\n                name: reward.name,\r\n                description: reward.description,\r\n                category: reward.category,\r\n                imageUrl: reward.imageUrl,\r\n                redemptionId: directRedemption._id};\r\n\r\n              typedLogger.info('Direct reward granted from prize capture', {\r\n                userId,\r\n                prizeId: prize._id,\r\n                rewardId: reward._id,\r\n                redemptionId: directRedemption._id});\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Create claim record\r\n      const claim = new Claim({\r\n        userId,\r\n        prizeId: prize._id,\r\n        location: {\r\n          type: 'Point',\r\n          coordinates: [location.longitude, location.latitude]},\r\n        claimedAt: new Date(),\r\n        pointsAwarded: finalPoints,\r\n        bonusMultiplier,\r\n        captureMethod,\r\n        distance,\r\n        validationScore,\r\n        status: 'verified',\r\n        metadata: {\r\n          contentType,\r\n          rewardGranted,\r\n          redemptionId: directRedemption?._id}});\r\n\r\n      await claim.save();\r\n\r\n      // Update user points (only if contentType includes points)\r\n      // Hybrid logic: If reward is granted, no points (Points OR Reward). If no reward, fallback to points.\r\n      let pointsToAdd = 0;\r\n      if (contentType === 'points') {\r\n        pointsToAdd = finalPoints;\r\n      } else if (contentType === 'hybrid') {\r\n        pointsToAdd = rewardGranted ? 0 : finalPoints;\r\n      }\r\n\r\n      const updatedUser = await User.findByIdAndUpdate(\r\n        userId,\r\n        {\r\n          $inc: {\r\n            points: pointsToAdd,\r\n            'stats.totalClaims': 1,\r\n            'stats.totalPoints': pointsToAdd,\r\n            ...(rewardGranted && { 'stats.rewardsRedeemed': 1 })},\r\n          $set: { lastActive: new Date() }},\r\n        { new: true }\r\n      );\r\n\r\n      // Check for level progression\r\n      const levelProgress = await this.checkLevelProgression(updatedUser);\r\n\r\n      // Check for achievements\r\n      const achievements = await this.checkAchievements(userId, prize, claim);\r\n\r\n      // Generate capture effects\r\n      const effects = this.generateCaptureEffects(prize.rarity, bonusMultiplier);\r\n\r\n      // Generate content reveal message\r\n      const message = this.generateRevealMessage(prize, finalPoints, bonusMultiplier);\r\n\r\n      return {\r\n        success: true,\r\n        prizeId: prize._id.toString(),\r\n        claimId: claim._id.toString(),\r\n        content: {\r\n          type: contentType,\r\n          displayType: (prize as any).displayType || 'standard',\r\n          animation: (prize as any).content?.animation || this.getAnimationForDisplayType((prize as any).displayType),\r\n          points: pointsToAdd,\r\n          bonusMultiplier,\r\n          directReward: rewardGranted ? rewardDetails : undefined,\r\n          specialReward: (prize as any).content?.specialReward,\r\n          message: this.generateRevealMessage(prize, pointsToAdd, bonusMultiplier, rewardDetails)},\r\n        userProgress: {\r\n          totalPoints: (updatedUser as any).points,\r\n          newLevel: levelProgress.leveledUp ? levelProgress.newLevel : undefined,\r\n          levelProgress: levelProgress.progress,\r\n          nextLevelPoints: levelProgress.nextLevel?.pointsToNext},\r\n        effects,\r\n        achievements: achievements.length > 0 ? achievements : undefined,\r\n        metadata: {\r\n          captureTime: new Date().toISOString(),\r\n          distance: Math.round(distance * 100) / 100,\r\n          validationScore: Math.round(validationScore * 100) / 100,\r\n          contentType,\r\n          rewardGranted}};\r\n    } catch (error) {\r\n      typedLogger.error('Process capture success error', { error: (error as any).message, userId, prizeId: prize._id });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Advanced anti-cheat validation for AR captures\r\n   */\r\n  private static async performAdvancedAntiCheat(\r\n    userId: string,\r\n    location: any, // Accepting inferred type from Zod\r\n    prize: any, // Keeping 'any' for prize\r\n    deviceInfo: any, // Accepting inferred type from Zod\r\n    arData: any // Accepting inferred type from Zod\r\n  ): Promise<{ valid: boolean; reason?: string; validationScore: number }> {\r\n    try {\r\n      const cfg = await this.getAntiCheatConfig();\r\n      let validationScore = 1.0;\r\n      const issues = [];\r\n\r\n      // Check device consistency\r\n      const deviceKey = `device:${userId}`;\r\n      const lastDevice = await this.redis.get(deviceKey);\r\n      if (lastDevice) {\r\n        const device = JSON.parse(lastDevice);\r\n        if (device.deviceModel !== deviceInfo.deviceModel) {\r\n          validationScore -= cfg.penalties.deviceChange;\r\n          issues.push('Device model changed');\r\n        }\r\n      }\r\n      await this.redis.setex(deviceKey, 86400, JSON.stringify(deviceInfo));\r\n\r\n      // Check capture frequency (prevent rapid-fire captures)\r\n      const captureKey = `captures:${userId}:${Math.floor(Date.now() / 60000)}`; // per minute\r\n      const captureCount = await this.redis.incr(captureKey);\r\n      await this.redis.expire(captureKey, 60);\r\n\r\n      if (captureCount > cfg.captureFrequencyPerMinute) {\r\n        return { valid: false, reason: 'TOO_MANY_CAPTURES', validationScore: 0 };\r\n      }\r\n\r\n      // Check AR data consistency (if provided)\r\n      if (arData) {\r\n        if (arData.trackingState === 'not_tracking') {\r\n          validationScore -= cfg.penalties.trackingNotTracking;\r\n          issues.push('Poor AR tracking');\r\n        }\r\n\r\n        if (arData.lightEstimation !== undefined && arData.lightEstimation < 0.1) {\r\n          validationScore -= cfg.penalties.lowLight;\r\n          issues.push('Suspicious lighting conditions');\r\n        }\r\n      }\r\n\r\n      // Check location accuracy\r\n      if (location.accuracy && location.accuracy > cfg.gpsAccuracyThreshold) {\r\n        validationScore -= cfg.penalties.lowAccuracy;\r\n        issues.push('Low GPS accuracy');\r\n      }\r\n\r\n      // Check for impossible travel speed\r\n      const lastCaptureKey = `last_capture:${userId}`;\r\n      const lastCapture = await this.redis.get(lastCaptureKey);\r\n      if (lastCapture) {\r\n        const last = JSON.parse(lastCapture);\r\n        const timeDiff = Date.now() - last.timestamp;\r\n        if (last.location.latitude !== undefined && last.location.longitude !== undefined &&\r\n            location.latitude !== undefined && location.longitude !== undefined) {\r\n          const distance = this.calculateDistance(\r\n            last.location.latitude,\r\n            last.location.longitude,\r\n            location.latitude,\r\n            location.longitude\r\n          );\r\n\r\n        const speed = distance / (timeDiff / 1000); // m/s\r\n        const maxSpeed = cfg.maxSpeedMps;\r\n\r\n        if (speed > maxSpeed && timeDiff > 1000) {\r\n          return { valid: false, reason: 'IMPOSSIBLE_TRAVEL_SPEED', validationScore: 0 };\r\n        }\r\n        }\r\n      }\r\n\r\n      // Store current capture for next validation\r\n      await this.redis.setex(lastCaptureKey, 300, JSON.stringify({\r\n        location: {\r\n          latitude: location.latitude,\r\n          longitude: location.longitude,\r\n          accuracy: location.accuracy,\r\n          altitude: location.altitude\r\n        },\r\n        timestamp: Date.now()}));\r\n\r\n      // Final validation score check\r\n      if (validationScore < cfg.validationScoreFloor) {\r\n        return { valid: false, reason: 'LOW_VALIDATION_SCORE', validationScore };\r\n      }\r\n\r\n      if (issues.length > 0) {\r\n        typedLogger.warn('Capture validation issues detected', { userId, issues, validationScore });\r\n      }\r\n\r\n      return { valid: true, validationScore };\r\n    } catch (error) {\r\n      typedLogger.error('Advanced anti-cheat error', { error: (error as any).message, userId });\r\n      return { valid: true, validationScore: 0.5 }; // Fail open\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check for level progression after points award\r\n   */\r\n  private static async checkLevelProgression(user: any) {\r\n    try {\r\n      const result = await ProgressionService.updateLevelForUser(user);\r\n      return result;\r\n    } catch (error) {\r\n      typedLogger.error('Check level progression error', { error: (error as any).message, userId: user._id });\r\n      return { leveledUp: false, newLevel: user.level, progress: 0, nextLevel: null };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check for achievements triggered by capture\r\n   */\r\n  private static async checkAchievements(userId: string, prize: any, claim: any): Promise<any[]> {\r\n    try {\r\n      const achievements = [];\r\n\r\n      // First capture achievement\r\n      const claimCount = await Claim.countDocuments({ userId });\r\n      if (claimCount === 1) {\r\n        achievements.push({\r\n          id: 'first_capture',\r\n          title: 'First Catch!',\r\n          description: 'Captured your first prize',\r\n          icon: 'first_catch',\r\n          points: 50});\r\n      }\r\n\r\n      // Distance-based achievements\r\n      if (claim.distance < 1) {\r\n        achievements.push({\r\n          id: 'perfect_catch',\r\n          title: 'Perfect Catch',\r\n          description: 'Captured a prize from less than 1 meter',\r\n          icon: 'perfect_catch',\r\n          points: 25});\r\n      }\r\n\r\n      // Rarity-based achievements\r\n      if (prize.rarity === 'legendary') {\r\n        achievements.push({\r\n          id: 'legendary_hunter',\r\n          title: 'Legendary Hunter',\r\n          description: 'Captured a legendary prize',\r\n          icon: 'legendary_hunter',\r\n          points: 200});\r\n      }\r\n\r\n      // Store achievements in user record\r\n      if (achievements.length > 0) {\r\n        await User.findByIdAndUpdate(userId, {\r\n          $push: {\r\n            'achievements': {\r\n              $each: achievements.map(ach => ({\r\n                ...ach,\r\n                unlockedAt: new Date()}))\r\n            }\r\n          }\r\n        });\r\n      }\r\n\r\n      return achievements;\r\n    } catch (error) {\r\n      typedLogger.error('Check achievements error', { error: (error as any).message, userId });\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate visual and audio effects for capture\r\n   */\r\n  private static generateCaptureEffects(rarity: string, bonusMultiplier: number): any {\r\n    const baseEffects = {\r\n      visualEffects: ['sparkles', 'glow'],\r\n      soundEffects: ['capture_success'],\r\n      hapticPattern: 'light',\r\n      duration: 2000};\r\n\r\n    // Enhance effects based on rarity\r\n    switch (rarity) {\r\n      case 'uncommon':\r\n        baseEffects.visualEffects.push('blue_particles');\r\n        baseEffects.soundEffects.push('uncommon_chime');\r\n        baseEffects.hapticPattern = 'medium';\r\n        break;\r\n      case 'rare':\r\n        baseEffects.visualEffects.push('purple_particles', 'ring_explosion');\r\n        baseEffects.soundEffects.push('rare_fanfare');\r\n        baseEffects.hapticPattern = 'heavy';\r\n        baseEffects.duration = 3000;\r\n        break;\r\n      case 'epic':\r\n        baseEffects.visualEffects.push('golden_particles', 'lightning', 'screen_flash');\r\n        baseEffects.soundEffects.push('epic_fanfare', 'thunder');\r\n        baseEffects.hapticPattern = 'intense';\r\n        baseEffects.duration = 4000;\r\n        break;\r\n      case 'legendary':\r\n        baseEffects.visualEffects.push('rainbow_particles', 'fireworks', 'screen_shake', 'light_rays');\r\n        baseEffects.soundEffects.push('legendary_fanfare', 'choir', 'explosion');\r\n        baseEffects.hapticPattern = 'legendary';\r\n        baseEffects.duration = 5000;\r\n        break;\r\n    }\r\n\r\n    // Bonus multiplier effects\r\n    if (bonusMultiplier > 1.5) {\r\n      baseEffects.visualEffects.push('bonus_multiplier_text');\r\n      baseEffects.soundEffects.push('bonus_sound');\r\n    }\r\n\r\n    return baseEffects;\r\n  }\r\n\r\n  /**\r\n   * Generate reveal message for captured content\r\n   */\r\n  private static generateRevealMessage(prize: any, points: number, bonusMultiplier: number, rewardDetails?: any): string {\r\n    let message = `You found ${prize.name}!`;\r\n\r\n    // Points message\r\n    if (points > 0) {\r\n      message += ` Earned ${points} points`;\r\n      if (bonusMultiplier > 1) {\r\n        message += ` (${Math.round((bonusMultiplier - 1) * 100)}% bonus!)`;\r\n      }\r\n      message += '!';\r\n    }\r\n\r\n    // Direct reward message\r\n    if (rewardDetails) {\r\n      if (points > 0) {\r\n        message += ` Plus a special reward: ${rewardDetails.name}!`;\r\n      } else {\r\n        message += ` You won: ${rewardDetails.name}!`;\r\n      }\r\n    }\r\n\r\n    // Legacy special reward\r\n    if (prize.content?.specialReward && !rewardDetails) {\r\n      message += ` Plus a special reward: ${prize.content.specialReward}`;\r\n    }\r\n\r\n    return message;\r\n  }\r\n\r\n  /**\r\n   * Get animation type based on display type\r\n   */\r\n  private static getAnimationForDisplayType(displayType: string): string {\r\n    const animationMap: Record<string, string> = {\r\n      'standard': 'standard',\r\n      'mystery_box': 'mystery_reveal',\r\n      'treasure': 'treasure_open',\r\n      'bonus': 'bonus_burst',\r\n      'special': 'special_event'};\r\n    return animationMap[displayType] || 'standard';\r\n  }\r\n\r\n  /**\r\n   * Get capture animation info for UI preparation\r\n   */\r\n  private static async getCaptureAnimationInfo(prize: any): Promise<any> {\r\n    const boxType = this.determineBoxType(prize);\r\n\r\n    return {\r\n      boxType,\r\n      rarity: prize.rarity,\r\n      estimatedDuration: this.getAnimationDuration(prize.rarity),\r\n      preloadAssets: this.getPreloadAssets(boxType, prize.rarity)};\r\n  }\r\n\r\n  /**\r\n   * Determine box type based on prize characteristics\r\n   */\r\n  private static determineBoxType(prize: any): string {\r\n    if (prize.category === 'special' || prize.rarity === 'legendary') {\r\n      return 'energy_orb';\r\n    } else if (prize.rarity === 'epic' || prize.rarity === 'rare') {\r\n      return 'treasure_chest';\r\n    } else if (prize.type === 'power_up') {\r\n      return 'energy_orb';\r\n    } else {\r\n      return 'mystery_box';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate complete box animation configuration\r\n   */\r\n  private static generateBoxAnimation(boxType: string, rarity: string): BoxAnimation {\r\n    const baseAnimation = {\r\n      approach: 'float_down',\r\n      idle: 'gentle_bob',\r\n      opening: 'lid_open',\r\n      reveal: 'content_emerge',\r\n      celebration: 'sparkle_burst'};\r\n\r\n    const baseEffects = {\r\n      particles: ['dust', 'sparkles'],\r\n      lighting: 'soft_glow',\r\n      sound: 'box_open'};\r\n\r\n    const baseDuration = {\r\n      total: 3000,\r\n      phases: [500, 1000, 1000, 500], // approach, idle, opening, celebration\r\n    };\r\n\r\n    // Customize based on rarity\r\n    if (rarity === 'legendary') {\r\n      baseAnimation.approach = 'dramatic_descent';\r\n      baseAnimation.opening = 'explosive_open';\r\n      baseAnimation.celebration = 'fireworks_burst';\r\n      baseEffects.particles.push('golden_rays', 'rainbow_sparkles');\r\n      baseEffects.lighting = 'intense_glow';\r\n      baseEffects.sound = 'legendary_reveal';\r\n      baseDuration.total = 5000;\r\n      baseDuration.phases = [1000, 1500, 2000, 500];\r\n    }\r\n\r\n    return {\r\n      type: boxType as any,\r\n      rarity: rarity as any,\r\n      animation: baseAnimation,\r\n      effects: baseEffects,\r\n      duration: baseDuration};\r\n  }\r\n\r\n  /**\r\n   * Get animation duration based on rarity\r\n   */\r\n  private static getAnimationDuration(rarity: string): number {\r\n    const durations = {\r\n      common: 2000,\r\n      uncommon: 2500,\r\n      rare: 3000,\r\n      epic: 4000,\r\n      legendary: 5000};\r\n\r\n    return durations[rarity] || 2000;\r\n  }\r\n\r\n  /**\r\n   * Get assets to preload for smooth animation\r\n   */\r\n  private static getPreloadAssets(boxType: string, rarity: string): string[] {\r\n    const assets = [`box_${boxType}`, `particles_${rarity}`];\r\n\r\n    if (rarity === 'legendary') {\r\n      assets.push('fireworks', 'rainbow_particles', 'light_rays');\r\n    } else if (rarity === 'epic') {\r\n      assets.push('golden_particles', 'lightning');\r\n    }\r\n\r\n    return assets;\r\n  }\r\n\r\n  /**\r\n   * Load anti-cheat config from Settings.custom.antiCheat or defaults.\r\n   */\r\n  private static async getAntiCheatConfig() {\r\n    const now = Date.now();\r\n    if (this.antiCheatCache && (now - this.antiCheatFetchedAt) < this.ANTICHEAT_CACHE_TTL_MS) {\r\n      return this.antiCheatCache;\r\n    }\r\n\r\n    const defaults = {\r\n      captureFrequencyPerMinute: 10,\r\n      maxSpeedMps: 50,\r\n      validationScoreFloor: 0.3,\r\n      gpsAccuracyThreshold: 50,\r\n      penalties: {\r\n        deviceChange: 0.1,\r\n        trackingNotTracking: 0.2,\r\n        lowLight: 0.1,\r\n        lowAccuracy: 0.1,\r\n      }\r\n    };\r\n\r\n    try {\r\n      const settings = await Settings.findOne({}, { 'custom.antiCheat': 1 }).lean();\r\n      const cfg = (settings as any)?.custom?.get?.('antiCheat') || (settings as any)?.custom?.antiCheat;\r\n      if (cfg) {\r\n        this.antiCheatCache = {\r\n          captureFrequencyPerMinute: cfg.captureFrequencyPerMinute ?? defaults.captureFrequencyPerMinute,\r\n          maxSpeedMps: cfg.maxSpeedMps ?? defaults.maxSpeedMps,\r\n          validationScoreFloor: cfg.validationScoreFloor ?? defaults.validationScoreFloor,\r\n          gpsAccuracyThreshold: cfg.gpsAccuracyThreshold ?? defaults.gpsAccuracyThreshold,\r\n          penalties: {\r\n            deviceChange: cfg.penalties?.deviceChange ?? defaults.penalties.deviceChange,\r\n            trackingNotTracking: cfg.penalties?.trackingNotTracking ?? defaults.penalties.trackingNotTracking,\r\n            lowLight: cfg.penalties?.lowLight ?? defaults.penalties.lowLight,\r\n            lowAccuracy: cfg.penalties?.lowAccuracy ?? defaults.penalties.lowAccuracy,\r\n          },\r\n        };\r\n        this.antiCheatFetchedAt = now;\r\n        return this.antiCheatCache;\r\n      }\r\n    } catch (error) {\r\n      typedLogger.warn('Anti-cheat settings load failed, using defaults', { error: (error as any).message });\r\n    }\r\n\r\n    this.antiCheatCache = defaults;\r\n    this.antiCheatFetchedAt = now;\r\n    return defaults;\r\n  }\r\n\r\n  /**\r\n   * Calculate distance between two points\r\n   */\r\n  private static calculateDistance(lat1: number, lng1: number, lat2: number, lng2: number): number {\r\n    const R = 6371000; // Earth's radius in meters\r\n    const dLat = (lat2 - lat1) * Math.PI / 180;\r\n    const dLng = (lng2 - lng1) * Math.PI / 180;\r\n    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +\r\n              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\r\n              Math.sin(dLng/2) * Math.sin(dLng/2);\r\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\r\n    return R * c;\r\n  }\r\n}\r\n\r\nexport default async function captureRoutes(fastify: FastifyInstance): Promise<void> {\r\n  // Attempt capture\r\n  fastify.post('/attempt', {\r\n    preHandler: [authenticate, claimsRateLimit],\r\n    schema: {\r\n      body: CaptureAttemptSchema\r\n    }\r\n  }, async (request: FastifyRequest<{ Body: z.infer<typeof CaptureAttemptSchema> }>, reply) => {\r\n    try {\r\n      const result = await CaptureService.attemptCapture(request.user.sub, request.body);\r\n      reply.send({ success: true, data: result });\r\n    } catch (error) {\r\n      reply.code(400).send({ success: false, error: (error as any).message });\r\n    }\r\n  });\r\n\r\n  // Pre-validate capture\r\n  fastify.post('/validate', {\r\n    preHandler: [authenticate, claimsRateLimit],\r\n    schema: {\r\n      body: CaptureValidationSchema\r\n    }\r\n  }, async (request: FastifyRequest<{ Body: z.infer<typeof CaptureValidationSchema> }>, reply) => {\r\n    try {\r\n      const result = await CaptureService.preValidateCapture(request.user.sub, request.body);\r\n      reply.send({ success: true, data: result });\r\n    } catch (error) {\r\n      reply.code(400).send({ success: false, error: (error as any).message });\r\n    }\r\n  });\r\n\r\n  // Get box animation\r\n  fastify.get('/animation/:prizeId', {\r\n    preHandler: [authenticate, claimsRateLimit],\r\n    schema: {\r\n      params: z.object({\r\n        prizeId: z.string()\r\n      })\r\n    }\r\n  }, async (request: FastifyRequest<{ Params: { prizeId: string } }>, reply) => {\r\n    try {\r\n      const result = await CaptureService.getBoxAnimation(request.params.prizeId);\r\n      reply.send({ success: true, data: result });\r\n    } catch (error) {\r\n      reply.code(400).send({ success: false, error: (error as any).message });\r\n    }\r\n  });\r\n\r\n}\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\claims\\index.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'PrizeStatus' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'AchievementService' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'AchievementTrigger' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Redemption' is defined but never used. Allowed unused vars must match /^_/u.","line":16,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Reward' is defined but never used. Allowed unused vars must match /^_/u.","line":17,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":17,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'broadcastGameEvent' is defined but never used. Allowed unused vars must match /^_/u.","line":19,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":49},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'getClaimDetailsSchema' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":40,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":40,"endColumn":28},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":68,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":68,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2593,2596],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2593,2596],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":75,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":75,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2889,2892],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2889,2892],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":76,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":76,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2953,2956],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2953,2956],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":77,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":77,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3020,3023],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3020,3023],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":160,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":160,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5868,5871],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5868,5871],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":165,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":165,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6068,6071],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6068,6071],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":171,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":171,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6291,6294],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6291,6294],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":205,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":205,"endColumn":80},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":206,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":206,"endColumn":76},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":226,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":226,"endColumn":68},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":250,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":250,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9187,9190],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9187,9190],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":283,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":283,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10455,10458],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10455,10458],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":338,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":338,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11963,11966],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11963,11966],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":340,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":340,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12012,12015],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12012,12015],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":367,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":367,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12958,12961],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12958,12961],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":384,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":384,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13260,13263],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13260,13263],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":505,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":505,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16996,16999],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16996,16999],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":516,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":516,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17387,17390],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17387,17390],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":525,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":525,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17538,17541],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17538,17541],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":529,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":529,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17656,17659],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17656,17659],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":578,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":578,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19284,19287],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19284,19287],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":603,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":603,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19897,19900],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19897,19900],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":617,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":617,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20331,20334],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20331,20334],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":632,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":632,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20747,20750],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20747,20750],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":656,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":656,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21379,21382],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21379,21382],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":770,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":770,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24584,24587],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24584,24587],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":792,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":792,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25248,25251],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25248,25251],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":798,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":798,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25377,25380],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25377,25380],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":810,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":810,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25772,25775],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25772,25775],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":36,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyInstance } from 'fastify';\nimport { authenticate, requireAdmin } from '@/middleware/auth';\nimport { claimsRateLimit } from '@/middleware/distributed-rate-limit';\nimport { z } from 'zod';\nimport { Types } from 'mongoose';\nimport { Claim } from '@/models/Claim';\nimport { Prize } from '@/models/Prize';\nimport { User } from '@/models/User';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { PrizeStatus, PrizeContentType } from '@/types';\nimport { calculateGeodesicDistance, isWithinTunisia } from '@/utils/geo';\nimport { validateAntiCheat, validateCooldowns } from '@/utils/anti-cheat';\nimport { checkIdempotency, setIdempotency } from '@/utils/idempotency';\nimport { AchievementService } from '../../services/achievement';\nimport { AchievementTrigger } from '@/types';\nimport Redemption from '../../models/Redemption';\nimport Reward from '../../models/Reward';\nimport { normalizeError } from '@/utils/api-errors';\nimport { broadcastAdminEvent, broadcastGameEvent } from '@/lib/websocket';\n\n// Validation schemas\nconst claimPrizeSchema = z.object({\n  prizeId: z.string().regex(/^[0-9a-fA-F]{24}$/, 'Invalid prize ID'),\n  location: z.object({\n    lat: z.number().min(-90).max(90),\n    lng: z.number().min(-180).max(180),\n    accuracy: z.number().min(0).optional()}),\n  deviceSignals: z.object({\n    speed: z.number().min(0).optional(),\n    mockLocation: z.boolean().optional(),\n    attestationToken: z.string().optional()}).optional(),\n  idempotencyKey: z.string().min(1).max(100)});\n\nconst getUserClaimsSchema = z.object({\n  page: z.number().min(1).default(1),\n  limit: z.number().min(1).max(100).default(50),\n  startDate: z.string().datetime().optional(),\n  endDate: z.string().datetime().optional()});\n\nconst getClaimDetailsSchema = z.object({\n  claimId: z.string().regex(/^[0-9a-fA-F]{24}$/, 'Invalid claim ID')});\n\n/**\n * Claims service\n */\nexport class ClaimsService {\n  /**\n   * Claim a prize\n   */\n  static async claimPrize(\n    userId: string,\n    data: z.infer<typeof claimPrizeSchema>\n  ) {\n    try {\n      // Check idempotency\n      const existingResult = await checkIdempotency(data.idempotencyKey);\n      if (existingResult) {\n        typedLogger.info('Idempotent claim request', {\n          userId,\n          prizeId: data.prizeId,\n          idempotencyKey: data.idempotencyKey});\n        return existingResult;\n      }\n\n      // Fall back to stored claim for idempotent retries when Redis is missing\n      const existingClaim = await Claim.findOne({ idempotencyKey: data.idempotencyKey }).lean();\n      if (existingClaim) {\n        if ((existingClaim as any).status === 'rejected') {\n          throw new Error('ANTI_CHEAT_VIOLATION');\n        }\n        const userSnapshot = await User.findById(userId).select('points level').lean();\n        return {\n          success: true,\n          claim: existingClaim,\n          pointsAwarded: (existingClaim as any).pointsAwarded || 0,\n          newBalance: (userSnapshot as any)?.points?.available ?? 0,\n          newLevel: (userSnapshot as any)?.level,\n        };\n      }\n\n      // Validate location is within Tunisia - ensure required coordinates exist\n      if (!isWithinTunisia(data.location as { lat: number; lng: number; accuracy?: number })) {\n        throw new Error('LOCATION_OUT_OF_BOUNDS');\n      }\n\n      // Get user and prize\n      const [user, prize] = await Promise.all([\n        User.findById(userId),\n        Prize.findById(data.prizeId).populate('createdBy', 'displayName')]);\n\n      if (!user) {\n        throw new Error('USER_NOT_FOUND');\n      }\n\n      if (!prize) {\n        throw new Error('PRIZE_NOT_FOUND');\n      }\n\n      // Check if prize is available using business logic instead of virtual property\n      const isPrizeAvailable = prize.status === 'active' &&\n                               prize.claimedCount < prize.quantity &&\n                               (!prize.expiresAt || new Date() < prize.expiresAt);\n\n      if (!isPrizeAvailable) {\n        throw new Error('PRIZE_NOT_AVAILABLE');\n      }\n\n      // Calculate distance to prize\n      const [prizeLng, prizeLat] = prize.location.coordinates;\n      const distance = calculateGeodesicDistance(\n        data.location as { lat: number; lng: number; accuracy?: number },\n        { lat: prizeLat, lng: prizeLng }\n      );\n\n      // Validation checks\n      const validationChecks = {\n        distanceValid: distance <= prize.location.radius,\n        timeValid: true,\n        speedValid: true,\n        cooldownValid: true,\n        dailyLimitValid: true};\n\n      // Stock validation handled by model claim() below\n\n      // Distance validation\n      if (!validationChecks.distanceValid) {\n        typedLogger.warn('Prize claim failed - distance too far', {\n          userId,\n          prizeId: data.prizeId,\n          distance,\n          maxDistance: prize.location.radius});\n        throw new Error('DISTANCE_TOO_FAR');\n      }\n\n      // Anti-cheat validation (always run; device signals optional)\n      let antiCheatResult: Awaited<ReturnType<typeof validateAntiCheat>> | null = null;\n      {\n        antiCheatResult = await validateAntiCheat(\n          userId,\n          data.location as { lat: number; lng: number; accuracy?: number },\n          data.deviceSignals\n        );\n\n        if (!antiCheatResult.allowed) {\n          typedLogger.warn('Prize claim failed - anti-cheat validation', {\n            userId,\n            prizeId: data.prizeId,\n            violations: antiCheatResult.violations,\n            riskScore: antiCheatResult.riskScore,\n          });\n          await this.recordRejectedClaim(userId, data, prize, distance, validationChecks, antiCheatResult);\n          throw new Error('ANTI_CHEAT_VIOLATION');\n        }\n      }\n\n      // Cooldown check\n      try {\n        await validateCooldowns(userId, prize.location.city);\n        validationChecks.cooldownValid = true;\n      } catch (error: any) {\n        validationChecks.cooldownValid = false;\n        typedLogger.warn('Prize claim failed - cooldown active', {\n          userId,\n          prizeId: data.prizeId,\n          error: (error as any).message});\n        throw error;\n      }\n\n      // Apply prize claim transition via model helper\n      // Using type assertion to access the claim method on the prize document\n      const claimedOk: boolean = (prize as any).claim(new Types.ObjectId(userId));\n      if (!claimedOk) {\n        throw new Error('PRIZE_NOT_AVAILABLE');\n      }\n\n      // Create claim record\n      const claim = new Claim({\n        userId: new Types.ObjectId(userId),\n        prizeId: new Types.ObjectId(data.prizeId),\n        location: data.location,\n        distance: Math.round(distance),\n        pointsAwarded: 0,\n        deviceSignals: data.deviceSignals || {},\n        validationChecks,\n        idempotencyKey: data.idempotencyKey,\n        status: 'approved',\n        riskScore: antiCheatResult?.riskScore || 0,\n        riskFactors: antiCheatResult?.violations || [],\n        flaggedAt: (antiCheatResult?.violations?.length || 0) > 0 ? new Date() : undefined,\n        antiCheatDetails: antiCheatResult?.details,\n      });\n      \n      // Persist prize claim state\n      await prize.save();\n\n      // Update user points and stats based on prize contentType\n      let pointsAwarded = 0;\n      let redemptionId = null;\n      \n      const contentType = prize.contentType as string;\n      \n      switch (contentType) {\n        case 'points':\n          // Points purs avec bonus multiplier\n          const pointsAmount = prize.pointsReward?.amount || prize.points || 0;\n          const bonusMultiplier = prize.pointsReward?.bonusMultiplier || 1;\n          pointsAwarded = Math.floor(pointsAmount * bonusMultiplier);\n          user.points.available += pointsAwarded;\n          user.points.total += pointsAwarded;\n          break;\n          \n        case PrizeContentType.REWARD:\n          // Reward direct (coupon, gift)\n          if (prize.directReward?.rewardId) {\n            redemptionId = await this.createDirectRedemptionSafe(\n              userId,\n              prize.directReward.rewardId.toString(),\n              1\n            );\n          }\n          pointsAwarded = 0;\n          break;\n          \n        case PrizeContentType.HYBRID:\n          // Points garantis + probabilit├® de reward\n          const guaranteedPoints = prize.pointsReward?.amount || 0;\n          user.points.available += guaranteedPoints;\n          user.points.total += guaranteedPoints;\n          pointsAwarded = guaranteedPoints;\n          \n          // Tirer au sort un reward\n          if (prize.directReward?.rewardId) {\n            const probability = prize.directReward?.probability || 0.3;\n            const roll = Math.random();\n            \n            if (roll <= probability) {\n              redemptionId = await this.createDirectRedemptionSafe(\n                userId,\n                prize.directReward.rewardId.toString(),\n                1\n              );\n              typedLogger.info('Bonus reward won!', { userId, prizeId: data.prizeId, probability, roll });\n            }\n          }\n          break;\n      }\n      \n      // Update claim with points awarded\n      claim.pointsAwarded = pointsAwarded;\n      if (redemptionId) (claim as any).redemptionId = redemptionId;\n      \n      user.stats.prizesFound += 1;  // Using prizesFound instead of totalClaims\n      user.stats.totalDistance = (user.stats.totalDistance || 0) + distance;\n      // Manually update location instead of calling method\n      user.location = {\n        lat: data.location.lat,\n        lng: data.location.lng,\n        city: user.location?.city || 'Unknown',  // Keep existing city or default\n        lastUpdated: new Date()\n      };\n\n      // Save all changes\n      // Persist computed points on claim\n      claim.pointsAwarded = pointsAwarded;\n      await Promise.all([\n        claim.save(),\n        user.save()]);\n\n      // Atomic increment of prize claimedCount (prevents race conditions)\n      await Prize.findByIdAndUpdate(\n        data.prizeId,\n        { $inc: { claimedCount: 1 } },\n        { new: true }\n      );\n\n      // Check achievements (async, don't wait)\n      const AchievementService = (await import('@/services/achievement')).default;\n      AchievementService.checkAchievements(userId, 'PRIZE_CLAIMED', {\n        prizeId: data.prizeId,\n        category: prize.category,\n        rarity: prize.rarity,\n        pointsAwarded}).catch(error => {\n        typedLogger.error('Check achievements error', { error: (error as any).message, userId, prizeId: data.prizeId });\n      });\n\n      // Store idempotency result\n      const result = {\n        success: true,\n        claim: claim.toJSON(),\n        pointsAwarded,\n        newBalance: user.points.available,\n        newLevel: user.level};\n\n      const resultForCache = JSON.parse(JSON.stringify(result));\n      await setIdempotency(data.idempotencyKey, resultForCache);\n\n      typedLogger.info('Prize claimed successfully', {\n        userId,\n        prizeId: data.prizeId,\n        claimId: claim._id,\n        pointsAwarded,\n        distance: Math.round(distance)});\n\n      // Broadcast to admin dashboard for real-time updates\n      broadcastAdminEvent({\n        type: 'capture_created',\n        data: {\n          claimId: claim._id,\n          userId,\n          prize: {\n            id: prize._id,\n            name: prize.name,\n            category: prize.category,\n            rarity: prize.rarity\n          },\n          pointsAwarded,\n          distance: Math.round(distance),\n          timestamp: new Date()\n        }\n      });\n\n      return result;\n\n    } catch (error) {\n      const normalized = normalizeError(error, 'Claim prize failed');\n      typedLogger.error('Claim prize error', {\n        error: normalized.message,\n        userId,\n        prizeId: data.prizeId,\n        location: data.location});\n      throw new Error(normalized.code);\n    }\n  }\n\n  private static async recordRejectedClaim(\n    userId: string,\n    data: z.infer<typeof claimPrizeSchema>,\n    prize: any,\n    distance: number,\n    validationChecks: any,\n    antiCheatResult: Awaited<ReturnType<typeof validateAntiCheat>>\n  ): Promise<void> {\n    try {\n      const rejectedClaim = new Claim({\n        userId: new Types.ObjectId(userId),\n        prizeId: new Types.ObjectId(data.prizeId),\n        location: data.location,\n        distance: Math.round(distance),\n        pointsAwarded: 0,\n        deviceSignals: data.deviceSignals || {},\n        validationChecks,\n        idempotencyKey: data.idempotencyKey,\n        status: 'rejected',\n        riskScore: antiCheatResult.riskScore || 0,\n        riskFactors: antiCheatResult.violations || [],\n        flaggedAt: new Date(),\n        antiCheatDetails: antiCheatResult.details,\n        metadata: {\n          ...(prize?.metadata || {}),\n          rejectionReason: 'ANTI_CHEAT_VIOLATION',\n        },\n      });\n\n      await rejectedClaim.save();\n    } catch (error) {\n      typedLogger.error('Failed to record rejected claim', {\n        error: (error as any).message,\n        userId,\n        prizeId: data.prizeId,\n      });\n    }\n  }\n\n  /**\n   * Get user claims\n   */\n  static async getUserClaims(\n    userId: string,\n    data: z.infer<typeof getUserClaimsSchema>\n  ) {\n    try {\n      const skip = (data.page - 1) * data.limit;\n      \n      const query: any = {\n        userId: new Types.ObjectId(userId),\n        status: { $ne: 'rejected' },\n      };\n      \n      if (data.startDate || data.endDate) {\n        query.claimedAt = {};\n        if (data.startDate) {\n          query.claimedAt.$gte = new Date(data.startDate);\n        }\n        if (data.endDate) {\n          query.claimedAt.$lte = new Date(data.endDate);\n        }\n      }\n\n      const [claims, total] = await Promise.all([\n        Claim.find(query)\n          .populate('prizeId', 'name description points rarity category imageUrl location')\n          .sort({ claimedAt: -1 })\n          .skip(skip)\n          .limit(data.limit),\n        Claim.countDocuments(query)]);\n\n      return {\n        claims: claims.map(claim => claim.toJSON()),\n        pagination: {\n          page: data.page,\n          limit: data.limit,\n          total,\n          pages: Math.ceil(total / data.limit),\n          hasNext: skip + data.limit < total,\n          hasPrev: data.page > 1}};\n\n    } catch (error) {\n      const normalized = normalizeError(error, 'Get user claims failed');\n      typedLogger.error('Get user claims error', {\n        error: normalized.message,\n        userId});\n      throw new Error(normalized.code);\n    }\n  }\n\n  /**\n   * Get claim details\n   */\n  static async getClaimDetails(\n    userId: string,\n    claimId: string\n  ) {\n    try {\n      const claim = await Claim.findOne({\n        _id: claimId,\n        userId: new Types.ObjectId(userId),\n        status: { $ne: 'rejected' },\n      })\n        .populate('prizeId', 'name description points rarity category imageUrl location createdBy')\n        .populate('userId', 'displayName level');\n\n      if (!claim) {\n        throw new Error('CLAIM_NOT_FOUND');\n      }\n\n      return claim.toJSON();\n\n    } catch (error) {\n      const normalized = normalizeError(error, 'Get claim details failed');\n      typedLogger.error('Get claim details error', {\n        error: normalized.message,\n        userId,\n        claimId});\n      throw new Error(normalized.code);\n    }\n  }\n\n  /**\n   * Get user claim statistics\n   */\n  static async getUserClaimStats(userId: string) {\n    try {\n      // Use aggregation to get user stats instead of non-existent method\n      const stats = await Claim.aggregate([\n        { $match: { userId: new Types.ObjectId(userId), status: { $ne: 'rejected' } } },\n        {\n          $group: {\n            _id: null,\n            totalClaims: { $sum: 1 },\n            totalPoints: { $sum: '$pointsAwarded' },\n            totalDistance: { $sum: '$distance' },\n            avgDistance: { $avg: '$distance' },\n            lastClaim: { $max: '$claimedAt' }\n          }\n        }\n      ]);\n\n      // Return default stats if no claims found\n      const result = stats[0] || {\n        totalClaims: 0,\n        totalPoints: 0,\n        totalDistance: 0,\n        avgDistance: 0,\n        lastClaim: null\n      };\n      \n      // Get additional stats\n      const [recentClaims, topCategories] = await Promise.all([\n        Claim.find({ userId: new Types.ObjectId(userId), status: { $ne: 'rejected' } })\n          .populate('prizeId', 'category')\n          .sort({ claimedAt: -1 })\n          .limit(10),\n        Claim.aggregate([\n          { $match: { userId: new Types.ObjectId(userId), status: { $ne: 'rejected' } } },\n          { $lookup: { from: 'prizes', localField: 'prizeId', foreignField: '_id', as: 'prize' } },\n          { $unwind: '$prize' },\n          { $group: { _id: '$prize.category', count: { $sum: 1 }, points: { $sum: '$pointsAwarded' } } },\n          { $sort: { count: -1 } },\n          { $limit: 5 }])]);\n\n      return {\n        ...result,\n        recentClaims: recentClaims.map(claim => ({\n          id: claim._id,\n          prizeCategory: (claim.prizeId as any)?.category,\n          pointsAwarded: claim.pointsAwarded,\n          claimedAt: claim.claimedAt,\n          distance: claim.distance})),\n        topCategories: topCategories.map(cat => ({\n          category: cat._id,\n          claims: cat.count,\n          totalPoints: cat.points}))};\n\n    } catch (error) {\n      typedLogger.error('Get user claim stats error', {\n        error: (error as any).message,\n        userId});\n      throw error;\n    }\n  }\n\n  /**\n   * Admin: Get all claims with filters\n   */\n  static async getAllClaims(options: any = {}) {\n    try {\n      const skip = ((options.page || 1) - 1) * (options.limit || 50);\n      \n      const query: any = {};\n      \n      if (options.userId) {\n        query.userId = new Types.ObjectId(options.userId);\n      }\n      \n      if (options.prizeId) {\n        query.prizeId = new Types.ObjectId(options.prizeId);\n      }\n      \n      if (options.startDate || options.endDate) {\n        query.claimedAt = {};\n        if (options.startDate) {\n          query.claimedAt.$gte = new Date(options.startDate);\n        }\n        if (options.endDate) {\n          query.claimedAt.$lte = new Date(options.endDate);\n        }\n      }\n\n      if (options.validOnly === true) {\n        query['validationChecks.distanceValid'] = true;\n        query['validationChecks.timeValid'] = true;\n        query['validationChecks.speedValid'] = true;\n        query['validationChecks.cooldownValid'] = true;\n        query['validationChecks.dailyLimitValid'] = true;\n      }\n\n      const [claims, total] = await Promise.all([\n        Claim.find(query)\n          .populate('userId', 'displayName email level')\n          .populate('prizeId', 'name description points category location')\n          .sort({ claimedAt: -1 })\n          .skip(skip)\n          .limit(options.limit || 50),\n        Claim.countDocuments(query)]);\n\n      return {\n        claims: claims.map(claim => claim.toJSON()),\n        pagination: {\n          page: options.page || 1,\n          limit: options.limit || 50,\n          total,\n          pages: Math.ceil(total / (options.limit || 50)),\n          hasNext: skip + (options.limit || 50) < total,\n          hasPrev: (options.page || 1) > 1}};\n\n    } catch (error) {\n      typedLogger.error('Get all claims error', {\n        error: (error as any).message,\n        options});\n      throw error;\n    }\n  }\n\n  /**\n   * Create a direct redemption for a prize reward\n   * @private\n   */\n  private static async createDirectRedemption(\n    userId: string,\n    rewardId: string,\n    quantity: number = 1\n  ): Promise<string> {\n    try {\n      const Redemption = (await import('@/models/Redemption')).default;\n      const Reward = (await import('@/models/Reward')).default;\n      \n      const reward = await Reward.findById(rewardId);\n      if (!reward) {\n        throw new Error('REWARD_NOT_FOUND');\n      }\n      \n      // V├®rifier le stock\n      if ((reward as any).stock < quantity) {\n        throw new Error('INSUFFICIENT_STOCK');\n      }\n      \n      // Cr├®er la redemption\n      const redemption = new Redemption({\n        userId: new Types.ObjectId(userId),\n        rewardId: new Types.ObjectId(rewardId),\n        quantity,\n        pointsSpent: 0, // Gratuit car obtenu via prize\n        status: 'PENDING',\n        source: 'PRIZE_CLAIM'});\n      \n      // D├®duire du stock\n      (reward as any).stock -= quantity;\n      \n      await Promise.all([\n        redemption.save(),\n        reward.save()]);\n      \n      typedLogger.info('Direct redemption created', {\n        userId,\n        rewardId,\n        redemptionId: redemption._id,\n        quantity});\n      \n      return redemption._id.toString();\n    } catch (error) {\n      typedLogger.error('Create direct redemption error', {\n        error: (error as any).message,\n        userId,\n        rewardId});\n      throw error;\n    }\n  }\n\n  /**\n   * Safe direct redemption creation using reward stock helpers and idempotency.\n   */\n  private static async createDirectRedemptionSafe(\n    userId: string,\n    rewardId: string,\n    quantity: number = 1\n  ): Promise<string> {\n    const Redemption = (await import('@/models/Redemption')).default;\n    const Reward = (await import('@/models/Reward')).default;\n\n    const reward = await Reward.findById(rewardId);\n    if (!reward) {\n      throw new Error('REWARD_NOT_FOUND');\n    }\n\n    // Reserve stock atomically\n    const reserved = (reward as any).reserveStock(quantity);\n    if (!reserved) {\n      throw new Error('INSUFFICIENT_STOCK');\n    }\n\n    // Simple idempotency key per user+reward+ts\n    const idempotencyKey = `PRIZE_REDEEM_${userId}_${rewardId}_${Date.now()}`;\n\n    const redemption = new Redemption({\n      userId: new Types.ObjectId(userId),\n      rewardId: new Types.ObjectId(rewardId),\n      quantity,\n      pointsSpent: 1, // schema requires min:1; business may treat this as free\n      status: 'PENDING',\n      idempotencyKey,\n      metadata: { source: 'PRIZE_CLAIM' },\n    });\n\n    await redemption.save();\n    await reward.save();\n\n    typedLogger.info('Direct redemption created (safe)', {\n      userId,\n      rewardId,\n      redemptionId: redemption._id,\n      quantity,\n    });\n\n    return redemption._id.toString();\n  }\n}\n\n/**\n * Claims routes\n */\nexport default async function claimsRoutes(fastify: FastifyInstance) {\n  // Claim a prize\n  fastify.post('/', {\n    preHandler: [authenticate, claimsRateLimit],\n    schema: {\n      body: claimPrizeSchema\n    }\n  }, async (request, reply) => {\n    try {\n      const result = await ClaimsService.claimPrize(\n        request.user.sub,\n        request.body\n      );\n      \n      reply.code(201).send({\n        success: true,\n        data: result,\n        timestamp: new Date().toISOString()});\n    } catch (error) {\n      const normalized = normalizeError(error, 'Claim prize failed');\n      const statusCodes: Record<string, number> = {\n        LOCATION_OUT_OF_BOUNDS: 400,\n        USER_NOT_FOUND: 404,\n        PRIZE_NOT_FOUND: 404,\n        PRIZE_NOT_AVAILABLE: 409,\n        DISTANCE_TOO_FAR: 400,\n        ANTI_CHEAT_VIOLATION: 403,\n        COOLDOWN_ACTIVE: 429,\n        DAILY_LIMIT_EXCEEDED: 429,\n      };\n      const statusCode = statusCodes[normalized.code] || 500;\n      reply.code(statusCode).send({\n        success: false,\n        error: normalized.code,\n        message: normalized.message,\n        timestamp: new Date().toISOString()});\n    }\n  });\n\n  // Get user claims\n  fastify.get<{Querystring: z.infer<typeof getUserClaimsSchema>}>('/my-claims', {\n    preHandler: [authenticate]}, async (request, reply) => {\n    try {\n      const result = await ClaimsService.getUserClaims(\n        request.user.sub,\n        request.query\n      );\n      \n      reply.send({\n        success: true,\n        data: result,\n        timestamp: new Date().toISOString()});\n    } catch (error) {\n      const normalized = normalizeError(error, 'Get user claims failed');\n      reply.code(500).send({\n        success: false,\n        error: normalized.code,\n        message: normalized.message,\n        timestamp: new Date().toISOString()});\n    }\n  });\n\n  // Get claim details\n  fastify.get<{Params: {claimId: string;}}>(\n    '/:claimId',\n    { preHandler: [authenticate] },\n    async (request, reply) => {\n    try {\n      const result = await ClaimsService.getClaimDetails(\n        request.user.sub,\n        request.params.claimId\n      );\n      \n      reply.send({\n        success: true,\n        data: result,\n        timestamp: new Date().toISOString()});\n    } catch (error) {\n      const normalized = normalizeError(error, 'Get claim details failed');\n      const statusCode = (error as any).message === 'CLAIM_NOT_FOUND' ? 404 : 500;\n      reply.code(statusCode).send({\n        success: false,\n        error: normalized.code,\n        message: normalized.message,\n        timestamp: new Date().toISOString()});\n    }\n  });\n\n  // Get user claim statistics\n  fastify.get('/my-stats', {\n    preHandler: [authenticate]}, async (request, reply) => {\n    try {\n      const result = await ClaimsService.getUserClaimStats(request.user.sub);\n      \n      reply.send({\n        success: true,\n        data: result,\n        timestamp: new Date().toISOString()});\n    } catch (error) {\n      reply.code(500).send({\n        success: false,\n        error: (error as any).message,\n        timestamp: new Date().toISOString()});\n    }\n  });\n\n  // Admin: Get all claims\n  fastify.get<{Querystring: any}>('/admin/all', {\n    preHandler: [authenticate, requireAdmin]}, async (request, reply) => {\n    try {\n      const result = await ClaimsService.getAllClaims(request.query);\n      \n      reply.send({\n        success: true,\n        data: result,\n        timestamp: new Date().toISOString()});\n    } catch (error) {\n      reply.code(500).send({\n        success: false,\n        error: (error as any).message,\n        timestamp: new Date().toISOString()});\n    }\n  });\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\claims\\routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\game\\index.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'FastifyRequest' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Settings' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":18},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":141,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":141,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4233,4236],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4233,4236],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":150,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":150,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4514,4517],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4514,4517],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":151,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":151,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4579,4582],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4579,4582],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":189,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":189,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5884,5887],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5884,5887],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":259,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":259,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8376,8379],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8376,8379],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":288,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":288,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9445,9448],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9445,9448],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":288,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":288,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9483,9486],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9483,9486],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":292,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":292,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9657,9660],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9657,9660],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":315,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":315,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10575,10578],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10575,10578],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":316,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":316,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10642,10645],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10642,10645],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":320,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":320,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10805,10808],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10805,10808],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":340,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":340,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11396,11399],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11396,11399],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":340,"column":79,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":340,"endColumn":82,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11433,11436],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11433,11436],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":342,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":342,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11544,11547],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11544,11547],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":379,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":379,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12502,12505],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12502,12505],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":380,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":380,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12564,12567],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12564,12567],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":383,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":383,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12718,12721],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12718,12721],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":391,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":391,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12855,12858],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12855,12858],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":441,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":441,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14511,14514],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14511,14514],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":442,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":442,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14554,14557],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14554,14557],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":443,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":443,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14598,14601],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14598,14601],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":444,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":444,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14640,14643],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14640,14643],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":445,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":445,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14718,14721],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14718,14721],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":466,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":466,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15463,15466],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15463,15466],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":467,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":467,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15507,15510],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15507,15510],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":468,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":468,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15587,15590],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15587,15590],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":473,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":473,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15824,15827],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15824,15827],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":482,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":482,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16089,16092],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16089,16092],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":537,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":537,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17668,17671],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17668,17671],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":552,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":552,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18179,18182],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18179,18182],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"prefer-const","severity":2,"message":"'challenges' is never reassigned. Use 'const' instead.","line":566,"column":11,"nodeType":"Identifier","messageId":"useConst","endLine":566,"endColumn":21,"fix":{"range":[18533,18585],"text":"const challenges = await this.redis.get(challengeKey);"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":577,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":577,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19036,19039],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19036,19039],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":594,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":594,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19579,19582],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19579,19582],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":617,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":617,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20429,20432],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20429,20432],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":635,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":635,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20971,20974],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20971,20974],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'userId' is defined but never used. Allowed unused args must match /^_/u.","line":641,"column":92,"nodeType":"Identifier","messageId":"unusedVar","endLine":641,"endColumn":106},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":750,"column":81,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":750,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24642,24645],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24642,24645],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":787,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":787,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25572,25575],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25572,25575],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":830,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":830,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26880,26883],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26880,26883],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":849,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":849,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[27410,27413],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[27410,27413],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":869,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":869,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[27982,27985],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[27982,27985],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":889,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":889,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28709,28712],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28709,28712],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":911,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":911,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[29390,29393],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[29390,29393],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":928,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":928,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[29864,29867],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[29864,29867],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":939,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":939,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[30240,30243],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[30240,30243],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":958,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":958,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[30789,30792],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[30789,30792],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":969,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":969,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31120,31123],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31120,31123],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":990,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":990,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31720,31723],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31720,31723],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1013,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1013,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32345,32348],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32345,32348],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1125,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1125,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[36057,36060],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[36057,36060],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1126,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1126,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[36138,36141],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[36138,36141],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1139,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1139,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[36535,36538],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[36535,36538],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1164,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1164,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[37428,37431],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[37428,37431],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":55,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import { FastifyInstance, FastifyRequest } from 'fastify';\nimport { authenticate } from '@/middleware/auth';\nimport { z } from 'zod';\nimport { User } from '@/models/User';\nimport { Prize } from '@/models/Prize';\nimport { Claim } from '@/models/Claim';\nimport { Settings } from '@/models/Settings';\nimport { Partner } from '@/models/Partner';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { redisClient } from '@/config/redis';\nimport { configService } from '@/services/config';\nimport { CaptureService } from '@/modules/capture/routes';\nimport { calculateGeodesicDistance as calculateDistance } from '@/utils/geo';\nimport { validateAntiCheat as detectCheating } from '@/utils/anti-cheat';\nimport { MetricsService, GameMetrics } from '@/services/metrics';\n\n// Define interfaces to replace 'any' types\ninterface GameSessionData {\n  deviceId: string;\n  platform: 'iOS' | 'Android' | 'Unity';\n  version: string;\n  deviceModel?: string;\n  osVersion?: string;\n  appVersion?: string;\n  location: {\n    latitude: number;\n    longitude: number;\n    accuracy: number;\n  };\n}\n\ninterface LocationUpdateData {\n  sessionId: string;\n  location: {\n    latitude: number;\n    longitude: number;\n    accuracy: number;\n    speed?: number;\n    heading?: number;\n  };\n  device?: {\n    model?: string;\n    osVersion?: string;\n    appVersion?: string;\n  };\n  timestamp: string;\n}\n\ninterface PowerUpUsageData {\n  powerUpId: string;\n  location: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\n// Game session schema\nconst GameSessionSchema = z.object({\n  deviceId: z.string(),\n  platform: z.enum(['iOS', 'Android', 'Unity']),\n  version: z.string(),\n  deviceModel: z.string().optional(),\n  osVersion: z.string().optional(),\n  appVersion: z.string().optional(),\n  location: z.object({\n    latitude: z.number().min(-90).max(90),\n    longitude: z.number().min(-180).max(180),\n    accuracy: z.number().min(0)})});\n\n// Location update schema\nconst LocationUpdateSchema = z.object({\n  sessionId: z.string(),\n  location: z.object({\n    latitude: z.number().min(-90).max(90),\n    longitude: z.number().min(-180).max(180),\n    accuracy: z.number().min(0),\n    speed: z.number().min(0).optional(),\n    heading: z.number().min(0).max(360).optional()}),\n  device: z.object({\n    model: z.string().optional(),\n    osVersion: z.string().optional(),\n    appVersion: z.string().optional(),\n  }).optional(),\n  timestamp: z.string().datetime()});\n\n// Power-up usage schema\nconst PowerUpUsageSchema = z.object({\n  powerUpId: z.string(),\n  location: z.object({\n    latitude: z.number().min(-90).max(90),\n    longitude: z.number().min(-180).max(180)})});\n\n// Capture attempt schema (CRITICAL for prize capture flow)\nconst CaptureAttemptSchema = z.object({\n  prizeId: z.string(),\n  location: z.object({\n    latitude: z.number().min(-90).max(90),\n    longitude: z.number().min(-180).max(180),\n    accuracy: z.number().min(0).max(1000).optional(),\n    altitude: z.number().optional()\n  }),\n  deviceInfo: z.object({\n    platform: z.enum(['iOS', 'Android']),\n    deviceModel: z.string(),\n    osVersion: z.string().optional(),\n    appVersion: z.string().optional(),\n    timestamp: z.string().datetime().optional()\n  }).optional(),\n  captureMethod: z.enum(['tap', 'gesture', 'voice']).default('tap')\n});\n\n// Capture validation schema\nconst CaptureValidationSchema = z.object({\n  prizeId: z.string(),\n  location: z.object({\n    latitude: z.number().min(-90).max(90),\n    longitude: z.number().min(-180).max(180)\n  })\n});\n\nexport class GameService {\n  private static redis = redisClient;\n\n  /**\n   * Start a new game session\n   */\n  static async startGameSession(userId: string, sessionData: GameSessionData, context?: { ip?: string; userAgent?: string }) {\n    try {\n      const user = await User.findById(userId);\n      if (!user) throw new Error('USER_NOT_FOUND');\n\n      if (user.isBanned) throw new Error('USER_BANNED');\n\n      // Persist last active + optional location/device + ip/ua\n      user.lastActive = new Date();\n      if (sessionData.location) {\n        user.updateLocation(sessionData.location.latitude, sessionData.location.longitude, user.location?.city || '');\n      }\n      user.addDevice(\n        sessionData.deviceId,\n        sessionData.platform as any,\n        undefined,\n        {\n          model: sessionData.deviceModel,\n          osVersion: sessionData.osVersion,\n          appVersion: sessionData.appVersion || sessionData.version,\n          userAgent: context?.userAgent,\n        }\n      );\n      if (context?.ip) (user as any).lastIp = context.ip;\n      if (context?.userAgent) (user as any).lastUserAgent = context.userAgent;\n      await user.save();\n\n      // Generate session ID\n      const sessionId = `game_session_${userId}_${Date.now()}`;\n      \n      // Store session in Redis\n      const session = {\n        sessionId,\n        userId,\n        startTime: new Date().toISOString(),\n        deviceId: sessionData.deviceId,\n        platform: sessionData.platform,\n        version: sessionData.version,\n        initialLocation: sessionData.location,\n        currentLocation: sessionData.location,\n        distanceTraveled: 0,\n        prizesFound: 0,\n        claimsAttempted: 0,\n        powerUpsUsed: 0,\n        status: 'active'};\n\n      await this.redis.setex(`session:${sessionId}`, 3600, JSON.stringify(session));\n      \n      // Update user last active\n      await User.findByIdAndUpdate(userId, {\n        $set: { lastActive: new Date() },\n        $inc: { 'stats.totalSessions': 1 }});\n\n      typedLogger.info('Game session started', { userId, sessionId, location: sessionData.location });\n\n      return {\n        sessionId,\n        startTime: session.startTime,\n        userLevel: user.level,\n        userPoints: user.points,\n        dailyChallenges: await this.getDailyChallenges(userId)};\n    } catch (error) {\n      typedLogger.error('Start game session error', { error: (error as any).message, userId });\n      throw error;\n    }\n  }\n\n  /**\n   * End game session\n   */\n  static async endGameSession(userId: string, sessionId: string) {\n    try {\n      const sessionKey = `session:${sessionId}`;\n      const sessionData = await this.redis.get(sessionKey);\n      \n      if (!sessionData) throw new Error('SESSION_NOT_FOUND');\n      \n      const session = JSON.parse(sessionData);\n      if (session.userId !== userId) throw new Error('SESSION_UNAUTHORIZED');\n\n      // Calculate session stats\n      const endTime = new Date();\n      const startTime = new Date(session.startTime);\n      const duration = Math.floor((endTime.getTime() - startTime.getTime()) / 1000); // seconds\n\n      // Update session with end data\n      session.endTime = endTime.toISOString();\n      session.duration = duration;\n      session.status = 'completed';\n\n      // Store final session data\n      await this.redis.setex(sessionKey, 86400, JSON.stringify(session)); // Keep for 24h\n\n      // Update user stats\n      await User.findByIdAndUpdate(userId, {\n        $inc: {\n          'stats.totalPlayTime': duration,\n          'stats.totalDistance': session.distanceTraveled || 0}});\n\n      // Calculate session rewards\n      const sessionRewards = this.calculateSessionRewards(session);\n\n      // Record game metrics for analytics\n      const gameMetrics: GameMetrics = {\n        sessionDuration: duration,\n        prizesFound: session.prizesFound || 0,\n        prizesClaimed: session.claimsAttempted || 0,\n        distanceTraveled: session.distanceTraveled || 0,\n        averageSpeed: duration > 0 ? (session.distanceTraveled || 0) / duration : 0,\n        batteryUsage: 0, // Unity client would provide this\n        networkLatency: 0, // Unity client would provide this\n        frameRate: 0, // Unity client would provide this\n        crashes: 0\n      };\n      await MetricsService.recordGameMetrics(userId, sessionId, gameMetrics);\n\n      typedLogger.info('Game session ended', { \n        userId, \n        sessionId, \n        duration, \n        distanceTraveled: session.distanceTraveled,\n        prizesFound: session.prizesFound});\n\n      return {\n        sessionId,\n        duration,\n        distanceTraveled: session.distanceTraveled,\n        prizesFound: session.prizesFound,\n        claimsAttempted: session.claimsAttempted,\n        powerUpsUsed: session.powerUpsUsed,\n        rewards: sessionRewards};\n    } catch (error) {\n      typedLogger.error('End game session error', { error: (error as any).message, userId, sessionId });\n      throw error;\n    }\n  }\n\n  /**\n   * Update player location during game\n   */\n  static async updateLocation(userId: string, locationData: LocationUpdateData, context?: { ip?: string; userAgent?: string }) {\n    try {\n      const sessionKey = `session:${locationData.sessionId}`;\n      const sessionData = await this.redis.get(sessionKey);\n      \n      if (!sessionData) throw new Error('SESSION_NOT_FOUND');\n      \n      const session = JSON.parse(sessionData);\n      if (session.userId !== userId) throw new Error('SESSION_UNAUTHORIZED');\n\n      // Check for cheating - adapt parameters to match anti-cheat function\n      // Convert location to Coordinates format (lat/lng)\n      const locationForAntiCheat = {\n        lat: locationData.location.latitude,\n        lng: locationData.location.longitude\n      };\n      const cheatDetection = await detectCheating(userId, locationForAntiCheat, {\n        speed: locationData.location.speed,\n        timestamp: new Date(locationData.timestamp)\n      });\n\n      if ((cheatDetection as any).isCheating || (cheatDetection as any).allowed === false) {\n        typedLogger.warn('Cheating detected', {\n          userId,\n          sessionId: locationData.sessionId,\n          reason: (cheatDetection as any).reason});\n\n        // Don't throw error, just log for analysis\n      }\n\n      // Calculate distance traveled\n      const distance = calculateDistance(\n        { lat: session.currentLocation.latitude, lng: session.currentLocation.longitude },\n        { lat: locationData.location.latitude, lng: locationData.location.longitude }\n      );\n\n      // Update session\n      session.currentLocation = locationData.location;\n      session.distanceTraveled += distance;\n      session.lastUpdate = new Date().toISOString();\n\n      await this.redis.setex(sessionKey, 3600, JSON.stringify(session));\n\n      // Persist user location + device meta + ip/ua best-effort\n      const user = await User.findById(userId);\n      if (user) {\n        user.updateLocation(locationData.location.latitude, locationData.location.longitude, user.location?.city || '');\n        user.lastActive = new Date();\n        if (context?.ip) (user as any).lastIp = context.ip;\n        if (context?.userAgent) (user as any).lastUserAgent = context.userAgent;\n        if (locationData.device) {\n          user.addDevice(\n            session.deviceId,\n            session.platform as any,\n            undefined,\n            {\n              model: locationData.device.model,\n              osVersion: locationData.device.osVersion,\n              appVersion: locationData.device.appVersion,\n              userAgent: context?.userAgent,\n            }\n          );\n        }\n        await user.save();\n      }\n\n      // Find nearby prizes\n      const nearbyPrizes = await this.findNearbyPrizes(locationData.location, userId);\n\n      return {\n        success: true,\n        distanceTraveled: session.distanceTraveled,\n        nearbyPrizes,\n        cheatWarning: (cheatDetection as any).isCheating ? (cheatDetection as any).reason : null};\n    } catch (error) {\n      typedLogger.error('Update location error', { error: (error as any).message, userId });\n      throw error;\n    }\n  }\n\n  /**\n   * Get leaderboard\n   */\n  static async getLeaderboard(type: string = 'points', limit: number = 50) {\n    try {\n      let sortField = 'points';\n      \n      switch (type) {\n        case 'claims':\n          sortField = 'stats.totalClaims';\n          break;\n        case 'distance':\n          sortField = 'stats.totalDistance';\n          break;\n        case 'level':\n          sortField = 'level';\n          break;\n        default:\n          sortField = 'points';\n      }\n\n      const users = await User.find({ isBanned: false })\n        .select('displayName level points stats.totalClaims stats.totalDistance avatar')\n        .sort({ [sortField]: -1 })\n        .limit(limit);\n\n      return users.map((user, index) => ({\n        rank: index + 1,\n        userId: user._id,\n        displayName: user.displayName,\n        level: user.level,\n        points: user.points,\n        totalClaims: (user as any).stats?.totalClaims || 0,\n        totalDistance: (user as any).stats?.totalDistance || 0,\n        avatar: user.avatar}));\n    } catch (error) {\n      typedLogger.error('Get leaderboard error', { error: (error as any).message, type });\n      throw error;\n    }\n  }\n\n  /**\n   * Get map data optimized for Unity\n   */\n  static async getMapData(bounds: any, userId: string) {\n    try {\n      const { north, south, east, west } = bounds;\n      \n      // Get active prizes in bounds\n      const prizes = await Prize.find({\n        status: 'active',\n        'location.coordinates': {\n          $geoWithin: {\n            $box: [[west, south], [east, north]]\n          }\n        }\n      }).select('title description category points location rarity expiresAt');\n\n      // Get active partner locations in bounds for map overlay\n      const partners = await Partner.find({\n        isActive: true,\n        'locations.coordinates': {\n          $geoWithin: {\n            $box: [[west, south], [east, north]]\n          }\n        }\n      })\n      .select('name category logo locations')\n      .limit(100); // guardrail\n\n      // Get user's claimed prizes to exclude\n      const userClaims = await Claim.find({ userId }).select('prizeId');\n      const claimedPrizeIds = userClaims.map(claim => claim.prizeId.toString());\n\n      // Filter out claimed prizes\n      const availablePrizes = prizes.filter(prize => \n        !claimedPrizeIds.includes(prize._id.toString())\n      );\n\n      // Format for Unity\n      const mapData = {\n        prizes: availablePrizes.map(prize => ({\n          id: prize._id,\n          title: prize.name,\n          category: prize.category,\n          points: prize.points,\n          rarity: prize.rarity,\n          position: {\n            lat: prize.location.coordinates[1],\n            lng: prize.location.coordinates[0]},\n          expiresAt: prize.expiresAt})),\n        partners: partners.map(partner => ({\n          id: partner._id,\n          name: partner.name,\n          category: (partner as any).category,\n          logo: (partner as any).logo,\n          locations: (partner as any).locations\n            ?.filter((loc: any) => loc.isActive && loc.coordinates?.length === 2)\n            .map((loc: any) => ({\n              id: loc._id,\n              name: loc.name,\n              position: { lat: loc.coordinates[1], lng: loc.coordinates[0] },\n              address: loc.address,\n              city: loc.city,\n            })) || []\n        })),\n        markers: [\n          // Prize markers\n          ...availablePrizes.map(prize => ({\n            id: prize._id,\n            type: 'prize' as const,\n            title: prize.name,\n            position: { lat: prize.location.coordinates[1], lng: prize.location.coordinates[0] },\n            category: prize.category,\n            rarity: prize.rarity,\n            points: prize.points,\n          })),\n          // Partner markers\n          ...partners.flatMap(partner =>\n            (partner as any).locations\n              ?.filter((loc: any) => loc.isActive && loc.coordinates?.length === 2)\n              .map((loc: any) => ({\n                id: loc._id,\n                type: 'partner' as const,\n                title: partner.name,\n                position: { lat: loc.coordinates[1], lng: loc.coordinates[0] },\n                category: (partner as any).category,\n              })) || []\n          ),\n        ],\n        bounds: { north, south, east, west },\n        timestamp: new Date().toISOString()};\n\n      return mapData;\n    } catch (error) {\n      typedLogger.error('Get map data error', { error: (error as any).message, bounds, userId });\n      throw error;\n    }\n  }\n\n  /**\n   * Use power-up\n   */\n  static async usePowerUp(userId: string, powerUpData: PowerUpUsageData) {\n    try {\n      const user = await User.findById(userId);\n      if (!user) throw new Error('USER_NOT_FOUND');\n\n      // Check if user has the power-up\n      const powerUp = user.inventory?.powerUps?.find(p => p.id === powerUpData.powerUpId);\n      if (!powerUp || powerUp.quantity <= 0) {\n        throw new Error('POWER_UP_NOT_AVAILABLE');\n      }\n\n      let effect = {};\n\n      switch (powerUpData.powerUpId) {\n        case 'radar_boost':\n          // Increase detection radius for 10 minutes\n          effect = {\n            type: 'radar_boost',\n            radius: 200, // meters\n            duration: 600, // seconds\n            expiresAt: new Date(Date.now() + 600000)};\n          break;\n        \n        case 'double_points':\n          // Double points for next 5 claims\n          effect = {\n            type: 'double_points',\n            multiplier: 2,\n            remainingUses: 5,\n            expiresAt: new Date(Date.now() + 3600000), // 1 hour max\n          };\n          break;\n        \n        case 'speed_boost':\n          // Reduce cooldown between claims\n          effect = {\n            type: 'speed_boost',\n            cooldownReduction: 0.5,\n            duration: 1800, // 30 minutes\n            expiresAt: new Date(Date.now() + 1800000)};\n          break;\n        \n        default:\n          throw new Error('UNKNOWN_POWER_UP');\n      }\n\n      // Apply power-up effect\n      const updateObj: any = {};\n      updateObj[`inventory.powerUps.${powerUp.id}.quantity`] = -1;\n\n      await User.findByIdAndUpdate(userId, {\n        $inc: updateObj,\n        $push: { activeEffects: effect }\n      });\n\n      typedLogger.info('Power-up used', { userId, powerUpId: powerUpData.powerUpId, location: powerUpData.location });\n\n      return {\n        success: true,\n        effect,\n        remainingQuantity: powerUp.quantity - 1};\n    } catch (error) {\n      typedLogger.error('Use power-up error', { error: (error as any).message, userId, powerUpData });\n      throw error;\n    }\n  }\n\n  /**\n   * Get daily challenges\n   */\n  static async getDailyChallenges(userId: string) {\n    try {\n      const today = new Date().toISOString().split('T')[0];\n      const challengeKey = `challenges:${userId}:${today}`;\n      \n      // Check if challenges already exist for today\n      let challenges = await this.redis.get(challengeKey);\n\n      if (!challenges) {\n        // Generate new daily challenges (now reads from Settings)\n        const newChallenges = await this.generateDailyChallenges(userId);\n        await this.redis.setex(challengeKey, 86400, JSON.stringify(newChallenges)); // 24 hours\n        return newChallenges;\n      } else {\n        return JSON.parse(challenges);\n      }\n    } catch (error) {\n      typedLogger.error('Get daily challenges error', { error: (error as any).message, userId });\n      throw error;\n    }\n  }\n\n  /**\n   * Complete daily challenge\n   */\n  static async completeChallenge(userId: string, challengeId: string) {\n    try {\n      const today = new Date().toISOString().split('T')[0];\n      const challengeKey = `challenges:${userId}:${today}`;\n      \n      const challengesData = await this.redis.get(challengeKey);\n      if (!challengesData) throw new Error('CHALLENGES_NOT_FOUND');\n      \n      const challenges = JSON.parse(challengesData);\n      const challenge = challenges.find((c: any) => c.id === challengeId);\n      \n      if (!challenge) throw new Error('CHALLENGE_NOT_FOUND');\n      if (challenge.completed) throw new Error('CHALLENGE_ALREADY_COMPLETED');\n      \n      // Mark as completed\n      challenge.completed = true;\n      challenge.completedAt = new Date().toISOString();\n      \n      // Award rewards\n      await User.findByIdAndUpdate(userId, {\n        $inc: { points: challenge.reward }});\n      \n      // Update challenges in Redis\n      await this.redis.setex(challengeKey, 86400, JSON.stringify(challenges));\n      \n      typedLogger.info('Challenge completed', { userId, challengeId, reward: challenge.reward });\n      \n      return {\n        success: true,\n        challenge,\n        pointsAwarded: challenge.reward};\n    } catch (error) {\n      typedLogger.error('Complete challenge error', { error: (error as any).message, userId, challengeId });\n      throw error;\n    }\n  }\n\n  /**\n   * Get user inventory\n   */\n  static async getInventory(userId: string) {\n    try {\n      const user = await User.findById(userId).select('inventory activeEffects');\n      if (!user) throw new Error('USER_NOT_FOUND');\n\n      return {\n        powerUps: user.inventory?.powerUps || [],\n        items: user.inventory?.items || [],\n        activeEffects: user.activeEffects || []};\n    } catch (error) {\n      typedLogger.error('Get inventory error', { error: (error as any).message, userId });\n      throw error;\n    }\n  }\n\n  // Helper methods\n  private static async findNearbyPrizes(location: { latitude: number; longitude: number }, userId: string) {\n    try {\n      // Get detection radius from config (real-time, can be changed without restart)\n      const detectionRadius = await configService.getConfigValue<number>('game.prizeDetectionRadiusM');\n      const maxDistance = (detectionRadius || 100) * 1; // Convert meters to meters (already in correct unit)\n\n      const nearbyPrizes = await Prize.find({\n        status: 'active',\n        'location.coordinates': {\n          $near: {\n            $geometry: {\n              type: 'Point',\n              coordinates: [location.longitude, location.latitude]\n            },\n            $maxDistance: maxDistance\n          }\n        }\n      }).limit(10);\n\n      return nearbyPrizes.map(prize => ({\n        id: prize._id,\n        title: prize.name,\n        category: prize.category,\n        points: prize.points,\n        rarity: prize.rarity,\n        position: {\n          lat: prize.location.coordinates[1],\n          lng: prize.location.coordinates[0]\n        },\n        distance: calculateDistance(\n          { lat: location.latitude, lng: location.longitude },\n          { lat: prize.location.coordinates[1], lng: prize.location.coordinates[0] }\n        )}));\n    } catch (error) {\n      typedLogger.error('Error finding nearby prizes', { error });\n      // Fallback to default 100m radius on error\n      const nearbyPrizes = await Prize.find({\n        status: 'active',\n        'location.coordinates': {\n          $near: {\n            $geometry: {\n              type: 'Point',\n              coordinates: [location.longitude, location.latitude]\n            },\n            $maxDistance: 100\n          }\n        }\n      }).limit(10);\n\n      return nearbyPrizes.map(prize => ({\n        id: prize._id,\n        title: prize.name,\n        category: prize.category,\n        points: prize.points,\n        rarity: prize.rarity,\n        position: {\n          lat: prize.location.coordinates[1],\n          lng: prize.location.coordinates[0]\n        },\n        distance: calculateDistance(\n          { lat: location.latitude, lng: location.longitude },\n          { lat: prize.location.coordinates[1], lng: prize.location.coordinates[0] }\n        )}));\n    }\n  }\n\n  private static async generateDailyChallenges(userId: string) {\n    try {\n      // Read from ConfigService (real-time, cached, with hot-reload support)\n      const dailyChallenges = await configService.getConfigValue('custom.dailyChallenges');\n      \n      if (dailyChallenges && Array.isArray(dailyChallenges)) {\n        return dailyChallenges;\n      }\n\n      // Fallback to default challenges if not configured\n      return [\n        {\n          id: 'daily_claims',\n          title: 'Prize Hunter',\n          description: 'Claim 5 prizes today',\n          type: 'claims',\n          target: 5,\n          progress: 0,\n          reward: 100,\n          completed: false\n        },\n        {\n          id: 'distance_walker',\n          title: 'Explorer',\n          description: 'Walk 2km while playing',\n          type: 'distance',\n          target: 2000, // meters\n          progress: 0,\n          reward: 75,\n          completed: false\n        },\n        {\n          id: 'category_variety',\n          title: 'Variety Seeker',\n          description: 'Claim prizes from 3 different categories',\n          type: 'categories',\n          target: 3,\n          progress: 0,\n          reward: 50,\n          completed: false\n        }\n      ];\n    } catch (error) {\n      typedLogger.error('Error generating daily challenges', { error: (error as any).message, userId });\n      // Return defaults on error\n      return [\n        {\n          id: 'daily_claims',\n          title: 'Prize Hunter',\n          description: 'Claim 5 prizes today',\n          type: 'claims',\n          target: 5,\n          progress: 0,\n          reward: 100,\n          completed: false\n        },\n        {\n          id: 'distance_walker',\n          title: 'Explorer',\n          description: 'Walk 2km while playing',\n          type: 'distance',\n          target: 2000,\n          progress: 0,\n          reward: 75,\n          completed: false\n        },\n        {\n          id: 'category_variety',\n          title: 'Variety Seeker',\n          description: 'Claim prizes from 3 different categories',\n          type: 'categories',\n          target: 3,\n          progress: 0,\n          reward: 50,\n          completed: false\n        }\n      ];\n    }\n  }\n\n  private static calculateSessionRewards(session: any) {\n    const rewards = {\n      basePoints: 0,\n      distanceBonus: 0,\n      timeBonus: 0,\n      discoveryBonus: 0,\n      total: 0};\n\n    // Base points for playing\n    rewards.basePoints = 10;\n\n    // Distance bonus (1 point per 100m)\n    rewards.distanceBonus = Math.floor(session.distanceTraveled / 100);\n\n    // Time bonus (1 point per minute, max 30)\n    rewards.timeBonus = Math.min(Math.floor(session.duration / 60), 30);\n\n    // Discovery bonus (5 points per prize found)\n    rewards.discoveryBonus = session.prizesFound * 5;\n\n    rewards.total = rewards.basePoints + rewards.distanceBonus + rewards.timeBonus + rewards.discoveryBonus;\n\n    return rewards;\n  }\n}\n\nexport default async function gameRoutes(fastify: FastifyInstance) {\n  // Start game session\n  fastify.post<{ Body: GameSessionData }>(\n    '/session/start',\n    {\n      preHandler: [authenticate],\n      schema: {\n        body: GameSessionSchema\n      }\n    }, async (request, reply) => {\n    try {\n      const result = await GameService.startGameSession(request.user.sub, request.body, {\n        ip: request.ip,\n        userAgent: (request.headers['user-agent'] as string) || undefined,\n      });\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      reply.code(400).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // End game session\n  fastify.post<{ Body: { sessionId: string } }>(\n    '/session/end',\n    {\n      preHandler: [authenticate],\n      schema: {\n        body: z.object({\n          sessionId: z.string()\n        })\n      }\n    }, async (request, reply) => {\n    try {\n      const result = await GameService.endGameSession(request.user.sub, request.body.sessionId);\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      reply.code(400).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Update location\n  fastify.post<{ Body: LocationUpdateData }>(\n    '/location/update',\n    {\n      preHandler: [authenticate],\n      schema: {\n        body: LocationUpdateSchema\n      }\n    }, async (request, reply) => {\n    try {\n      const result = await GameService.updateLocation(request.user.sub, request.body, {\n        ip: request.ip,\n        userAgent: (request.headers['user-agent'] as string) || undefined,\n      });\n      reply.send(result);\n    } catch (error) {\n      reply.code(400).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Get leaderboard\n  fastify.get<{ Querystring: { type?: 'points' | 'claims' | 'distance' | 'level'; limit?: string } }>(\n    '/leaderboard',\n    {\n      preHandler: [authenticate],\n      schema: {\n        querystring: z.object({\n          type: z.enum(['points', 'claims', 'distance', 'level']).default('points'),\n          limit: z.coerce.number().min(1).max(100).default(50)\n        })\n      }\n    }, async (request, reply) => {\n    try {\n      const result = await GameService.getLeaderboard(request.query.type, parseInt(request.query.limit || '50', 10));\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      reply.code(500).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Get map data for Unity\n  fastify.get<{ Querystring: { north: string; south: string; east: string; west: string } }>(\n    '/map/data',\n    {\n      preHandler: [authenticate],\n      schema: {\n        querystring: z.object({\n          north: z.coerce.number(),\n          south: z.coerce.number(),\n          east: z.coerce.number(),\n          west: z.coerce.number()\n        })\n      }\n    }, async (request, reply) => {\n    try {\n      const result = await GameService.getMapData(request.query, request.user.sub);\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      reply.code(500).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Use power-up\n  fastify.post<{ Body: PowerUpUsageData }>(\n    '/power-ups/use',\n    {\n      preHandler: [authenticate],\n      schema: {\n        body: PowerUpUsageSchema\n      }\n    }, async (request, reply) => {\n    try {\n      const result = await GameService.usePowerUp(request.user.sub, request.body);\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      reply.code(400).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Get daily challenges\n  fastify.get('/challenges/daily', {\n    preHandler: [authenticate]}, async (request, reply) => {\n    try {\n      const result = await GameService.getDailyChallenges(request.user.sub);\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      reply.code(500).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Complete challenge\n  fastify.post<{ Body: { challengeId: string } }>(\n    '/challenges/complete',\n    {\n      preHandler: [authenticate],\n      schema: {\n        body: z.object({\n          challengeId: z.string()\n        })\n      }\n    }, async (request, reply) => {\n    try {\n      const result = await GameService.completeChallenge(request.user.sub, request.body.challengeId);\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      reply.code(400).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Get inventory\n  fastify.get('/inventory', {\n    preHandler: [authenticate]}, async (request, reply) => {\n    try {\n      const result = await GameService.getInventory(request.user.sub);\n      reply.send(result);\n    } catch (error) {\n      reply.code(500).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Capture prize attempt - CRITICAL ENDPOINT FOR GAME FLOW\n  fastify.post<{ Body: z.infer<typeof CaptureAttemptSchema> }>(\n    '/capture/attempt',\n    {\n      preHandler: [authenticate],\n      schema: { body: CaptureAttemptSchema }\n    },\n    async (request, reply) => {\n      try {\n        const result = await CaptureService.attemptCapture(\n          request.user.sub,\n          request.body\n        );\n        reply.send({ success: true, data: result });\n      } catch (error) {\n        reply.code(400).send({ \n          success: false, \n          error: (error as any).message \n        });\n      }\n    }\n  );\n\n  // Validate capture location - for pre-validation checks\n  fastify.post<{ Body: z.infer<typeof CaptureValidationSchema> }>(\n    '/capture/validate',\n    {\n      preHandler: [authenticate],\n      schema: { body: CaptureValidationSchema }\n    },\n    async (request, reply) => {\n      try {\n        const result = await CaptureService.preValidateCapture(\n          request.user.sub,\n          request.body\n        );\n        reply.send({ success: true, data: result });\n      } catch (error) {\n        reply.code(400).send({ \n          success: false, \n          error: (error as any).message \n        });\n      }\n    }\n  );\n\n  // Unity client performance metrics endpoint\n  const UnityMetricsSchema = z.object({\n    sessionId: z.string(),\n    metrics: z.object({\n      frameRate: z.number().min(0).max(144),\n      networkLatency: z.number().min(0),\n      batteryUsage: z.number().min(0).max(100),\n      memoryUsage: z.number().min(0).optional(),\n      cpuUsage: z.number().min(0).max(100).optional(),\n      crashes: z.number().min(0).default(0),\n      loadTime: z.number().min(0).optional(),\n      arSessionStability: z.number().min(0).max(100).optional()\n    })\n  });\n\n  fastify.post<{ Body: z.infer<typeof UnityMetricsSchema> }>(\n    '/metrics/report',\n    {\n      preHandler: [authenticate],\n      schema: { body: UnityMetricsSchema }\n    },\n    async (request, reply) => {\n      try {\n        const { sessionId, metrics } = request.body;\n        const userId = request.user.sub;\n\n        // Get session to calculate derived metrics\n        const sessionKey = `session:${sessionId}`;\n        const sessionData = await redisClient.get(sessionKey);\n        \n        let sessionDuration = 0;\n        let distanceTraveled = 0;\n        let prizesFound = 0;\n        let prizesClaimed = 0;\n\n        if (sessionData) {\n          const session = JSON.parse(sessionData);\n          if (session.userId === userId) {\n            const startTime = new Date(session.startTime);\n            sessionDuration = Math.floor((Date.now() - startTime.getTime()) / 1000);\n            distanceTraveled = session.distanceTraveled || 0;\n            prizesFound = session.prizesFound || 0;\n            prizesClaimed = session.claimsAttempted || 0;\n          }\n        }\n\n        // Record Unity game metrics\n        const gameMetrics: GameMetrics = {\n          sessionDuration,\n          prizesFound,\n          prizesClaimed,\n          distanceTraveled,\n          averageSpeed: sessionDuration > 0 ? distanceTraveled / sessionDuration : 0,\n          batteryUsage: metrics.batteryUsage,\n          networkLatency: metrics.networkLatency,\n          frameRate: metrics.frameRate,\n          crashes: metrics.crashes\n        };\n\n        await MetricsService.recordGameMetrics(userId, sessionId, gameMetrics);\n\n        // Record additional Unity-specific metrics\n        if (metrics.memoryUsage !== undefined) {\n          await MetricsService.recordMetric({\n            name: 'unity.memory.usage',\n            value: metrics.memoryUsage,\n            userId,\n            sessionId,\n            tags: { platform: 'unity', unit: 'mb' }\n          });\n        }\n\n        if (metrics.cpuUsage !== undefined) {\n          await MetricsService.recordMetric({\n            name: 'unity.cpu.usage',\n            value: metrics.cpuUsage,\n            userId,\n            sessionId,\n            tags: { platform: 'unity', unit: 'percent' }\n          });\n        }\n\n        if (metrics.arSessionStability !== undefined) {\n          await MetricsService.recordMetric({\n            name: 'unity.ar.stability',\n            value: metrics.arSessionStability,\n            userId,\n            sessionId,\n            tags: { platform: 'unity', unit: 'percent' }\n          });\n        }\n\n        if (metrics.loadTime !== undefined) {\n          await MetricsService.recordMetric({\n            name: 'unity.load.time',\n            value: metrics.loadTime,\n            userId,\n            sessionId,\n            tags: { platform: 'unity', unit: 'ms' }\n          });\n        }\n\n        typedLogger.info('Unity metrics received', { userId, sessionId, frameRate: metrics.frameRate });\n\n        reply.send({ success: true, message: 'Metrics recorded' });\n      } catch (error) {\n        typedLogger.error('Record Unity metrics error', { error: (error as any).message });\n        reply.code(400).send({ success: false, error: (error as any).message });\n      }\n    }\n  );\n\n  // Get real-time metrics for admin/monitoring\n  fastify.get('/metrics/realtime', {\n    preHandler: [authenticate]\n  }, async (request, reply) => {\n    try {\n      const metrics = await MetricsService.getRealTimeMetrics();\n      reply.send({ success: true, data: metrics });\n    } catch (error) {\n      reply.code(500).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Get Unity performance report for admin\n  fastify.get<{ Querystring: { start?: string; end?: string } }>(\n    '/metrics/unity-performance',\n    {\n      preHandler: [authenticate],\n      schema: {\n        querystring: z.object({\n          start: z.string().datetime().optional(),\n          end: z.string().datetime().optional()\n        })\n      }\n    },\n    async (request, reply) => {\n      try {\n        const now = new Date();\n        const start = request.query.start ? new Date(request.query.start) : new Date(now.getTime() - 24 * 60 * 60 * 1000);\n        const end = request.query.end ? new Date(request.query.end) : now;\n\n        const metrics = await MetricsService.getUnityPerformanceMetrics({ start, end });\n        reply.send({ success: true, data: metrics });\n      } catch (error) {\n        reply.code(500).send({ success: false, error: (error as any).message });\n      }\n    }\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\game\\routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\gamification\\index.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'User' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":14},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":25,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":25,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1057,1060],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1057,1060],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":47,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1807,1810],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1807,1810],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":87,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":87,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2786,2789],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2786,2789],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":110,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":110,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3451,3454],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3451,3454],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":136,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":136,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4216,4219],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4216,4219],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":158,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":158,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4860,4863],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4860,4863],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'achievementSchema' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":165,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":165,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'updateAchievementSchema' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":184,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":184,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'achievementParamsSchema' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":203,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":203,"endColumn":30},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":214,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":214,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7489,7492],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7489,7492],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":231,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":231,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8128,8131],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8128,8131],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';\nimport { authenticate } from '@/middleware/auth';\nimport { z } from 'zod';\nimport AchievementService from '@/services/achievement';\nimport { Achievement } from '@/models/Achievement';\nimport { User } from '@/models/User';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { Types } from 'mongoose';\n\n// Define proper TypeScript interfaces\ninterface AchievementData {\n  name: string;\n  description: string;\n  icon: string;\n  category: 'explorer' | 'collector' | 'social' | 'master' | 'special';\n  trigger: 'PRIZE_CLAIMED' | 'LEVEL_UP' | 'REWARD_REDEEMED' | 'FRIEND_ADDED' | 'STREAK_MILESTONE' | 'DISTANCE_MILESTONE' | 'MANUAL';\n  condition: {\n    type: 'TOTAL_CLAIMS' | 'TOTAL_POINTS' | 'LEVEL_REACHED' | 'STREAK_DAYS' | 'CATEGORY_CLAIMS' | 'RARITY_CLAIMS' | 'DISTANCE_TRAVELED' | 'FRIENDS_COUNT' | 'REWARDS_REDEEMED';\n    target: number;\n    category?: string;\n    rarity?: string;\n  };\n  rewards: {\n    type: 'POINTS' | 'POWER_UP' | 'COSMETIC' | 'TITLE' | 'BADGE';\n    value: any;\n    description: string;\n  }[];\n  isActive: boolean;\n  isHidden: boolean;\n  order: number;\n}\n\ninterface UpdateAchievementData {\n  name?: string;\n  description?: string;\n  icon?: string;\n  category?: 'explorer' | 'collector' | 'social' | 'master' | 'special';\n  trigger?: 'PRIZE_CLAIMED' | 'LEVEL_UP' | 'REWARD_REDEEMED' | 'FRIEND_ADDED' | 'STREAK_MILESTONE' | 'DISTANCE_MILESTONE' | 'MANUAL';\n  condition?: {\n    type: 'TOTAL_CLAIMS' | 'TOTAL_POINTS' | 'LEVEL_REACHED' | 'STREAK_DAYS' | 'CATEGORY_CLAIMS' | 'RARITY_CLAIMS' | 'DISTANCE_TRAVELED' | 'FRIENDS_COUNT' | 'REWARDS_REDEEMED';\n    target: number;\n    category?: string;\n    rarity?: string;\n  };\n  rewards?: {\n    type: 'POINTS' | 'POWER_UP' | 'COSMETIC' | 'TITLE' | 'BADGE';\n    value: any;\n    description: string;\n  }[];\n  isActive?: boolean;\n  isHidden?: boolean;\n  order?: number;\n}\n\n/**\n * Gamification Service\n * Handles achievements, challenges, and other gamification mechanics\n */\nexport class GamificationService {\n  /**\n   * Get user achievements\n   */\n  static async getUserAchievements(userId: string) {\n    return await AchievementService.getUserAchievements(userId);\n  }\n\n  /**\n   * Get recently unlocked achievements\n   */\n  static async getRecentlyUnlocked(userId: string, limit: number = 10) {\n    return await AchievementService.getRecentlyUnlocked(userId, limit);\n  }\n\n  /**\n   * Get all achievements (admin)\n   */\n  static async getAllAchievements() {\n    try {\n      const achievements = await Achievement.find({})\n        .sort({ category: 1, order: 1 })\n        .lean();\n\n      return {\n        achievements,\n        total: achievements.length};\n    } catch (error) {\n      typedLogger.error('Get all achievements error', { error: (error as any).message });\n      throw error;\n    }\n  }\n\n  /**\n   * Create achievement (admin)\n   */\n  static async createAchievement(data: AchievementData, adminId: string) {\n    try {\n      const achievement = new Achievement({\n        ...data,\n        createdBy: new Types.ObjectId(adminId),\n        createdAt: new Date(),\n        updatedAt: new Date()});\n      await achievement.save();\n\n      typedLogger.info('Achievement created', { achievementId: achievement._id, name: achievement.name });\n\n      return {\n        success: true,\n        achievement: achievement.toJSON()};\n    } catch (error) {\n      typedLogger.error('Create achievement error', { error: (error as any).message, data });\n      throw error;\n    }\n  }\n\n  /**\n   * Update achievement (admin)\n   */\n  static async updateAchievement(achievementId: string, data: UpdateAchievementData) {\n    try {\n      const achievement = await Achievement.findByIdAndUpdate(\n        new Types.ObjectId(achievementId),\n        { ...data, updatedAt: new Date() },\n        { new: true, runValidators: true }\n      );\n\n      if (!achievement) {\n        throw new Error('ACHIEVEMENT_NOT_FOUND');\n      }\n\n      typedLogger.info('Achievement updated', { achievementId: achievement._id, name: achievement.name });\n\n      return {\n        success: true,\n        achievement: achievement.toJSON()};\n    } catch (error) {\n      typedLogger.error('Update achievement error', { error: (error as any).message, achievementId, data });\n      throw error;\n    }\n  }\n\n  /**\n   * Delete achievement (admin)\n   */\n  static async deleteAchievement(achievementId: string) {\n    try {\n      const achievement = await Achievement.findByIdAndDelete(new Types.ObjectId(achievementId));\n\n      if (!achievement) {\n        throw new Error('ACHIEVEMENT_NOT_FOUND');\n      }\n\n      typedLogger.info('Achievement deleted', { achievementId: achievement._id, name: achievement.name });\n\n      return {\n        success: true,\n        message: 'Achievement deleted'};\n    } catch (error) {\n      typedLogger.error('Delete achievement error', { error: (error as any).message, achievementId });\n      throw error;\n    }\n  }\n}\n\n// Validation schemas\nconst achievementSchema = z.object({\n  name: z.string().min(3).max(100),\n  description: z.string().min(10).max(500),\n  icon: z.string().url().optional().default(''),\n  category: z.enum(['explorer', 'collector', 'social', 'master', 'special']),\n  trigger: z.enum(['PRIZE_CLAIMED', 'LEVEL_UP', 'REWARD_REDEEMED', 'FRIEND_ADDED', 'STREAK_MILESTONE', 'DISTANCE_MILESTONE', 'MANUAL']),\n  condition: z.object({\n    type: z.enum(['TOTAL_CLAIMS', 'TOTAL_POINTS', 'LEVEL_REACHED', 'STREAK_DAYS', 'CATEGORY_CLAIMS', 'RARITY_CLAIMS', 'DISTANCE_TRAVELED', 'FRIENDS_COUNT', 'REWARDS_REDEEMED']),\n    target: z.number().min(1),\n    category: z.string().optional(),\n    rarity: z.string().optional()}),\n  rewards: z.array(z.object({\n    type: z.enum(['POINTS', 'POWER_UP', 'COSMETIC', 'TITLE', 'BADGE']),\n    value: z.any(),\n    description: z.string().min(1)})).min(1),\n  isActive: z.boolean().default(true),\n  isHidden: z.boolean().default(false),\n  order: z.number().default(0)});\n\nconst updateAchievementSchema = z.object({\n  name: z.string().min(3).max(100).optional(),\n  description: z.string().min(10).max(500).optional(),\n  icon: z.string().url().optional(),\n  category: z.enum(['explorer', 'collector', 'social', 'master', 'special']).optional(),\n  trigger: z.enum(['PRIZE_CLAIMED', 'LEVEL_UP', 'REWARD_REDEEMED', 'FRIEND_ADDED', 'STREAK_MILESTONE', 'DISTANCE_MILESTONE', 'MANUAL']).optional(),\n  condition: z.object({\n    type: z.enum(['TOTAL_CLAIMS', 'TOTAL_POINTS', 'LEVEL_REACHED', 'STREAK_DAYS', 'CATEGORY_CLAIMS', 'RARITY_CLAIMS', 'DISTANCE_TRAVELED', 'FRIENDS_COUNT', 'REWARDS_REDEEMED']),\n    target: z.number().min(1),\n    category: z.string().optional(),\n    rarity: z.string().optional()}).optional(),\n  rewards: z.array(z.object({\n    type: z.enum(['POINTS', 'POWER_UP', 'COSMETIC', 'TITLE', 'BADGE']),\n    value: z.any(),\n    description: z.string().min(1)})).optional(),\n  isActive: z.boolean().optional(),\n  isHidden: z.boolean().optional(),\n  order: z.number().optional()});\n\nconst achievementParamsSchema = z.object({\n  achievementId: z.string().regex(/^[0-9a-fA-F]{24}$/, \"Invalid achievement ID\")});\n\nexport default async function gamificationRoutes(fastify: FastifyInstance) {\n  // Get user achievements\n  fastify.get('/achievements', {\n    preHandler: [authenticate]}, async (request, reply) => {\n    try {\n      const result = await GamificationService.getUserAchievements(request.user.sub);\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      reply.code(500).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Get recently unlocked achievements\n  fastify.get('/achievements/recent', {\n    preHandler: [authenticate],\n    schema: {\n      querystring: z.object({\n        limit: z.coerce.number().min(1).max(50).default(10)})\n    }\n  }, async (request: FastifyRequest<{ Querystring: { limit?: number } }>, reply: FastifyReply) => {\n    try {\n      const limit = request.query.limit || 10;\n      const result = await GamificationService.getRecentlyUnlocked(request.user.sub, limit);\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      reply.code(500).send({ success: false, error: (error as any).message });\n    }\n  });\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\gamification\\routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\integration\\routes.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":49,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":49,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1793,1796],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1793,1796],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"prefer-const","severity":2,"message":"'mongoQuery' is never reassigned. Use 'const' instead.","line":55,"column":11,"nodeType":"Identifier","messageId":"useConst","endLine":55,"endColumn":26,"fix":{"range":[1964,1989],"text":"const mongoQuery: any = {};"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":55,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1980,1983],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1980,1983],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":75,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":75,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2726,2729],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2726,2729],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":148,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":148,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5279,5282],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5279,5282],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":156,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":156,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5448,5451],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5448,5451],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":195,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":195,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6946,6949],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6946,6949],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":196,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":196,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7003,7006],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7003,7006],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":265,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":265,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9259,9262],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9259,9262],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":273,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":273,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9439,9442],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9439,9442],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"prefer-const","severity":2,"message":"'filterQuery' is never reassigned. Use 'const' instead.","line":283,"column":11,"nodeType":"Identifier","messageId":"useConst","endLine":283,"endColumn":27,"fix":{"range":[9849,9936],"text":"const filterQuery: any = {\n        createdAt: { $gte: startDate, $lte: endDate }\n      };"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":283,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":283,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9866,9869],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9866,9869],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":326,"column":83,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":326,"endColumn":86,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11254,11257],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11254,11257],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'displayField' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":350,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":350,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":384,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":384,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13021,13024],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13021,13024],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":399,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":399,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13528,13531],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13528,13531],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":400,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":400,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13604,13607],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13604,13607],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":401,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":401,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13690,13693],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13690,13693],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":402,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":402,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13728,13731],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13728,13731],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":412,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":412,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14130,14133],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14130,14133],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":413,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":413,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14206,14209],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14206,14209],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":414,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":414,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14286,14289],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14286,14289],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":429,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":429,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14761,14764],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14761,14764],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":435,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":435,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14909,14912],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14909,14912],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":458,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":458,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15681,15684],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15681,15684],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":480,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":480,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16465,16468],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16465,16468],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":481,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":481,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16494,16497],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16494,16497],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'filterQuery' is defined but never used. Allowed unused args must match /^_/u.","line":497,"column":44,"nodeType":"Identifier","messageId":"unusedVar","endLine":497,"endColumn":60},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":497,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":497,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17089,17092],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17089,17092],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":505,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":505,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17292,17295],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17292,17295],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":518,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":518,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17694,17697],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17694,17697],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":519,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":519,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17737,17740],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17737,17740],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":520,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":520,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17782,17785],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17782,17785],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":521,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":521,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17818,17821],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17818,17821],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":524,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":524,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17896,17899],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17896,17899],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":535,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":535,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18247,18250],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18247,18250],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":538,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":538,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18327,18330],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18327,18330],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":539,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":539,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18360,18363],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18360,18363],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":540,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":540,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18396,18399],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18396,18399],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":541,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":541,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18449,18452],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18449,18452],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'filterQuery' is defined but never used. Allowed unused args must match /^_/u.","line":544,"column":79,"nodeType":"Identifier","messageId":"unusedVar","endLine":544,"endColumn":95},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":544,"column":92,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":544,"endColumn":95,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18580,18583],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18580,18583],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":581,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":581,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19893,19896],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19893,19896],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":594,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":594,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20261,20264],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20261,20264],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":713,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":713,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24670,24673],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24670,24673],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"prefer-const","severity":2,"message":"'query' is never reassigned. Use 'const' instead.","line":732,"column":11,"nodeType":"Identifier","messageId":"useConst","endLine":732,"endColumn":21,"fix":{"range":[25196,25232],"text":"const query: any = { isActive: true };"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":732,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":732,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25207,25210],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25207,25210],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":762,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":762,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26152,26155],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26152,26155],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":763,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":763,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26197,26200],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26197,26200],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":764,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":764,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26243,26246],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26243,26246],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":782,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":782,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26709,26712],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26709,26712],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"prefer-const","severity":2,"message":"'query' is never reassigned. Use 'const' instead.","line":802,"column":11,"nodeType":"Identifier","messageId":"useConst","endLine":802,"endColumn":21,"fix":{"range":[27261,27372],"text":"const query: any = {\n        isActive: true,\n        stockAvailable: { $gt: 0 }  // Only available items\n      };"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":802,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":802,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[27272,27275],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[27272,27275],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":830,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":830,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28241,28244],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28241,28244],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":831,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":831,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28286,28289],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28286,28289],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":832,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":832,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28332,28335],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28332,28335],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":887,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":887,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[30061,30064],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[30061,30064],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":888,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":888,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[30115,30118],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[30115,30118],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":58,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":4,"fixableWarningCount":0,"source":"import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';\nimport { authenticate } from '@/middleware/auth';\nimport { z } from 'zod';\nimport { User } from '@/models/User';\nimport { Prize } from '@/models/Prize';\nimport { Claim } from '@/models/Claim';\nimport { Partner } from '@/models/Partner';\nimport { Reward } from '@/models/Reward';\nimport { Redemption } from '@/models/Redemption';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { redisClient } from '@/config/redis';\nimport { normalizeError } from '@/utils/api-errors';\n\n/**\n * Integration-specific endpoints for React Admin Panel and Unity Game\n * These endpoints are optimized for frontend integration with proper data formatting\n */\n\n// Schemas for integration endpoints\nconst ReactTableQuerySchema = z.object({\n  page: z.coerce.number().min(1).default(1),\n  limit: z.coerce.number().min(1).max(100).default(20),\n  sortBy: z.string().optional(),\n  sortOrder: z.enum(['asc', 'desc']).default('desc'),\n  search: z.string().optional(),\n  filters: z.string().optional(), // JSON string of filters\n});\n\nconst UnityMapBoundsSchema = z.object({\n  centerLat: z.coerce.number().min(-90).max(90),\n  centerLng: z.coerce.number().min(-180).max(180),\n  radiusKm: z.coerce.number().min(0.1).max(50).default(5),\n  maxPrizes: z.coerce.number().min(1).max(500).default(100)});\n\nconst ReactDashboardFiltersSchema = z.object({\n  dateRange: z.object({\n    start: z.string().datetime(),\n    end: z.string().datetime()}).optional(),\n  city: z.string().optional(),\n  governorate: z.string().optional(),\n  category: z.string().optional()});\n\nexport class IntegrationService {\n  private static redis = redisClient;\n\n  /**\n   * Get React-optimized user data with pagination and filtering\n   */\n  static async getReactUsersTable(query: any) {\n    try {\n      const { page, limit, sortBy = 'createdAt', sortOrder, search, filters } = query;\n      const skip = (page - 1) * limit;\n\n      // Build query\n      let mongoQuery: any = {};\n      \n      if (search) {\n        mongoQuery.$or = [\n          { displayName: { $regex: search, $options: 'i' } },\n          { email: { $regex: search, $options: 'i' } }];\n      }\n\n      if (filters) {\n        const parsedFilters = JSON.parse(filters);\n        if (parsedFilters.status) {\n          if (parsedFilters.status === 'active') mongoQuery.isActive = true;\n          if (parsedFilters.status === 'banned') mongoQuery.isBanned = true;\n          if (parsedFilters.status === 'inactive') mongoQuery.isActive = false;\n        }\n        if (parsedFilters.role) mongoQuery.role = parsedFilters.role;\n        if (parsedFilters.city) mongoQuery['location.city'] = parsedFilters.city;\n      }\n\n      // Build sort\n      const sortObj: any = {};\n      sortObj[sortBy] = sortOrder === 'asc' ? 1 : -1;\n\n      const [users, total] = await Promise.all([\n        User.find(mongoQuery)\n          .select('email displayName role level points isBanned lastActive createdAt location stats')\n          .sort(sortObj)\n          .skip(skip)\n          .limit(limit)\n          .lean(),\n        User.countDocuments(mongoQuery)]);\n\n      // Bulk fetch claim stats for all users to avoid N+1 queries\n      const userIds = users.map(user => user._id);\n      const claimStats = await Claim.aggregate([\n        {\n          $match: {\n            userId: { $in: userIds }\n          }\n        },\n        {\n          $group: {\n            _id: '$userId',\n            totalClaims: { $sum: 1 },\n            totalDistance: { $sum: '$distance' },\n            totalPointsFromClaims: { $sum: '$pointsAwarded' }\n          }\n        }\n      ]);\n\n      // Create a map for quick lookup of claim stats\n      const claimStatsMap = new Map();\n      claimStats.forEach(stat => {\n        claimStatsMap.set(stat._id.toString(), stat);\n      });\n\n      // Format for React Table\n      const formattedUsers = users.map(user => {\n        const userClaimStats = claimStatsMap.get(user._id.toString()) || { totalClaims: 0, totalDistance: 0 };\n\n        return {\n          id: user._id,\n          email: user.email,\n          displayName: user.displayName,\n          fullName: user.displayName,\n          role: user.role,\n          level: user.level,\n          points: user.points,\n          status: user.isBanned ? 'banned' :\n            (user.lastActive && new Date().getTime() - new Date(user.lastActive).getTime() < 7 * 24 * 60 * 60 * 1000 ? 'active' : 'inactive'),\n          isEmailVerified: !!user.email,  // Assuming email presence indicates verification\n          city: user.location?.city,\n          governorate: null,  // Governorate field does not exist in the schema\n          totalClaims: userClaimStats.totalClaims,\n          totalDistance: Math.round(userClaimStats.totalDistance / 1000 * 100) / 100, // km\n          lastActive: user.lastActive,\n          createdAt: user.createdAt,\n          avatar: user.avatar};\n      });\n\n      return {\n        data: formattedUsers,\n        pagination: {\n          page,\n          limit,\n          total,\n          totalPages: Math.ceil(total / limit)},\n        meta: {\n          sortBy,\n          sortOrder,\n          search,\n          filters: filters ? JSON.parse(filters) : null}};\n    } catch (error) {\n      typedLogger.error('Get React users table error', { error: (error as any).message, query });\n      throw error;\n    }\n  }\n\n  /**\n   * Get Unity-optimized map data with performance optimizations\n   */\n  static async getUnityMapData(query: any, userId: string) {\n    try {\n      const { centerLat, centerLng, radiusKm, maxPrizes } = query;\n      \n      // Calculate bounding box for efficient querying\n      const radiusInDegrees = radiusKm / 111.32; // Approximate conversion\n      const bounds = {\n        north: centerLat + radiusInDegrees,\n        south: centerLat - radiusInDegrees,\n        east: centerLng + (radiusInDegrees / Math.cos(centerLat * Math.PI / 180)),\n        west: centerLng - (radiusInDegrees / Math.cos(centerLat * Math.PI / 180))};\n\n      // Get active prizes within bounds\n      const prizes = await Prize.find({\n        status: 'active',\n        'location.coordinates': {\n          $geoWithin: {\n            $box: [[bounds.west, bounds.south], [bounds.east, bounds.north]]\n          }\n        }\n      })\n      .select('name category points rarity location expiresAt partnerId')\n      .limit(maxPrizes)\n      .lean();\n\n      // Get user's claimed prizes to exclude\n      const userClaims = await Claim.find({ userId }).select('prizeId').lean();\n      const claimedPrizeIds = new Set(userClaims.map(claim => claim.prizeId.toString()));\n\n      // Filter and format for Unity\n      const unityPrizes = prizes\n        .filter(prize => !claimedPrizeIds.has(prize._id.toString()))\n        .map(prize => ({\n          id: prize._id.toString(),\n          title: prize.name,\n          category: prize.category,\n          points: prize.points,\n          rarity: prize.rarity,\n          position: {\n            lat: (prize as any).location.coordinates[1],\n            lng: (prize as any).location.coordinates[0]},\n          expiresAt: prize.expiresAt?.toISOString(),\n          // Unity-specific optimizations\n          distanceFromCenter: this.calculateDistance(\n            centerLat, centerLng,\n            prize.location.coordinates[1], prize.location.coordinates[0]\n          )}))\n        .sort((a, b) => a.distanceFromCenter - b.distanceFromCenter); // Closest first\n\n      // Get nearby partners for context\n      const nearbyPartners = await Partner.find({\n        'locations.coordinates': {\n          $geoWithin: {\n            $centerSphere: [[centerLng, centerLat], radiusKm / 6378.1] // Earth radius in km\n          }\n        },\n        isActive: true})\n      .select('name logo locations')\n      .limit(20)\n      .lean();\n\n      const unityPartners = nearbyPartners.map(partner => ({\n        id: partner._id.toString(),\n        name: partner.name,\n        logo: partner.logo,\n        locations: partner.locations\n          .filter(loc => loc.isActive)\n          .map(loc => ({\n            id: loc._id.toString(),\n            name: loc.name,\n            position: {\n              lat: loc.coordinates[1],\n              lng: loc.coordinates[0]}}))}));\n\n      const markers = [\n        ...unityPrizes.map((p) => ({\n          id: p.id,\n          type: 'prize' as const,\n          title: p.title,\n          position: p.position,\n          category: p.category,\n          rarity: p.rarity,\n          points: p.points,\n        })),\n        ...unityPartners.flatMap((partner) =>\n          partner.locations.map((loc) => ({\n            id: loc.id,\n            type: 'partner' as const,\n            title: partner.name,\n            position: loc.position,\n            category: partner.id,\n            logo: partner.logo,\n          }))\n        ),\n      ];\n\n      return {\n        prizes: unityPrizes,\n        partners: unityPartners,\n        markers,\n        bounds,\n        center: { lat: centerLat, lng: centerLng },\n        radiusKm,\n        timestamp: new Date().toISOString(),\n        performance: {\n          totalPrizesInArea: prizes.length,\n          availablePrizes: unityPrizes.length,\n          claimedByUser: claimedPrizeIds.size}};\n    } catch (error) {\n      typedLogger.error('Get Unity map data error', { error: (error as any).message, query, userId });\n      throw error;\n    }\n  }\n\n  /**\n   * Get React dashboard analytics with real-time data\n   */\n  static async getReactDashboardAnalytics(filters: any = {}) {\n    try {\n      const now = new Date();\n      const { dateRange, city, governorate, category } = filters;\n      \n      // Default to last 7 days if no date range provided\n      const startDate = dateRange?.start ? new Date(dateRange.start) : new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\n      const endDate = dateRange?.end ? new Date(dateRange.end) : now;\n\n      // Build filter query\n      let filterQuery: any = {\n        createdAt: { $gte: startDate, $lte: endDate }\n      };\n\n      if (city) filterQuery.city = city;\n      if (governorate) filterQuery.governorate = governorate;\n      if (category) filterQuery.category = category;\n\n      // Parallel queries for dashboard data\n      const [\n        userStats,\n        claimStats,\n        prizeStats,\n        revenueStats,\n        geographicData,\n        categoryData,\n        timeSeriesData\n      ] = await Promise.all([\n        this.getUserAnalytics(filterQuery),\n        this.getClaimAnalytics(filterQuery),\n        this.getPrizeAnalytics(filterQuery),\n        this.getRevenueAnalytics(filterQuery),\n        this.getGeographicAnalytics(filterQuery),\n        this.getCategoryAnalytics(filterQuery),\n        this.getTimeSeriesAnalytics(startDate, endDate, filterQuery)]);\n\n      return {\n        summary: {\n          users: userStats,\n          claims: claimStats,\n          prizes: prizeStats,\n          revenue: revenueStats},\n        charts: {\n          geographic: geographicData,\n          categories: categoryData,\n          timeSeries: timeSeriesData},\n        filters: {\n          dateRange: { start: startDate, end: endDate },\n          city,\n          governorate,\n          category},\n        lastUpdated: now.toISOString()};\n    } catch (error) {\n      typedLogger.error('Get React dashboard analytics error', { error: (error as any).message, filters });\n      throw error;\n    }\n  }\n\n  /**\n   * Get Unity-optimized leaderboard with social features\n   */\n  static async getUnityLeaderboard(userId: string, type: string = 'points', limit: number = 50) {\n    try {\n      let sortField = 'points';\n      let displayField = 'points';\n      \n      switch (type) {\n        case 'claims':\n          sortField = 'stats.totalClaims';\n          displayField = 'totalClaims';\n          break;\n        case 'distance':\n          sortField = 'stats.totalDistance';\n          displayField = 'totalDistance';\n          break;\n        case 'level':\n          sortField = 'level';\n          displayField = 'level';\n          break;\n      }\n\n      // Get top players\n      const topPlayers = await User.find({ \n        isBanned: false,\n        isActive: true \n      })\n        .select('displayName level points stats.totalClaims stats.totalDistance avatar location.city')\n        .sort({ [sortField]: -1 })\n        .limit(limit)\n        .lean();\n\n      // Get current user's rank\n      const currentUser = await User.findById(userId).select(sortField).lean();\n      if (!currentUser) {\n        throw new Error('USER_NOT_FOUND');\n      }\n\n      // Get current user's value for comparison\n      const userValue = this.getSortFieldValue(currentUser, sortField);\n\n      const userRank = await User.countDocuments({\n        isBanned: false,\n        isActive: true,\n        [sortField]: { $gt: userValue }\n      }) + 1;\n\n      // Get user's friends/nearby players (if implemented)\n      const nearbyUser = await User.findById(userId).select('location.city level points stats').lean();\n      const nearbyPlayers = await User.find({\n        isBanned: false,\n        isActive: true,\n        'location.city': (nearbyUser as any)?.location?.city,\n        _id: { $ne: userId }\n      })\n        .select('displayName level points stats.totalClaims stats.totalDistance avatar')\n        .sort({ [sortField]: -1 })\n        .limit(10)\n        .lean();\n\n      // Format for Unity\n      const leaderboard = topPlayers.map((player, index) => ({\n        rank: index + 1,\n        userId: player._id.toString(),\n        displayName: player.displayName,\n        level: player.level,\n        points: player.points,\n        totalClaims: (player as any).stats?.totalClaims || 0,\n        totalDistance: Math.round(((player as any).stats?.totalDistance || 0) / 1000 * 100) / 100, // km\n        avatar: (player as any).avatar,\n        city: (player as any).location?.city,\n        isCurrentUser: player._id.toString() === userId,\n        value: this.getDisplayValue(player, type)}));\n\n      const nearbyLeaderboard = nearbyPlayers.map((player, index) => ({\n        rank: index + 1,\n        userId: player._id.toString(),\n        displayName: player.displayName,\n        level: player.level,\n        points: player.points,\n        totalClaims: (player as any).stats?.totalClaims || 0,\n        totalDistance: Math.round(((player as any).stats?.totalDistance || 0) / 1000 * 100) / 100,\n        avatar: (player as any).avatar,\n        isCurrentUser: false,\n        value: this.getDisplayValue(player, type)}));\n\n      return {\n        global: leaderboard,\n        nearby: nearbyLeaderboard,\n        currentUser: {\n          rank: userRank,\n          userId,\n          ...leaderboard.find(p => p.isCurrentUser) || {}},\n        type,\n        limit,\n        timestamp: new Date().toISOString()};\n    } catch (error) {\n      typedLogger.error('Get Unity leaderboard error', { error: (error as any).message, userId, type });\n      throw error;\n    }\n  }\n\n  // Helper methods for analytics\n  private static async getUserAnalytics(filterQuery: any) {\n    const [total, active, newUsers, growth] = await Promise.all([\n      User.countDocuments({ isBanned: false }),\n      User.countDocuments({ \n        isBanned: false, \n        lastActive: { $gte: new Date(Date.now() - 24 * 60 * 60 * 1000) }\n      }),\n      User.countDocuments(filterQuery),\n      User.countDocuments({\n        ...filterQuery,\n        createdAt: { \n          $gte: new Date(filterQuery.createdAt.$gte.getTime() - (filterQuery.createdAt.$lte.getTime() - filterQuery.createdAt.$gte.getTime())),\n          $lt: filterQuery.createdAt.$gte\n        }\n      })]);\n\n    return {\n      total,\n      active,\n      new: newUsers,\n      growth: growth > 0 ? ((newUsers - growth) / growth * 100) : 0};\n  }\n\n  private static async getClaimAnalytics(filterQuery: any) {\n    const claimQuery = { claimedAt: filterQuery.createdAt };\n    if (filterQuery.city) claimQuery['city'] = filterQuery.city;\n    if (filterQuery.category) claimQuery['category'] = filterQuery.category;\n\n    const [totalClaims, totalPoints, avgPoints] = await Promise.all([\n      Claim.countDocuments(claimQuery),\n      Claim.aggregate([\n        { $match: claimQuery },\n        { $group: { _id: null, total: { $sum: '$pointsAwarded' } } }\n      ]),\n      Claim.aggregate([\n        { $match: claimQuery },\n        { $group: { _id: null, avg: { $avg: '$pointsAwarded' } } }\n      ])]);\n\n    return {\n      total: totalClaims,\n      points: totalPoints[0]?.total || 0,\n      average: Math.round(avgPoints[0]?.avg || 0)};\n  }\n\n  private static async getPrizeAnalytics(filterQuery: any) {\n    const prizeQuery: any = { createdAt: filterQuery.createdAt };\n    if (filterQuery.city) prizeQuery.city = filterQuery.city;\n    if (filterQuery.category) prizeQuery.category = filterQuery.category;\n\n    const [total, active, claimed] = await Promise.all([\n      Prize.countDocuments(prizeQuery),\n      Prize.countDocuments({ ...prizeQuery, status: 'active' }),\n      Prize.countDocuments({ ...prizeQuery, currentClaims: { $gt: 0 } })]);\n\n    return {\n      total,\n      active,\n      claimed,\n      claimRate: total > 0 ? (claimed / total * 100) : 0};\n  }\n\n  private static async getRevenueAnalytics(filterQuery: any) {\n    // Placeholder for revenue analytics\n    return {\n      totalRedemptions: 0,\n      partnerPayouts: 0,\n      conversionRate: 0};\n  }\n\n  private static async getGeographicAnalytics(filterQuery: any) {\n    const geographic = await Claim.aggregate([\n      { $match: { claimedAt: filterQuery.createdAt } },\n      { \n        $group: {\n          _id: { city: '$city', governorate: '$governorate' },\n          claims: { $sum: 1 },\n          points: { $sum: '$pointsAwarded' }}\n      },\n      { $sort: { claims: -1 } },\n      { $limit: 20 }]);\n\n    return geographic.map(item => ({\n      city: (item as any)._id.city,\n      governorate: (item as any)._id.governorate,\n      claims: (item as any).claims,\n      points: (item as any).points}));\n  }\n\n  private static async getCategoryAnalytics(filterQuery: any) {\n    const categories = await Claim.aggregate([\n      { $match: { claimedAt: filterQuery.createdAt } },\n      { \n        $group: {\n          _id: '$category',\n          claims: { $sum: 1 },\n          points: { $sum: '$pointsAwarded' }}\n      },\n      { $sort: { claims: -1 } }]);\n\n    const total = categories.reduce((sum, cat) => sum + (cat as any).claims, 0);\n\n    return categories.map(item => ({\n      category: (item as any)._id,\n      claims: (item as any).claims,\n      points: (item as any).points,\n      percentage: total > 0 ? ((item as any).claims / total * 100) : 0}));\n  }\n\n  private static async getTimeSeriesAnalytics(startDate: Date, endDate: Date, filterQuery: any) {\n    const days = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24));\n    const timeSeries = [];\n\n    for (let i = 0; i < days; i++) {\n      const date = new Date(startDate.getTime() + i * 24 * 60 * 60 * 1000);\n      const nextDate = new Date(date.getTime() + 24 * 60 * 60 * 1000);\n\n      const [claims, users, sessions] = await Promise.all([\n        Claim.countDocuments({\n          claimedAt: { $gte: date, $lt: nextDate }}),\n        User.countDocuments({\n          createdAt: { $gte: date, $lt: nextDate }}),\n        // Sessions would need to be implemented\n        0]);\n\n      timeSeries.push({\n        date: date.toISOString().split('T')[0],\n        claims,\n        users,\n        sessions});\n    }\n\n    return timeSeries;\n  }\n\n  private static calculateDistance(lat1: number, lng1: number, lat2: number, lng2: number): number {\n    const R = 6371; // Earth's radius in km\n    const dLat = (lat2 - lat1) * Math.PI / 180;\n    const dLng = (lng2 - lng1) * Math.PI / 180;\n    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +\n              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n              Math.sin(dLng/2) * Math.sin(dLng/2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n    return R * c;\n  }\n\n  private static getDisplayValue(player: any, type: string): number {\n    switch (type) {\n      case 'claims':\n        return player.stats?.totalClaims || 0;\n      case 'distance':\n        return Math.round((player.stats?.totalDistance || 0) / 1000 * 100) / 100;\n      case 'level':\n        return player.level;\n      default:\n        return player.points;\n    }\n  }\n\n  private static getSortFieldValue(user: any, sortField: string): number {\n    if (sortField === 'level') {\n      return user.level;\n    } else if (sortField === 'points') {\n      return user.points;\n    } else if (sortField === 'stats.totalClaims') {\n      return user.stats?.totalClaims || 0;\n    } else if (sortField === 'stats.totalDistance') {\n      return user.stats?.totalDistance || 0;\n    } else {\n      // Default to points if unknown field\n      return user.points;\n    }\n  }\n}\n\nexport default async function integrationRoutes(fastify: FastifyInstance) {\n  // React Admin Panel Endpoints\n  \n  // Get React-optimized users table\n  fastify.get('/react/users', {\n    preHandler: [authenticate],\n    schema: {\n      querystring: ReactTableQuerySchema\n    }\n  }, async (request: FastifyRequest<{ Querystring: z.infer<typeof ReactTableQuerySchema> }>, reply) => {\n    try {\n      const result = await IntegrationService.getReactUsersTable(request.query);\n      reply.send({ success: true, ...result });\n    } catch (error) {\n      const normalized = normalizeError(error, 'React users fetch failed');\n      reply.code(500).send({ success: false, error: normalized.code, message: normalized.message });\n    }\n  });\n\n  // Get React dashboard analytics\n  fastify.get('/react/dashboard/analytics', {\n    preHandler: [authenticate],\n    schema: {\n      querystring: ReactDashboardFiltersSchema\n    }\n  }, async (request: FastifyRequest<{ Querystring: z.infer<typeof ReactDashboardFiltersSchema> }>, reply) => {\n    try {\n      const result = await IntegrationService.getReactDashboardAnalytics(request.query);\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      const normalized = normalizeError(error, 'React dashboard analytics failed');\n      reply.code(500).send({ success: false, error: normalized.code, message: normalized.message });\n    }\n  });\n\n  // Unity Game Endpoints\n\n  // Get Unity-optimized map data\n  fastify.get('/unity/map', {\n    preHandler: [authenticate],\n    schema: {\n      querystring: UnityMapBoundsSchema\n    }\n  }, async (request: FastifyRequest<{ Querystring: z.infer<typeof UnityMapBoundsSchema> }>, reply) => {\n    try {\n      const result = await IntegrationService.getUnityMapData(request.query, request.user.sub);\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      const normalized = normalizeError(error, 'Unity map fetch failed');\n      reply.code(500).send({ success: false, error: normalized.code, message: normalized.message });\n    }\n  });\n\n  // Get Unity leaderboard with social features\n  fastify.get('/unity/leaderboard', {\n    preHandler: [authenticate],\n    schema: {\n      querystring: z.object({\n        type: z.enum(['points', 'claims', 'distance', 'level']).default('points'),\n        limit: z.coerce.number().min(1).max(100).default(50)\n      })\n    }\n  }, async (request: FastifyRequest<{ Querystring: { type?: 'points' | 'claims' | 'distance' | 'level'; limit?: string } }>, reply: FastifyReply) => {\n    try {\n      const result = await IntegrationService.getUnityLeaderboard(\n        request.user.sub,\n        request.query.type || 'points',\n        request.query.limit ? parseInt(request.query.limit, 10) : 50\n      );\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      const normalized = normalizeError(error, 'Unity leaderboard failed');\n      reply.code(500).send({ success: false, error: normalized.code, message: normalized.message });\n    }\n  });\n\n  // Health check for integrations\n  fastify.get('/health', async (request: FastifyRequest, reply) => {\n    reply.send({\n      status: 'healthy',\n      integration: {\n        react: 'ready',\n        unity: 'ready'},\n      timestamp: new Date().toISOString()});\n  });\n\n  // Marketplace integration endpoints for React Admin Panel\n  // Get marketplace categories\n  fastify.get('/marketplace/categories', {\n    preHandler: [authenticate]}, async (request, reply) => {\n    try {\n      // Get unique categories from rewards\n      const categories = await Reward.distinct('category');\n\n      const formattedCategories = categories.map((cat, index) => ({\n        id: index + 1,\n        name: cat,\n        slug: cat.toLowerCase().replace(/\\s+/g, '-'),\n        count: 0 // Will be populated on request\n      }));\n\n      reply.send({ success: true, categories: formattedCategories });\n    } catch (error) {\n      reply.code(500).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Get marketplace items for admin panel\n  fastify.get('/admin/marketplace/items', {\n    preHandler: [authenticate]}, async (request, reply) => {\n    try {\n      const { page = '1', limit = '20', category, search } = request.query as {\n        page?: string;\n        limit?: string;\n        category?: string;\n        search?: string;\n      };\n\n      const pageNum = parseInt(page, 10) || 1;\n      const limitNum = parseInt(limit, 10) || 20;\n      const skip = (pageNum - 1) * limitNum;\n\n      let query: any = { isActive: true };\n      if (category) query.category = category;\n      if (search) {\n        query.$or = [\n          { name: { $regex: search, $options: 'i' } },\n          { description: { $regex: search, $options: 'i' } }\n        ];\n      }\n\n      const [items, total] = await Promise.all([\n        Reward.find(query)\n          .populate('partnerId', 'name logo')\n          .sort({ createdAt: -1 })\n          .skip(skip)\n          .limit(limitNum)\n          .lean(),\n        Reward.countDocuments(query)\n      ]);\n\n      const formattedItems = items.map(item => ({\n        id: item._id,\n        name: item.name,\n        description: item.description,\n        category: item.category,\n        pointsCost: item.pointsCost,\n        stockQuantity: item.stockQuantity,\n        stockAvailable: item.stockAvailable,\n        isActive: item.isActive,\n        isPopular: item.isPopular,\n        partner: item.partnerId ? {\n          id: (item as any).partnerId._id,\n          name: (item as any).partnerId.name,\n          logo: (item as any).partnerId.logo\n        } : null,\n        imageUrl: item.imageUrl,\n        createdAt: item.createdAt,\n        updatedAt: item.updatedAt\n      }));\n\n      reply.send({\n        success: true,\n        data: {\n          items: formattedItems,\n          total,\n          page: pageNum,\n          limit: limitNum,\n          totalPages: Math.ceil(total / limitNum)\n        }\n      });\n    } catch (error) {\n      reply.code(500).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Get marketplace items for Unity/Client\n  fastify.get('/marketplace', {\n    preHandler: [authenticate]}, async (request, reply) => {\n    try {\n      const { page = '1', limit = '20', category, minCost, maxCost } = request.query as {\n        page?: string;\n        limit?: string;\n        category?: string;\n        minCost?: string;\n        maxCost?: string;\n      };\n\n      const pageNum = parseInt(page, 10) || 1;\n      const limitNum = parseInt(limit, 10) || 20;\n      const skip = (pageNum - 1) * limitNum;\n\n      let query: any = {\n        isActive: true,\n        stockAvailable: { $gt: 0 }  // Only available items\n      };\n\n      if (category) query.category = category;\n      if (minCost) query.pointsCost = { ...query.pointsCost, $gte: parseInt(minCost, 10) };\n      if (maxCost) query.pointsCost = { ...query.pointsCost, $lte: parseInt(maxCost, 10) };\n\n      const [items, total] = await Promise.all([\n        Reward.find(query)\n          .populate('partnerId', 'name logo')\n          .sort({ isPopular: -1, createdAt: -1 })\n          .skip(skip)\n          .limit(limitNum)\n          .lean(),\n        Reward.countDocuments(query)\n      ]);\n\n      const formattedItems = items.map(item => ({\n        id: item._id,\n        title: item.name,\n        description: item.description,\n        category: item.category,\n        pointsCost: item.pointsCost,\n        stockAvailable: item.stockAvailable,\n        isFeatured: item.isPopular,\n        partner: item.partnerId ? {\n          id: (item as any).partnerId._id,\n          name: (item as any).partnerId.name,\n          logo: (item as any).partnerId.logo\n        } : null,\n        imageUrl: item.imageUrl,\n        createdAt: item.createdAt\n      }));\n\n      reply.send({\n        success: true,\n        data: {\n          items: formattedItems,\n          total,\n          page: pageNum,\n          limit: limitNum,\n          totalPages: Math.ceil(total / limitNum)\n        }\n      });\n    } catch (error) {\n      const normalized = normalizeError(error, 'Marketplace fetch failed');\n      reply.code(500).send({ success: false, error: normalized.code, message: normalized.message });\n    }\n  });\n\n  // Get user's marketplace history\n  fastify.get('/marketplace/history', {\n    preHandler: [authenticate],\n    schema: {\n      querystring: {\n        type: 'object',\n        properties: {\n          page: { type: 'integer', minimum: 1, default: 1 },\n          limit: { type: 'integer', minimum: 1, maximum: 100, default: 20 }\n        }\n      }\n    }\n  }, async (request, reply) => {\n    try {\n      const userId = request.user.sub;\n      const { page = 1, limit = 20 } = request.query as { page?: number; limit?: number; };\n\n      const pageNum = page;\n      const limitNum = limit;\n      const skip = (pageNum - 1) * limitNum;\n\n      const [history, total] = await Promise.all([\n        Redemption.find({ userId, 'metadata.source': 'marketplace' })\n          .populate('rewardId', 'name description category pointsCost imageUrl')\n          .populate('userId', 'displayName email')\n          .sort({ createdAt: -1 })\n          .skip(skip)\n          .limit(limitNum)\n          .lean(),\n        Redemption.countDocuments({ userId, 'metadata.source': 'marketplace' })\n      ]);\n\n      const formattedHistory = history.map(item => {\n        const populatedReward = (item as any).rewardId;\n        const populatedUser = (item as any).userId;\n\n        return {\n          id: item._id,\n          userId: item.userId,\n          user: populatedUser ? {\n            id: populatedUser._id,\n            displayName: populatedUser.displayName,\n            email: populatedUser.email\n          } : null,\n          rewardId: item.rewardId,\n          reward: populatedReward ? {\n            id: populatedReward._id,\n            name: populatedReward.name,\n            description: populatedReward.description,\n            category: populatedReward.category,\n            pointsCost: populatedReward.pointsCost,\n            imageUrl: populatedReward.imageUrl\n          } : null,\n          pointsSpent: item.pointsSpent,\n          status: item.status,\n          createdAt: item.createdAt,\n          redeemedAt: item.redeemedAt\n        };\n      });\n\n      reply.send({\n        success: true,\n        data: {\n          history: formattedHistory,\n          total,\n          page: pageNum,\n          limit: limitNum,\n          totalPages: Math.ceil(total / limitNum)\n        }\n      });\n    } catch (error) {\n      const normalized = normalizeError(error, 'Marketplace history failed');\n      reply.code(500).send({ success: false, error: normalized.code, message: normalized.message });\n    }\n  });\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\marketplace\\partner.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\marketplace\\routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'requireAdmin' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'requireRole' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":38,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":49},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'UserRole' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":67,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":75},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'PurchaseItemSchema' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":27,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":27,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'RedeemItemSchema' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":36,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":36,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'location' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":161,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":161,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'deviceInfo' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":247,"column":33,"nodeType":"Identifier","messageId":"unusedVar","endLine":247,"endColumn":43},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":431,"column":15,"nodeType":"BlockStatement","messageId":"unexpected","endLine":431,"endColumn":17,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[14815,14815],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'redemptionCode' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":560,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":560,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'location' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":560,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":560,"endColumn":39},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'location' is defined but never used. Allowed unused args must match /^_/u.","line":657,"column":41,"nodeType":"Identifier","messageId":"unusedVar","endLine":657,"endColumn":91},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":666,"column":17,"nodeType":"BlockStatement","messageId":"unexpected","endLine":666,"endColumn":19,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[24025,24025],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":680,"column":17,"nodeType":"BlockStatement","messageId":"unexpected","endLine":680,"endColumn":19,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[24490,24490],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'redemption' is defined but never used. Allowed unused args must match /^_/u.","line":793,"column":78,"nodeType":"Identifier","messageId":"unusedVar","endLine":793,"endColumn":101},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":981,"column":15,"nodeType":"BlockStatement","messageId":"unexpected","endLine":981,"endColumn":17,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[35067,35067],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":1003,"column":15,"nodeType":"BlockStatement","messageId":"unexpected","endLine":1003,"endColumn":17,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[36032,36032],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":16,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyInstance, FastifyRequest } from 'fastify';\nimport { requireOnline } from '@/middleware/require-online';\nimport { authenticate, requireAdmin, requireRole } from '@/middleware/auth';\nimport { z } from 'zod';\nimport { User } from '@/models/User';\nimport { Partner } from '@/models/Partner';\nimport { AuditLog } from '@/models/AuditLog';\nimport { Reward } from '@/models/Reward';\nimport { Redemption } from '@/models/Redemption';\nimport { Code } from '@/models/Code';\nimport { RewardsService } from '@/modules/rewards';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { redisClient } from '@/config/redis';\nimport mongoose, { Document, FilterQuery, Types } from 'mongoose';\nimport { Metadata, RedemptionStatus, IRedemption, IReward, IUser, UserRole } from '@/types';\nimport { broadcastAdminEvent } from '@/lib/websocket';\n\n/**\n * Marketplace Module\n * Core Feature 4: Utilisateur ├®change ÔåÆ D├®pense points contre r├®compenses\n * Complete marketplace system for exchanging points for real rewards\n */\n\n// Unified with core Reward/Redemption: legacy marketplace schemas removed.\n\n// Request schemas\nconst PurchaseItemSchema = z.object({\n  itemId: z.string(),\n  location: z.object({\n    latitude: z.number().min(-90).max(90),\n    longitude: z.number().min(-180).max(180)}).optional(),\n  deviceInfo: z.object({\n    platform: z.string(),\n    version: z.string()}).optional()});\n\nconst RedeemItemSchema = z.object({\n  redemptionCode: z.string(),\n  location: z.object({\n    latitude: z.number().min(-90).max(90),\n    longitude: z.number().min(-180).max(180)}),\n  verificationCode: z.string().optional()});\n\ntype RewardLocationMetadata = {\n  coordinates: { coordinates: [number, number] };\n  radius: number;\n};\n\ntype RewardMetadata = Metadata & {\n  maxPerUser?: number;\n  availableLocations?: RewardLocationMetadata[];\n  usageValidityDays?: number;\n  originalValue?: number;\n  howToRedeem?: string;\n  isSponsored?: boolean;\n};\n\ntype RewardWithPartner = IReward & { partnerId?: { name?: string; logo?: string } };\ntype PopulatedUser = Pick<IUser, '_id' | 'displayName' | 'email'>;\ntype PopulatedReward = Pick<IReward, '_id' | 'name' | 'pointsCost' | 'category' | 'imageUrl' | 'description'>;\ntype RedemptionCore = Omit<IRedemption, keyof Document>;\ntype RedemptionWithPopulated = Omit<RedemptionCore, 'userId' | 'rewardId'> & {\n  userId?: Types.ObjectId | PopulatedUser;\n  rewardId?: Types.ObjectId | PopulatedReward;\n};\ntype MarketplaceRedemption = RedemptionWithPopulated & {\n  isExpired: boolean;\n  daysRemaining: number;\n  canRedeem: boolean;\n};\ntype RedemptionResponse = { redemption?: { id?: string; metadata?: Metadata }; redemptionId?: string };\n\nconst isPopulatedUser = (value: Types.ObjectId | PopulatedUser | undefined): value is PopulatedUser =>\n  !!value && typeof value === 'object' && 'displayName' in value;\n\nconst isPopulatedReward = (value: Types.ObjectId | PopulatedReward | undefined): value is PopulatedReward =>\n  !!value && typeof value === 'object' && 'name' in value;\n\n// Enhanced marketplace item type for API responses\nexport interface MarketplaceItem {\n  id: string;\n  title: string;\n  description: string;\n  category: string;\n  pointsCost: number;\n  images: string[];\n  partnerName: string | null;\n  partnerLogo: string | null;\n  canAfford: boolean;\n  stockStatus: string;\n  savings: number | null;\n}\n\nexport interface MarketplaceResponse {\n  items: MarketplaceItem[];\n  categories: string[];\n  totalItems: number;\n  filters: {\n    priceRanges: { min: number; max: number; label: string }[];\n    categories: { name: string; count: number }[];\n    partners: { id: string; name?: string; count: number }[];\n  };\n  userInfo: {\n    currentPoints: number;\n    canAfford: number;\n    recentPurchases: number;\n  };\n}\n\n// Purchased item details for redemption\nexport interface PurchasedItemDetails {\n  title: string;\n  description: string;\n  partnerName?: string;\n  originalValue?: number;\n  currency: string;\n}\n\nexport interface PurchaseResult {\n  success: boolean;\n  redemption: {\n    id: string;\n    code: string;\n    qrCode: string;\n    item: PurchasedItemDetails;\n    validUntil: string;\n    howToRedeem: string;\n  };\n  userBalance: {\n    previousPoints: number;\n    pointsSpent: number;\n    remainingPoints: number;\n  };\n  message: string;\n}\n\nexport class MarketplaceService {\n  private static redis = redisClient;\n  private static FILTER_CACHE_KEY = 'marketplace:filters:v1';\n\n  /**\n   * Get marketplace items with filtering and user context\n   */\n  static async getMarketplace(\n    userId: string,\n    filters: {\n      category?: string;\n      minPoints?: number;\n      maxPoints?: number;\n      location?: { latitude: number; longitude: number };\n      search?: string;\n      featured?: boolean;\n      page?: number;\n      limit?: number;\n    } = {}\n  ): Promise<MarketplaceResponse> {\n    try {\n      const { \n        category, \n        minPoints, \n        maxPoints, \n        location, \n        search, \n        featured, \n        page = 1, \n        limit = 20 \n      } = filters;\n      const safeLimit = Math.min(100, Math.max(1, limit || 20));\n      const safePage = Math.max(1, page || 1);\n\n      // Build sponsored reward query\n      const query: FilterQuery<IReward> = { isActive: true, stockAvailable: { $gt: 0 }, 'metadata.isSponsored': true };\n      if (category) query.category = category;\n      if (minPoints !== undefined || maxPoints !== undefined) {\n        const pointsCostFilter: { $gte?: number; $lte?: number } = {};\n        if (minPoints !== undefined) pointsCostFilter.$gte = minPoints;\n        if (maxPoints !== undefined) pointsCostFilter.$lte = maxPoints;\n        query.pointsCost = pointsCostFilter;\n      }\n      if (featured) query.isPopular = true;\n      if (search) {\n        query.$text = { $search: search };\n      }\n\n      const [rewards, totalItems, user] = await Promise.all([\n        Reward.find(query)\n          .populate('partnerId', 'name logo')\n          .sort({ isPopular: -1, createdAt: -1 })\n          .skip((safePage - 1) * safeLimit)\n          .limit(safeLimit)\n          .lean<RewardWithPartner[]>(),\n        Reward.countDocuments(query),\n        User.findById(userId).select('points').lean<IUser>(),\n      ]);\n\n      const pointsAvailable = user?.points?.available || 0;\n      const enhancedItems = rewards.map((r) => {\n        const metadata = r.metadata as RewardMetadata | undefined;\n        const originalValue = typeof metadata?.originalValue === 'number' ? metadata.originalValue : undefined;\n        return {\n        id: r._id.toString(),\n        title: r.name,\n        description: r.description,\n        category: r.category,\n        pointsCost: r.pointsCost,\n        images: r.imageUrl ? [r.imageUrl] : [],\n        partnerName: (r.partnerId as { name?: string } | undefined)?.name || null,\n        partnerLogo: (r.partnerId as { logo?: string } | undefined)?.logo || null,\n        canAfford: pointsAvailable >= r.pointsCost,\n        stockStatus: this.getStockStatus(r.stockQuantity ?? -1, (r.stockQuantity ?? 0) - (r.stockAvailable ?? 0)),\n        savings: typeof originalValue === 'number' ? (originalValue - (r.pointsCost * 0.01)) : null,\n      };\n      });\n\n      const filters_data = await this.getFilterOptions();\n\n      // Extract unique categories using a Set\n      const categorySet = new Set<string>();\n      for (const r of rewards) {\n        categorySet.add(r.category);\n      }\n      const uniqueCategories = Array.from(categorySet);\n\n      return {\n        items: enhancedItems,\n        categories: uniqueCategories,\n        totalItems,\n        filters: filters_data,\n        userInfo: {\n          currentPoints: pointsAvailable,\n          canAfford: enhancedItems.filter(i => i.canAfford).length,\n          recentPurchases: 0 } };\n    } catch (error) {\n      typedLogger.error('Get marketplace error', { error: error instanceof Error ? error.message : String(error), userId, filters });\n      throw error;\n    }\n  }\n\n  /**\n   * Purchase/redeem an item with points\n   */\n  static async purchaseItem(userId: string, purchaseData: {\n    itemId: string;\n    location?: { latitude: number; longitude: number };\n    deviceInfo?: { platform: string; version: string };\n  }): Promise<PurchaseResult> {\n    try {\n      const { itemId, location, deviceInfo } = purchaseData;\n\n      // Get item and user\n      const [item, user] = await Promise.all([\n        Reward.findById(itemId).populate('partnerId', 'name logo'),\n        User.findById(userId)\n      ]);\n\n      if (!item || !item.isActive) {\n        throw new Error('ITEM_NOT_AVAILABLE');\n      }\n\n      if (!user) {\n        throw new Error('USER_NOT_FOUND');\n      }\n\n      // Check if user is guest\n      if (user.isGuest) {\n        throw new Error('GUEST_CANNOT_REDEEM');\n      }\n\n      // Validate user can afford item\n      const userAvailablePoints = user.points?.available || 0;\n      const itemCost = item.pointsCost || 0;\n      if (userAvailablePoints < itemCost) {\n        throw new Error('INSUFFICIENT_POINTS');\n      }\n\n      // Check stock availability - properly validate quantities exist\n      const itemStockQuantity = item.stockQuantity || 0;\n      const itemStockAvailable = item.stockAvailable || 0;\n      if (itemStockQuantity !== -1 && itemStockAvailable <= 0) {\n        throw new Error('OUT_OF_STOCK');\n      }\n\n      // Check user purchase limit - convert userId to ObjectId for query\n      const userRedemptions = await Redemption.countDocuments({\n        userId: new Types.ObjectId(userId),\n        rewardId: item._id,\n        status: { $in: ['PENDING', 'FULFILLED', 'CANCELLED'] }\n      });\n\n      const itemMetadata = item.metadata as RewardMetadata | undefined;\n      const maxPurchases = typeof itemMetadata?.maxPerUser === 'number' ? itemMetadata.maxPerUser : Number.MAX_SAFE_INTEGER;\n      if (userRedemptions >= maxPurchases) {\n        throw new Error('MAX_PURCHASES_EXCEEDED');\n      }\n\n      // Check location restrictions\n      const availableLocations = Array.isArray(itemMetadata?.availableLocations)\n        ? itemMetadata?.availableLocations\n        : [];\n      if (location && availableLocations.length > 0) {\n        const isLocationValid = await this.validateLocation(location, availableLocations);\n        if (!isLocationValid) {\n          throw new Error('LOCATION_NOT_SUPPORTED');\n        }\n      }\n\n      // Generate redemption code from the code pools first\n      const redemptionCode = await Code.reserveCode(item._id, new Types.ObjectId(userId));\n      if (!redemptionCode) {\n        throw new Error('FAILED_TO_GENERATE_REDEMPTION_CODE');\n      }\n\n      // Generate QR code using the redemption code from Code model\n      const qrCodeData = await this.generateQRCode(redemptionCode.code, item._id.toString());\n\n      // Calculate validity period\n      const usageValidityDays = typeof itemMetadata?.usageValidityDays === 'number' && Number.isFinite(itemMetadata.usageValidityDays)\n        ? itemMetadata.usageValidityDays\n        : 30;\n      const validUntil = new Date();\n      validUntil.setDate(validUntil.getDate() + usageValidityDays);\n\n      // Compute partner commission and settlement metadata - validate item.partnerId exists before use\n      let commissionRate = 0;\n      if (item.partnerId) {\n        try {\n          const partner = await Partner.findById(item.partnerId);\n          if (partner) {\n            commissionRate = (partner as { commissionRate?: number }).commissionRate || 0;\n          }\n        } catch {\n          // Default to 0 commission rate if partner lookup fails\n          commissionRate = 0;\n        }\n      }\n      const POINTS_TO_CURRENCY_RATE = 0.01; // TODO: move to config/settings\n      const itemPointsCost = item.pointsCost || 0;\n      const grossValue = +(itemPointsCost * POINTS_TO_CURRENCY_RATE).toFixed(2);\n      const platformShare = +(grossValue * (commissionRate / 100)).toFixed(2);\n      const partnerShare = +(grossValue - platformShare).toFixed(2);\n\n      // Create redemption record with proper typing\n      const redemption = new Redemption({\n        userId: new Types.ObjectId(userId),\n        rewardId: item._id,\n        pointsSpent: itemPointsCost,\n        status: 'PENDING',\n        codeId: redemptionCode._id,\n        redeemedAt: undefined,\n        idempotencyKey: `${userId}-${item._id.toString()}-${Date.now()}`,\n        metadata: {\n          source: 'marketplace',\n          commissionRateApplied: commissionRate,\n          grossValue,\n          partnerShare,\n          platformShare,\n          redemptionCode: redemptionCode.code\n        }\n      });\n\n      // Execute transaction with MongoDB session\n      const session = await mongoose.startSession();\n      session.startTransaction();\n\n      try {\n        // Save redemption with session\n        await redemption.save({ session });\n\n        // Update user points and stats with session (using properly typed values)\n        await User.findByIdAndUpdate(userId, {\n          $inc: {\n            'points.available': -itemPointsCost,\n            'points.spent': itemPointsCost,\n            'stats.totalRedemptions': 1,\n            'stats.totalPointsSpent': itemPointsCost},\n          $push: {\n            'purchaseHistory': {\n              rewardId: item._id,\n              pointsSpent: itemPointsCost,\n              purchasedAt: new Date()}\n          }\n        }, { session });\n\n        // Update item stock with session - use proper item ID instead of undefined var\n        await Reward.findByIdAndUpdate(item._id, {\n          $inc: {\n            stockReserved: 1,\n            stockAvailable: -1\n          }\n        }, { session });\n\n        // Commit transaction\n        await session.commitTransaction();\n      } catch (error) {\n        // Rollback transaction on error\n        await session.abortTransaction();\n        throw error;\n      } finally {\n        // End session\n        session.endSession();\n      }\n\n      // Log purchase\n      typedLogger.info('Item purchased successfully', {\n        userId,\n        itemId,\n        pointsSpent: item.pointsCost,\n        redemptionId: redemption._id.toString()});\n\n      // Audit log\n      try {\n        // Create audit log using the model directly since TypeScript doesn't recognize the static method\n        const auditLog = new AuditLog({\n          userId: new Types.ObjectId(userId),\n          action: 'marketplace_purchase',\n          resource: 'reward',\n          resourceId: item._id.toString(),\n          category: 'business',\n          severity: 'low',\n          success: true,\n          description: `Purchased ${item.name} for ${item.pointsCost} points`,\n          metadata: {\n            commissionRate,\n            grossValue,\n            partnerShare,\n            platformShare,\n            redemptionId: redemption._id.toString()\n          },\n          timestamp: new Date()\n        });\n        await auditLog.save();\n      } catch {}\n\n      // Track purchase analytics\n      await this.trackPurchaseAnalytics(userId, item, redemption);\n\n      // Trigger achievements (async, don't wait)\n      import('@/services/achievement').then(({ default: AchievementService }) => {\n        AchievementService.checkAchievements(userId, 'REWARD_REDEEMED', {\n          rewardId: item._id.toString(),\n          pointsSpent: item.pointsCost,\n          redemptionId: redemption._id.toString()}).catch(error => {\n          typedLogger.error('Check achievements error (REWARD_REDEEMED)', { error: error instanceof Error ? error.message : String(error), userId });\n        });\n      });\n\n      // Broadcast to admin dashboard for real-time updates\n      broadcastAdminEvent({\n        type: 'redemption_created',\n        data: {\n          redemptionId: redemption._id.toString(),\n          userId,\n          reward: {\n            id: item._id.toString(),\n            name: item.name,\n            category: item.category,\n            pointsCost: item.pointsCost\n          },\n          status: redemption.status,\n          timestamp: new Date()\n        }\n      });\n\n      return {\n        success: true,\n        redemption: {\n          id: redemption._id.toString(),\n          code: redemptionCode.code,  // Using the actual redemption code from the Code model\n          qrCode: qrCodeData,  // Including the QR code data\n          item: {\n            title: item.name,\n            description: item.description,\n            partnerName: (item.partnerId as { name?: string } | undefined)?.name,\n            originalValue: typeof itemMetadata?.originalValue === 'number' ? itemMetadata.originalValue : undefined,\n            currency: 'TND'},  // Default currency\n          validUntil: validUntil.toISOString(), // Using the calculated validity period\n          howToRedeem: typeof itemMetadata?.howToRedeem === 'string' ? itemMetadata.howToRedeem : 'Show this QR code to partner for redemption'},\n        userBalance: {\n          previousPoints: user.points?.available || 0,\n          pointsSpent: item.pointsCost,\n          remainingPoints: (user.points?.available || 0) - item.pointsCost},\n        message: `Successfully purchased ${item.name}! Show the QR code to a partner for redemption.`};\n    } catch (error) {\n      typedLogger.error('Purchase item error', { error: error instanceof Error ? error.message : String(error), userId, purchaseData });\n      throw error;\n    }\n  }\n\n  /**\n   * Get user's redemption history\n   */\n  static async getUserRedemptions(\n    userId: string,\n    filters: { status?: string; page?: number; limit?: number } = {}\n  ): Promise<{ redemptions: MarketplaceRedemption[]; totalCount: number; summary: Record<string, number> }> {\n    try {\n      const { status, page = 1, limit = 20 } = filters;\n\n      const query: FilterQuery<IRedemption> = { userId: new Types.ObjectId(userId) };\n      if (status) query.status = status;\n\n      // Query only marketplace redemptions\n      const marketplaceQuery = { ...query, 'metadata.source': 'marketplace' };\n\n      const [redemptions, totalCount] = await Promise.all([\n        Redemption.find(marketplaceQuery)\n          .populate('rewardId', 'name description category pointsCost imageUrl')\n          .sort({ createdAt: -1 })\n          .skip((page - 1) * limit)\n          .limit(limit)\n          .lean<RedemptionWithPopulated[]>(),\n        Redemption.countDocuments(marketplaceQuery)\n      ]);\n\n      // Enhance redemptions with status info\n      const enhancedRedemptions = redemptions.map((redemption): MarketplaceRedemption => {\n        // The redemption object should already have populated fields via populate() call\n\n        // Calculate expiration based on creation date + 30 days\n        const isExpired = redemption.createdAt ?\n                   new Date().getTime() - new Date(redemption.createdAt).getTime() > 30 * 24 * 60 * 60 * 1000 :\n                   false;  // 30 days validity\n\n        const daysRemaining = redemption.createdAt ?\n                      this.getDaysRemaining(new Date(new Date(redemption.createdAt).getTime() + 30 * 24 * 60 * 60 * 1000)) :\n                      30; // Default 30 days remaining\n\n        const canRedeem = redemption.status === RedemptionStatus.PENDING &&\n                   !isExpired; // Can redeem if not expired (within 30 days)\n\n        return {\n          ...redemption,\n          isExpired,\n          daysRemaining,\n          canRedeem,\n        };\n      });\n\n      return {\n        redemptions: enhancedRedemptions,\n        totalCount,\n        summary: {\n          total: totalCount,\n          pending: redemptions.filter(r => r.status === RedemptionStatus.PENDING).length,\n          confirmed: redemptions.filter(r => r.status === RedemptionStatus.FULFILLED).length,\n          redeemed: redemptions.filter(r => r.status === RedemptionStatus.FULFILLED).length,\n          expired: redemptions.filter(r =>\n            r.status === RedemptionStatus.CANCELLED\n          ).length}};\n    } catch (error) {\n      typedLogger.error('Get user redemptions error', { error: error instanceof Error ? error.message : String(error), userId, filters });\n      throw error;\n    }\n  }\n\n  /**\n   * Redeem an item at partner location\n   */\n  static async redeemItem(redemptionData: { redemptionCode: string; location: { latitude: number; longitude: number } }): Promise<{ success: boolean; message: string }> {\n    try {\n      const { redemptionCode, location } = redemptionData;\n\n      // Find redemption by code (this field doesn't exist in Redemption model, so we use id)\n      // The marketplace uses the Redemption model, but redemption codes are handled differently\n      // So we'll find by id or skip this method since it may be deprecated\n      throw new Error('METHOD_DEPRECATED: redemption codes are handled differently in the new system');\n    } catch (error) {\n      typedLogger.error('Redeem item error', { error: error instanceof Error ? error.message : String(error), redemptionData });\n      throw error;\n    }\n  }\n\n  /**\n   * Get marketplace analytics for admin\n   */\n  static async getMarketplaceAnalytics(timeframe: string = '30d'): Promise<Metadata> {\n    try {\n      const days = parseInt(timeframe.replace('d', ''));\n      const startDate = new Date();\n      startDate.setDate(startDate.getDate() - days);\n\n      const [\n        totalRedemptions,\n        totalPointsSpent,\n        topItems,\n        categoryStats,\n        revenueByPartner\n      ] = await Promise.all([\n        Redemption.countDocuments({ createdAt: { $gte: startDate } }),\n        Redemption.aggregate([\n          { $match: { createdAt: { $gte: startDate } } },\n          { $group: { _id: null, total: { $sum: '$pointsSpent' } } }\n        ]),\n        this.getTopItems(startDate),\n        this.getCategoryStats(startDate),\n        this.getRevenueByPartner(startDate)]);\n\n      return {\n        overview: {\n          totalRedemptions,\n          totalPointsSpent: totalPointsSpent[0]?.total || 0,\n          averagePointsPerRedemption: totalRedemptions > 0 ? \n            Math.round((totalPointsSpent[0]?.total || 0) / totalRedemptions) : 0},\n        topItems,\n        categoryStats,\n        revenueByPartner,\n        timeframe,\n        generatedAt: new Date().toISOString()};\n    } catch (error) {\n      typedLogger.error('Get marketplace analytics error', { error: error instanceof Error ? error.message : String(error), timeframe });\n      throw error;\n    }\n  }\n\n  // Private helper methods\n  private static async getUserPurchaseCount(userId: string): Promise<number> {\n    try {\n      const today = new Date();\n      today.setHours(0, 0, 0, 0);\n      \n      return await Redemption.countDocuments({\n        userId,\n        createdAt: { $gte: today }\n      });\n    } catch (error) {\n      return 0;\n    }\n  }\n\n  private static getTimeRemaining(validUntil: Date): string | null {\n    const now = new Date();\n    const diff = validUntil.getTime() - now.getTime();\n    \n    if (diff <= 0) return 'Expired';\n    \n    const days = Math.floor(diff / (1000 * 60 * 60 * 24));\n    const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));\n    \n    if (days > 0) return `${days} days`;\n    return `${hours} hours`;\n  }\n\n  private static getDaysRemaining(validUntil: Date): number {\n    const now = new Date();\n    const diff = validUntil.getTime() - now.getTime();\n    return Math.max(0, Math.floor(diff / (1000 * 60 * 60 * 24)));\n  }\n\n  private static getStockStatus(stock: number, totalRedemptions: number): string {\n    if (stock === -1) return 'unlimited';\n    \n    const remaining = stock - totalRedemptions;\n    if (remaining <= 0) return 'out_of_stock';\n    if (remaining <= 5) return 'low_stock';\n    return 'in_stock';\n  }\n\n  private static async getFilterOptions(location?: { latitude: number; longitude: number }): Promise<{ priceRanges: { min: number; max: number; label: string }[]; categories: { name: string; count: number }[]; partners: { id: string; name?: string; count: number }[] }> {\n    try {\n      // Try short-lived cache first\n      if (this.redis) {\n        try {\n          const cached = await this.redis.get(this.FILTER_CACHE_KEY);\n          if (cached) {\n            return JSON.parse(cached);\n          }\n        } catch {}\n      }\n\n      const [priceRanges, categories, partners] = await Promise.all([\n        this.getPriceRanges(),\n        this.getCategoryOptions(),\n        this.getPartnerOptions()]);\n\n      const payload = { priceRanges, categories, partners };\n\n      // Cache for a few minutes to reduce aggregation load\n      if (this.redis) {\n        try {\n          await this.redis.set(this.FILTER_CACHE_KEY, JSON.stringify(payload), 'EX', 300); // 5 minutes\n        } catch {}\n      }\n\n      return payload;\n    } catch (error) {\n      return { priceRanges: [], categories: [], partners: [] };\n    }\n  }\n\n  private static async getPriceRanges(): Promise<{ min: number; max: number; label: string }[]> {\n    return [\n      { min: 0, max: 100, label: 'Under 100 points' },\n      { min: 100, max: 500, label: '100-500 points' },\n      { min: 500, max: 1000, label: '500-1000 points' },\n      { min: 1000, max: 5000, label: '1000-5000 points' },\n      { min: 5000, max: 999999, label: '5000+ points' }];\n  }\n\n  private static async getCategoryOptions(): Promise<{ name: string; count: number }[]> {\n    try {\n      const categories = await Reward.aggregate([\n        { $match: { isActive: true, 'metadata.isSponsored': true } },\n        { $group: { _id: '$category', count: { $sum: 1 } } },\n        { $sort: { count: -1 } }\n      ]);\n\n      return categories.map(cat => ({\n        name: cat._id,\n        count: cat.count }));\n    } catch (error) {\n      return [];\n    }\n  }\n\n  private static async getPartnerOptions(): Promise<{ id: string; name?: string; count: number }[]> {\n    try {\n      const partners = await Reward.aggregate([\n        { $match: { isActive: true, 'metadata.isSponsored': true, partnerId: { $exists: true } } },\n        { $group: { _id: '$partnerId', count: { $sum: 1 } } },\n        { $sort: { count: -1 } },\n        { $limit: 20 }\n      ]);\n\n      return partners.map(p => ({ id: p._id, count: p.count }));\n    } catch (error) {\n      return [];\n    }\n  }\n\n  private static async validateLocation(\n    userLocation: { latitude: number; longitude: number },\n    availableLocations: { coordinates: { coordinates: [number, number] }; radius: number }[]\n  ): Promise<boolean> {\n    try {\n      for (const location of availableLocations) {\n        const distance = this.calculateDistance(\n          userLocation.latitude,\n          userLocation.longitude,\n          location.coordinates.coordinates[1],\n          location.coordinates.coordinates[0]\n        );\n\n        if (distance <= location.radius) {\n          return true;\n        }\n      }\n      return false;\n    } catch (error) {\n      return true; // Fail open\n    }\n  }\n\n  private static calculateDistance(lat1: number, lng1: number, lat2: number, lng2: number): number {\n    const R = 6371000; // Earth's radius in meters\n    const dLat = (lat2 - lat1) * Math.PI / 180;\n    const dLng = (lng2 - lng1) * Math.PI / 180;\n    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +\n              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n              Math.sin(dLng/2) * Math.sin(dLng/2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n    return R * c;\n  }\n\n  private static generateRedemptionCode(): string {\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n    let code = '';\n    for (let i = 0; i < 8; i++) {\n      code += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    return code;\n  }\n\n  private static generateVerificationCode(): string {\n    return Math.floor(100000 + Math.random() * 900000).toString(); // 6-digit code\n  }\n\n  private static async generateQRCode(redemptionCode: string, itemId: string): Promise<string> {\n    try {\n      // In a real implementation, use a QR code library like 'qrcode'\n      const qrData = {\n        type: 'yallacatch_redemption',\n        code: redemptionCode,\n        itemId: itemId.toString(),\n        timestamp: Date.now()};\n      \n      // Return base64 encoded QR code data\n      return Buffer.from(JSON.stringify(qrData)).toString('base64');\n    } catch (error) {\n      typedLogger.error('Generate QR code error', { error: error instanceof Error ? error.message : String(error), redemptionCode });\n      return '';\n    }\n  }\n\n  private static async trackPurchaseAnalytics(userId: string, item: IReward, redemption: IRedemption): Promise<void> {\n    try {\n      const analyticsKey = `marketplace_analytics:${new Date().toISOString().split('T')[0]}`;\n      await this.redis.hincrby(analyticsKey, 'total_purchases', 1);\n      await this.redis.hincrby(analyticsKey, `category_${item.category}`, 1);\n      await this.redis.hincrby(analyticsKey, 'total_points_spent', item.pointsCost);\n      await this.redis.expire(analyticsKey, 30 * 24 * 60 * 60); // 30 days\n    } catch (error) {\n      typedLogger.error('Track purchase analytics error', { error: error instanceof Error ? error.message : String(error), userId });\n    }\n  }\n\n  private static async getTopItems(startDate: Date): Promise<{ title: string; partnerName: string; count: number; totalPoints: number }[]> {\n    try {\n      return await Redemption.aggregate([\n        { $match: { createdAt: { $gte: startDate }, 'metadata.source': 'marketplace' } },\n        { $group: {\n          _id: '$rewardId',\n          count: { $sum: 1 },\n          totalPoints: { $sum: '$pointsSpent' }\n        }},\n        { $lookup: {\n          from: 'rewards',\n          localField: '_id',\n          foreignField: '_id',\n          as: 'item'\n        }},\n        { $unwind: '$item' },\n        { $sort: { count: -1 } },\n        { $limit: 10 },\n        { $project: {\n          title: '$item.name',\n          partnerName: '$item.partnerId',\n          count: 1,\n          totalPoints: 1\n        }}\n      ]);\n    } catch (error) {\n      return [];\n    }\n  }\n\n  private static async getCategoryStats(startDate: Date): Promise<{ _id: string; count: number; totalPoints: number }[]> {\n    try {\n      return await Redemption.aggregate([\n        { $match: { createdAt: { $gte: startDate }, 'metadata.source': 'marketplace' } },\n        { $lookup: {\n          from: 'rewards',\n          localField: 'rewardId',\n          foreignField: '_id',\n          as: 'item'\n        }},\n        { $unwind: '$item' },\n        { $group: {\n          _id: '$item.category',\n          count: { $sum: 1 },\n          totalPoints: { $sum: '$pointsSpent' }\n        }},\n        { $sort: { count: -1 } }\n      ]);\n    } catch (error) {\n      return [];\n    }\n  }\n\n  private static async getRevenueByPartner(startDate: Date): Promise<{ _id: string; count: number; totalPoints: number }[]> {\n    try {\n      return await Redemption.aggregate([\n        { $match: { createdAt: { $gte: startDate }, 'metadata.source': 'marketplace' } },\n        { $lookup: {\n          from: 'rewards',\n          localField: 'rewardId',\n          foreignField: '_id',\n          as: 'item'\n        }},\n        { $unwind: '$item' },\n        { $group: {\n          _id: '$item.partnerId',\n          count: { $sum: 1 },\n          totalPoints: { $sum: '$pointsSpent' }\n        }},\n        { $sort: { totalPoints: -1 } },\n        { $limit: 10 }\n      ]);\n    } catch (error) {\n      return [];\n    }\n  }\n}\n\nexport default async function marketplaceRoutes(fastify: FastifyInstance) {\n  // Get marketplace items\n  fastify.get('/', {\n    preHandler: [authenticate],\n    schema: {\n      querystring: z.object({\n        category: z.string().optional(),\n        minPoints: z.number().optional(),\n        maxPoints: z.number().optional(),\n        latitude: z.number().optional(),\n        longitude: z.number().optional(),\n        search: z.string().optional(),\n        featured: z.boolean().optional(),\n        page: z.number().int().min(1).default(1),\n        limit: z.number().int().min(1).max(100).default(20)\n      })\n    }\n  }, async (request: FastifyRequest<{ Querystring: {\n    category?: string;\n    minPoints?: string;\n    maxPoints?: string;\n    latitude?: string;\n    longitude?: string;\n    search?: string;\n    featured?: string;\n    page?: string;\n    limit?: string;\n  } }>, reply) => {\n    try {\n      const query = request.query;\n      const safePage = Math.max(1, parseInt(query.page) || 1);\n      const safeLimit = Math.min(100, Math.max(1, parseInt(query.limit) || 20));\n      const location = query.latitude && query.longitude ? {\n        latitude: parseFloat(query.latitude),\n        longitude: parseFloat(query.longitude)} : undefined;\n\n      const result = await MarketplaceService.getMarketplace((request as FastifyRequest & { user: { sub: string } }).user.sub, {\n        category: query.category,\n        minPoints: query.minPoints ? parseInt(query.minPoints) : undefined,\n        maxPoints: query.maxPoints ? parseInt(query.maxPoints) : undefined,\n        search: query.search,\n        featured: query.featured ? query.featured === 'true' : undefined,\n        page: safePage,\n        limit: safeLimit,\n        location});\n      reply.header('Cache-Control', 'private, max-age=120').send({ success: true, data: result });\n    } catch (error) {\n      reply.code(500).send({ success: false, error: error instanceof Error ? error.message : String(error) });\n    }\n  });\n\n  // Purchase item (requires online connection)\n  fastify.post('/purchase', {\n    preHandler: [authenticate, requireOnline],\n    schema: {\n      body: z.object({\n        rewardId: z.string().optional(),\n        itemId: z.string().optional(), // backward compatibility\n        idempotencyKey: z.string().optional(),\n        location: z.object({\n          latitude: z.number().min(-90).max(90),\n          longitude: z.number().min(-180).max(180)\n        }).optional(),\n        deviceInfo: z.object({\n          platform: z.string(),\n          version: z.string()\n        }).optional()\n      })\n    }\n  }, async (request: FastifyRequest<{ Body: { rewardId?: string; itemId?: string; idempotencyKey?: string; location?: { latitude: number; longitude: number }; deviceInfo?: { platform: string; version: string } } }> & { user: { sub: string } }, reply) => {\n    try {\n      const body = request.body || {};\n      const rewardId = body.rewardId || body.itemId; // backward compatibility\n      if (!rewardId) {\n        return reply.code(400).send({ success: false, error: 'REWARD_ID_REQUIRED' });\n      }\n\n      const reward = await Reward.findById(rewardId);\n      if (!reward || !reward.isActive) {\n        return reply.code(404).send({ success: false, error: 'REWARD_NOT_AVAILABLE' });\n      }\n\n      // Idempotency\n      const idempotencyKey = body.idempotencyKey || `marketplace-${request.user.sub}-${rewardId}-${Date.now()}`;\n\n      // Perform core redemption\n      const res = await RewardsService.redeemReward(request.user.sub, {\n        rewardId: rewardId.toString(),\n        idempotencyKey,\n      });\n\n      // Compute commission and settlement metadata\n      let commissionRate = 0;\n      try {\n        if (reward.partnerId) {\n          const partner = await Partner.findById(reward.partnerId);\n          commissionRate = (partner as { commissionRate?: number } | null)?.commissionRate ?? 0;\n        }\n      } catch {}\n      const POINTS_TO_CURRENCY_RATE = 0.01; // TODO: move to Settings\n      const grossValue = +(reward.pointsCost * POINTS_TO_CURRENCY_RATE).toFixed(2);\n      const platformShare = +(grossValue * (commissionRate / 100)).toFixed(2);\n      const partnerShare = +(grossValue - platformShare).toFixed(2);\n\n      try {\n        const redemptionResponse = res as RedemptionResponse;\n        await Redemption.findByIdAndUpdate(new Types.ObjectId(redemptionResponse?.redemption?.id || redemptionResponse?.redemptionId), {\n          $set: {\n            metadata: {\n              ...(redemptionResponse?.redemption?.metadata || {}),\n              source: 'marketplace',\n              partnerId: reward.partnerId || null,\n              commissionRateApplied: commissionRate,\n              pointsToCurrencyRate: POINTS_TO_CURRENCY_RATE,\n              grossValue,\n              partnerShare,\n              platformShare,\n            },\n          },\n        });\n      } catch {}\n\n      return reply.send({ success: true, data: res });\n    } catch (error) {\n      return reply.code(400).send({ success: false, error: error instanceof Error ? error.message : String(error) });\n    }\n  });\n\n  // Get user redemptions\n  fastify.get('/redemptions', {\n    preHandler: [authenticate],\n    schema: {\n      querystring: z.object({\n        status: z.string().optional(),\n        page: z.number().int().min(1).default(1),\n        limit: z.number().int().min(1).max(100).default(20)\n      })\n    }\n  }, async (request: FastifyRequest<{ Querystring: { status?: string; page?: string; limit?: string } }> & { user: { sub: string } }, reply) => {\n    try {\n      const q = request.query || {};\n      const page = Math.max(1, parseInt(q.page || '1') || 1);\n      const limit = Math.min(100, Math.max(1, parseInt(q.limit || '20') || 20));\n      const skip = (page - 1) * limit;\n      const query: FilterQuery<IRedemption> = { userId: new Types.ObjectId(request.user.sub), 'metadata.source': 'marketplace' };\n      if (q.status && q.status !== 'all') query.status = q.status;\n\n      const [items, total] = await Promise.all([\n        Redemption.find(query)\n          .populate('rewardId', 'name pointsCost category imageUrl')\n          .sort({ createdAt: -1 })\n          .skip(skip)\n          .limit(limit)\n          .lean(),\n        Redemption.countDocuments(query),\n      ]);\n\n      reply.send({ success: true, data: { redemptions: items, total, page, limit, hasMore: skip + limit < total } });\n    } catch (error) {\n      reply.code(500).send({ success: false, error: error instanceof Error ? error.message : String(error) });\n    }\n  });\n\n  // Redeem item (for partners)\n  // Deprecated: partner redeem endpoint; use /rewards/qr-scan instead\n  fastify.post('/redeem', {}, async (request, reply) => {\n    return reply.code(410).send({ success: false, error: 'ENDPOINT_DEPRECATED', message: 'Use /api/v1/rewards/qr-scan' });\n  });\n\n  // Get marketplace analytics (admin only)\n  fastify.get('/analytics', {\n    preHandler: [authenticate],\n    schema: {\n      querystring: z.object({\n        timeframe: z.string().default('30d')\n      })\n    }\n  }, async (request: FastifyRequest<{ Querystring: { timeframe?: string } }>, reply) => {\n    try {\n      const days = parseInt((request.query?.timeframe || '30d').replace('d', '')) || 30;\n      const startDate = new Date();\n      startDate.setDate(startDate.getDate() - days);\n\n      const pipeline = [\n        { $match: { createdAt: { $gte: startDate }, 'metadata.source': 'marketplace' } },\n        { $group: { _id: null, total: { $sum: 1 }, pointsSpent: { $sum: '$pointsSpent' } } },\n      ];\n      const [agg] = await Redemption.aggregate(pipeline);\n      reply.send({ success: true, data: { totalRedemptions: agg?.total || 0, totalPointsSpent: agg?.pointsSpent || 0, timeframe: `${days}d` } });\n    } catch (error) {\n      reply.code(500).send({ success: false, error: error instanceof Error ? error.message : String(error) });\n    }\n  });\n\n  // Ô£¿ NEW: Get marketplace categories (for admin panel)\n  fastify.get('/categories', {\n    preHandler: [authenticate]}, async (request, reply) => {\n    try {\n      const categories = await Reward.aggregate([\n        { $match: { isActive: true, metadata: { $exists: true }, 'metadata.isSponsored': true } },\n        { \n          $group: { \n            _id: '$category', \n            count: { $sum: 1 },\n            description: { $first: '$categoryDescription' }\n          }\n        },\n        { $sort: { count: -1 }}\n      ]);\n\n      const formattedCategories = categories.map(cat => ({\n        id: cat._id,\n        name: cat._id,\n        slug: cat._id.toLowerCase().replace(/\\s+/g, '-'),\n        rewardCount: cat.count,\n        description: cat.description || `Cat├®gorie ${cat._id}`}));\n\n      return reply.send({ success: true, categories: formattedCategories, total: categories.length });\n    } catch (error) {\n      return reply.code(500).send({ success: false, error: error instanceof Error ? error.message : String(error) });\n    }\n  });\n\n  // Ô£¿ NEW: Get featured rewards (for admin panel)\n  fastify.get('/featured', {\n    preHandler: [authenticate]}, async (request, reply) => {\n    try {\n      const featured = await Reward.find({ isActive: true, isPopular: true, metadata: { $exists: true }, 'metadata.isSponsored': true })\n      .sort({ popularity: -1, createdAt: -1 })\n      .limit(20)\n      .lean();\n\n      reply.send({ success: true, rewards: featured, total: featured.length });\n    } catch (error) {\n      reply.code(500).send({ success: false, error: error instanceof Error ? error.message : String(error) });\n    }\n  });\n\n\n  // Ô£¿ NEW: Get marketplace history (for admin panel)\n  fastify.get('/history', {\n    preHandler: [authenticate],\n    schema: {\n      querystring: z.object({\n        status: z.enum(['completed', 'pending', 'cancelled', 'all']).default('all'),\n        page: z.coerce.number().min(1).default(1),\n        limit: z.coerce.number().min(1).max(100).default(20)\n      })\n    }\n  }, async (request: FastifyRequest<{ Querystring: { status?: 'completed' | 'pending' | 'cancelled' | 'all'; page?: number; limit?: number } }>, reply) => {\n    try {\n      const { status, page = 1, limit = 20 } = request.query;\n      const safePage = Math.max(1, page || 1);\n      const safeLimit = Math.min(100, Math.max(1, limit || 20));\n      const query: FilterQuery<IRedemption> = { 'metadata.source': 'marketplace' };\n      if (status && status !== 'all') query.status = status;\n      const [history, total] = await Promise.all([\n        Redemption.find(query)\n          .populate('userId', 'displayName email')\n          .populate('rewardId', 'name pointsCost category imageUrl')\n          .sort({ createdAt: -1 })\n          .skip((safePage - 1) * safeLimit)\n          .limit(safeLimit)\n          .lean(),\n        Redemption.countDocuments(query)]);\n\n      const formattedHistory = history.map(item => {\n        const populatedUser = isPopulatedUser(item.userId) ? item.userId : undefined;\n        const populatedReward = isPopulatedReward(item.rewardId) ? item.rewardId : undefined;\n\n        return {\n          id: item._id,\n          userId: populatedUser?._id,\n          user: {\n            id: populatedUser?._id,\n            username: populatedUser?.displayName,\n            email: populatedUser?.email},\n          rewardId: populatedReward?._id,\n          reward: {\n            id: populatedReward?._id,\n            name: populatedReward?.name,\n            pointsCost: populatedReward?.pointsCost,\n            category: populatedReward?.category,\n            imageUrl: populatedReward?.imageUrl},\n          status: item.status,\n          pointsSpent: item.pointsSpent || populatedReward?.pointsCost,\n          redeemedAt: item.redeemedAt,\n          createdAt: item.createdAt};\n      });\n\n      reply.send({ \n        success: true, \n        history: formattedHistory, \n        total,\n        page: safePage,\n        limit: safeLimit,\n        hasMore: total > safePage * safeLimit\n      });\n    } catch (error) {\n      reply.code(500).send({ success: false, error: error instanceof Error ? error.message : String(error) });\n    }\n  });\n\n  // NOTE: Partner self-service routes were moved to /api/v1/partner/marketplace/*.\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\notifications\\index.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":21,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[859,862],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[859,862],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":69,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":69,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2016,2019],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2016,2019],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":71,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2089,2092],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2089,2092],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":73,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2202,2205],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2202,2205],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":80,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":80,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2434,2437],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2434,2437],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":85,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":85,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2545,2548],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2545,2548],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":92,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":92,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2851,2854],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2851,2854],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":119,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":119,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3764,3767],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3764,3767],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":137,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":137,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4293,4296],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4293,4296],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":151,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":151,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4657,4660],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4657,4660],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":153,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":153,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4761,4764],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4761,4764],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":165,"column":79,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":165,"endColumn":82,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5115,5118],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5115,5118],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":179,"column":82,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":179,"endColumn":85,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5627,5630],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5627,5630],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":212,"column":82,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":212,"endColumn":85,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6894,6897],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6894,6897],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":231,"column":84,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":231,"endColumn":87,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7553,7556],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7553,7556],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":257,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":257,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8412,8415],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8412,8415],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":258,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":258,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8463,8466],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8463,8466],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":260,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":260,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8556,8559],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8556,8559],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":265,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":265,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8786,8789],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8786,8789],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":318,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":318,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10475,10478],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10475,10478],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":336,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":336,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11118,11121],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11118,11121],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":351,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":351,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11647,11650],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11647,11650],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":366,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":366,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12157,12160],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12157,12160],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":378,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":378,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12552,12555],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12552,12555],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":393,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":393,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13083,13086],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13083,13086],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":408,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":408,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13623,13626],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13623,13626],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":428,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":428,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14241,14244],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14241,14244],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":440,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":440,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14632,14635],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14632,14635],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":28,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';\nimport { authenticate, requireAdmin } from '@/middleware/auth';\nimport { z } from 'zod';\nimport { Notification } from '@/models/Notification';\nimport { UserNotification } from '@/models/UserNotification';\nimport { DeviceToken, DevicePlatform } from '@/models/DeviceToken';\nimport UnifiedNotificationService from '@/services/notification-service';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { NotificationType, NotificationTargetType } from '@/types';\nimport { Types } from 'mongoose';\nimport { createHash } from 'crypto';\n\n// Define proper TypeScript interfaces\ninterface SendNotificationData {\n  title: string;\n  message: string;\n  type: NotificationType;\n  targetType: NotificationTargetType;\n  targetValue?: string;\n  scheduledFor?: string;\n  metadata?: Record<string, any>;\n}\n\ninterface GetUserNotificationOptions {\n  page?: number;\n  limit?: number;\n  unreadOnly?: boolean;\n}\n\ninterface MarkAsReadData {\n  notificationIds?: string[];\n  all?: boolean;\n}\n\ninterface NotificationSettings {\n  push?: boolean;\n  email?: boolean;\n  sms?: boolean;\n  inApp?: boolean;\n  types?: Record<string, boolean>;\n}\n\ninterface PushSubscriptionData {\n  endpoint: string;\n  keys: {\n    p256dh: string;\n    auth: string;\n  };\n}\n\n/**\n * Notification Service\n */\nexport class NotificationService {\n  static async sendNotification(adminId: string, data: SendNotificationData) {\n    try {\n      const deliveryMethod =\n        data.type === NotificationType.IN_APP ? 'inapp' : (data.type === NotificationType.PUSH || data.type === NotificationType.EMAIL ? data.type : 'all');\n      const result = await UnifiedNotificationService.sendNotification({\n        createdBy: adminId,\n        title: data.title,\n        message: data.message,\n        type: data.type,\n        targetType: data.targetType,\n        targetValue: data.targetValue,\n        scheduledFor: data.scheduledFor,\n        metadata: data.metadata || {},\n        deliveryMethod,\n      } as any);\n\n      const notification = await Notification.findById((result as any).notificationId).lean();\n      typedLogger.info('Notification created', {\n        notificationId: (result as any).notificationId,\n        adminId,\n        type: data.type,\n        targetType: data.targetType});\n\n      return notification || result;\n    } catch (error) {\n      typedLogger.error('Send notification error', { error: (error as any).message, adminId, data });\n      throw error;\n    }\n  }\n\n  static async processNotification(notification: any) {\n    try {\n      const result = await UnifiedNotificationService.processScheduledNotification(\n        notification?._id?.toString?.() || notification?.id?.toString?.() || ''\n      );\n      return result;\n    } catch (error) {\n      typedLogger.error('Process notification error', { error: (error as any).message, notificationId: notification._id });\n      throw error;\n    }\n  }\n\n  static async getNotifications(options: { page?: number; limit?: number; } = {}) {\n    try {\n      const page = options.page || 1;\n      const limit = options.limit || 50;\n      const skip = ((page as number) - 1) * (limit as number);\n\n      const [notifications, total] = await Promise.all([\n        Notification.find()\n          .populate('createdBy', 'displayName')\n          .sort({ createdAt: -1 })\n          .skip(skip)\n          .limit(limit as number),\n        Notification.countDocuments()]);\n\n      return {\n        notifications: notifications.map(n => n.toJSON()),\n        pagination: {\n          page: page as number,\n          limit: limit as number,\n          total,\n          pages: Math.ceil(total / (limit as number))}};\n    } catch (error) {\n      typedLogger.error('Get notifications error', { error: (error as any).message });\n      throw error;\n    }\n  }\n\n  /**\n   * Get user's notifications\n   */\n  static async getUserNotifications(userId: string, options: GetUserNotificationOptions) {\n    try {\n      const result = await UnifiedNotificationService.getUserNotifications({\n        userId,\n        page: options.page || 1,\n        limit: options.limit || 20,\n        unreadOnly: options.unreadOnly || false,\n      });\n      return result;\n    } catch (error) {\n      typedLogger.error('Get user notifications error', { error: (error as any).message, userId, options });\n      throw error;\n    }\n  }\n\n  /**\n   * Mark notifications as read\n   */\n  static async markNotificationsRead(userId: string, data: MarkAsReadData) {\n    try {\n      return await UnifiedNotificationService.markNotificationsAsRead({\n        userId,\n        notificationIds: data.notificationIds,\n        all: data.all,\n      } as any);\n    } catch (error) {\n      typedLogger.error('Mark notifications read error', { error: (error as any).message, userId, data });\n      throw error;\n    }\n  }\n\n  /**\n   * Get notification settings for user\n   */\n  static async getNotificationSettings(userId: string) {\n    try {\n      return await UnifiedNotificationService.getUserPreferences(userId);\n    } catch (error) {\n      typedLogger.error('Get notification settings error', { error: (error as any).message, userId });\n      throw error;\n    }\n  }\n\n  /**\n   * Update notification settings for user\n   */\n  static async updateNotificationSettings(userId: string, settings: NotificationSettings) {\n    try {\n      const updated = await UnifiedNotificationService.updateUserPreferences(userId, settings);\n      typedLogger.info('Notification settings updated', { userId, settings });\n      return updated;\n    } catch (error) {\n      typedLogger.error('Update notification settings error', { error: (error as any).message, userId, settings });\n      throw error;\n    }\n  }\n\n  /**\n   * Subscribe to push notifications\n   */\n  static async subscribePushNotifications(userId: string, subscriptionData: PushSubscriptionData) {\n    try {\n      const deviceId = `web_${createHash('sha1').update(subscriptionData.endpoint).digest('hex').slice(0, 24)}`;\n      const existing = await DeviceToken.findOne({ userId: new Types.ObjectId(userId), fcmToken: subscriptionData.endpoint });\n      if (existing) {\n        existing.deviceId = deviceId;\n        existing.platform = DevicePlatform.WEB;\n        existing.isActive = true;\n        existing.lastUsed = new Date();\n        await existing.save();\n      } else {\n        await DeviceToken.create({\n          userId: new Types.ObjectId(userId),\n          deviceId,\n          platform: DevicePlatform.WEB,\n          fcmToken: subscriptionData.endpoint,\n          isActive: true,\n          lastUsed: new Date(),\n        });\n      }\n\n      typedLogger.info('User subscribed to push notifications', { userId, endpoint: subscriptionData.endpoint });\n\n      return { success: true, message: 'Successfully subscribed to push notifications' };\n    } catch (error) {\n      typedLogger.error('Subscribe push notifications error', { error: (error as any).message, userId, subscriptionData });\n      throw error;\n    }\n  }\n\n  /**\n   * Unsubscribe from push notifications\n   */\n  static async unsubscribePushNotifications(userId: string, endpoint: string) {\n    try {\n      await DeviceToken.updateMany(\n        { userId: new Types.ObjectId(userId), fcmToken: endpoint },\n        { $set: { isActive: false } }\n      );\n\n      typedLogger.info('User unsubscribed from push notifications', { userId, endpoint });\n\n      return { success: true, message: 'Successfully unsubscribed from push notifications' };\n    } catch (error) {\n      typedLogger.error('Unsubscribe push notifications error', { error: (error as any).message, userId, endpoint });\n      throw error;\n    }\n  }\n\n  /**\n   * Get notification statistics for user\n   */\n  static async getNotificationStats(userId: string) {\n    try {\n      const baseQuery = { userId: new Types.ObjectId(userId), 'preferencesApplied.inApp': { $ne: false } };\n      const [totalCount, unreadCount, recentUserNotifications] = await Promise.all([\n        UserNotification.countDocuments(baseQuery),\n        UserNotification.countDocuments({ ...baseQuery, isRead: false }),\n        UserNotification.find(baseQuery)\n          .populate('notificationId', 'title type createdAt')\n          .sort({ createdAt: -1 })\n          .limit(5)\n          .lean()\n      ]);\n\n      return {\n        total: totalCount,\n        unread: unreadCount,\n        recent: recentUserNotifications.map(un => ({\n          id: un._id,\n          title: (un as any).notificationId?.title,\n          type: (un as any).notificationId?.type,\n          isRead: un.isRead || false,\n          createdAt: (un as any).notificationId?.createdAt || un.createdAt\n        })),\n        preferences: await this.getNotificationSettings(userId)\n      };\n    } catch (error) {\n      typedLogger.error('Get notification stats error', { error: (error as any).message, userId });\n      throw error;\n    }\n  }\n}\n\n// Validation schemas\nconst sendNotificationSchema = z.object({\n  title: z.string().min(1).max(100),\n  message: z.string().min(1).max(500),\n  type: z.nativeEnum(NotificationType),\n  targetType: z.nativeEnum(NotificationTargetType),\n  targetValue: z.string().optional(),\n  scheduledFor: z.string().datetime().optional(),\n  metadata: z.record(z.unknown()).optional()});\n\nconst getNotificationsSchema = z.object({\n  page: z.coerce.number().min(1).default(1),\n  limit: z.coerce.number().min(1).max(50).default(20),\n  unreadOnly: z.coerce.boolean().default(false)});\n\nconst markAsReadSchema = z.object({\n  notificationIds: z.array(z.string()).optional(),\n  all: z.boolean().optional()});\n\nconst updateSettingsSchema = z.object({\n  push: z.boolean().optional(),\n  email: z.boolean().optional(),\n  sms: z.boolean().optional(),\n  inApp: z.boolean().optional(),\n  types: z.record(z.boolean()).optional(),\n});\n\nconst subscribePushSchema = z.object({\n  endpoint: z.string().url(),\n  keys: z.object({\n    p256dh: z.string(),\n    auth: z.string()\n  })\n});\n\nexport default async function notificationsRoutes(fastify: FastifyInstance) {\n  // Admin: Send notification\n  fastify.post('/admin/send', {\n    preHandler: [authenticate, requireAdmin],\n    schema: {\n      body: sendNotificationSchema\n    }\n  }, async (request: FastifyRequest<{ Body: SendNotificationData }>, reply: FastifyReply) => {\n    try {\n      const result = await NotificationService.sendNotification(request.user.sub, request.body);\n      reply.code(201).send({ success: true, data: result });\n    } catch (error) {\n      reply.code(400).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Admin: Get notifications\n  fastify.get('/admin', {\n    preHandler: [authenticate, requireAdmin],\n    schema: {\n      querystring: z.object({\n        page: z.coerce.number().min(1).default(1),\n        limit: z.coerce.number().min(1).max(100).default(50)\n      })\n    }\n  }, async (request: FastifyRequest<{ Querystring: { page?: number; limit?: number } }>, reply: FastifyReply) => {\n    try {\n      const result = await NotificationService.getNotifications(request.query);\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      reply.code(500).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // User: Get notifications\n  fastify.get('/', {\n    preHandler: [authenticate],\n    schema: {\n      querystring: getNotificationsSchema\n    }\n  }, async (request: FastifyRequest<{ Querystring: GetUserNotificationOptions }>, reply: FastifyReply) => {\n    try {\n      const result = await NotificationService.getUserNotifications(request.user.sub, request.query);\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      reply.code(500).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // User: Mark notifications as read\n  fastify.put('/read', {\n    preHandler: [authenticate],\n    schema: {\n      body: markAsReadSchema\n    }\n  }, async (request: FastifyRequest<{ Body: MarkAsReadData }>, reply: FastifyReply) => {\n    try {\n      const result = await NotificationService.markNotificationsRead(request.user.sub, request.body);\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      reply.code(400).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // User: Get notification settings\n  fastify.get('/settings', {\n    preHandler: [authenticate]\n  }, async (request, reply) => {\n    try {\n      const result = await NotificationService.getNotificationSettings(request.user.sub);\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      reply.code(500).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // User: Update notification settings\n  fastify.put('/settings', {\n    preHandler: [authenticate],\n    schema: {\n      body: updateSettingsSchema\n    }\n  }, async (request: FastifyRequest<{ Body: NotificationSettings }>, reply: FastifyReply) => {\n    try {\n      const result = await NotificationService.updateNotificationSettings(request.user.sub, request.body);\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      reply.code(400).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // User: Subscribe to push notifications\n  fastify.post('/push/subscribe', {\n    preHandler: [authenticate],\n    schema: {\n      body: subscribePushSchema\n    }\n  }, async (request: FastifyRequest<{ Body: PushSubscriptionData }>, reply: FastifyReply) => {\n    try {\n      const result = await NotificationService.subscribePushNotifications(request.user.sub, request.body);\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      reply.code(400).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // User: Unsubscribe from push notifications\n  fastify.delete('/push/unsubscribe', {\n    preHandler: [authenticate],\n    schema: {\n      body: z.object({\n        endpoint: z.string().url()\n      })\n    }\n  }, async (request: FastifyRequest<{ Body: { endpoint: string } }>, reply: FastifyReply) => {\n    try {\n      const result = await NotificationService.unsubscribePushNotifications(\n        request.user.sub,\n        request.body.endpoint\n      );\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      reply.code(400).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // User: Get notification statistics\n  fastify.get('/stats', {\n    preHandler: [authenticate]\n  }, async (request, reply) => {\n    try {\n      const result = await NotificationService.getNotificationStats(request.user.sub);\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      reply.code(500).send({ success: false, error: (error as any).message });\n    }\n  });\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\notifications\\push.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":77,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":77,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2502,2505],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2502,2505],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":80,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":80,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2601,2604],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2601,2604],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":111,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3327,3330],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3327,3330],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":114,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":114,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3428,3431],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3428,3431],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":127,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":127,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3662,3665],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3662,3665],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":156,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":156,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4483,4486],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4483,4486],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":159,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":159,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4585,4588],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4585,4588],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":169,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":169,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4773,4776],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4773,4776],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":201,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":201,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5621,5624],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5621,5624],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":204,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":204,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5720,5723],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5720,5723],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":217,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":217,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5959,5962],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5959,5962],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":252,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":252,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6930,6933],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6930,6933],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":255,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":255,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7031,7034],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7031,7034],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":267,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":267,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7307,7310],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7307,7310],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-useless-catch","severity":2,"message":"Unnecessary try/catch wrapper.","line":280,"column":5,"nodeType":"TryStatement","messageId":"unnecessaryCatch","endLine":289,"endColumn":6},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":287,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":287,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7977,7980],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7977,7980],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":294,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":294,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8131,8134],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8131,8134],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":312,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":312,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8720,8723],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8720,8723],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":313,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":313,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8747,8750],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8747,8750],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":322,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":322,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9024,9027],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9024,9027],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":341,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":341,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9650,9653],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9650,9653],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":342,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":342,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9677,9680],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9677,9680],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":351,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":351,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9963,9966],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9963,9966],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-useless-catch","severity":2,"message":"Unnecessary try/catch wrapper.","line":367,"column":5,"nodeType":"TryStatement","messageId":"unnecessaryCatch","endLine":376,"endColumn":6},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":374,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":374,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10717,10720],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10717,10720],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":25,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';\nimport { z } from 'zod';\nimport { Types } from 'mongoose';\nimport { DeviceToken, DevicePlatform, INotificationPreferences } from '@/models/DeviceToken';\nimport { typedLogger } from '@/lib/typed-logger';\n\n// Validation schemas\nconst registerDeviceSchema = z.object({\n  deviceId: z.string().min(1).max(100),\n  platform: z.enum(['ios', 'android', 'web']),\n  fcmToken: z.string().min(1),\n  apnsToken: z.string().optional()});\n\nconst unregisterDeviceSchema = z.object({\n  deviceId: z.string().min(1).max(100)});\n\nconst updatePreferencesSchema = z.object({\n  deviceId: z.string().optional(),\n  preferences: z.object({\n    enabled: z.boolean().optional(),\n    prizeNearby: z.boolean().optional(),\n    friendRequest: z.boolean().optional(),\n    achievementUnlocked: z.boolean().optional(),\n    dailyReminder: z.boolean().optional(),\n    marketplaceDeals: z.boolean().optional(),\n    eventStarted: z.boolean().optional(),\n    levelUp: z.boolean().optional()})});\n\n/**\n * Push Notification Service\n */\nexport class PushNotificationService {\n  /**\n   * Register device for push notifications\n   */\n  static async registerDevice(\n    userId: string,\n    data: z.infer<typeof registerDeviceSchema>\n  ) {\n    try {\n      // Check if device already registered\n      let deviceToken = await DeviceToken.findOne({\n        userId: new Types.ObjectId(userId),\n        deviceId: data.deviceId});\n\n      if (deviceToken) {\n        // Update existing token\n        deviceToken.fcmToken = data.fcmToken;\n        deviceToken.apnsToken = data.apnsToken;\n        deviceToken.platform = data.platform as DevicePlatform;\n        deviceToken.isActive = true;\n        deviceToken.lastUsed = new Date();\n        await deviceToken.save();\n      } else {\n        // Create new device token\n        deviceToken = new DeviceToken({\n          userId: new Types.ObjectId(userId),\n          deviceId: data.deviceId,\n          platform: data.platform as DevicePlatform,\n          fcmToken: data.fcmToken,\n          apnsToken: data.apnsToken,\n          isActive: true,\n          lastUsed: new Date()});\n        await deviceToken.save();\n      }\n\n      typedLogger.info('Device registered for push notifications', {\n        userId,\n        deviceId: data.deviceId,\n        platform: data.platform});\n\n      return {\n        deviceId: deviceToken.deviceId,\n        platform: deviceToken.platform,\n        preferences: deviceToken.preferences};\n      \n    } catch (error: any) {\n      typedLogger.error('Register device error', {\n        userId,\n        error: (error as any).message});\n      throw error;\n    }\n  }\n\n  /**\n   * Unregister device from push notifications\n   */\n  static async unregisterDevice(\n    userId: string,\n    data: z.infer<typeof unregisterDeviceSchema>\n  ) {\n    try {\n      const deviceToken = await DeviceToken.findOne({\n        userId: new Types.ObjectId(userId),\n        deviceId: data.deviceId});\n\n      if (!deviceToken) {\n        throw new Error('DEVICE_NOT_FOUND');\n      }\n\n      deviceToken.isActive = false;\n      await deviceToken.save();\n\n      typedLogger.info('Device unregistered from push notifications', {\n        userId,\n        deviceId: data.deviceId});\n\n      return {\n        message: 'Device unregistered successfully'};\n      \n    } catch (error: any) {\n      typedLogger.error('Unregister device error', {\n        userId,\n        error: (error as any).message});\n      throw error;\n    }\n  }\n\n  /**\n   * Update notification preferences\n   */\n  static async updatePreferences(\n    userId: string,\n    data: z.infer<typeof updatePreferencesSchema>\n  ) {\n    try {\n      const query: any = {\n        userId: new Types.ObjectId(userId),\n        isActive: true};\n\n      if (data.deviceId) {\n        query.deviceId = data.deviceId;\n      }\n\n      const deviceTokens = await DeviceToken.find(query);\n\n      if (deviceTokens.length === 0) {\n        throw new Error('NO_ACTIVE_DEVICES');\n      }\n\n      // Update preferences for all devices (or specific device)\n      for (const deviceToken of deviceTokens) {\n        Object.assign(deviceToken.preferences, data.preferences);\n        await deviceToken.save();\n      }\n\n      typedLogger.info('Notification preferences updated', {\n        userId,\n        deviceId: data.deviceId || 'all',\n        preferences: data.preferences});\n\n      return {\n        updated: deviceTokens.length,\n        preferences: deviceTokens[0].preferences};\n      \n    } catch (error: any) {\n      typedLogger.error('Update preferences error', {\n        userId,\n        error: (error as any).message});\n      throw error;\n    }\n  }\n\n  /**\n   * Get notification preferences\n   */\n  static async getPreferences(userId: string, deviceId?: string) {\n    try {\n      const query: any = {\n        userId: new Types.ObjectId(userId),\n        isActive: true};\n\n      if (deviceId) {\n        query.deviceId = deviceId;\n      }\n\n      const deviceTokens = await DeviceToken.find(query);\n\n      if (deviceTokens.length === 0) {\n        // Return default preferences\n        return {\n          devices: [],\n          defaultPreferences: {\n            enabled: true,\n            prizeNearby: true,\n            friendRequest: true,\n            achievementUnlocked: true,\n            dailyReminder: true,\n            marketplaceDeals: true,\n            eventStarted: true,\n            levelUp: true}};\n      }\n\n      return {\n        devices: deviceTokens.map(dt => ({\n          deviceId: dt.deviceId,\n          platform: dt.platform,\n          preferences: dt.preferences,\n          lastUsed: dt.lastUsed}))};\n      \n    } catch (error: any) {\n      typedLogger.error('Get preferences error', {\n        userId,\n        error: (error as any).message});\n      throw error;\n    }\n  }\n\n  /**\n   * Send push notification (helper for internal use)\n   */\n  static async sendNotification(\n    userId: string,\n    notification: {\n      title: string;\n      body: string;\n      data?: any;\n      type?: string;\n    }\n  ) {\n    try {\n      const deviceTokens = await DeviceToken.find({\n        userId: new Types.ObjectId(userId),\n        isActive: true,\n        'preferences.enabled': true});\n\n      if (deviceTokens.length === 0) {\n        return {\n          sent: 0,\n          message: 'No active devices'};\n      }\n\n      // Filter by notification type preference\n      const filteredDevices = deviceTokens.filter(dt => {\n        if (!notification.type) return true;\n        \n        const prefKey = notification.type as keyof INotificationPreferences;\n        return dt.preferences[prefKey] !== false;\n      });\n\n      // In production, send via FCM/APNS\n      // For now, just log\n      typedLogger.info('Push notification sent', {\n        userId,\n        devices: filteredDevices.length,\n        notification});\n\n      return {\n        sent: filteredDevices.length,\n        devices: filteredDevices.map(dt => dt.deviceId)};\n      \n    } catch (error: any) {\n      typedLogger.error('Send notification error', {\n        userId,\n        error: (error as any).message});\n      throw error;\n    }\n  }\n}\n\n/**\n * Push Notification Routes\n */\nexport default async function pushNotificationRoutes(fastify: FastifyInstance) {\n  // POST /api/notifications/register-device\n  fastify.post('/register-device', {\n    preHandler: [(fastify as any).authenticate],\n    schema: {\n      description: 'Register device for push notifications',\n      tags: ['Push Notifications'],\n      response: {\n        200: {\n          type: 'object',\n          properties: {\n            deviceId: { type: 'string' },\n            platform: { type: 'string' },\n            preferences: { type: 'object' }}}}\n    }\n  }, async (request: FastifyRequest, reply: FastifyReply) => {\n    try {\n      const userId = request.user.sub;\n      const data = registerDeviceSchema.parse(request.body);\n\n      const result = await PushNotificationService.registerDevice(userId, data);\n\n      return reply.code(200).send(result);\n    } catch (error: any) {\n      throw error;\n    }\n  });\n\n  // POST /api/notifications/unregister-device\n  fastify.post('/unregister-device', {\n    preHandler: [(fastify as any).authenticate],\n    schema: {\n      description: 'Unregister device from push notifications',\n      tags: ['Push Notifications'],\n      response: {\n        200: {\n          type: 'object',\n          properties: {\n            message: { type: 'string' }}}}\n    }\n  }, async (request: FastifyRequest, reply: FastifyReply) => {\n    try {\n      const userId = request.user.sub;\n      const data = unregisterDeviceSchema.parse(request.body);\n\n      const result = await PushNotificationService.unregisterDevice(userId, data);\n\n      return reply.code(200).send(result);\n    } catch (error: any) {\n      if ((error as any).message === 'DEVICE_NOT_FOUND') {\n        return reply.code(404).send({ error: 'DEVICE_NOT_FOUND', message: 'Device not found' });\n      }\n      throw error;\n    }\n  });\n\n  // PUT /api/notifications/preferences\n  fastify.put('/preferences', {\n    preHandler: [(fastify as any).authenticate],\n    schema: {\n      description: 'Update notification preferences',\n      tags: ['Push Notifications'],\n      response: {\n        200: {\n          type: 'object',\n          properties: {\n            updated: { type: 'number' },\n            preferences: { type: 'object' }}}}\n    }\n  }, async (request: FastifyRequest, reply: FastifyReply) => {\n    try {\n      const userId = request.user.sub;\n      const data = updatePreferencesSchema.parse(request.body);\n\n      const result = await PushNotificationService.updatePreferences(userId, data);\n\n      return reply.code(200).send(result);\n    } catch (error: any) {\n      if ((error as any).message === 'NO_ACTIVE_DEVICES') {\n        return reply.code(404).send({ error: 'NO_ACTIVE_DEVICES', message: 'No active devices found' });\n      }\n      throw error;\n    }\n  });\n\n  // GET /api/notifications/preferences\n  fastify.get('/preferences', {\n    preHandler: [(fastify as any).authenticate],\n    schema: {\n      description: 'Get notification preferences',\n      tags: ['Push Notifications'],\n      querystring: {\n        type: 'object',\n        properties: {\n          deviceId: { type: 'string' }}},\n      response: {\n        200: {\n          type: 'object',\n          properties: {\n            devices: { type: 'array' },\n            defaultPreferences: { type: 'object' }}}}\n    }\n  }, async (request: FastifyRequest, reply: FastifyReply) => {\n    try {\n      const userId = request.user.sub;\n      const { deviceId } = request.query as { deviceId?: string };\n      \n      const result = await PushNotificationService.getPreferences(userId, deviceId);\n      \n      return reply.code(200).send(result);\n    } catch (error: any) {\n      throw error;\n    }\n  });\n}\n\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\notifications\\routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\offline\\index.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":52,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":52,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1474,1477],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1474,1477],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":53,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1503,1506],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1503,1506],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":54,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1535,1538],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1535,1538],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":106,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":106,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3534,3537],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3534,3537],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":111,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3710,3713],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3710,3713],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":124,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":124,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4024,4027],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4024,4027],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":127,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":127,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4120,4123],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4120,4123],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":138,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":138,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4318,4321],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4318,4321],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":140,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":140,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4379,4382],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4379,4382],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":178,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":178,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5566,5569],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5566,5569],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":180,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":180,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5627,5630],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5627,5630],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":213,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":213,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6576,6579],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6576,6579],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":217,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":217,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6665,6668],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6665,6668],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":218,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":218,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6708,6711],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6708,6711],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":228,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":228,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6906,6909],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6906,6909],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":230,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":230,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6967,6970],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6967,6970],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":282,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":282,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8380,8383],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8380,8383],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":287,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":287,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8504,8507],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8504,8507],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'userId' is defined but never used. Allowed unused args must match /^_/u.","line":295,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":295,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'actionData' is defined but never used. Allowed unused args must match /^_/u.","line":296,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":296,"endColumn":20},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":296,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":296,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8652,8655],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8652,8655],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":297,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":297,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8669,8672],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8669,8672],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":313,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":313,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8987,8990],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8987,8990],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":342,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":342,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10090,10093],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10090,10093],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":345,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":345,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10189,10192],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10189,10192],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":353,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":353,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10382,10385],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10382,10385],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":360,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":360,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10611,10614],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10611,10614],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":413,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":413,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12312,12315],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12312,12315],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":414,"column":78,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":414,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12396,12399],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12396,12399],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":462,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":462,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13633,13636],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13633,13636],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":463,"column":78,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":463,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13717,13720],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13717,13720],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":471,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":471,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13858,13861],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13858,13861],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'deviceInfo' is defined but never used. Allowed unused args must match /^_/u.","line":471,"column":51,"nodeType":"Identifier","messageId":"unusedVar","endLine":471,"endColumn":66},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":471,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":471,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13875,13878],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13875,13878],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":512,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":512,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15076,15079],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15076,15079],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":513,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":513,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15159,15162],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15159,15162],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":516,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":516,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15273,15276],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15273,15276],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":525,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":525,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15423,15426],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15423,15426],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":543,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":543,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16023,16026],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16023,16026],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":546,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":546,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16104,16107],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16104,16107],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":547,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":547,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16177,16180],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16177,16180],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":561,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":561,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16645,16648],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16645,16648],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":562,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":562,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16723,16726],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16723,16726],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":594,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":594,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17482,17485],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17482,17485],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":595,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":595,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17564,17567],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17564,17567],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":611,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":611,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17929,17932],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17929,17932],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":618,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":618,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18142,18145],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18142,18145],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":619,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":619,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18225,18228],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18225,18228],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":666,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":666,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19394,19397],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19394,19397],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":669,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":669,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19498,19501],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19498,19501],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-useless-catch","severity":2,"message":"Unnecessary try/catch wrapper.","line":698,"column":5,"nodeType":"TryStatement","messageId":"unnecessaryCatch","endLine":707,"endColumn":6},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":705,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":705,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20504,20507],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20504,20507],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-useless-catch","severity":2,"message":"Unnecessary try/catch wrapper.","line":738,"column":5,"nodeType":"TryStatement","messageId":"unnecessaryCatch","endLine":747,"endColumn":6},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":745,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":745,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21664,21667],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21664,21667],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-useless-catch","severity":2,"message":"Unnecessary try/catch wrapper.","line":767,"column":5,"nodeType":"TryStatement","messageId":"unnecessaryCatch","endLine":775,"endColumn":6},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":773,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":773,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22362,22365],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22362,22365],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-useless-catch","severity":2,"message":"Unnecessary try/catch wrapper.","line":802,"column":5,"nodeType":"TryStatement","messageId":"unnecessaryCatch","endLine":808,"endColumn":6},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":806,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":806,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23329,23332],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23329,23332],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-useless-catch","severity":2,"message":"Unnecessary try/catch wrapper.","line":835,"column":5,"nodeType":"TryStatement","messageId":"unnecessaryCatch","endLine":841,"endColumn":6},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":839,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":839,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24310,24313],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24310,24313],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-useless-catch","severity":2,"message":"Unnecessary try/catch wrapper.","line":868,"column":5,"nodeType":"TryStatement","messageId":"unnecessaryCatch","endLine":874,"endColumn":6},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":869,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":869,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25148,25151],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25148,25151],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":872,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":872,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25326,25329],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25326,25329],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":63,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';\nimport { authenticate } from '@/middleware/auth';\nimport { z } from 'zod';\nimport { Types } from 'mongoose';\nimport {\n  OfflineQueue,\n  OfflineActionType,\n  OfflineActionStatus,\n  ConflictResolution\n} from '@/models/OfflineQueue';\nimport { User } from '@/models/User';\nimport { Prize } from '@/models/Prize';\nimport { Claim } from '@/models/Claim';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { ClaimsService } from '@/modules/claims';\n\n// Validation schemas\nconst syncActionsSchema = z.object({\n  actions: z.array(z.object({\n    actionType: z.enum([\n      'claim_prize',\n      'update_profile',\n      'send_friend_request',\n      'accept_friend_request',\n      'purchase_item',\n      'unlock_achievement']),\n    actionData: z.any(),\n    clientTimestamp: z.string().datetime(),\n    metadata: z.object({\n      deviceId: z.string(),\n      platform: z.string(),\n      appVersion: z.string(),\n      networkType: z.string().optional()})})),\n  conflictResolution: z.enum(['server_wins', 'client_wins', 'merge', 'manual']).default('server_wins')});\n\nconst getSyncStatusSchema = z.object({\n  since: z.string().datetime().optional()});\n\n/**\n * Offline Service (Enhanced)\n */\nexport class OfflineService {\n  /**\n   * Sync offline actions\n   */\n  static async syncActions(\n    userId: string,\n    data: z.infer<typeof syncActionsSchema>\n  ) {\n    try {\n      const results = {\n        synced: [] as any[],\n        failed: [] as any[],\n        conflicts: [] as any[]};\n\n      for (const action of data.actions) {\n        try {\n          // Create queue entry\n          const queueEntry = new OfflineQueue({\n            userId: new Types.ObjectId(userId),\n            actionType: action.actionType as OfflineActionType,\n            actionData: action.actionData,\n            status: OfflineActionStatus.SYNCING,\n            clientTimestamp: new Date(action.clientTimestamp),\n            serverTimestamp: new Date(),\n            attempts: 1,\n            metadata: action.metadata});\n\n          // Process action based on type\n          const result = await this.processAction(\n            userId,\n            action.actionType as OfflineActionType,\n            action.actionData,\n            data.conflictResolution as ConflictResolution\n          );\n\n          if (result.success) {\n            queueEntry.status = OfflineActionStatus.SYNCED;\n            queueEntry.syncedAt = new Date();\n            results.synced.push({\n              actionType: action.actionType,\n              result: result.data});\n          } else if (result.conflict) {\n            queueEntry.status = OfflineActionStatus.CONFLICT;\n            queueEntry.conflict = {\n              serverData: result.serverData,\n              clientData: result.clientData,\n              resolution: data.conflictResolution as ConflictResolution,\n              resolvedData: result.resolvedData};\n            results.conflicts.push({\n              actionType: action.actionType,\n              conflict: queueEntry.conflict});\n          } else {\n            queueEntry.status = OfflineActionStatus.FAILED;\n            queueEntry.error = {\n              code: result.error?.code || 'UNKNOWN_ERROR',\n              message: result.error?.message || 'Unknown error',\n              details: result.error?.details};\n            results.failed.push({\n              actionType: action.actionType,\n              error: queueEntry.error});\n          }\n\n          await queueEntry.save();\n\n        } catch (error: any) {\n          results.failed.push({\n            actionType: action.actionType,\n            error: {\n              code: 'PROCESSING_ERROR',\n              message: (error as any).message}});\n        }\n      }\n\n      typedLogger.info('Offline actions synced', {\n        userId,\n        total: data.actions.length,\n        synced: results.synced.length,\n        failed: results.failed.length,\n        conflicts: results.conflicts.length});\n\n      return results;\n      \n    } catch (error: any) {\n      typedLogger.error('Sync actions error', {\n        userId,\n        error: (error as any).message});\n      throw error;\n    }\n  }\n\n  /**\n   * Process individual action\n   */\n  private static async processAction(\n    userId: string,\n    actionType: OfflineActionType,\n    actionData: any,\n    conflictResolution: ConflictResolution\n  ): Promise<any> {\n    // SECURITY HARDENING: Force SERVER_WINS for critical actions\n    // This prevents hacked clients from overriding server state for prizes/rewards\n    let resolution = conflictResolution;\n    const criticalActions = [\n      OfflineActionType.CLAIM_PRIZE,\n      OfflineActionType.PURCHASE_ITEM,\n      OfflineActionType.UNLOCK_ACHIEVEMENT\n    ];\n\n    if (criticalActions.includes(actionType)) {\n      resolution = ConflictResolution.SERVER_WINS;\n    }\n\n    switch (actionType) {\n      case OfflineActionType.CLAIM_PRIZE:\n        return await this.processClaim(userId, actionData, resolution);\n      \n      case OfflineActionType.UPDATE_PROFILE:\n        return await this.processProfileUpdate(userId, actionData, resolution);\n      \n      case OfflineActionType.SEND_FRIEND_REQUEST:\n        return await this.processFriendRequest(userId, actionData);\n      \n      default:\n        return {\n          success: false,\n          error: {\n            code: 'UNSUPPORTED_ACTION',\n            message: `Action type ${actionType} not supported`}};\n    }\n  }\n\n  /**\n   * Process claim with conflict detection\n   */\n  private static async processClaim(\n    userId: string,\n    actionData: any,\n    conflictResolution: ConflictResolution\n  ): Promise<any> {\n    try {\n      // Check if claim already exists (idempotency)\n      const existingClaim = await Claim.findOne({\n        userId: new Types.ObjectId(userId),\n        prizeId: new Types.ObjectId(actionData.prizeId)});\n\n      if (existingClaim) {\n        // Conflict detected\n        if (conflictResolution === ConflictResolution.SERVER_WINS) {\n          return {\n            success: true,\n            data: existingClaim,\n            conflict: false};\n        } else {\n          return {\n            success: false,\n            conflict: true,\n            serverData: existingClaim,\n            clientData: actionData,\n            resolvedData: existingClaim, // Server wins by default\n          };\n        }\n      }\n\n      // Process claim normally\n      const result = await ClaimsService.claimPrize(userId, actionData);\n      \n      return {\n        success: true,\n        data: result,\n        conflict: false};\n      \n    } catch (error: any) {\n      return {\n        success: false,\n        error: {\n          code: (error as any).message,\n          message: (error as any).message,\n          details: error}};\n    }\n  }\n\n  /**\n   * Process profile update with conflict detection\n   */\n  private static async processProfileUpdate(\n    userId: string,\n    actionData: any,\n    conflictResolution: ConflictResolution\n  ): Promise<any> {\n    try {\n      const user = await User.findById(userId);\n      \n      if (!user) {\n        return {\n          success: false,\n          error: {\n            code: 'USER_NOT_FOUND',\n            message: 'User not found'}};\n      }\n\n      // Check for conflicts\n      const serverUpdatedAt = user.updatedAt;\n      const clientUpdatedAt = new Date(actionData.updatedAt || 0);\n\n      if (serverUpdatedAt > clientUpdatedAt) {\n        // Conflict detected\n        if (conflictResolution === ConflictResolution.SERVER_WINS) {\n          return {\n            success: true,\n            data: user,\n            conflict: false};\n        } else if (conflictResolution === ConflictResolution.CLIENT_WINS) {\n          // Apply client changes\n          Object.assign(user, actionData.updates);\n          await user.save();\n          return {\n            success: true,\n            data: user,\n            conflict: false};\n        } else {\n          // Merge strategy\n          return {\n            success: false,\n            conflict: true,\n            serverData: user,\n            clientData: actionData,\n            resolvedData: user, // Server wins by default\n          };\n        }\n      }\n\n      // No conflict, apply changes\n      Object.assign(user, actionData.updates);\n      await user.save();\n\n      return {\n        success: true,\n        data: user,\n        conflict: false};\n      \n    } catch (error: any) {\n      return {\n        success: false,\n        error: {\n          code: 'UPDATE_ERROR',\n          message: (error as any).message}};\n    }\n  }\n\n  /**\n   * Process friend request\n   */\n  private static async processFriendRequest(\n    userId: string,\n    actionData: any\n  ): Promise<any> {\n    // Implementation would go here\n    return {\n      success: true,\n      data: { message: 'Friend request sent' },\n      conflict: false};\n  }\n\n  /**\n   * Get sync status\n   */\n  static async getSyncStatus(\n    userId: string,\n    data: z.infer<typeof getSyncStatusSchema>\n  ) {\n    try {\n      const query: any = {\n        userId: new Types.ObjectId(userId)};\n\n      if (data.since) {\n        query.createdAt = { $gte: new Date(data.since) };\n      }\n\n      const [pending, syncing, synced, failed, conflicts] = await Promise.all([\n        OfflineQueue.countDocuments({ ...query, status: OfflineActionStatus.PENDING }),\n        OfflineQueue.countDocuments({ ...query, status: OfflineActionStatus.SYNCING }),\n        OfflineQueue.countDocuments({ ...query, status: OfflineActionStatus.SYNCED }),\n        OfflineQueue.countDocuments({ ...query, status: OfflineActionStatus.FAILED }),\n        OfflineQueue.countDocuments({ ...query, status: OfflineActionStatus.CONFLICT })]);\n\n      const recentActions = await OfflineQueue.find(query)\n        .sort({ createdAt: -1 })\n        .limit(20)\n        .select('actionType status clientTimestamp syncedAt error conflict');\n\n      return {\n        status: {\n          pending,\n          syncing,\n          synced,\n          failed,\n          conflicts,\n          total: pending + syncing + synced + failed + conflicts},\n        recentActions};\n      \n    } catch (error: any) {\n      typedLogger.error('Get sync status error', {\n        userId,\n        error: (error as any).message});\n      throw error;\n    }\n  }\n\n  /**\n   * Get offline data package for Unity (download data for offline play)\n   */\n  static async getOfflineDataPackage(userId: string, request: any) {\n    try {\n      const { location, dataTypes = ['prizes'], maxItems = 100 } = request;\n      const user = await User.findById(userId);\n      \n      if (!user) throw new Error('USER_NOT_FOUND');\n\n      const offlinePackage: any = {\n        userId,\n        packageId: `offline_${userId}_${Date.now()}`,\n        location,\n        generatedAt: new Date().toISOString(),\n        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),\n        data: {},\n        metadata: {\n          version: '1.0',\n          totalItems: 0,\n          estimatedSize: 0\n        }\n      };\n\n      // Get prizes data\n      if (dataTypes.includes('prizes')) {\n        const prizes = await this.getOfflinePrizes(location, maxItems, userId);\n        offlinePackage.data.prizes = prizes;\n        offlinePackage.metadata.totalItems += prizes.length;\n      }\n\n      // Get challenges data\n      if (dataTypes.includes('challenges')) {\n        const challenges = await this.getOfflineChallenges(userId);\n        offlinePackage.data.challenges = challenges;\n        offlinePackage.metadata.totalItems += challenges.length;\n      }\n\n      // Get leaderboard data\n      if (dataTypes.includes('leaderboard')) {\n        const leaderboard = await this.getOfflineLeaderboard();\n        offlinePackage.data.leaderboard = leaderboard;\n        offlinePackage.metadata.totalItems += leaderboard.length;\n      }\n\n      // Add user-specific data\n      offlinePackage.data.user = {\n        id: user._id,\n        displayName: user.displayName,\n        level: user.level,\n        points: user.points,\n        stats: user.stats || {}\n      };\n\n      offlinePackage.metadata.estimatedSize = JSON.stringify(offlinePackage).length;\n\n      typedLogger.info('Offline package generated', {\n        userId,\n        packageId: offlinePackage.packageId,\n        totalItems: offlinePackage.metadata.totalItems\n      });\n\n      return offlinePackage;\n    } catch (error: any) {\n      typedLogger.error('Get offline data package error', { error: (error as any).message, userId });\n      throw error;\n    }\n  }\n\n  /**\n   * Get offline capabilities and limits\n   */\n  static async getOfflineCapabilities(userId: string) {\n    try {\n      const user = await User.findById(userId);\n      if (!user) throw new Error('USER_NOT_FOUND');\n\n      const capabilities = {\n        maxOfflineDuration: 7 * 24 * 60 * 60 * 1000,\n        maxOfflineActions: 1000,\n        maxDataPackageSize: 10 * 1024 * 1024,\n        supportedActions: [\n          'claim_prize',\n          'update_profile',\n          'send_friend_request',\n          'accept_friend_request',\n          'purchase_item',\n          'unlock_achievement'\n        ],\n        syncInterval: 5 * 60 * 1000,\n        conflictResolution: {\n          strategy: 'server_wins',\n          allowUserChoice: true\n        },\n        dataTypes: {\n          prizes: {\n            maxRadius: 50,\n            maxItems: 500,\n            cacheDuration: 24 * 60 * 60 * 1000\n          },\n          challenges: {\n            maxItems: 50,\n            cacheDuration: 24 * 60 * 60 * 1000\n          },\n          leaderboard: {\n            maxItems: 100,\n            cacheDuration: 30 * 60 * 1000\n          }\n        }\n      };\n\n      return capabilities;\n    } catch (error: any) {\n      typedLogger.error('Get offline capabilities error', { error: (error as any).message, userId });\n      throw error;\n    }\n  }\n\n  /**\n   * Validate offline action\n   */\n  static async validateOfflineAction(action: any, deviceInfo: any) {\n    try {\n      const validation = {\n        isValid: true,\n        errors: [] as string[],\n        warnings: [] as string[]\n      };\n\n      // Check timestamp validity\n      const actionTime = new Date(action.timestamp);\n      const now = new Date();\n      const maxOfflineTime = 7 * 24 * 60 * 60 * 1000;\n\n      if (actionTime > now) {\n        validation.isValid = false;\n        validation.errors.push('Action timestamp is in the future');\n      }\n\n      if (now.getTime() - actionTime.getTime() > maxOfflineTime) {\n        validation.isValid = false;\n        validation.errors.push('Action is too old (>7 days)');\n      }\n\n      // Validate action data based on type\n      switch (action.type) {\n        case 'claim_prize':\n          if (!action.data.prizeId || !action.data.location) {\n            validation.isValid = false;\n            validation.errors.push('Missing required fields for prize claim');\n          }\n          break;\n\n        case 'update_profile':\n          if (!action.data.updates) {\n            validation.isValid = false;\n            validation.errors.push('Missing profile updates');\n          }\n          break;\n      }\n\n      return validation;\n    } catch (error: any) {\n      typedLogger.error('Validate offline action error', { error: (error as any).message, action });\n      return {\n        isValid: false,\n        errors: ['Validation error: ' + (error as any).message],\n        warnings: []\n      };\n    }\n  }\n\n  /**\n   * Helper: Get offline prizes\n   */\n  private static async getOfflinePrizes(location: any, maxItems: number, userId: string) {\n    try {\n      const prizes = await Prize.find({\n        status: 'active',\n        'location.coordinates': {\n          $geoWithin: {\n            $centerSphere: [\n              [location.longitude, location.latitude],\n              location.radius / 6378.1\n            ]\n          }\n        }\n      })\n      .select('title description category points rarity location expiresAt')\n      .limit(maxItems)\n      .lean();\n\n      const userClaims = await Claim.find({ userId }).select('prizeId').lean();\n      const claimedPrizeIds = new Set(userClaims.map((claim: any) => claim.prizeId.toString()));\n\n      return prizes\n        .filter((prize: any) => !claimedPrizeIds.has(prize._id.toString()))\n        .map((prize: any) => ({\n          id: prize._id.toString(),\n          title: prize.title,\n          description: prize.description,\n          category: prize.category,\n          points: prize.points,\n          rarity: prize.rarity,\n          position: {\n            lat: prize.location.coordinates[1],\n            lng: prize.location.coordinates[0]\n          },\n          expiresAt: prize.expiresAt?.toISOString(),\n          offlineClaimable: true\n        }));\n    } catch (error: any) {\n      typedLogger.error('Get offline prizes error', { error: (error as any).message, location });\n      return [];\n    }\n  }\n\n  /**\n   * Helper: Get offline challenges\n   */\n  private static async getOfflineChallenges(userId: string) {\n    try {\n      return [\n        {\n          id: 'offline_distance',\n          title: 'Distance Walker',\n          description: 'Walk 2km while playing',\n          type: 'distance',\n          target: 2000,\n          progress: 0,\n          reward: 75,\n          offlineSupported: true\n        },\n        {\n          id: 'offline_exploration',\n          title: 'Explorer',\n          description: 'Visit 5 different locations',\n          type: 'exploration',\n          target: 5,\n          progress: 0,\n          reward: 50,\n          offlineSupported: true\n        }\n      ];\n    } catch (error: any) {\n      typedLogger.error('Get offline challenges error', { error: (error as any).message, userId });\n      return [];\n    }\n  }\n\n  /**\n   * Helper: Get offline leaderboard\n   */\n  private static async getOfflineLeaderboard() {\n    try {\n      const topUsers = await User.find({ isBanned: false })\n        .select('displayName level points')\n        .sort({ points: -1 })\n        .limit(50)\n        .lean();\n\n      return topUsers.map((user: any, index: number) => ({\n        rank: index + 1,\n        userId: user._id.toString(),\n        displayName: user.displayName,\n        level: user.level,\n        points: user.points\n      }));\n    } catch (error: any) {\n      typedLogger.error('Get offline leaderboard error', { error: (error as any).message });\n      return [];\n    }\n  }\n\n  /**\n   * Retry failed actions\n   */\n  static async retryFailedActions(userId: string) {\n    try {\n      const failedActions = await OfflineQueue.find({\n        userId: new Types.ObjectId(userId),\n        status: OfflineActionStatus.FAILED,\n        attempts: { $lt: 3 }}).limit(10);\n\n      const results = [];\n\n      for (const action of failedActions) {\n        action.status = OfflineActionStatus.SYNCING;\n        action.attempts += 1;\n        await action.save();\n\n        const result = await this.processAction(\n          userId,\n          action.actionType,\n          action.actionData,\n          ConflictResolution.SERVER_WINS\n        );\n\n        if (result.success) {\n          action.status = OfflineActionStatus.SYNCED;\n          action.syncedAt = new Date();\n        } else {\n          action.status = OfflineActionStatus.FAILED;\n          action.error = result.error;\n        }\n\n        await action.save();\n        results.push({\n          actionType: action.actionType,\n          success: result.success});\n      }\n\n      return {\n        retried: results.length,\n        results};\n      \n    } catch (error: any) {\n      typedLogger.error('Retry failed actions error', {\n        userId,\n        error: (error as any).message});\n      throw error;\n    }\n  }\n}\n\n/**\n * Enhanced Offline Routes\n */\nexport default async function offlineEnhancedRoutes(fastify: FastifyInstance) {\n  // POST /api/offline/sync - Sync offline actions\n  fastify.post('/sync', {\n    preHandler: [authenticate],\n    schema: {\n      description: 'Sync offline actions with conflict resolution',\n      tags: ['Offline'],\n      body: syncActionsSchema,\n      response: {\n        200: {\n          type: 'object',\n          properties: {\n            synced: { type: 'array', items: {} },\n            failed: { type: 'array', items: {} },\n            conflicts: { type: 'array', items: {} }\n          }\n        }\n      }\n    }\n  }, async (request: FastifyRequest<{ Body: z.infer<typeof syncActionsSchema> }>, reply: FastifyReply) => {\n    try {\n      const userId = request.user!.sub;\n      const data = request.body;\n\n      const result = await OfflineService.syncActions(userId, data);\n\n      return reply.code(200).send(result);\n    } catch (error: any) {\n      throw error;\n    }\n  });\n\n  // GET /api/offline/status - Get sync status\n  fastify.get('/status', {\n    preHandler: [authenticate],\n    schema: {\n      description: 'Get offline sync status',\n      tags: ['Offline'],\n      querystring: getSyncStatusSchema,\n      response: {\n        200: {\n          type: 'object',\n          properties: {\n            status: {\n              type: 'object',\n              properties: {\n                pending: { type: 'number' },\n                syncing: { type: 'number' },\n                synced: { type: 'number' },\n                failed: { type: 'number' },\n                conflicts: { type: 'number' },\n                total: { type: 'number' }\n              }\n            },\n            recentActions: { type: 'array', items: {} }\n          }\n        }\n      }\n    }\n  }, async (request: FastifyRequest<{ Querystring: z.infer<typeof getSyncStatusSchema> }>, reply: FastifyReply) => {\n    try {\n      const userId = request.user!.sub;\n      const data = request.query;\n\n      const result = await OfflineService.getSyncStatus(userId, data);\n\n      return reply.code(200).send(result);\n    } catch (error: any) {\n      throw error;\n    }\n  });\n\n  // POST /api/offline/retry - Retry failed actions\n  fastify.post('/retry', {\n    preHandler: [authenticate],\n    schema: {\n      description: 'Retry failed offline actions',\n      tags: ['Offline'],\n      response: {\n        200: {\n          type: 'object',\n          properties: {\n            retried: { type: 'number' },\n            results: { type: 'array', items: {} }\n          }\n        }\n      }\n    }\n  }, async (request: FastifyRequest, reply: FastifyReply) => {\n    try {\n      const userId = request.user!.sub;\n\n      const result = await OfflineService.retryFailedActions(userId);\n\n      return reply.code(200).send(result);\n    } catch (error: any) {\n      throw error;\n    }\n  });\n\n  // POST /api/offline/data/download - Download offline data package\n  fastify.post('/data/download', {\n    preHandler: [authenticate],\n    schema: {\n      description: 'Download offline data package for Unity',\n      tags: ['Offline'],\n      response: {\n        200: {\n          type: 'object',\n          properties: {\n            success: { type: 'boolean' },\n            data: {\n              type: 'object',\n              properties: {\n                packageId: { type: 'string' },\n                data: { type: 'object' },\n                metadata: { type: 'object' }\n              }\n            }\n          }\n        }\n      }\n    }\n  }, async (request: FastifyRequest, reply: FastifyReply) => {\n    try {\n      const userId = request.user!.sub;\n      const result = await OfflineService.getOfflineDataPackage(userId, request.body);\n      return reply.code(200).send({ success: true, data: result });\n    } catch (error: any) {\n      throw error;\n    }\n  });\n\n  // GET /api/offline/capabilities - Get offline capabilities\n  fastify.get('/capabilities', {\n    preHandler: [authenticate],\n    schema: {\n      description: 'Get offline capabilities and limits',\n      tags: ['Offline'],\n      response: {\n        200: {\n          type: 'object',\n          properties: {\n            success: { type: 'boolean' },\n            data: {\n              type: 'object',\n              properties: {\n                maxOfflineDuration: { type: 'number' },\n                maxOfflineActions: { type: 'number' },\n                supportedActions: { type: 'array', items: {} }\n              }\n            }\n          }\n        }\n      }\n    }\n  }, async (request: FastifyRequest, reply: FastifyReply) => {\n    try {\n      const userId = request.user!.sub;\n      const result = await OfflineService.getOfflineCapabilities(userId);\n      return reply.code(200).send({ success: true, data: result });\n    } catch (error: any) {\n      throw error;\n    }\n  });\n\n  // POST /api/offline/validate - Validate offline action\n  fastify.post('/validate', {\n    preHandler: [authenticate],\n    schema: {\n      description: 'Validate offline action before sync',\n      tags: ['Offline'],\n      response: {\n        200: {\n          type: 'object',\n          properties: {\n            success: { type: 'boolean' },\n            data: {\n              type: 'object',\n              properties: {\n                isValid: { type: 'boolean' },\n                errors: { type: 'array', items: { type: 'string' } },\n                warnings: { type: 'array', items: { type: 'string' } }\n              }\n            }\n          }\n        }\n      }\n    }\n  }, async (request: FastifyRequest, reply: FastifyReply) => {\n    try {\n      const { action, deviceInfo } = request.body as any;\n      const result = await OfflineService.validateOfflineAction(action, deviceInfo);\n      return reply.code(200).send({ success: true, data: result });\n    } catch (error: any) {\n      throw error;\n    }\n  });\n}\n\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\offline\\routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\prizes\\index.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'requireAdmin' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'config' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'IPrizeDocument' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":76,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":90},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'IPrizeModel' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":92,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":103},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'IUserDocument' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":105,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":118},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'prizeDetailsSchema' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":31,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":31,"endColumn":25},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":159,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":159,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5832,5835],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5832,5835],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":202,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":202,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7090,7093],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7090,7093],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":223,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":223,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7515,7518],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7515,7518],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":257,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":257,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8695,8698],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8695,8698],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":271,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":271,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8956,8959],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8956,8959],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":308,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":308,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10008,10011],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10008,10011],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":357,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":357,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11461,11464],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11461,11464],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":413,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":413,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13003,13006],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13003,13006],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":446,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":446,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13722,13725],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13722,13725],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":469,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":469,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14299,14302],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14299,14302],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":489,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":489,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14804,14807],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14804,14807],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":518,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":518,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15442,15445],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15442,15445],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":532,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":532,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15750,15753],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15750,15753],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":557,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":557,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16308,16311],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16308,16311],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":604,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":604,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17726,17729],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17726,17729],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":638,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":638,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18639,18642],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18639,18642],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":664,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":664,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19342,19345],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19342,19345],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":23,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyInstance } from 'fastify';\nimport { authenticate, requireAdmin } from '@/middleware/auth';\nimport { z } from 'zod';\nimport { Types } from 'mongoose';\nimport { Prize } from '@/models/Prize';\nimport { User } from '@/models/User';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { config, TUNISIA_CITIES } from '@/config';\nimport { PrizeType, PrizeCategory, PrizeRarity, PrizeStatus, LocationType, IPrizeDocument, IPrizeModel, IUserDocument } from '@/types';\nimport { calculateGeodesicDistance, isWithinTunisia, findNearestCity } from '@/utils/geo';\nimport { validateAntiCheat } from '@/utils/anti-cheat';\n\n// Validation schemas\nconst nearbyPrizesSchema = z.object({\n  lat: z.number().min(-90).max(90),\n  lng: z.number().min(-180).max(180),\n  radius: z.number().min(0.1).max(50).default(5), // km\n  category: z.enum(Object.values(PrizeCategory) as [string, ...string[]]).optional(),\n  rarity: z.enum(Object.values(PrizeRarity) as [string, ...string[]]).optional(),\n  minPoints: z.number().min(1).optional(),\n  maxPoints: z.number().min(1).optional(),\n  limit: z.number().min(1).max(100).default(50)});\n\nconst cityPrizesSchema = z.object({\n  city: z.enum(Object.keys(TUNISIA_CITIES) as [string, ...string[]]),\n  category: z.enum(Object.values(PrizeCategory) as [string, ...string[]]).optional(),\n  rarity: z.enum(Object.values(PrizeRarity) as [string, ...string[]]).optional(),\n  limit: z.number().min(1).max(100).default(50),\n  page: z.number().min(1).default(1)});\n\nconst prizeDetailsSchema = z.object({\n  prizeId: z.string().regex(/^[0-9a-fA-F]{24}$/, 'Invalid prize ID')});\n\nconst searchPrizesSchema = z.object({\n  query: z.string().min(1).max(100),\n  city: z.enum(Object.keys(TUNISIA_CITIES) as [string, ...string[]]).optional(),\n  category: z.enum(Object.values(PrizeCategory) as [string, ...string[]]).optional(),\n  limit: z.number().min(1).max(50).default(20),\n  page: z.number().min(1).default(1)});\n\nconst createPrizeSchema = z.object({\n  name: z.string().min(2).max(100),\n  description: z.string().min(10).max(500),\n  type: z.enum(Object.values(PrizeType) as [string, ...string[]]),\n  category: z.enum(Object.values(PrizeCategory) as [string, ...string[]]),\n  points: z.number().min(1).max(10000),\n  rarity: z.enum(Object.values(PrizeRarity) as [string, ...string[]]),\n  quantity: z.number().min(1).max(1000).default(1),\n  location: z.object({\n    type: z.enum(Object.values(LocationType) as [string, ...string[]]).default(LocationType.GPS),\n    coordinates: z.array(z.number()).length(2), // [lng, lat]\n    radius: z.number().min(10).max(500).default(50),\n    city: z.enum(Object.keys(TUNISIA_CITIES) as [string, ...string[]]),\n    address: z.string().max(200).optional(),\n    markerUrl: z.string().url().optional(),\n    confidenceThreshold: z.number().min(0.1).max(1.0).default(0.8)}),\n  visibility: z.object({\n    startAt: z.string().datetime().optional(),\n    endAt: z.string().datetime().optional()}).optional(),\n  expiresAt: z.string().datetime().optional(),\n  imageUrl: z.string().url().optional(),\n  value: z.number().min(0).optional(),\n  tags: z.array(z.string().max(20)).max(10).default([])});\n\nconst updatePrizeSchema = createPrizeSchema.partial();\n\nconst bulkCreatePrizesSchema = z.object({\n  prizes: z.array(createPrizeSchema).min(1).max(100)});\n\n/**\n * Prize service\n */\nexport class PrizeService {\n  /**\n   * Get nearby prizes for a user\n   */\n  static async getNearbyPrizes(\n    userId: string,\n    data: z.infer<typeof nearbyPrizesSchema>\n  ) {\n    try {\n      // Validate location is within Tunisia\n      if (!isWithinTunisia({ lat: data.lat, lng: data.lng })) {\n        throw new Error('LOCATION_OUT_OF_BOUNDS');\n      }\n\n      // Anti-cheat: block suspicious location signals\n      const antiCheatResult = await validateAntiCheat(\n        userId,\n        { lat: data.lat, lng: data.lng },\n        undefined\n      );\n      if (!antiCheatResult.allowed) {\n        typedLogger.warn('Nearby prizes blocked by anti-cheat', {\n          userId,\n          location: { lat: data.lat, lng: data.lng },\n          violations: antiCheatResult.violations,\n          riskScore: antiCheatResult.riskScore,\n        });\n        throw new Error('ANTI_CHEAT_VIOLATION');\n      }\n\n      // Find nearby prizes\n      const prizes = await Prize.findNearby(\n        data.lat,\n        data.lng,\n        data.radius,\n        {\n          category: data.category,\n          rarity: data.rarity,\n          minPoints: data.minPoints,\n          maxPoints: data.maxPoints,\n          limit: data.limit}\n      );\n\n      // Calculate distance for each prize\n      const prizesWithDistance = prizes.map(prize => {\n        const [lng, lat] = prize.location.coordinates;\n        const distance = calculateGeodesicDistance(\n          { lat: data.lat, lng: data.lng },\n          { lat, lng }\n        );\n\n        return {\n          ...prize.toJSON(),\n          distance: Math.round(distance),\n          isWithinRadius: distance <= prize.location.radius};\n      });\n\n      // Update user location\n      const user = await User.findById(userId);\n      if (user) {\n        const city = findNearestCity({ lat: data.lat, lng: data.lng });\n          user.location = {\n            lat: data.lat,\n            lng: data.lng,\n            city,\n            lastUpdated: new Date()\n          };\n        await user.save();\n      }\n\n      typedLogger.info('Nearby prizes retrieved', {\n        userId,\n        location: { lat: data.lat, lng: data.lng },\n        radius: data.radius,\n        count: prizes.length});\n\n      return {\n        prizes: prizesWithDistance,\n        location: {\n          lat: data.lat,\n          lng: data.lng,\n          city: findNearestCity({ lat: data.lat, lng: data.lng })},\n        total: prizes.length};\n\n    } catch (error) {\n      typedLogger.error('Get nearby prizes error', {\n        error: (error as any).message,\n        userId,\n        location: { lat: data.lat, lng: data.lng }});\n      throw error;\n    }\n  }\n\n  /**\n   * Get prizes by city\n   */\n  static async getCityPrizes(data: z.infer<typeof cityPrizesSchema>) {\n    try {\n      const skip = (data.page - 1) * data.limit;\n\n      const prizes = await Prize.findByCity(data.city, {\n        category: data.category,\n        rarity: data.rarity,\n        limit: data.limit,\n        skip});\n\n      const total = await Prize.countDocuments({\n        'location.city': data.city,\n        status: PrizeStatus.ACTIVE,\n        'visibility.startAt': { $lte: new Date() },\n        $or: [\n          { 'visibility.endAt': { $exists: false } },\n          { 'visibility.endAt': { $gt: new Date() } }\n        ],\n        ...(data.category && { category: data.category }),\n        ...(data.rarity && { rarity: data.rarity })});\n\n      return {\n        prizes: prizes.map(prize => prize.toJSON()),\n        pagination: {\n          page: data.page,\n          limit: data.limit,\n          total,\n          pages: Math.ceil(total / data.limit),\n          hasNext: skip + data.limit < total,\n          hasPrev: data.page > 1}};\n\n    } catch (error) {\n      typedLogger.error('Get city prizes error', {\n        error: (error as any).message,\n        city: data.city});\n      throw error;\n    }\n  }\n\n  /**\n   * Get prize details\n   */\n  static async getPrizeDetails(\n    userId: string,\n    prizeId: string,\n    userLocation?: { lat: number; lng: number }\n  ) {\n    try {\n      const prize = await Prize.findById(prizeId).populate('createdBy', 'displayName');\n\n      if (!prize) {\n        throw new Error('PRIZE_NOT_FOUND');\n      }\n\n      const result: any = {\n        ...prize.toJSON(),\n        canClaim: prize.status === 'active' && prize.claimedCount < prize.quantity};\n\n      // Calculate distance if user location provided\n      if (userLocation) {\n        const antiCheatResult = await validateAntiCheat(\n          userId,\n          { lat: userLocation.lat, lng: userLocation.lng },\n          undefined\n        );\n        if (!antiCheatResult.allowed) {\n          typedLogger.warn('Prize details blocked by anti-cheat', {\n            userId,\n            prizeId,\n            location: userLocation,\n            violations: antiCheatResult.violations,\n            riskScore: antiCheatResult.riskScore,\n          });\n          throw new Error('ANTI_CHEAT_VIOLATION');\n        }\n\n        const [lng, lat] = prize.location.coordinates;\n        const distance = calculateGeodesicDistance(userLocation, { lat, lng });\n\n        result.distance = Math.round(distance);\n        result.isWithinRadius = distance <= prize.location.radius;\n        result.canClaim = result.canClaim && result.isWithinRadius;\n      }\n\n      return result;\n\n    } catch (error) {\n      typedLogger.error('Get prize details error', {\n        error: (error as any).message,\n        userId,\n        prizeId});\n      throw error;\n    }\n  }\n\n  /**\n   * Search prizes\n   */\n  static async searchPrizes(data: z.infer<typeof searchPrizesSchema>) {\n    try {\n      const skip = (data.page - 1) * data.limit;\n\n      const query: any = {\n        $text: { $search: data.query },\n        status: PrizeStatus.ACTIVE,\n        'visibility.startAt': { $lte: new Date() },\n        $or: [\n          { 'visibility.endAt': { $exists: false } },\n          { 'visibility.endAt': { $gt: new Date() } }\n        ]};\n\n      if (data.city) {\n        query['location.city'] = data.city;\n      }\n\n      if (data.category) {\n        query.category = data.category;\n      }\n\n      const prizes = await Prize.find(query)\n        .sort({ score: { $meta: 'textScore' }, points: -1 })\n        .limit(data.limit)\n        .skip(skip);\n\n      const total = await Prize.countDocuments(query);\n\n      return {\n        prizes: prizes.map(prize => prize.toJSON()),\n        query: data.query,\n        pagination: {\n          page: data.page,\n          limit: data.limit,\n          total,\n          pages: Math.ceil(total / data.limit),\n          hasNext: skip + data.limit < total,\n          hasPrev: data.page > 1}};\n\n    } catch (error) {\n      typedLogger.error('Search prizes error', {\n        error: (error as any).message,\n        query: data.query});\n      throw error;\n    }\n  }\n\n  /**\n   * Create a new prize (admin only)\n   */\n  static async createPrize(\n    adminId: string,\n    data: z.infer<typeof createPrizeSchema>\n  ) {\n    try {\n      // Validate coordinates are within Tunisia\n      const [lng, lat] = data.location.coordinates;\n      if (!isWithinTunisia({ lat, lng })) {\n        throw new Error('COORDINATES_OUT_OF_BOUNDS');\n      }\n\n      // Auto-detect city if not matching coordinates\n      const detectedCity = findNearestCity({ lat, lng });\n      if (data.location.city !== detectedCity) {\n        typedLogger.warn('City mismatch detected', {\n          provided: data.location.city,\n          detected: detectedCity,\n          coordinates: [lng, lat]});\n      }\n\n      const prize = new Prize({\n        ...data,\n        createdBy: new Types.ObjectId(adminId),\n        visibility: {\n          startAt: data.visibility?.startAt ? new Date(data.visibility.startAt) : new Date(),\n          endAt: data.visibility?.endAt ? new Date(data.visibility.endAt) : undefined},\n        expiresAt: data.expiresAt ? new Date(data.expiresAt) : undefined});\n\n      await prize.save();\n\n      typedLogger.info('Prize created', {\n        prizeId: prize._id,\n        adminId,\n        name: prize.name,\n        location: prize.location});\n\n      return prize.toJSON();\n\n    } catch (error) {\n      typedLogger.error('Create prize error', {\n        error: (error as any).message,\n        adminId,\n        prizeName: data.name});\n      throw error;\n    }\n  }\n\n  /**\n   * Update a prize (admin only)\n   */\n  static async updatePrize(\n    adminId: string,\n    prizeId: string,\n    data: z.infer<typeof updatePrizeSchema>\n  ) {\n    try {\n      const prize = await Prize.findById(prizeId);\n\n      if (!prize) {\n        throw new Error('PRIZE_NOT_FOUND');\n      }\n\n      // Validate coordinates if provided\n      if (data.location?.coordinates) {\n        const [lng, lat] = data.location.coordinates;\n        if (!isWithinTunisia({ lat, lng })) {\n          throw new Error('COORDINATES_OUT_OF_BOUNDS');\n        }\n      }\n\n      // Update fields\n      Object.keys(data).forEach(key => {\n        if (data[key] !== undefined) {\n          if (key === 'visibility' && data.visibility) {\n            prize.visibility = {\n              startAt: data.visibility.startAt ? new Date(data.visibility.startAt) : prize.visibility.startAt,\n              endAt: data.visibility.endAt ? new Date(data.visibility.endAt) : prize.visibility.endAt};\n          } else if (key === 'expiresAt' && data.expiresAt) {\n            prize.expiresAt = new Date(data.expiresAt);\n          } else {\n            prize[key] = data[key];\n          }\n        }\n      });\n\n      await prize.save();\n\n      typedLogger.info('Prize updated', {\n        prizeId: prize._id,\n        adminId,\n        updates: Object.keys(data)});\n\n      return prize.toJSON();\n\n    } catch (error) {\n      typedLogger.error('Update prize error', {\n        error: (error as any).message,\n        adminId,\n        prizeId});\n      throw error;\n    }\n  }\n\n  /**\n   * Delete a prize (admin only) - Hard delete\n   */\n  static async deletePrize(adminId: string, prizeId: string) {\n    try {\n      const prize = await Prize.findById(prizeId);\n\n      if (!prize) {\n        throw new Error('PRIZE_NOT_FOUND');\n      }\n\n      const prizeName = prize.name;\n      \n      // Hard delete - actually remove from database\n      await Prize.findByIdAndDelete(prizeId);\n\n      typedLogger.info('Prize deleted', {\n        prizeId,\n        adminId,\n        name: prizeName\n      });\n\n      return { success: true };\n\n    } catch (error) {\n      typedLogger.error('Delete prize error', {\n        error: (error as any).message,\n        adminId,\n        prizeId});\n      throw error;\n    }\n  }\n\n  /**\n   * Bulk create prizes (admin only)\n   */\n  static async bulkCreatePrizes(\n    adminId: string,\n    data: z.infer<typeof bulkCreatePrizesSchema>\n  ) {\n    try {\n      const results = [];\n      const errors = [];\n\n      for (let i = 0; i < data.prizes.length; i++) {\n        try {\n          const prize = await this.createPrize(adminId, data.prizes[i]);\n          results.push({ index: i, success: true, prize });\n        } catch (error) {\n          errors.push({ index: i, error: (error as any).message });\n        }\n      }\n\n      typedLogger.info('Bulk prizes created', {\n        adminId,\n        total: data.prizes.length,\n        successful: results.length,\n        failed: errors.length});\n\n      return {\n        successful: results,\n        failed: errors,\n        summary: {\n          total: data.prizes.length,\n          successful: results.length,\n          failed: errors.length}};\n\n    } catch (error) {\n      typedLogger.error('Bulk create prizes error', {\n        error: (error as any).message,\n        adminId,\n        count: data.prizes.length});\n      throw error;\n    }\n  }\n\n  /**\n   * Get prize statistics\n   */\n  static async getPrizeStats(city?: string) {\n    try {\n      const stats = await Prize.getStatsByCity();\n\n      if (city) {\n        return stats.find(stat => stat._id === city) || {\n          _id: city,\n          totalPrizes: 0,\n          activePrizes: 0,\n          claimedPrizes: 0,\n          totalPoints: 0,\n          averagePoints: 0,\n          rarityDistribution: []};\n      }\n\n      return stats;\n\n    } catch (error) {\n      typedLogger.error('Get prize stats error', {\n        error: (error as any).message,\n        city});\n      throw error;\n    }\n  }\n\n  /**\n   * Get heatmap data for prizes\n   */\n  static async getHeatmapData(city?: string) {\n    try {\n      return await Prize.getHeatmapData(city);\n    } catch (error) {\n      typedLogger.error('Get heatmap data error', {\n        error: (error as any).message,\n        city});\n      throw error;\n    }\n  }\n}\n\n/**\n * Prize routes\n */\nexport default async function prizeRoutes(fastify: FastifyInstance) {\n  // Get nearby prizes\n  fastify.get('/nearby', {\n    preHandler: [authenticate]}, async (request, reply) => {\n    try {\n      const result = await PrizeService.getNearbyPrizes(\n        request.user!.sub,\n        request.query\n      );\n\n      reply.send({\n        success: true,\n        data: result,\n        timestamp: new Date().toISOString()});\n    } catch (error) {\n      const message = (error as any).message;\n      const statusCode = message === 'LOCATION_OUT_OF_BOUNDS'\n        ? 400\n        : message === 'ANTI_CHEAT_VIOLATION'\n          ? 403\n          : 500;\n      reply.code(statusCode).send({\n        success: false,\n        error: message,\n        timestamp: new Date().toISOString()});\n    }\n  });\n\n  // Get prizes by city\n  fastify.get<{ Params: { city: string }, Querystring: z.infer<typeof cityPrizesSchema> }>('/city/:city', {\n    preHandler: [authenticate],\n    schema: {\n      params: {\n        type: 'object',\n        required: ['city'],\n        properties: {\n          city: { type: 'string', enum: Object.keys(TUNISIA_CITIES) }\n        }\n      },\n      querystring: {\n        type: 'object',\n        properties: {\n          category: { type: 'string', enum: Object.values(PrizeCategory) },\n          rarity: { type: 'string', enum: Object.values(PrizeRarity) },\n          limit: { type: 'number', minimum: 1, maximum: 100, default: 50 },\n          page: { type: 'number', minimum: 1, default: 1 }\n        }\n      },\n    }\n  }, async (request, reply) => {\n    try {\n      const result = await PrizeService.getCityPrizes({\n        ...request.query,\n        city: request.params.city});\n\n      reply.send({\n        success: true,\n        data: result,\n        timestamp: new Date().toISOString()});\n    } catch (error) {\n      reply.code(500).send({\n        success: false,\n        error: (error as any).message,\n        timestamp: new Date().toISOString()});\n    }\n  });\n\n  // Get prize details\n  fastify.get<{ Params: { prizeId: string }, Querystring: { lat?: number, lng?: number } }>('/:prizeId', {\n    preHandler: [authenticate],\n    schema: {\n      querystring: {\n        type: 'object',\n        properties: {\n          lat: { type: 'number' },\n          lng: { type: 'number' }\n        }\n      }\n    }\n  }, async (request, reply) => {\n    try {\n      const userLocation = request.query.lat && request.query.lng ? {\n        lat: request.query.lat,\n        lng: request.query.lng} : undefined;\n\n      const result = await PrizeService.getPrizeDetails(\n        request.user!.sub,\n        request.params.prizeId,\n        userLocation\n      );\n\n      reply.send({\n        success: true,\n        data: result,\n        timestamp: new Date().toISOString()});\n    } catch (error) {\n      const message = (error as any).message;\n      const statusCode = message === 'PRIZE_NOT_FOUND'\n        ? 404\n        : message === 'ANTI_CHEAT_VIOLATION'\n          ? 403\n          : 500;\n      reply.code(statusCode).send({\n        success: false,\n        error: message,\n        timestamp: new Date().toISOString()});\n    }\n  });\n\n  // Search prizes\n  fastify.get('/search', {\n    preHandler: [authenticate]}, async (request, reply) => {\n    try {\n      const result = await PrizeService.searchPrizes(request.query);\n\n      reply.send({\n        success: true,\n        data: result,\n        timestamp: new Date().toISOString()});\n    } catch (error) {\n      reply.code(500).send({\n        success: false,\n        error: (error as any).message,\n        timestamp: new Date().toISOString()});\n    }\n  });\n\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\prizes\\routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\rewards\\index.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'updateRewardSchema' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":48,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":48,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'addStockSchema' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":50,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":50,"endColumn":21},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":68,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":68,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2563,2566],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2563,2566],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":79,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2928,2931],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2928,2931],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":127,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":127,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4299,4302],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4299,4302],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":168,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":168,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5456,5459],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5456,5459],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":320,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":320,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9954,9957],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9954,9957],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":330,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":330,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10146,10149],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10146,10149],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":336,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":336,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10306,10309],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10306,10309],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":364,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":364,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11060,11063],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11060,11063],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":379,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":379,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11423,11426],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11423,11426],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":387,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":387,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11571,11574],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11571,11574],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":397,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":397,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11881,11884],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11881,11884],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":405,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":405,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12042,12045],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12042,12045],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":416,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":416,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12476,12479],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12476,12479],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":424,"column":79,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":424,"endColumn":82,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12665,12668],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12665,12668],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":435,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":435,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13110,13113],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13110,13113],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":443,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":443,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13279,13282],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13279,13282],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":448,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":448,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13519,13522],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13519,13522],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":456,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":456,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13684,13687],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13684,13687],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":456,"column":81,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":456,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13703,13706],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13703,13706],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":462,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":462,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13858,13861],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13858,13861],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":501,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":501,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15193,15196],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15193,15196],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":509,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":509,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15341,15344],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15341,15344],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":509,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":509,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15355,15358],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15355,15358],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":512,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":512,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15431,15434],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15431,15434],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":595,"column":116,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":595,"endColumn":119,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18139,18142],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18139,18142],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":600,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":600,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18397,18400],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18397,18400],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":617,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":617,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18991,18994],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18991,18994],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":617,"column":78,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":617,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19043,19046],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19043,19046],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":641,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":641,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19760,19763],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19760,19763],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":649,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":649,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19964,19967],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19964,19967],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":683,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":683,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20887,20890],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20887,20890],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":697,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":697,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21335,21338],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21335,21338],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":697,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":697,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21380,21383],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21380,21383],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":698,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":698,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21423,21426],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21423,21426],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":698,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":698,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21456,21459],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21456,21459],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":716,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":716,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21993,21996],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21993,21996],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":737,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":737,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22576,22579],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22576,22579],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":779,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":779,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23505,23508],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23505,23508],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":779,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":779,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23524,23527],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23524,23527],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":781,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":781,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23562,23565],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23562,23565],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":792,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":792,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23927,23930],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23927,23930],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":796,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":796,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24101,24104],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24101,24104],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":800,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":800,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24242,24245],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24242,24245],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":808,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":808,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24400,24403],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24400,24403],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":812,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":812,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24583,24586],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24583,24586],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1037,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1037,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[30971,30974],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[30971,30974],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1063,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1063,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31653,31656],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31653,31656],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1074,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1074,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32025,32028],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32025,32028],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1102,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1102,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32940,32943],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32940,32943],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1132,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1132,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[33641,33644],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[33641,33644],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1167,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1167,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[34842,34845],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[34842,34845],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1171,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1171,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[35043,35046],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[35043,35046],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1182,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1182,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[35408,35411],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[35408,35411],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1198,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1198,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[36041,36044],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[36041,36044],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1218,"column":108,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1218,"endColumn":111,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[36763,36766],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[36763,36766],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1221,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1221,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[36892,36895],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[36892,36895],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1224,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1224,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[37033,37036],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[37033,37036],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1228,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1228,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[37190,37193],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[37190,37193],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1232,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1232,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[37322,37325],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[37322,37325],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1251,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1251,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[37965,37968],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[37965,37968],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1255,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1255,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[38097,38100],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[38097,38100],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1261,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1261,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[38301,38304],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[38301,38304],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1270,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1270,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[38563,38566],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[38563,38566],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1294,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1294,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[39328,39331],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[39328,39331],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1317,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1317,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[40144,40147],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[40144,40147],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1326,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1326,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[40518,40521],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[40518,40521],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1348,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1348,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[41229,41232],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[41229,41232],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1367,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1367,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[41868,41871],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[41868,41871],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1391,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1391,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[42616,42619],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[42616,42619],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":71,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';\nimport { authenticate } from '@/middleware/auth';\nimport { z } from 'zod';\nimport { Types } from 'mongoose';\nimport { Reward } from '@/models/Reward';\nimport { Redemption } from '@/models/Redemption';\nimport { Code } from '@/models/Code';\nimport { User } from '@/models/User';\nimport { Partner } from '@/models/Partner';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { RewardCategory, RedemptionStatus, CodeStatus } from '@/types';\nimport { checkIdempotency, setIdempotency } from '@/utils/idempotency';\nimport { normalizeError } from '@/utils/api-errors';\nimport { broadcastAdminEvent } from '@/lib/websocket';\nimport { PartnerLocationsService } from '@/services/partner-locations';\nimport { PartnerStatsService } from '@/services/partner-stats';\n\n// Validation schemas\nconst getRewardsSchema = z.object({\n  category: z.enum(Object.values(RewardCategory) as [string, ...string[]]).optional(),\n  minCost: z.number().min(1).optional(),\n  maxCost: z.number().min(1).optional(),\n  popular: z.boolean().optional(),\n  page: z.number().min(1).default(1),\n  limit: z.number().min(1).max(100).default(50),\n  sort: z.enum(['pointsCost', 'name', 'popularity']).default('pointsCost')});\n\nconst searchRewardsSchema = z.object({\n  query: z.string().min(1).max(100),\n  category: z.enum(Object.values(RewardCategory) as [string, ...string[]]).optional(),\n  limit: z.number().min(1).max(50).default(20)});\n\nconst redeemRewardSchema = z.object({\n  rewardId: z.string().regex(/^[0-9a-fA-F]{24}$/, 'Invalid reward ID'),\n  idempotencyKey: z.string().min(1).max(100)});\n\nconst createRewardSchema = z.object({\n  name: z.string().min(2).max(100),\n  description: z.string().min(10).max(500),\n  category: z.enum(Object.values(RewardCategory) as [string, ...string[]]),\n  pointsCost: z.number().min(1).max(100000),\n  stockQuantity: z.number().min(1).max(10000),\n  imageUrl: z.string().url().optional(),\n  isPopular: z.boolean().default(false),\n  partnerId: z.string().regex(/^[0-9a-fA-F]{24}$/).optional(),\n  metadata: z.record(z.any()).optional()});\n\nconst updateRewardSchema = createRewardSchema.partial();\n\nconst addStockSchema = z.object({\n  quantity: z.number().min(1).max(1000)});\n\nconst promoCodeSchema = z.object({\n  code: z.string().min(4).max(64)\n});\n\n/**\n * Rewards service\n */\nexport class RewardsService {\n  /**\n   * Get available rewards\n   */\n  static async getRewards(data: z.infer<typeof getRewardsSchema>) {\n    try {\n      const skip = (data.page - 1) * data.limit;\n\n      const query: any = {\n        isActive: true,\n        stockAvailable: { $gt: 0 }};\n\n      if (data.category) query.category = data.category;\n      if (data.maxCost) query.pointsCost = { ...query.pointsCost, $lte: data.maxCost };\n      if (data.minCost) {\n        query.pointsCost = { ...query.pointsCost, $gte: data.minCost };\n      }\n\n      // Build sort object\n      let sort: any = {};\n      if (data.sort === 'popularity') {\n        sort = { 'stats.redemptionsCount': -1 }; // Sort by redemption count\n      } else if (data.sort === 'pointsCost') {\n        sort = { pointsCost: 1 };\n      } else {\n        sort = { name: 1 };\n      }\n\n      const [rewards, total] = await Promise.all([\n        Reward.find(query)\n          .populate('partnerId', 'name logo logoUrl')\n          .sort(sort)\n          .skip(skip)\n          .limit(data.limit),\n        Reward.countDocuments(query)\n      ]);\n\n      return {\n        rewards: rewards.map(reward => {\n          // Add isAvailable property to match expected format\n          return {\n            ...reward.toJSON(),\n            isAvailable: reward.stockAvailable > 0\n          };\n        }),\n        pagination: {\n          page: data.page,\n          limit: data.limit,\n          total,\n          pages: Math.ceil(total / data.limit),\n          hasNext: skip + data.limit < total,\n          hasPrev: data.page > 1}};\n\n    } catch (error) {\n      const normalized = normalizeError(error, 'Get rewards failed');\n      typedLogger.error('Get rewards error', {\n        error: normalized.message,\n        filters: data});\n      throw new Error(normalized.code);\n    }\n  }\n\n  /**\n   * Search rewards\n   */\n  static async searchRewards(data: z.infer<typeof searchRewardsSchema>) {\n    try {\n      const query: any = {\n        $text: { $search: data.query },  // Assumes a text index is created on name and description\n        isActive: true,\n        stockAvailable: { $gt: 0 }\n      };\n\n      if (data.category) query.category = data.category;\n\n      const rewards = await Reward.find(query)\n        .populate('partnerId', 'name logo logoUrl')\n        .limit(data.limit);\n\n      return {\n        rewards: rewards.map(reward => ({\n          ...reward.toJSON(),\n          isAvailable: reward.stockAvailable > 0\n        })),\n        query: data.query,\n        total: rewards.length};\n\n    } catch (error) {\n      const normalized = normalizeError(error, 'Search rewards failed');\n      typedLogger.error('Search rewards error', {\n        error: normalized.message,\n        query: data.query});\n      throw new Error(normalized.code);\n    }\n  }\n\n  /**\n   * Get reward details\n   */\n  static async getRewardDetails(rewardId: string, userId?: string) {\n    try {\n      const reward = await Reward.findById(rewardId)\n        .populate('partnerId', 'name logo logoUrl website');\n\n      if (!reward) {\n        throw new Error('REWARD_NOT_FOUND');\n      }\n\n      const result: any = {\n        ...reward.toJSON(),\n        canRedeem: reward.stockAvailable > 0,\n        isAvailable: reward.stockAvailable > 0};\n\n      // Check if user can afford this reward\n      if (userId) {\n        const user = await User.findById(userId);\n        if (user) {\n          result.canAfford = user.points.available >= reward.pointsCost;\n          result.canRedeem = result.canRedeem && result.canAfford;\n        }\n      }\n\n      return result;\n\n    } catch (error) {\n      const normalized = normalizeError(error, 'Get reward details failed');\n      typedLogger.error('Get reward details error', {\n        error: normalized.message,\n        rewardId,\n        userId});\n      throw new Error(normalized.code);\n    }\n  }\n\n  /**\n   * Redeem a reward\n   */\n  static async redeemReward(\n    userId: string,\n    data: z.infer<typeof redeemRewardSchema>\n  ) {\n    try {\n      // Check idempotency\n      const existingResult = await checkIdempotency(data.idempotencyKey);\n      if (existingResult) {\n        typedLogger.info('Idempotent redemption request', {\n          userId,\n          rewardId: data.rewardId,\n          idempotencyKey: data.idempotencyKey});\n        return existingResult;\n      }\n\n      // Get user and reward\n      const [user, reward] = await Promise.all([\n        User.findById(userId),\n        Reward.findById(data.rewardId).populate('partnerId', 'name')]);\n\n      if (!user) {\n        throw new Error('USER_NOT_FOUND');\n      }\n\n      if (!reward) {\n        throw new Error('REWARD_NOT_FOUND');\n      }\n\n      if (reward.stockAvailable <= 0) {\n        throw new Error('REWARD_NOT_AVAILABLE');\n      }\n\n      if (user.points.available < reward.pointsCost) {\n        throw new Error('INSUFFICIENT_POINTS');\n      }\n\n      // Check stock availability\n      if (reward.stockAvailable < 1) {\n        throw new Error('OUT_OF_STOCK');\n      }\n\n      // Try to get a code for this reward\n      const code = await Code.reserveCode(\n        new Types.ObjectId(data.rewardId),\n        new Types.ObjectId(userId)\n      );\n\n      // Create redemption record\n      const redemption = new Redemption({\n        userId: new Types.ObjectId(userId),\n        rewardId: new Types.ObjectId(data.rewardId),\n        pointsSpent: reward.pointsCost,\n        status: RedemptionStatus.PENDING,\n        codeId: code?._id,\n        idempotencyKey: data.idempotencyKey});\n\n      // Deduct points from user\n      if (user.points.available < reward.pointsCost) {\n        throw new Error('INSUFFICIENT_POINTS');\n      }\n      user.points.available -= reward.pointsCost;\n      user.points.spent += reward.pointsCost;\n      user.stats.rewardsRedeemed = (user.stats.rewardsRedeemed || 0) + 1;\n\n      // Update reward stock\n      reward.stockAvailable -= 1;\n      reward.stockReserved = (reward.stockReserved || 0) + 1; // Track reserved stock\n\n      // Save all changes separately to avoid type issues in Promise.all\n      // The code from reserveCode is already saved, so we just save the other documents\n      await Promise.all([\n        redemption.save(),\n        user.save(),\n        reward.save()\n      ]);\n\n      // Prepare result\n      const result = {\n        success: true,\n        redemption: {\n          id: redemption._id,\n          status: redemption.status,\n          pointsSpent: redemption.pointsSpent,\n          redeemedAt: redemption.createdAt,\n          code: code ? {\n            id: code._id,\n            code: code.code,\n            poolName: code.poolName} : null},\n        newBalance: user.points.available,\n        reward: {\n          id: reward._id,\n          name: reward.name,\n          category: reward.category,\n          partner: reward.partnerId}};\n\n      const resultForCache = JSON.parse(JSON.stringify(result));\n      // Store idempotency result\n      await setIdempotency(data.idempotencyKey, resultForCache);\n\n      broadcastAdminEvent({\n        type: 'redemption_created',\n        data: {\n          redemptionId: redemption._id,\n          userId,\n          rewardId: reward._id,\n          rewardName: reward.name,\n          pointsSpent: reward.pointsCost,\n          status: redemption.status,\n          timestamp: new Date()\n        }\n      });\n\n      typedLogger.info('Reward redeemed successfully', {\n        userId,\n        rewardId: data.rewardId,\n        redemptionId: redemption._id,\n        pointsSpent: reward.pointsCost,\n        hasCode: !!code});\n\n      return result;\n\n    } catch (error) {\n      typedLogger.error('Redeem reward error', {\n        error: (error as any).message,\n        userId,\n        rewardId: data.rewardId});\n      throw error;\n    }\n  }\n\n  /**\n   * Get user redemptions\n   */\n  static async getUserRedemptions(userId: string, options: any = {}) {\n    try {\n      const page = options.page || 1;\n      const limit = options.limit || 20;\n      const skip = (page - 1) * limit;\n\n      const query: any = {\n        userId: new Types.ObjectId(userId)\n      };\n\n      const [redemptions, total] = await Promise.all([\n        Redemption.find(query)\n          .populate('rewardId', 'name description pointsCost')\n          .sort({ createdAt: -1 })\n          .skip(skip)\n          .limit(limit),\n        Redemption.countDocuments(query)\n      ]);\n\n      return {\n        redemptions: redemptions.map(redemption => redemption.toJSON()),\n        total,\n        pagination: {\n          page,\n          limit,\n          total,\n          pages: Math.ceil(total / limit),\n          hasNext: skip + limit < total,\n          hasPrev: page > 1\n        }\n      };\n\n    } catch (error) {\n      typedLogger.error('Get user redemptions error', {\n        error: (error as any).message,\n        userId});\n      throw error;\n    }\n  }\n\n\n  /**\n   * Get reward categories\n   */\n  static async getRewardCategories(): Promise<string[]> {\n    try {\n      const categories = await Reward.distinct('category');\n      return categories as string[];\n    } catch (error) {\n      typedLogger.error('Get reward categories error', { error: (error as any).message });\n      throw error;\n    }\n  }\n\n  /**\n   * Get featured rewards\n   */\n  static async getFeaturedRewards(limit: number = 10): Promise<any[]> {\n    try {\n      return await Reward.find({\n        isPopular: true,\n        isActive: true,\n        stockAvailable: { $gt: 0 }\n      })\n      .sort({ pointsCost: 1 }) // cheapest first\n      .limit(limit);\n    } catch (error) {\n      typedLogger.error('Get featured rewards error', { error: (error as any).message });\n      throw error;\n    }\n  }\n\n  /**\n   * Add reward to favorites\n   */\n  static async addToFavorites(userId: string, rewardId: string): Promise<any> {\n    try {\n      // In a real implementation, this would add to a user's favorites list\n      // For now, we'll just return the reward\n      const reward = await Reward.findById(rewardId);\n      if (!reward) {\n        throw new Error('REWARD_NOT_FOUND');\n      }\n\n      return { success: true, rewardId, message: 'Added to favorites' };\n    } catch (error) {\n      typedLogger.error('Add to favorites error', { error: (error as any).message, userId, rewardId });\n      throw error;\n    }\n  }\n\n  /**\n   * Remove reward from favorites\n   */\n  static async removeFromFavorites(userId: string, rewardId: string): Promise<any> {\n    try {\n      // In a real implementation, this would remove from a user's favorites list\n      // For now, we'll just return success\n      const reward = await Reward.findById(rewardId);\n      if (!reward) {\n        throw new Error('REWARD_NOT_FOUND');\n      }\n\n      return { success: true, rewardId, message: 'Removed from favorites' };\n    } catch (error) {\n      typedLogger.error('Remove from favorites error', { error: (error as any).message, userId, rewardId });\n      throw error;\n    }\n  }\n\n  /**\n   * Get user's favorite rewards\n   */\n  static async getFavoriteRewards(userId: string): Promise<any[]> {\n    try {\n      // For now, return an empty array - in a real system this would fetch from a user favorites collection\n      return [];\n    } catch (error) {\n      typedLogger.error('Get favorite rewards error', { error: (error as any).message, userId });\n      throw error;\n    }\n  }\n\n  /**\n   * Get redemption history for user\n   */\n  static async getRedemptionHistory(userId: string, options: any = {}): Promise<any> {\n    try {\n      const page = options.page || 1;\n      const limit = options.limit || 20;\n      const skip = (page - 1) * limit;\n\n      const query: any = { userId: new Types.ObjectId(userId) };\n\n      // Apply status filter if provided\n      if (options.status && options.status !== 'all') {\n        if (options.status === 'active') {\n          query.status = { $in: [RedemptionStatus.PENDING] };  // Only pending redemptions are \"active\"\n        } else if (options.status === 'used') {\n          query.status = RedemptionStatus.FULFILLED;\n        } else if (options.status === 'expired') {\n          // This would require checking expiration dates\n          // For now, we'll skip this since expiration logic isn't fully defined\n        }\n      }\n\n      const [redemptions, total] = await Promise.all([\n        Redemption.find(query)\n          .populate('rewardId', 'name description pointsCost')\n          .sort({ createdAt: -1 })\n          .skip(skip)\n          .limit(limit),\n        Redemption.countDocuments(query)\n      ]);\n\n      return {\n        redemptions: redemptions.map(r => ({\n          id: r._id,\n          reward: r.rewardId,\n          pointsSpent: r.pointsSpent,\n          status: r.status,\n          createdAt: r.createdAt\n        })),\n        pagination: {\n          page,\n          limit,\n          total,\n          hasMore: skip + limit < total\n        }\n      };\n    } catch (error) {\n      typedLogger.error('Get redemption history error', { error: (error as any).message, userId });\n      throw error;\n    }\n  }\n\n  /**\n   * Scan QR code for redemption\n   */\n  static async scanQRCode(userId: string, data: any): Promise<any> {\n    try {\n      // Decode QR code data from base64\n      let qrData: any;\n\n      try {\n        // Try to decode from base64\n        if (data.qrCode.startsWith('ey') || data.qrCode.length > 100) { // Likely base64 encoded\n          const decodedStr = Buffer.from(data.qrCode, 'base64').toString('utf-8');\n          qrData = JSON.parse(decodedStr);\n        } else {\n          // Direct JSON string\n          qrData = JSON.parse(data.qrCode);\n        }\n      } catch (parseError) {\n        // If parsing fails, treat the qrCode as a direct code\n        qrData = {\n          type: 'yallacatch_redemption',\n          code: data.qrCode,\n          itemId: data.itemId || null,\n          timestamp: Date.now()\n        };\n      }\n\n      // Validate QR code data\n      if (!qrData.code) {\n        throw new Error('INVALID_QR_CODE_MISSING_CODE');\n      }\n\n      if (qrData.type !== 'yallacatch_redemption') {\n        throw new Error('INVALID_QR_CODE_TYPE');\n      }\n\n      // First, get the current user to check authorization\n      const currentUser = await User.findById(userId);\n      if (!currentUser) {\n        throw new Error('USER_NOT_FOUND');\n      }\n\n      // Find the redemption associated with this code\n      // Check if this is a marketplace redemption first\n      let redemption = await Redemption.findOne({\n        'metadata.redemptionCode': qrData.code,\n        status: RedemptionStatus.PENDING\n      });\n\n      // If not found in marketplace, try searching in the Code model\n      if (!redemption) {\n        const code = await Code.findOne({\n          code: qrData.code,\n          status: CodeStatus.AVAILABLE\n        });\n\n        if (code) {\n          redemption = await Redemption.findOne({\n            codeId: code._id,\n            status: RedemptionStatus.PENDING\n          });\n        }\n      }\n\n      if (!redemption) {\n        throw new Error('REDEMPTION_NOT_FOUND_OR_ALREADY_FULFILLED');\n      }\n\n      // Check redemption status\n      if (redemption.status === RedemptionStatus.FULFILLED) {\n        throw new Error('REDEMPTION_ALREADY_FULFILLED');\n      }\n\n      if (redemption.status === RedemptionStatus.CANCELLED) {\n        throw new Error('REDEMPTION_CANCELLED');\n      }\n\n      // Authorization check: Only the original user or an authorized partner can scan\n      const redemptionUser = await User.findById(redemption.userId);\n      if (!redemptionUser) {\n        throw new Error('REDEMPTION_USER_NOT_FOUND');\n      }\n\n      const reward = await Reward.findById(redemption.rewardId).populate('partnerId', 'name');\n      if (!reward) {\n        throw new Error('REWARD_NOT_FOUND');\n      }\n\n      const { UserRole } = await import('@/types');\n      const isAdminOrMod = [UserRole.ADMIN, UserRole.SUPER_ADMIN, UserRole.MODERATOR].includes(currentUser.role as any);\n      const isSameUser = redemption.userId.toString() === userId;\n      const isPartnerUser = currentUser.role === UserRole.PARTNER\n        && currentUser.partnerId\n        && reward.partnerId\n        && currentUser.partnerId.toString() === (reward as any).partnerId._id?.toString();\n\n      if (!isAdminOrMod && !isPartnerUser && !isSameUser) {\n        throw new Error('UNAUTHORIZED_REDEMPTION_SCAN');\n      }\n\n      // Update redemption status to FULFILLED\n      redemption.status = RedemptionStatus.FULFILLED;\n      redemption.fulfilledAt = new Date();\n      // Track who fulfilled the redemption\n      redemption.redeemedBy = new Types.ObjectId(userId);\n\n      await redemption.save();\n\n      // Update user redemption stats\n      const redeemedUser = await User.findById(redemption.userId);\n      if (redeemedUser) {\n        (redeemedUser as any).stats.redemptionsFulfilled = ((redeemedUser as any).stats.redemptionsFulfilled || 0) + 1;\n        await redeemedUser.save();\n      }\n\n      // Log redemption fulfillment\n      typedLogger.info('QR code redemption fulfilled', {\n        redemptionId: redemption._id,\n        code: qrData.code,\n        userId,\n        redeemedBy: userId,\n        fulfilledAt: redemption.fulfilledAt\n      });\n\n      return {\n        success: true,\n        redemption: {\n          id: redemption._id,\n          status: redemption.status,\n          pointsSpent: redemption.pointsSpent,\n          fulfilledAt: redemption.fulfilledAt,\n          rewardId: redemption.rewardId,\n          reward: {\n            id: reward._id,\n            name: reward.name,\n            partner: (reward as any).partnerId || null\n          }\n        },\n        data: qrData,\n        userId,\n        scannedAt: new Date()};\n\n    } catch (error) {\n      typedLogger.error('Scan QR code error', { error: (error as any).message, userId, data });\n      throw error;\n    }\n  }\n\n  /**\n   * Redeem a promo code (points-only or reward -> QR)\n   */\n  static async redeemPromoCode(userId: string, data: { code: string }) {\n    const codeStr = (data.code || '').trim().toUpperCase();\n    if (!codeStr) {\n      throw new Error('INVALID_CODE');\n    }\n\n    const codeDoc = await Code.findOne({\n      code: codeStr,\n      isActive: true,\n      status: CodeStatus.AVAILABLE,\n      $or: [\n        { expiresAt: { $exists: false } },\n        { expiresAt: { $gt: new Date() } }\n      ]\n    });\n\n    if (!codeDoc) {\n      throw new Error('CODE_NOT_AVAILABLE');\n    }\n\n    // Reward-linked promo code: create redemption and return QR payload\n    if (codeDoc.rewardId) {\n      const reward = await Reward.findById(codeDoc.rewardId).populate('partnerId', 'name');\n      if (!reward) {\n        throw new Error('REWARD_NOT_FOUND');\n      }\n      if ((reward as any).stockAvailable <= 0) {\n        throw new Error('REWARD_NOT_AVAILABLE');\n      }\n\n      const redemption = new Redemption({\n        userId: new Types.ObjectId(userId),\n        rewardId: reward._id,\n        pointsSpent: 0,\n        status: RedemptionStatus.PENDING,\n        codeId: codeDoc._id,\n        idempotencyKey: `promo-${codeDoc._id}-${userId}-${Date.now()}`,\n        metadata: { redemptionCode: codeDoc.code }\n      });\n\n      (reward as any).stockAvailable = Math.max(0, (reward as any).stockAvailable - 1);\n      (reward as any).stockReserved = ((reward as any).stockReserved || 0) + 1;\n\n      codeDoc.status = CodeStatus.USED;\n      codeDoc.isUsed = true;\n      codeDoc.usedBy = new Types.ObjectId(userId);\n      codeDoc.usedAt = new Date();\n\n      await Promise.all([\n        redemption.save(),\n        reward.save(),\n        codeDoc.save()\n      ]);\n\n      const qrPayload = Buffer.from(JSON.stringify({\n        type: 'yallacatch_redemption',\n        code: codeDoc.code,\n        redemptionId: redemption._id.toString(),\n        rewardId: reward._id.toString(),\n        partnerId: (reward as any).partnerId?._id?.toString() || null\n      })).toString('base64');\n\n      typedLogger.info('Promo code redeemed for reward', {\n        userId,\n        code: codeDoc.code,\n        rewardId: reward._id,\n        redemptionId: redemption._id\n      });\n\n      return {\n        success: true,\n        type: 'reward',\n        redemption: {\n          id: redemption._id,\n          status: redemption.status,\n          code: codeDoc.code,\n          reward: {\n            id: reward._id,\n            name: reward.name,\n            category: reward.category,\n            partner: (reward as any).partnerId || null\n          }\n        },\n        qr: qrPayload\n      };\n    }\n\n    // Points-only promo code\n    const user = await User.findById(userId);\n    if (!user) {\n      throw new Error('USER_NOT_FOUND');\n    }\n\n    const pointsValue = codeDoc.pointsValue || 0;\n    user.points.available += pointsValue;\n    user.points.total += pointsValue;\n    user.updateLevel?.();\n\n    codeDoc.status = CodeStatus.USED;\n    codeDoc.isUsed = true;\n    codeDoc.usedBy = new Types.ObjectId(userId);\n    codeDoc.usedAt = new Date();\n\n    await Promise.all([user.save(), codeDoc.save()]);\n\n    typedLogger.info('Promo code redeemed for points', {\n      userId,\n      code: codeDoc.code,\n      points: pointsValue\n    });\n\n    return {\n      success: true,\n      type: 'points',\n      pointsAwarded: pointsValue,\n      newBalance: user.points.available\n    };\n  }\n\n  /**\n   * Get all partners\n   */\n  static async getPartners(options: any = {}): Promise<any[]> {\n    try {\n      const query: any = { isActive: true };\n\n      if (options.category) {\n        query.categories = { $in: [options.category] };\n      }\n\n      const partners = await Partner.find(query)\n        .sort({ name: 1 })\n        .limit(options.limit || 50);\n\n      // Return plain objects with only active locations to keep maps clean for Unity/game clients\n      return partners.map((p: any) => {\n        const obj = typeof p.toObject === 'function' ? p.toObject() : p;\n        return {\n          ...obj,\n          locations: (obj.locations || []).filter((loc: any) => loc.isActive !== false),\n        };\n      });\n    } catch (error) {\n      typedLogger.error('Get partners error', { error: (error as any).message, options });\n      throw error;\n    }\n  }\n\n  /**\n   * Get partner locations\n   */\n  static async getPartnerLocations(partnerId: string): Promise<any[]> {\n    try {\n      return await PartnerLocationsService.getLocations(partnerId);\n    } catch (error) {\n      typedLogger.error('Get partner locations error', { error: (error as any).message, partnerId });\n      throw error;\n    }\n  }\n}\n\n/**\n * Rewards routes\n */\nexport default async function rewardsRoutes(fastify: FastifyInstance) {\n  // Get available rewards\n  fastify.get('/', {\n    preHandler: [authenticate]}, async (request, reply) => {\n    try {\n      const result = await RewardsService.getRewards(request.query);\n      \n      reply.send({\n        success: true,\n        data: result,\n        timestamp: new Date().toISOString()});\n    } catch (error) {\n      const normalized = normalizeError(error, 'Get rewards failed');\n      reply.code(500).send({\n        success: false,\n        error: normalized.code,\n        message: normalized.message,\n        timestamp: new Date().toISOString()});\n    }\n  });\n\n  // Search rewards\n  fastify.get('/search', {\n    preHandler: [authenticate]}, async (request, reply) => {\n    try {\n      const result = await RewardsService.searchRewards(request.query);\n      \n      reply.send({\n        success: true,\n        data: result,\n        timestamp: new Date().toISOString()});\n    } catch (error) {\n      const normalized = normalizeError(error, 'Search rewards failed');\n      reply.code(500).send({\n        success: false,\n        error: normalized.code,\n        message: normalized.message,\n        timestamp: new Date().toISOString()});\n    }\n  });\n\n  // Get reward details\n  fastify.get('/:rewardId', {\n    preHandler: [authenticate],\n    schema: {\n      params: {\n        type: 'object',\n        required: ['rewardId'],\n        properties: {\n          rewardId: { type: 'string' }\n        }\n      }\n    }\n  }, async (request: FastifyRequest<{\n    Params: { rewardId: string };\n  }>, reply: FastifyReply) => {\n    try {\n      const result = await RewardsService.getRewardDetails(\n        request.params.rewardId,\n        request.user.sub\n      );\n      \n      reply.send({\n        success: true,\n        data: result,\n        timestamp: new Date().toISOString()});\n    } catch (error) {\n      const normalized = normalizeError(error, 'Get reward failed');\n      const statusCode = normalized.code === 'REWARD_NOT_FOUND' ? 404 : 400;\n      reply.code(statusCode).send({\n        success: false,\n        error: normalized.code,\n        message: normalized.message,\n        timestamp: new Date().toISOString()});\n    }\n  });\n\n  // Redeem a reward\n  fastify.post('/:rewardId/redeem', {\n    preHandler: [authenticate],\n    schema: {\n      params: {\n        type: 'object',\n        required: ['rewardId'],\n        properties: {\n          rewardId: { type: 'string' }\n        }\n      },\n      body: {\n        type: 'object',\n        required: ['idempotencyKey'],\n        properties: {\n          idempotencyKey: { type: 'string', minLength: 1, maxLength: 100 }\n        }\n      }\n    }\n  }, async (request: FastifyRequest<{\n    Params: { rewardId: string };\n    Body: { idempotencyKey: string };\n  }>, reply: FastifyReply) => {\n    try {\n      const result = await RewardsService.redeemReward(\n        request.user.sub,\n        {\n          rewardId: request.params.rewardId,\n          idempotencyKey: request.body.idempotencyKey}\n      );\n      \n      reply.code(201).send({\n        success: true,\n        data: result,\n        timestamp: new Date().toISOString()});\n    } catch (error) {\n      const normalized = normalizeError(error, 'Redeem reward failed');\n      const statusCodes: Record<string, number> = {\n        USER_NOT_FOUND: 404,\n        REWARD_NOT_FOUND: 404,\n        REWARD_NOT_AVAILABLE: 409,\n        OUT_OF_STOCK: 409,\n        INSUFFICIENT_POINTS: 400,\n      };\n      const statusCode = statusCodes[normalized.code] || 500;\n      reply.code(statusCode).send({\n        success: false,\n        error: normalized.code,\n        message: normalized.message,\n        timestamp: new Date().toISOString()});\n    }\n  });\n\n  // Get user redemptions\n  fastify.get('/my-redemptions', {\n    preHandler: [authenticate]}, async (request, reply) => {\n    try {\n      const result = await RewardsService.getUserRedemptions(\n        request.user.sub,\n        request.query\n      );\n      \n      reply.send({\n        success: true,\n        data: result,\n        timestamp: new Date().toISOString()});\n    } catch (error) {\n      const normalized = normalizeError(error, 'Get redemptions failed');\n      reply.code(500).send({\n        success: false,\n        error: normalized.code,\n        message: normalized.message,\n        timestamp: new Date().toISOString()});\n    }\n  });\n\n  // ========================================\n  // Routes from rewards-extended.ts (9 routes)\n  // ========================================\n  // Get reward categories\n  fastify.get('/categories', async (request, reply) => {\n    try {\n      const result = await RewardsService.getRewardCategories();\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      const normalized = normalizeError(error, 'Get categories failed');\n      reply.code(500).send({ success: false, error: normalized.code, message: normalized.message });\n    }\n  });\n\n  // Get featured rewards\n  fastify.get('/featured', {\n    schema: {\n      querystring: {\n        type: 'object',\n        properties: {\n          limit: {\n            type: 'integer',\n            minimum: 1,\n            maximum: 50,\n            default: 10\n          }\n        }\n      }\n    }\n  }, async (request: FastifyRequest<{\n    Querystring: { limit?: number };\n  }>, reply: FastifyReply) => {\n    try {\n      const result = await RewardsService.getFeaturedRewards(request.query.limit || 10);\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      const normalized = normalizeError(error, 'Get featured rewards failed');\n      reply.code(500).send({ success: false, error: normalized.code, message: normalized.message });\n    }\n  });\n\n  // Add to favorites\n  fastify.post('/favorites', {\n    preHandler: [authenticate],\n    schema: {\n      body: {\n        type: 'object',\n        required: ['rewardId'],\n        properties: {\n          rewardId: { type: 'string' }\n        }\n      }\n    }\n  }, async (request: FastifyRequest<{\n    Body: { rewardId: string };\n  }>, reply: FastifyReply) => {\n    try {\n      const result = await RewardsService.addToFavorites(\n        request.user.sub,\n        request.body.rewardId\n      );\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      reply.code(400).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Remove from favorites\n  fastify.delete('/favorites/:rewardId', {\n    preHandler: [authenticate],\n    schema: {\n      params: {\n        type: 'object',\n        required: ['rewardId'],\n        properties: {\n          rewardId: { type: 'string' }\n        }\n      }\n    }\n  }, async (request: FastifyRequest<{\n    Params: { rewardId: string };\n  }>, reply: FastifyReply) => {\n    try {\n      const result = await RewardsService.removeFromFavorites(\n        request.user.sub,\n        request.params.rewardId\n      );\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      reply.code(400).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Get favorite rewards\n  fastify.get('/favorites', {\n    preHandler: [authenticate]}, async (request, reply) => {\n    try {\n      const result = await RewardsService.getFavoriteRewards(request.user.sub);\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      reply.code(500).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Get redemption history\n  fastify.get('/history', {\n    preHandler: [authenticate],\n    schema: {\n      querystring: {\n        type: 'object',\n        properties: {\n          page: { type: 'integer', minimum: 1, default: 1 },\n          limit: { type: 'integer', minimum: 1, maximum: 50, default: 20 },\n          status: {\n            type: 'string',\n            enum: ['all', 'active', 'used', 'expired'],\n            default: 'all'\n          }\n        }\n      }\n    }\n  }, async (request: FastifyRequest<{\n    Querystring: { page?: number; limit?: number; status?: 'all' | 'active' | 'used' | 'expired' };\n  }>, reply: FastifyReply) => {\n    try {\n      const result = await RewardsService.getRedemptionHistory(request.user.sub, request.query);\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      reply.code(500).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Scan QR code\n  const qrScanSchema = {\n    body: {\n      type: 'object',\n      required: ['qrCode'],\n      properties: {\n        qrCode: { type: 'string' },\n        location: {\n          type: 'object',\n          properties: {\n            lat: { type: 'number' },\n            lng: { type: 'number' }\n          }\n        }\n      }\n    }\n  };\n\n  const qrScanHandler = async (\n    request: FastifyRequest,\n    reply: FastifyReply\n  ) => {\n    try {\n      const result = await RewardsService.scanQRCode(request.user.sub, request.body);\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      reply.code(400).send({ success: false, error: (error as any).message });\n    }\n  };\n\n  // Keep legacy path but allow partner users too (authZ is enforced in service)\n  fastify.post('/qr-scan', {\n    preHandler: [authenticate],\n    schema: qrScanSchema\n  }, qrScanHandler);\n\n  // New explicit path with slash for consistency with frontend helpers\n  fastify.post('/qr/scan', {\n    preHandler: [authenticate],\n    schema: qrScanSchema\n  }, qrScanHandler);\n\n  // Partner self-serve location update (partner role only)\n  const partnerLocationSchema = z.object({\n    locationId: z.string().optional(),\n    name: z.string().min(1).max(100),\n    address: z.string().min(1).max(200),\n    city: z.string().min(1).max(50),\n    lat: z.number().min(-90).max(90),\n    lng: z.number().min(-180).max(180),\n    phone: z.string().max(20).optional(),\n    isActive: z.boolean().optional(),\n    features: z.array(z.string()).optional(),\n  });\n\n  fastify.post('/partners/me/location', {\n    preHandler: [authenticate],\n  }, async (request: FastifyRequest<{ Body: z.infer<typeof partnerLocationSchema> }>, reply: FastifyReply) => {\n    try {\n      const { UserRole } = await import('@/types');\n      const user = await User.findById(request.user.sub);\n      if (!user || (user as any).role !== UserRole.PARTNER || !user.partnerId) {\n        return reply.code(403).send({ success: false, error: 'FORBIDDEN' });\n      }\n\n      const payload = partnerLocationSchema.parse((request as any).body || {});\n      await PartnerLocationsService.upsertLocation(user.partnerId.toString(), payload);\n      const locations = await PartnerLocationsService.getLocations(user.partnerId.toString());\n\n      return reply.send({\n        success: true,\n        data: {\n          partnerId: user.partnerId,\n          locations,\n        }\n      });\n    } catch (error: any) {\n      return reply.code(400).send({ success: false, error: error.message || 'LOCATION_UPDATE_FAILED' });\n    }\n  });\n\n  // Redeem promo code (points-only or reward -> QR)\n  fastify.post('/promo/redeem', {\n    preHandler: [authenticate],\n    schema: {\n      body: promoCodeSchema\n    }\n  }, async (request: FastifyRequest<{ Body: { code: string } }>, reply: FastifyReply) => {\n    try {\n      const result = await RewardsService.redeemPromoCode(request.user.sub, request.body);\n      return reply.send({ success: true, data: result });\n    } catch (error) {\n      return reply.code(400).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Pending redemptions (admin or partner scoped)\n  fastify.get('/redemptions/pending', {\n    preHandler: [authenticate],\n    schema: {\n      querystring: {\n        type: 'object',\n        properties: {\n          limit: { type: 'integer', minimum: 1, maximum: 200, default: 50 },\n          partnerId: { type: 'string' }\n        }\n      }\n    }\n  }, async (request: FastifyRequest<{ Querystring: { limit?: number; partnerId?: string } }>, reply: FastifyReply) => {\n    try {\n      const { UserRole } = await import('@/types');\n      const user = await User.findById(request.user.sub);\n      const isAdmin = user && [UserRole.ADMIN, UserRole.SUPER_ADMIN, UserRole.MODERATOR].includes((user as any).role);\n      const limit = Math.min(Math.max((request.query.limit as number) || 50, 1), 200);\n\n      const redemptionQuery: any = { status: RedemptionStatus.PENDING };\n\n      // If partner user, force filter by their partnerId\n      if (user?.partnerId && (user as any).role === UserRole.PARTNER) {\n        redemptionQuery['rewardId'] = { $exists: true };\n      }\n\n      const partnerFilter = (user?.partnerId && (user as any).role === UserRole.PARTNER)\n        ? user.partnerId.toString()\n        : request.query.partnerId;\n\n      const populateReward: any = {\n        path: 'rewardId',\n        select: 'name category partnerId',\n        populate: { path: 'partnerId', select: 'name' }\n      };\n\n      if (partnerFilter) {\n        populateReward.match = { partnerId: new Types.ObjectId(partnerFilter) };\n      }\n\n      let redemptions = await Redemption.find(redemptionQuery)\n        .populate(populateReward)\n        .populate('userId', 'displayName email')\n        .sort({ createdAt: 1 })\n        .limit(limit)\n        .lean();\n\n      // Filter out redemptions whose reward partnerId doesn't match (after populate)\n      if (partnerFilter) {\n        redemptions = redemptions.filter(r => (r as any).rewardId?.partnerId);\n      }\n\n      // If non-admin/non-partner, forbid\n      if (!isAdmin && (!(user?.partnerId) || (user as any).role !== UserRole.PARTNER)) {\n        return reply.code(403).send({ success: false, error: 'FORBIDDEN' });\n      }\n\n      return reply.send({\n        success: true,\n        data: redemptions.map((r: any) => ({\n          id: r._id,\n          user: r.userId,\n          reward: r.rewardId,\n          status: r.status,\n          createdAt: r.createdAt\n        }))\n      });\n    } catch (error) {\n      return reply.code(500).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Get partners\n  fastify.get('/partners', {\n    schema: {\n      querystring: {\n        type: 'object',\n        properties: {\n          page: { type: 'integer', minimum: 1, default: 1 },\n          limit: { type: 'integer', minimum: 1, maximum: 50, default: 20 },\n          category: { type: 'string' },\n          city: { type: 'string' }\n        }\n      }\n    }\n  }, async (request: FastifyRequest<{\n    Querystring: { page?: number; limit?: number; category?: string; city?: string };\n  }>, reply: FastifyReply) => {\n    try {\n      const result = await RewardsService.getPartners(request.query);\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      reply.code(500).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Partner dashboard stats (admin or partner scoped)\n  fastify.get('/partners/stats', {\n    preHandler: [authenticate],\n    schema: {\n      querystring: {\n        type: 'object',\n        properties: {\n          partnerId: { type: 'string' },\n          limitRecent: { type: 'integer', minimum: 1, maximum: 50, default: 5 }\n        }\n      }\n    }\n  }, async (request: FastifyRequest<{ Querystring: { partnerId?: string; limitRecent?: number } }>, reply: FastifyReply) => {\n    try {\n      const { UserRole } = await import('@/types');\n      const user = await User.findById(request.user.sub);\n      const limitRecent = Math.min(Math.max((request.query.limitRecent as number) || 5, 1), 50);\n\n      let partnerId: string | undefined = request.query.partnerId;\n      if (user && (user as any).role === UserRole.PARTNER) {\n        partnerId = user.partnerId?.toString();\n      }\n      if (!partnerId) {\n        return reply.code(400).send({ success: false, error: 'PARTNER_ID_REQUIRED' });\n      }\n\n      const stats = await PartnerStatsService.getPartnerStats(partnerId, limitRecent);\n      return reply.send({ success: true, data: stats });\n    } catch (error: any) {\n      return reply.code(500).send({ success: false, error: error.message || 'PARTNER_STATS_FAILED' });\n    }\n  });\n\n  // Partner self locations (for portal map/list)\n  fastify.get('/partners/me/locations', {\n    preHandler: [authenticate],\n    schema: {\n      querystring: {\n        type: 'object',\n        properties: {\n          partnerId: { type: 'string' }\n        }\n      }\n    }\n  }, async (request: FastifyRequest<{ Querystring: { partnerId?: string } }>, reply: FastifyReply) => {\n    try {\n      const { UserRole } = await import('@/types');\n      const user = await User.findById(request.user.sub);\n\n      let partnerId: string | undefined = request.query.partnerId;\n      if (user && (user as any).role === UserRole.PARTNER) {\n        partnerId = user.partnerId?.toString();\n      }\n\n      if (!partnerId) {\n        return reply.code(400).send({ success: false, error: 'PARTNER_ID_REQUIRED' });\n      }\n\n      const partner = await Partner.findById(partnerId).select('name');\n      if (!partner) {\n        return reply.code(404).send({ success: false, error: 'PARTNER_NOT_FOUND' });\n      }\n\n      const locations = await PartnerLocationsService.getLocations(partnerId);\n      return reply.send({\n        success: true,\n        data: locations,\n        partner: { id: partner._id, name: partner.name }\n      });\n    } catch (error: any) {\n      return reply.code(500).send({ success: false, error: error.message || 'PARTNER_LOCATIONS_FAILED' });\n    }\n  });\n\n  // Get partner locations\n  fastify.get('/partners/:partnerId/locations', {\n    preHandler: [authenticate],\n    schema: {\n      params: {\n        type: 'object',\n        required: ['partnerId'],\n        properties: {\n          partnerId: { type: 'string' }\n        }\n      }\n    }\n  }, async (request: FastifyRequest<{\n    Params: { partnerId: string };\n  }>, reply: FastifyReply) => {\n    try {\n      const result = await RewardsService.getPartnerLocations(request.params.partnerId);\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      reply.code(500).send({ success: false, error: (error as any).message });\n    }\n  });\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\rewards\\routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\social\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\social\\routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'IFriendship' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'config' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'UserProfile' is defined but never used. Allowed unused vars must match /^_/u.","line":80,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":80,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'NearbyPlayer' is defined but never used. Allowed unused vars must match /^_/u.","line":111,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":111,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":115,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":115,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2849,2852],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2849,2852],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'FriendRequestSchema' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":129,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":129,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TeamCreateSchema' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":133,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":133,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'SocialChallengeSchema' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":139,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":139,"endColumn":28},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":208,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":208,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5816,5819],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5816,5819],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":256,"column":79,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":256,"endColumn":82,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7396,7399],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7396,7399],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":284,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":284,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8210,8213],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8210,8213],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":335,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":335,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10142,10145],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10142,10145],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":397,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":397,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11843,11846],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11843,11846],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":457,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":457,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13670,13673],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13670,13673],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":529,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":529,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16099,16102],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16099,16102],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"prefer-const","severity":2,"message":"'query' is never reassigned. Use 'const' instead.","line":589,"column":11,"nodeType":"Identifier","messageId":"useConst","endLine":589,"endColumn":21,"fix":{"range":[17964,17984],"text":"const query: any = {};"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":589,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":589,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17975,17978],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17975,17978],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":641,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":641,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19774,19777],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19774,19777],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":694,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":694,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21742,21745],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21742,21745],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":738,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":738,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23365,23368],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23365,23368],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":744,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":744,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23704,23707],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23704,23707],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":866,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":866,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[27654,27657],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[27654,27657],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":903,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":903,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28661,28664],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28661,28664],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":929,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":929,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[29317,29320],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[29317,29320],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":962,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":962,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[30315,30318],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[30315,30318],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":993,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":993,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31166,31169],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31166,31169],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":994,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":994,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31243,31246],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31243,31246],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":995,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":995,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31321,31324],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31321,31324],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":996,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":996,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31456,31459],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31456,31459],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1023,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1023,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32193,32196],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32193,32196],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1024,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1024,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32276,32279],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32276,32279],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1025,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1025,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32387,32390],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32387,32390],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1052,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1052,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[33124,33127],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[33124,33127],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1053,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1053,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[33207,33210],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[33207,33210],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1054,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1054,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[33318,33321],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[33318,33321],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1081,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1081,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[34035,34038],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[34035,34038],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1082,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1082,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[34118,34121],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[34118,34121],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1083,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1083,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[34229,34232],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[34229,34232],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1110,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1110,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[34944,34947],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[34944,34947],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1111,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1111,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[35027,35030],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[35027,35030],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1112,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1112,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[35138,35141],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[35138,35141],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1124,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1124,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[35602,35605],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[35602,35605],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1136,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1136,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[36046,36049],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[36046,36049],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1163,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1163,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[36785,36788],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[36785,36788],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1175,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1175,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[37213,37216],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[37213,37216],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":45,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';\nimport { authenticate } from '@/middleware/auth';\nimport { userRateLimit } from '@/middleware/distributed-rate-limit';\nimport { z } from 'zod';\nimport { User } from '@/models/User';\nimport { Friendship, IFriendship, FriendshipStatus } from '@/models/Friendship';\nimport { Types } from 'mongoose';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { redisClient } from '@/config/redis';\nimport { config } from '@/config';\nimport { normalizeError } from '@/utils/api-errors';\n\n// Define proper TypeScript interfaces\ninterface FriendRequestData {\n  targetUserId: string;\n  message?: string;\n}\n\ninterface TeamCreateData {\n  name: string;\n  description?: string;\n  isPublic: boolean;\n  maxMembers: number;\n}\n\ninterface SocialChallengeData {\n  title: string;\n  description: string;\n  type: 'team_claims' | 'friend_race' | 'group_distance' | 'collaborative';\n  targetValue: number;\n  duration: number;\n  rewards: {\n    points: number;\n    powerUps?: string[];\n    badges?: string[];\n  };\n  participants: {\n    minUsers: number;\n    maxUsers: number;\n    requireTeam: boolean;\n  };\n}\n\nconst friendRequestSchema = z.object({\n  targetUserId: z.string().regex(/^[0-9a-fA-F]{24}$/),\n  message: z.string().max(500).optional(),\n});\n\nconst teamCreateSchema = z.object({\n  name: z.string().min(2).max(100),\n  description: z.string().max(500).optional(),\n  isPublic: z.boolean(),\n  maxMembers: z.number().int().min(2).max(100),\n});\n\nconst socialChallengeSchema = z.object({\n  title: z.string().min(2).max(200),\n  description: z.string().min(2).max(1000),\n  type: z.enum(['team_claims', 'friend_race', 'group_distance', 'collaborative']),\n  targetValue: z.number().positive(),\n  duration: z.number().positive(),\n  rewards: z.object({\n    points: z.number().nonnegative(),\n    powerUps: z.array(z.string()).optional(),\n    badges: z.array(z.string()).optional(),\n  }),\n  participants: z.object({\n    minUsers: z.number().int().min(1),\n    maxUsers: z.number().int().min(1),\n    requireTeam: z.boolean(),\n  }),\n});\n\ninterface LocationData {\n  latitude: number;\n  longitude: number;\n  accuracy?: number;\n}\n\ninterface UserProfile {\n  _id: Types.ObjectId;\n  displayName: string;\n  level: string;\n  points: {\n    available: number;\n    total: number;\n    spent: number;\n  };\n  avatar?: string;\n  location?: {\n    lat: number;\n    lng: number;\n    city: string;\n    lastUpdated: Date;\n  };\n  stats: {\n    prizesFound: number;\n    rewardsRedeemed: number;\n    sessionsCount: number;\n    totalPlayTime: number;\n    longestStreak: number;\n    currentStreak: number;\n    favoriteCity?: string;\n    lastClaimDate?: Date;\n    dailyClaimsCount: number;\n  };\n  lastActive: Date;\n  createdAt: Date;\n}\n\ninterface NearbyPlayer {\n  userId: Types.ObjectId;\n  displayName: string;\n  level: string;\n  points: any;\n  avatar?: string;\n  distance: number;\n  lastSeen: Date;\n  activity: string;\n}\n\n/**\n * Social Features Module\n * Essential for modern AR games - friends, teams, social challenges\n * Missing from current implementation but critical for user engagement\n */\n\n// Schemas\nconst FriendRequestSchema = z.object({\n  targetUserId: z.string(),\n  message: z.string().max(200).optional()});\n\nconst TeamCreateSchema = z.object({\n  name: z.string().min(3).max(50),\n  description: z.string().max(200).optional(),\n  isPublic: z.boolean().default(true),\n  maxMembers: z.number().min(2).max(50).default(10)});\n\nconst SocialChallengeSchema = z.object({\n  title: z.string().min(5).max(100),\n  description: z.string().max(500),\n  type: z.enum(['team_claims', 'friend_race', 'group_distance', 'collaborative']),\n  targetValue: z.number().min(1),\n  duration: z.number().min(3600).max(604800), // 1 hour to 1 week in seconds\n  rewards: z.object({\n    points: z.number().min(0),\n    powerUps: z.array(z.string()).optional(),\n    badges: z.array(z.string()).optional()}),\n  participants: z.object({\n    minUsers: z.number().min(2).default(2),\n    maxUsers: z.number().min(2).max(100).default(10),\n    requireTeam: z.boolean().default(false)})});\n\nexport class SocialService {\n  private static redis = redisClient;\n\n  /**\n   * Send friend request\n   */\n  static async sendFriendRequest(fromUserId: string, data: FriendRequestData) {\n    try {\n      const { targetUserId, message } = data;\n\n      // Check if users exist\n      const [fromUser, targetUser] = await Promise.all([\n        User.findById(fromUserId),\n        User.findById(targetUserId)]);\n\n      if (!fromUser || !targetUser) {\n        throw new Error('USER_NOT_FOUND');\n      }\n\n      if (fromUserId === targetUserId) {\n        throw new Error('CANNOT_ADD_SELF');\n      }\n\n      // Check if already friends or request exists using Friendship model\n      const friendshipExists = await Friendship.findOne({\n        $or: [\n          { userId: new Types.ObjectId(fromUserId), friendId: new Types.ObjectId(targetUserId) },\n          { userId: new Types.ObjectId(targetUserId), friendId: new Types.ObjectId(fromUserId) }\n        ]\n      });\n\n      if (friendshipExists) {\n        throw new Error(`FRIENDSHIP_${friendshipExists.status.toUpperCase()}`);\n      }\n\n      // Create friend request using Friendship model\n      const friendship = new Friendship({\n        userId: new Types.ObjectId(fromUserId),\n        friendId: new Types.ObjectId(targetUserId),\n        status: FriendshipStatus.PENDING,\n        message: message || '',\n        createdAt: new Date()\n      });\n\n      await friendship.save();\n\n      typedLogger.info('Friend request sent', { fromUserId, targetUserId });\n\n      return {\n        success: true,\n        friendshipId: friendship._id,\n        message: friendship.message,\n        createdAt: friendship.createdAt};\n    } catch (error) {\n      typedLogger.error('Send friend request error', { error: (error as any).message, fromUserId, data });\n      throw error;\n    }\n  }\n\n  /**\n   * Accept/Reject friend request\n   */\n  static async respondToFriendRequest(userId: string, fromUserId: string, action: 'accept' | 'reject') {\n    try {\n      // Find the pending friendship request\n      let friendship = await Friendship.findOne({\n        userId: new Types.ObjectId(userId),\n        friendId: new Types.ObjectId(fromUserId),\n        status: FriendshipStatus.PENDING\n      });\n\n      // Check reverse direction too (in case request was made the other way)\n      if (!friendship) {\n        friendship = await Friendship.findOne({\n          userId: new Types.ObjectId(fromUserId),\n          friendId: new Types.ObjectId(userId),\n          status: FriendshipStatus.PENDING\n        });\n      }\n\n      if (!friendship) {\n        throw new Error('FRIEND_REQUEST_NOT_FOUND');\n      }\n\n      if (action === 'accept') {\n        // Update friendship status to accepted\n        friendship.status = FriendshipStatus.ACCEPTED;\n        friendship.acceptedAt = new Date();\n        await friendship.save();\n\n        typedLogger.info('Friend request accepted', { userId, fromUserId });\n      } else {\n        // Update friendship status to rejected\n        friendship.status = FriendshipStatus.REJECTED;\n        friendship.rejectedAt = new Date();\n        await friendship.save();\n\n        typedLogger.info('Friend request rejected', { userId, fromUserId });\n      }\n\n      return { success: true, action };\n    } catch (error) {\n      typedLogger.error('Respond to friend request error', { error: (error as any).message, userId, fromUserId, action });\n      throw error;\n    }\n  }\n\n  /**\n   * Get user's friends with online status\n   */\n  static async getFriends(userId: string) {\n    try {\n      // Get accepted friendships for this user\n      const friendships = await Friendship.find({\n        $or: [\n          { userId: new Types.ObjectId(userId), status: FriendshipStatus.ACCEPTED },\n          { friendId: new Types.ObjectId(userId), status: FriendshipStatus.ACCEPTED }\n        ]\n      }).populate([\n        {\n          path: 'userId',\n          select: 'displayName avatar level points lastActive'\n        },\n        {\n          path: 'friendId',\n          select: 'displayName avatar level points lastActive'\n        }\n      ]);\n\n      const friends = await Promise.all(\n        friendships.map(async (friendship: any) => {\n          // Determine which user is the friend (not the current user)\n          const friend = friendship.userId.toString() === userId\n            ? friendship.friendId\n            : friendship.userId;\n\n          // Check online status (last active within 5 minutes)\n          const isOnline = friend.lastActive &&\n            (Date.now() - new Date(friend.lastActive).getTime()) < 5 * 60 * 1000;\n\n          // Get current game session if online\n          let currentActivity = null;\n          if (isOnline) {\n            const sessionKeys = await this.redis.keys(`session:game_session_${friend._id}_*`);\n            if (sessionKeys.length > 0) {\n              const sessionData = await this.redis.get(sessionKeys[0]);\n              if (sessionData) {\n                const session = JSON.parse(sessionData);\n                currentActivity = {\n                  type: 'playing',\n                  location: session.currentLocation,\n                  startTime: session.startTime};\n              }\n            }\n          }\n\n          return {\n            userId: friend._id,\n            displayName: friend.displayName,\n            avatar: friend.avatar,\n            level: friend.level,\n            points: friend.points,\n            isOnline,\n            lastActive: friend.lastActive,\n            currentActivity,\n            friendshipDate: friendship.createdAt};\n        })\n      );\n\n      const onlineCount = friends.filter(f => f.isOnline).length;\n\n      return {\n        friends: friends.sort((a, b) => {\n          // Sort by online status first, then by last active\n          if (a.isOnline && !b.isOnline) return -1;\n          if (!a.isOnline && b.isOnline) return 1;\n          return new Date(b.lastActive).getTime() - new Date(a.lastActive).getTime();\n        }),\n        onlineCount,\n        totalCount: friends.length};\n    } catch (error) {\n      typedLogger.error('Get friends error', { error: (error as any).message, userId });\n      throw error;\n    }\n  }\n\n  /**\n   * Create team for collaborative gameplay\n   */\n  static async createTeam(creatorId: string, teamData: TeamCreateData) {\n    try {\n      const creator = await User.findById(creatorId);\n      if (!creator) throw new Error('USER_NOT_FOUND');\n\n      const team = {\n        _id: `team_${creatorId}_${Date.now()}`,\n        name: teamData.name,\n        description: teamData.description || '',\n        creatorId,\n        members: [{\n          userId: creatorId,\n          role: 'leader',\n          joinedAt: new Date(),\n          status: 'active'}],\n        isPublic: teamData.isPublic,\n        maxMembers: teamData.maxMembers,\n        stats: {\n          totalClaims: 0,\n          totalPoints: 0,\n          totalDistance: 0,\n          activeChallenges: 0},\n        settings: {\n          allowInvites: true,\n          requireApproval: !teamData.isPublic,\n          shareLocation: true},\n        createdAt: new Date(),\n        updatedAt: new Date()};\n\n      // Store team data\n      await this.redis.setex(\n        `team:${team._id}`,\n        30 * 24 * 60 * 60, // 30 days\n        JSON.stringify(team)\n      );\n\n      // Add team to user's profile\n      await User.findByIdAndUpdate(creatorId, {\n        $push: {\n          'social.teams': {\n            teamId: team._id,\n            role: 'leader',\n            joinedAt: new Date()}\n        }\n      });\n\n      typedLogger.info('Team created', { creatorId, teamId: team._id, name: team.name });\n\n      return {\n        teamId: team._id,\n        name: team.name,\n        memberCount: 1,\n        role: 'leader'};\n    } catch (error) {\n      typedLogger.error('Create team error', { error: (error as any).message, creatorId, teamData });\n      throw error;\n    }\n  }\n\n  /**\n   * Create social challenge\n   */\n  static async createSocialChallenge(creatorId: string, challengeData: SocialChallengeData) {\n    try {\n      const creator = await User.findById(creatorId);\n      if (!creator) throw new Error('USER_NOT_FOUND');\n\n      const challenge = {\n        _id: `social_challenge_${creatorId}_${Date.now()}`,\n        title: challengeData.title,\n        description: challengeData.description,\n        type: challengeData.type,\n        creatorId,\n        targetValue: challengeData.targetValue,\n        currentValue: 0,\n        duration: challengeData.duration,\n        rewards: challengeData.rewards,\n        participants: {\n          ...challengeData.participants,\n          current: 1,\n          users: [{\n            userId: creatorId,\n            joinedAt: new Date(),\n            contribution: 0,\n            status: 'active'}]},\n        status: 'recruiting',\n        startTime: null,\n        endTime: null,\n        createdAt: new Date(),\n        updatedAt: new Date()};\n\n      // Store challenge\n      await this.redis.setex(\n        `social_challenge:${challenge._id}`,\n        challengeData.duration + 24 * 60 * 60, // Duration + 1 day buffer\n        JSON.stringify(challenge)\n      );\n\n      // Add to global challenges list\n      await this.redis.lpush('social_challenges:active', challenge._id);\n\n      typedLogger.info('Social challenge created', {\n        creatorId,\n        challengeId: challenge._id,\n        type: challenge.type\n      });\n\n      return {\n        challengeId: challenge._id,\n        title: challenge.title,\n        type: challenge.type,\n        participantCount: 1,\n        status: 'recruiting'};\n    } catch (error) {\n      typedLogger.error('Create social challenge error', { error: (error as any).message, creatorId, challengeData });\n      throw error;\n    }\n  }\n\n  /**\n   * Get nearby players for social interactions\n   */\n  static async getNearbyPlayers(userId: string, location: LocationData, radiusKm: number = 5) {\n    try {\n      // Calculate actual distances using aggregation\n      const result = await User.aggregate([\n        {\n          $geoNear: {\n            near: { type: 'Point', coordinates: [location.longitude, location.latitude] },\n            distanceField: 'distance',\n            maxDistance: radiusKm * 1000, // Convert km to meters\n            query: {\n              _id: { $ne: new Types.ObjectId(userId) }, // Exclude self\n              isBanned: false,\n              lastActive: { $gte: new Date(Date.now() - 3600000) } // Active in last hour\n            },\n            includeLocs: 'location',\n            spherical: true\n          }\n        },\n        {\n          $limit: 20\n        }\n      ]);\n\n      // Calculate actual distances using our helper function for consistency\n      return {\n        players: result.map(user => {\n          // Calculate distance using our helper function\n          // User location has the coordinates in {lat, lng} format\n          const userLocation = user.location;\n          if (!userLocation) {\n            // If user has no location, return Infinity distance\n            return {\n              userId: user._id,\n              displayName: user.displayName,\n              level: user.level,\n              points: user.points,\n              avatar: user.avatar,\n              distance: Infinity,\n              lastSeen: user.lastActive,\n              activity: 'active'\n            };\n          }\n\n          const distance = this.calculateDistance(\n            location.latitude,\n            location.longitude,\n            userLocation.lat,\n            userLocation.lng\n          );\n\n          return {\n            userId: user._id,\n            displayName: user.displayName,\n            level: user.level,\n            points: user.points,\n            avatar: user.avatar,\n            distance: Math.round(distance * 100) / 100, // Round to 2 decimals\n            lastSeen: user.lastActive,\n            activity: 'active' // All returned users are active based on the filter\n          };\n        }),\n        total: result.length,\n        searchRadius: radiusKm};\n    } catch (error) {\n      typedLogger.error('Get nearby players error', { error: (error as any).message, userId, location });\n      throw error;\n    }\n  }\n\n  // Helper methods\n  private static async checkFriendshipStatus(userId1: string, userId2: string) {\n    // Use Friendship model to check the status\n    const friendship = await Friendship.findOne({\n      $or: [\n        { userId: new Types.ObjectId(userId1), friendId: new Types.ObjectId(userId2) },\n        { userId: new Types.ObjectId(userId2), friendId: new Types.ObjectId(userId1) }\n      ]\n    });\n\n    if (!friendship) {\n      return { status: 'none' };\n    }\n\n    switch (friendship.status) {\n      case FriendshipStatus.ACCEPTED:\n        return { status: 'friends' };\n      case FriendshipStatus.PENDING:\n        // Determine if it's incoming or outgoing based on who initiated\n        if (friendship.userId.toString() === userId2) {\n          return { status: 'pending_outgoing' };\n        } else {\n          return { status: 'pending_incoming' };\n        }\n      case FriendshipStatus.REJECTED:\n        return { status: 'rejected' };\n      case FriendshipStatus.BLOCKED:\n        return { status: 'blocked' };\n      default:\n        return { status: 'none' };\n    }\n  }\n\n  private static calculateDistance(lat1: number, lng1: number, lat2: number, lng2: number): number {\n    const R = 6371; // Earth's radius in km\n    const dLat = (lat2 - lat1) * Math.PI / 180;\n    const dLng = (lng2 - lng1) * Math.PI / 180;\n    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +\n              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n              Math.sin(dLng/2) * Math.sin(dLng/2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n    return R * c;\n  }\n\n  /**\n   * Get leaderboard\n   */\n  static async getLeaderboard(\n    userId: string,\n    type: 'global' | 'city' | 'friends',\n    city?: string,\n    limit: number = 50,\n    offset: number = 0\n  ) {\n    try {\n      let query: any = {};\n\n      if (type === 'city' && city) {\n        query['location.city'] = city;\n      } else if (type === 'friends') {\n        // Get friends using the Friendship model instead of non-existent social.friends field\n        const friendships = await Friendship.find({\n          $or: [\n            { userId: new Types.ObjectId(userId), status: FriendshipStatus.ACCEPTED },\n            { friendId: new Types.ObjectId(userId), status: FriendshipStatus.ACCEPTED }\n          ]\n        });\n\n        const friendIds = friendships.map(f =>\n          f.userId.toString() === userId ? f.friendId.toString() : f.userId.toString()\n        );\n\n        query._id = { $in: [...friendIds, userId] };\n      }\n\n      const leaderboard = await User.find(query)\n        .select('displayName level points avatar location.city')\n        .sort({ points: -1, level: -1 })\n        .skip(offset)\n        .limit(limit)\n        .lean();\n\n      const total = await User.countDocuments(query);\n\n      // Find current user rank\n      const currentUser = await User.findById(userId).select('points level').lean();\n      const rank = currentUser ? await User.countDocuments({\n        ...query,\n        $or: [\n          { points: { $gt: currentUser.points } },\n          { points: currentUser.points, level: { $gt: currentUser.level } }\n        ]\n      }) + 1 : null;\n\n      return {\n        leaderboard: leaderboard.map((user, index) => ({\n          rank: offset + index + 1,\n          userId: user._id,\n          displayName: user.displayName,\n          level: user.level,\n          points: user.points,\n          avatar: user.avatar,\n          city: user.location?.city})),\n        total,\n        currentUserRank: rank,\n        type};\n    } catch (error) {\n      typedLogger.error('Get leaderboard error', { error: (error as any).message, userId, type });\n      throw error;\n    }\n  }\n\n  /**\n   * Share capture\n   */\n  static async shareCapture(\n    userId: string,\n    captureId: string,\n    platform: 'facebook' | 'instagram' | 'twitter' | 'whatsapp',\n    message?: string\n  ) {\n    try {\n      const { Claim } = await import('@/models/Claim');\n      const claim = await Claim.findById(captureId);\n\n      if (!claim || claim.userId.toString() !== userId) {\n        throw new Error('CAPTURE_NOT_FOUND');\n      }\n\n      // Generate share URL - using environment var instead of config object\n      const frontendUrl = process.env.FRONTEND_URL || 'https://yallacatch.com';\n      const shareUrl = `${frontendUrl}/captures/${captureId}`;\n      const shareText = message || `Je viens de capturer un prix sur YallaCatch! ­ƒÄü`;\n\n      // Platform-specific share URLs\n      const shareUrls: Record<string, string> = {\n        facebook: `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(shareUrl)}`,\n        twitter: `https://twitter.com/intent/tweet?text=${encodeURIComponent(shareText)}&url=${encodeURIComponent(shareUrl)}`,\n        whatsapp: `https://wa.me/?text=${encodeURIComponent(shareText + ' ' + shareUrl)}`,\n        instagram: shareUrl, // Instagram doesn't support direct sharing, return capture URL\n      };\n\n      // Log share activity\n      await User.findByIdAndUpdate(userId, {\n        $inc: { 'stats.rewardsRedeemed': 1 },  // Using rewardsRedeemed instead of non-existent totalShares\n        $push: {\n          'stats.shareHistory': {  // Using stats.shareHistory instead of non-existent social.recentShares\n            captureId,\n            platform,\n            sharedAt: new Date()}\n        }\n      });\n\n      typedLogger.info('Capture shared', { userId, captureId, platform });\n\n      return {\n        success: true,\n        shareUrl: shareUrls[platform],\n        platform};\n    } catch (error) {\n      typedLogger.error('Share capture error', { error: (error as any).message, userId, captureId });\n      throw error;\n    }\n  }\n\n  /**\n   * Get user profile\n   */\n  static async getUserProfile(requesterId: string, targetUserId: string) {\n    try {\n      const targetUser = await User.findById(targetUserId)\n        .select('displayName level points avatar location stats createdAt')\n        .lean();\n\n      if (!targetUser) {\n        throw new Error('USER_NOT_FOUND');\n      }\n\n      // Check friendship status\n      const friendshipStatus = await this.checkFriendshipStatus(requesterId, targetUserId);\n\n      // Get recent captures (public or if friends)\n      let recentCaptures = [];\n      if (friendshipStatus.status === 'friends' || requesterId === targetUserId) {\n        const { Claim } = await import('@/models/Claim');\n        recentCaptures = await Claim.find({ userId: targetUserId, status: 'validated' })\n          .sort({ claimedAt: -1 })\n          .limit(10)\n          .select('prizeId claimedAt points')\n          .lean();\n      }\n\n      return {\n        userId: targetUser._id,\n        displayName: targetUser.displayName,\n        level: targetUser.level,\n        points: targetUser.points,\n        avatar: targetUser.avatar,\n        bio: '',  // Bio field doesn't exist in user model\n        city: targetUser.location?.city,\n        stats: {\n          totalCaptures: targetUser.stats?.prizesFound || 0,  // Using prizesFound instead of non-existent totalCaptures\n          totalPoints: targetUser.points,\n          totalShares: targetUser.stats?.rewardsRedeemed || 0,  // Using rewardsRedeemed instead of non-existent totalShares\n          friendsCount: (targetUser as any).friendsCount || 0},  // Calculate or use actual friends field if it exists\n        recentCaptures,\n        friendshipStatus: friendshipStatus.status,\n        joinedAt: targetUser.createdAt,\n        isOwnProfile: requesterId === targetUserId};\n    } catch (error) {\n      typedLogger.error('Get user profile error', { error: (error as any).message, requesterId, targetUserId });\n      throw error;\n    }\n  }\n}\n\nexport default async function socialRoutes(fastify: FastifyInstance) {\n  const sendError = (reply: FastifyReply, error: unknown, fallback: string, status = 400) => {\n    const normalized = normalizeError(error, fallback);\n    reply.code(status).send({ success: false, error: normalized.code, message: normalized.message });\n  };\n  // Friend management\n  fastify.post('/friends/request', {\n    preHandler: [authenticate, userRateLimit],\n    schema: { body: friendRequestSchema }\n  }, async (request: FastifyRequest<{ Body: FriendRequestData }>, reply) => {\n    try {\n      const result = await SocialService.sendFriendRequest(request.user.sub, request.body);\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      sendError(reply, error, 'Friend request failed');\n    }\n  });\n\n  fastify.post('/friends/respond', {\n    preHandler: [authenticate, userRateLimit],\n    schema: {\n      body: {\n        type: 'object',\n        required: ['fromUserId', 'action'],\n        properties: {\n          fromUserId: { type: 'string' },\n          action: {\n            type: 'string',\n            enum: ['accept', 'reject']\n          }\n        }\n      }\n    }\n  }, async (request: FastifyRequest<{\n    Body: { fromUserId: string; action: 'accept' | 'reject' };\n  }>, reply: FastifyReply) => {\n    try {\n      const result = await SocialService.respondToFriendRequest(\n        request.user.sub,\n        request.body.fromUserId,\n        request.body.action\n      );\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      sendError(reply, error, 'Friend response failed');\n    }\n  });\n\n  fastify.get('/friends', {\n    preHandler: [authenticate]}, async (request, reply) => {\n    try {\n      const result = await SocialService.getFriends(request.user.sub);\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      sendError(reply as FastifyReply, error, 'Get friends failed', 500);\n    }\n  });\n\n  // Team management\n  fastify.post('/teams', {\n    preHandler: [authenticate, userRateLimit],\n    schema: { body: teamCreateSchema }\n  }, async (request: FastifyRequest<{ Body: TeamCreateData }>, reply) => {\n    try {\n      const result = await SocialService.createTeam(request.user.sub, request.body);\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      sendError(reply, error, 'Team creation failed');\n    }\n  });\n\n  // Social challenges\n  fastify.post('/challenges', {\n    preHandler: [authenticate, userRateLimit],\n    schema: { body: socialChallengeSchema }\n  }, async (request: FastifyRequest<{ Body: SocialChallengeData }>, reply) => {\n    try {\n      const result = await SocialService.createSocialChallenge(request.user.sub, request.body);\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      sendError(reply, error, 'Challenge creation failed');\n    }\n  });\n\n  // Leaderboard\n  fastify.get('/leaderboard', {\n    preHandler: [authenticate],\n    schema: {\n      querystring: {\n        type: 'object',\n        properties: {\n          type: { type: 'string', enum: ['global', 'city', 'friends'], default: 'global' },\n          city: { type: 'string' },\n          limit: { type: 'number', minimum: 1, maximum: 100, default: 50 },\n          offset: { type: 'number', minimum: 0, default: 0 }\n        }\n      }\n    }\n  }, async (request: FastifyRequest<{\n    Querystring: {\n      type?: 'global' | 'city' | 'friends';\n      city?: string;\n      limit?: number;\n      offset?: number;\n    }\n  }>, reply: FastifyReply) => {\n    try {\n      const result = await SocialService.getLeaderboard(\n        request.user.sub,\n        request.query.type,\n        request.query.city,\n        request.query.limit,\n        request.query.offset\n      );\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      reply.code(500).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Share capture\n  fastify.post('/share', {\n    preHandler: [authenticate],\n    schema: {\n      body: {\n        type: 'object',\n        required: ['captureId', 'platform'],\n        properties: {\n          captureId: { type: 'string' },\n          platform: {\n            type: 'string',\n            enum: ['facebook', 'instagram', 'twitter', 'whatsapp']\n          },\n          message: { type: 'string', maxLength: 500 }\n        }\n      }\n    }\n  }, async (request: FastifyRequest<{\n    Body: {\n      captureId: string;\n      platform: 'facebook' | 'instagram' | 'twitter' | 'whatsapp';\n      message?: string;\n    }\n  }>, reply: FastifyReply) => {\n    try {\n      const result = await SocialService.shareCapture(\n        request.user.sub,\n        request.body.captureId,\n        request.body.platform,\n        request.body.message\n      );\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      reply.code(400).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Get user profile\n  fastify.get('/profile/:userId', {\n    preHandler: [authenticate],\n    schema: {\n      params: {\n        type: 'object',\n        required: ['userId'],\n        properties: {\n          userId: { type: 'string' }\n        }\n      }\n    }\n  }, async (request: FastifyRequest<{\n    Params: { userId: string };\n  }>, reply: FastifyReply) => {\n    try {\n      const result = await SocialService.getUserProfile(\n        request.user.sub,\n        request.params.userId\n      );\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      reply.code(404).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Nearby players\n  fastify.get('/nearby', {\n    preHandler: [authenticate],\n    schema: {\n      querystring: {\n        type: 'object',\n        required: ['latitude', 'longitude', 'radius'],\n        properties: {\n          latitude: { type: 'number', minimum: -90, maximum: 90 },\n          longitude: { type: 'number', minimum: -180, maximum: 180 },\n          radius: { type: 'number', minimum: 0.1, maximum: 50, default: 5 }\n        }\n      }\n    }\n  }, async (request: FastifyRequest<{\n    Querystring: {\n      latitude: number;\n      longitude: number;\n      radius: number;\n    }\n  }>, reply: FastifyReply) => {\n    try {\n      const result = await SocialService.getNearbyPlayers(\n        request.user.sub,\n        { latitude: request.query.latitude, longitude: request.query.longitude },\n        request.query.radius\n      );\n      reply.send({ success: true, data: result });\n    } catch (error) {\n      reply.code(500).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // ========================================\n  // NEW FRIENDSHIP ROUTES (using FriendshipService)\n  // ========================================\n\n  // Send friend request\n  fastify.post('/friends/send', {\n    preHandler: [authenticate],\n    schema: {\n      body: {\n        type: 'object',\n        required: ['friendId'],\n        properties: {\n          friendId: { type: 'string' }\n        }\n      }\n    }\n  }, async (request: FastifyRequest<{\n    Body: { friendId: string };\n  }>, reply: FastifyReply) => {\n    try {\n      const FriendshipService = (await import('@/services/friendship')).default;\n      const result = await FriendshipService.sendFriendRequest(\n        request.user.sub,\n        request.body.friendId\n      );\n      reply.code(201).send(result);\n    } catch (error) {\n      const statusCode = (error as any).message === 'USER_NOT_FOUND' ? 404 :\n                         (error as any).message === 'CANNOT_ADD_SELF' ? 400 :\n                         (error as any).message.startsWith('FRIENDSHIP_ALREADY_EXISTS') ? 409 : 500;\n      reply.code(statusCode).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Accept friend request\n  fastify.post('/friends/accept/:friendshipId', {\n    preHandler: [authenticate],\n    schema: {\n      params: {\n        type: 'object',\n        required: ['friendshipId'],\n        properties: {\n          friendshipId: { type: 'string' }\n        }\n      }\n    }\n  }, async (request: FastifyRequest<{\n    Params: { friendshipId: string };\n  }>, reply: FastifyReply) => {\n    try {\n      const FriendshipService = (await import('@/services/friendship')).default;\n      const result = await FriendshipService.acceptFriendRequest(\n        request.user.sub,\n        request.params.friendshipId\n      );\n      reply.send(result);\n    } catch (error) {\n      const statusCode = (error as any).message === 'FRIENDSHIP_NOT_FOUND' ? 404 :\n                         (error as any).message === 'FORBIDDEN' ? 403 : 400;\n      reply.code(statusCode).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Reject friend request\n  fastify.post('/friends/reject/:friendshipId', {\n    preHandler: [authenticate],\n    schema: {\n      params: {\n        type: 'object',\n        required: ['friendshipId'],\n        properties: {\n          friendshipId: { type: 'string' }\n        }\n      }\n    }\n  }, async (request: FastifyRequest<{\n    Params: { friendshipId: string };\n  }>, reply: FastifyReply) => {\n    try {\n      const FriendshipService = (await import('@/services/friendship')).default;\n      const result = await FriendshipService.rejectFriendRequest(\n        request.user.sub,\n        request.params.friendshipId\n      );\n      reply.send(result);\n    } catch (error) {\n      const statusCode = (error as any).message === 'FRIENDSHIP_NOT_FOUND' ? 404 :\n                         (error as any).message === 'FORBIDDEN' ? 403 : 400;\n      reply.code(statusCode).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Remove friend\n  fastify.delete('/friends/:friendshipId', {\n    preHandler: [authenticate],\n    schema: {\n      params: {\n        type: 'object',\n        required: ['friendshipId'],\n        properties: {\n          friendshipId: { type: 'string' }\n        }\n      }\n    }\n  }, async (request: FastifyRequest<{\n    Params: { friendshipId: string };\n  }>, reply: FastifyReply) => {\n    try {\n      const FriendshipService = (await import('@/services/friendship')).default;\n      const result = await FriendshipService.removeFriend(\n        request.user.sub,\n        request.params.friendshipId\n      );\n      reply.send(result);\n    } catch (error) {\n      const statusCode = (error as any).message === 'FRIENDSHIP_NOT_FOUND' ? 404 :\n                         (error as any).message === 'FORBIDDEN' ? 403 : 500;\n      reply.code(statusCode).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Block user\n  fastify.post('/friends/block/:friendshipId', {\n    preHandler: [authenticate],\n    schema: {\n      params: {\n        type: 'object',\n        required: ['friendshipId'],\n        properties: {\n          friendshipId: { type: 'string' }\n        }\n      }\n    }\n  }, async (request: FastifyRequest<{\n    Params: { friendshipId: string };\n  }>, reply: FastifyReply) => {\n    try {\n      const FriendshipService = (await import('@/services/friendship')).default;\n      const result = await FriendshipService.blockUser(\n        request.user.sub,\n        request.params.friendshipId\n      );\n      reply.send(result);\n    } catch (error) {\n      const statusCode = (error as any).message === 'FRIENDSHIP_NOT_FOUND' ? 404 :\n                         (error as any).message === 'FORBIDDEN' ? 403 : 500;\n      reply.code(statusCode).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Get pending friend requests (received)\n  fastify.get('/friends/requests/pending', {\n    preHandler: [authenticate]}, async (request, reply) => {\n    try {\n      const FriendshipService = (await import('@/services/friendship')).default;\n      const result = await FriendshipService.getPendingRequests(request.user.sub);\n      reply.send(result);\n    } catch (error) {\n      reply.code(500).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Get sent friend requests\n  fastify.get('/friends/requests/sent', {\n    preHandler: [authenticate]}, async (request, reply) => {\n    try {\n      const FriendshipService = (await import('@/services/friendship')).default;\n      const result = await FriendshipService.getSentRequests(request.user.sub);\n      reply.send(result);\n    } catch (error) {\n      reply.code(500).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Check friendship status\n  fastify.get('/friends/status/:userId', {\n    preHandler: [authenticate],\n    schema: {\n      params: {\n        type: 'object',\n        required: ['userId'],\n        properties: {\n          userId: { type: 'string' }\n        }\n      }\n    }\n  }, async (request: FastifyRequest<{\n    Params: { userId: string };\n  }>, reply: FastifyReply) => {\n    try {\n      const FriendshipService = (await import('@/services/friendship')).default;\n      const status = await FriendshipService.getFriendshipStatus(\n        request.user.sub,\n        request.params.userId\n      );\n      reply.send({ status });\n    } catch (error) {\n      reply.code(500).send({ success: false, error: (error as any).message });\n    }\n  });\n\n  // Get friends count\n  fastify.get('/friends/count', {\n    preHandler: [authenticate]}, async (request, reply) => {\n    try {\n      const FriendshipService = (await import('@/services/friendship')).default;\n      const count = await FriendshipService.countFriends(request.user.sub);\n      reply.send({ count });\n    } catch (error) {\n      reply.code(500).send({ success: false, error: (error as any).message });\n    }\n  });\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\users\\index.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":55,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2041,2044],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2041,2044],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":110,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":110,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3726,3729],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3726,3729],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":114,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":114,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4037,4040],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4037,4040],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":115,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":115,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4111,4114],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4111,4114],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":123,"column":15,"nodeType":"BlockStatement","messageId":"unexpected","endLine":123,"endColumn":17,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[4436,4436],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":197,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":197,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6641,6644],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6641,6644],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":198,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":198,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6714,6717],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6714,6717],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":232,"column":69,"nodeType":"BlockStatement","messageId":"unexpected","endLine":232,"endColumn":71,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[7773,7773],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":249,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":249,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8104,8107],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8104,8107],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":294,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":294,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9520,9523],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9520,9523],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":371,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":371,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11718,11721],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11718,11721],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":413,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":413,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12985,12988],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12985,12988],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":422,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":422,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13115,13118],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13115,13118],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":464,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":464,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14341,14344],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14341,14344],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":468,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":468,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14480,14483],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14480,14483],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":491,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":491,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15082,15085],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15082,15085],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":495,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":495,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15196,15199],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15196,15199],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":513,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":513,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15683,15686],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15683,15686],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":529,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":529,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16120,16123],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16120,16123],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":533,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":533,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16253,16256],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16253,16256],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":552,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":552,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16871,16874],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16871,16874],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":21,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FastifyInstance } from 'fastify';\nimport { authenticate } from '@/middleware/auth';\nimport { z } from 'zod';\nimport { Types } from 'mongoose';\nimport { User } from '@/models/User';\nimport { Claim } from '@/models/Claim';\nimport { Achievement } from '@/models/Achievement';\nimport { RedisCache } from '@/config/redis';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { UserLevel } from '@/types';\nimport { TUNISIA_CITIES } from '@/config';\nimport { PointsHistoryService } from '@/services/points-history';\n\n// Validation schemas\nconst updateProfileSchema = z.object({\n  displayName: z.string().min(2).max(50).optional(),\n  email: z.string().email().optional(),\n  preferences: z.object({\n    language: z.enum(['ar', 'fr', 'en']).optional(),\n    theme: z.enum(['light', 'dark']).optional(),\n    notifications: z.object({\n      push: z.boolean().optional(),\n      email: z.boolean().optional(),\n      sms: z.boolean().optional(),\n      inApp: z.boolean().optional(),\n    }).optional(),\n    privacy: z.object({\n      showOnLeaderboard: z.boolean().optional(),\n      shareLocation: z.boolean().optional()}).optional()}).optional()});\n\nconst getLeaderboardSchema = z.object({\n  city: z.enum(Object.keys(TUNISIA_CITIES) as [string, ...string[]]).optional(),\n  level: z.enum(Object.values(UserLevel) as [string, ...string[]]).optional(),\n  timeframe: z.enum(['daily', 'weekly', 'monthly', 'all-time']).default('weekly'),\n  limit: z.number().min(1).max(100).default(50)});\n\nconst pointsHistorySchema = z.object({\n  page: z.coerce.number().int().min(1).default(1),\n  limit: z.coerce.number().int().min(1).max(100).default(50),\n  includeZero: z.coerce.boolean().optional(),\n  filter: z.enum(['all', 'credit', 'debit', 'achievement', 'claim']).optional(),\n});\n\n/**\n * Users service\n */\nexport class UsersService {\n  /**\n   * Get user profile\n   */\n  static async getProfile(userId: string) {\n    try {\n      // Try cache first to reduce DB load\n      const cacheKey = `user:profile:${userId}`;\n      const cached = await RedisCache.get<any>(cacheKey);\n      if (cached) return cached;\n\n      const user = await User.findById(userId).select('-password');\n      \n      if (!user) {\n        throw new Error('USER_NOT_FOUND');\n      }\n\n      // Get additional stats\n      const claimStats = await Claim.aggregate([\n        { $match: { userId: new Types.ObjectId(userId), status: { $ne: 'rejected' } } },\n        {\n          $group: {\n            _id: null,\n            totalClaims: { $sum: 1 },\n            totalPoints: { $sum: '$pointsAwarded' },\n            averageDistance: { $avg: '$distance' },\n            validClaims: {\n              $sum: {\n                $cond: [\n                  {\n                    $and: [\n                      '$validationChecks.distanceValid',\n                      '$validationChecks.timeValid',\n                      '$validationChecks.speedValid',\n                      '$validationChecks.cooldownValid',\n                      '$validationChecks.dailyLimitValid'\n                    ]\n                  },\n                  1,\n                  0\n                ]\n              }\n            }\n          }\n        }\n      ]);\n\n      const [resolvedClaimStats, recentActivity] = await Promise.all([\n        Promise.resolve(claimStats[0] || {\n          totalClaims: 0,\n          totalPoints: 0,\n          averageDistance: 0,\n          validClaims: 0,\n        }),\n        Claim.find({ userId: new Types.ObjectId(userId), status: { $ne: 'rejected' } })\n          .populate('prizeId', 'name category points')\n          .sort({ claimedAt: -1 })\n          .limit(5)]);\n\n      const result = {\n        ...user.toJSON(),\n        stats: {\n          ...user.stats,\n          totalClaims: (user as any).stats?.totalClaims || resolvedClaimStats.totalClaims || user.stats.prizesFound || 0,  // Use database field if exists, else calculated value or fallback\n          ...resolvedClaimStats},\n        recentActivity: recentActivity.map(claim => ({\n          id: claim._id,\n          prizeName: (claim.prizeId as any)?.name || 'Unknown Prize',\n          prizeCategory: (claim.prizeId as any)?.category || 'General',\n          pointsAwarded: claim.pointsAwarded,\n          claimedAt: claim.claimedAt}))};\n\n      // Cache briefly (60s) for hot reads (best-effort)\n      try {\n        const cachedResult = JSON.parse(JSON.stringify(result));\n        await RedisCache.set(cacheKey, cachedResult, 60);\n      } catch {}\n\n      return result;\n\n    } catch (error) {\n      typedLogger.error('Get profile error', {\n        error: error instanceof Error ? error.message : 'Unknown error',\n        userId});\n      throw error;\n    }\n  }\n\n  /**\n   * Update user profile\n   */\n  static async updateProfile(\n    userId: string,\n    data: z.infer<typeof updateProfileSchema>\n  ) {\n    try {\n      const user = await User.findById(userId);\n      \n      if (!user) {\n        throw new Error('USER_NOT_FOUND');\n      }\n\n      // Update fields\n      if (data.displayName) {\n        user.displayName = data.displayName;\n      }\n\n      if (data.email) {\n        // Check if email is already taken\n        const existingUser = await User.findOne({\n          email: data.email,\n          _id: { $ne: userId }});\n        \n        if (existingUser) {\n          throw new Error('EMAIL_ALREADY_EXISTS');\n        }\n        \n        user.email = data.email;\n      }\n\n      if (data.preferences) {\n        // Handle preferences individually to keep enum compatibility and partial updates.\n\n        // Handle language: schema has string literals but model expects Language enum\n        if (data.preferences.language) {\n          // Convert string to Language enum\n          const { Language } = await import('@/types');\n          switch (data.preferences.language) {\n            case 'fr':\n              user.preferences.language = Language.FR;\n              break;\n            case 'ar':\n              user.preferences.language = Language.AR;\n              break;\n            case 'en':\n              user.preferences.language = Language.EN;\n              break;\n            default:\n              user.preferences.language = Language.FR; // default fallback\n          }\n        }\n\n        // Handle theme: schema has string literals but model expects Theme enum\n        if (data.preferences.theme) {\n          const { Theme } = await import('@/types');\n          user.preferences.theme = data.preferences.theme === 'dark' ? Theme.DARK : Theme.LIGHT;\n        }\n\n        // Handle notifications: merge partial updates into the stored object\n        if (data.preferences.notifications) {\n          const current = (user.preferences.notifications as any) || {};\n          const incoming = data.preferences.notifications as any;\n          const normalizeBoolean = (value: boolean) => ({\n            push: value,\n            email: value,\n            sms: value,\n            inApp: value,\n          });\n\n          const next =\n            typeof incoming === 'boolean'\n              ? normalizeBoolean(incoming)\n              : {\n                  push: incoming.push ?? current.push ?? true,\n                  email: incoming.email ?? current.email ?? false,\n                  sms: incoming.sms ?? current.sms ?? false,\n                  inApp: incoming.inApp ?? current.inApp ?? true,\n                };\n\n          user.preferences.notifications = {\n            ...(current || {}),\n            ...next,\n          };\n        }\n\n        // Note: privacy settings from schema are not stored in User model, only in request validation\n      }\n\n      await user.save();\n\n      typedLogger.info('Profile updated', {\n        userId,\n        updates: Object.keys(data)});\n\n      // Invalidate cached profile (best-effort)\n      try { await RedisCache.del(`user:profile:${userId}`); } catch {}\n\n      return user.toJSON();\n\n    } catch (error) {\n      typedLogger.error('Update profile error', {\n        error: (error as Error).message,\n        userId});\n      throw error;\n    }\n  }\n\n  /**\n   * Get leaderboard\n   */\n  static async getLeaderboard(data: z.infer<typeof getLeaderboardSchema>) {\n    try {\n      const query: any = {\n        'preferences.privacy.showOnLeaderboard': { $ne: false },\n        isBanned: false,\n        deletedAt: { $exists: false }};\n\n      if (data.city) {\n        query['location.city'] = data.city;\n      }\n\n      if (data.level) {\n        query.level = data.level;\n      }\n\n      // Add timeframe filter for recent activity\n      if (data.timeframe !== 'all-time') {\n        const now = new Date();\n        let startDate: Date;\n\n        switch (data.timeframe) {\n          case 'daily':\n            startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n            break;\n          case 'weekly':\n            startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\n            break;\n          case 'monthly':\n            startDate = new Date(now.getFullYear(), now.getMonth(), 1);\n            break;\n        }\n\n        query.lastActive = { $gte: startDate };\n      }\n\n      const users = await User.find(query).select('-password')\n        .select('displayName level points.total stats.totalClaims location.city createdAt')\n        .sort({ 'points.total': -1, 'stats.totalClaims': -1 })\n        .limit(data.limit);\n\n      return {\n        leaderboard: users.map((user, index) => ({\n          rank: index + 1,\n          id: user._id,\n          displayName: user.displayName,\n          level: user.level,\n          totalPoints: user.points.total,\n          totalClaims: (user.stats as any).totalClaims || 0,  // Use database field or fallback to 0\n          city: user.location.city,\n          joinedAt: user.createdAt})),\n        timeframe: data.timeframe,\n        city: data.city,\n        level: data.level,\n        total: users.length};\n\n    } catch (error) {\n      typedLogger.error('Get leaderboard error', {\n        error: (error as Error).message,\n        filters: data});\n      throw error;\n    }\n  }\n\n  /**\n   * Get user statistics\n   */\n  static async getUserStats(userId: string) {\n    try {\n      const user = await User.findById(userId);\n      \n      if (!user) {\n        throw new Error('USER_NOT_FOUND');\n      }\n\n      // Get detailed statistics\n      const claimStats = await Claim.aggregate([\n        { $match: { userId: new Types.ObjectId(userId) } },\n        {\n          $group: {\n            _id: null,\n            totalClaims: { $sum: 1 },\n            totalPoints: { $sum: '$pointsAwarded' },\n            averageDistance: { $avg: '$distance' },\n            validClaims: {\n              $sum: {\n                $cond: [\n                  {\n                    $and: [\n                      '$validationChecks.distanceValid',\n                      '$validationChecks.timeValid',\n                      '$validationChecks.speedValid',\n                      '$validationChecks.cooldownValid',\n                      '$validationChecks.dailyLimitValid'\n                    ]\n                  },\n                  1,\n                  0\n                ]\n              }\n            }\n          }\n        }\n      ]);\n\n      const [resolvedClaimStats, rankInfo, levelProgress, achievements] = await Promise.all([\n        Promise.resolve(claimStats[0] || {\n          totalClaims: 0,\n          totalPoints: 0,\n          averageDistance: 0,\n          validClaims: 0,\n        }),\n        this.getUserRank(userId),\n        this.getLevelProgress(user),\n        Achievement.find({ userId: user._id })]);\n\n      return {\n        user: {\n          id: user._id,\n          displayName: user.displayName,\n          level: user.level,\n          joinedAt: user.createdAt},\n        points: user.points,\n        stats: {\n          ...user.stats,\n          totalClaims: (user.stats as any).totalClaims || resolvedClaimStats.totalClaims || user.stats.prizesFound || 0, // Use database field if exists, else calculated value or fallback\n          ...resolvedClaimStats},\n        rank: rankInfo,\n        levelProgress,\n        achievements: achievements || []};\n\n    } catch (error) {\n      typedLogger.error('Get user stats error', {\n        error: (error as Error).message,\n        userId});\n      throw error;\n    }\n  }\n\n  /**\n   * Get user rank\n   */\n  static async getUserRank(userId: string) {\n    try {\n      const user = await User.findById(userId);\n      if (!user) return null;\n\n      // Global rank\n      const globalRank = await User.countDocuments({\n        'points.total': { $gt: user.points.total },\n        isBanned: false,\n        deletedAt: { $exists: false }}) + 1;\n\n      // City rank\n      const cityRank = user.location.city ? await User.countDocuments({\n        'points.total': { $gt: user.points.total },\n        'location.city': user.location.city,\n        isBanned: false,\n        deletedAt: { $exists: false }}) + 1 : null;\n\n      return {\n        global: globalRank,\n        city: cityRank,\n        cityName: user.location.city};\n\n    } catch (error) {\n      typedLogger.error('Get user rank error', {\n        error: (error as any).message,\n        userId});\n      return null;\n    }\n  }\n\n  /**\n   * Get level progress\n   */\n  static getLevelProgress(user: any) {\n    const levels = Object.values(UserLevel);\n    const currentLevelIndex = levels.indexOf(user.level);\n    \n    if (currentLevelIndex === -1 || currentLevelIndex === levels.length - 1) {\n      return {\n        currentLevel: user.level,\n        nextLevel: null,\n        progress: 100,\n        pointsToNext: 0,\n        pointsForNext: 0};\n    }\n\n    const nextLevel = levels[currentLevelIndex + 1];\n    const pointsForNext = User.getPointsForLevel(nextLevel);\n    const pointsToNext = Math.max(0, pointsForNext - user.points.total);\n    const progress = Math.min(100, (user.points.total / pointsForNext) * 100);\n\n    return {\n      currentLevel: user.level,\n      nextLevel,\n      progress: Math.round(progress),\n      pointsToNext,\n      pointsForNext};\n  }\n}\n\n/**\n * Users routes\n */\nexport default async function usersRoutes(fastify: FastifyInstance) {\n  // Get user profile\n  fastify.get('/profile', {\n    preHandler: [authenticate]}, async (request, reply) => {\n    try {\n      const result = await UsersService.getProfile(request.user.sub);\n      \n      reply.send({\n        success: true,\n        data: result,\n        timestamp: new Date().toISOString()});\n    } catch (error) {\n      const statusCode = (error as any).message === 'USER_NOT_FOUND' ? 404 : 500;\n      \n      reply.code(statusCode).send({\n        success: false,\n        error: (error as any).message,\n        timestamp: new Date().toISOString()});\n    }\n  });\n\n  // Update user profile\n  fastify.patch('/profile', {\n    preHandler: [authenticate]}, async (request, reply) => {\n    try {\n      const result = await UsersService.updateProfile(\n        request.user.sub,\n        request.body\n      );\n      \n      reply.send({\n        success: true,\n        data: result,\n        timestamp: new Date().toISOString()});\n    } catch (error) {\n      const statusCodes = {\n        'USER_NOT_FOUND': 404,\n        'EMAIL_ALREADY_EXISTS': 409};\n      \n      const statusCode = statusCodes[(error as any).message] || 500;\n      \n      reply.code(statusCode).send({\n        success: false,\n        error: (error as any).message,\n        timestamp: new Date().toISOString()});\n    }\n  });\n\n  // Get leaderboard\n  fastify.get('/leaderboard', {\n    preHandler: [authenticate]}, async (request, reply) => {\n    try {\n      const result = await UsersService.getLeaderboard(request.query);\n      \n      reply.send({\n        success: true,\n        data: result,\n        timestamp: new Date().toISOString()});\n    } catch (error) {\n      reply.code(500).send({\n        success: false,\n        error: (error as any).message,\n        timestamp: new Date().toISOString()});\n    }\n  });\n\n  // Get user statistics\n  fastify.get('/stats', {\n    preHandler: [authenticate]}, async (request, reply) => {\n    try {\n      const result = await UsersService.getUserStats(request.user.sub);\n\n      reply.send({\n        success: true,\n        data: result,\n        timestamp: new Date().toISOString()});\n    } catch (error) {\n      const statusCode = (error as any).message === 'USER_NOT_FOUND' ? 404 : 500;\n\n      reply.code(statusCode).send({\n        success: false,\n        error: (error as any).message,\n        timestamp: new Date().toISOString()});\n    }\n  });\n\n  // Get points history (reconstructed from existing records)\n  fastify.get('/points/history', {\n    preHandler: [authenticate]}, async (request, reply) => {\n    try {\n      const query = pointsHistorySchema.parse(request.query || {});\n      const result = await PointsHistoryService.getUserHistory(request.user.sub, query);\n      reply.send({\n        success: true,\n        data: result,\n        timestamp: new Date().toISOString(),\n      });\n    } catch (error) {\n      reply.code(500).send({\n        success: false,\n        error: (error as any).message,\n        timestamp: new Date().toISOString(),\n      });\n    }\n  });\n\n  // NOTE: Admin routes (ban, unban, get all users) have been moved to admin module to eliminate duplication\n  // and maintain proper separation of concerns between user and admin functionality\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\modules\\users\\routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\scripts\\create-admin.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\server.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'errors' is defined but never used. Allowed unused args must match /^_/u.","line":41,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":41,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'dataVar' is defined but never used. Allowed unused args must match /^_/u.","line":41,"column":36,"nodeType":"Identifier","messageId":"unusedVar","endLine":41,"endColumn":43},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'request' is defined but never used. Allowed unused args must match /^_/u.","line":88,"column":69,"nodeType":"Identifier","messageId":"unusedVar","endLine":88,"endColumn":76},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'reply' is defined but never used. Allowed unused args must match /^_/u.","line":88,"column":78,"nodeType":"Identifier","messageId":"unusedVar","endLine":88,"endColumn":83},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'request' is defined but never used. Allowed unused args must match /^_/u.","line":98,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":98,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'reply' is defined but never used. Allowed unused args must match /^_/u.","line":98,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":98,"endColumn":40},{"ruleId":"no-extra-semi","severity":2,"message":"Unnecessary semicolon.","line":344,"column":36,"nodeType":"EmptyStatement","messageId":"unexpected","endLine":344,"endColumn":37,"fix":{"range":[12644,12682],"text":";\n\n    // Register routes\n    console"}},{"ruleId":"no-extra-semi","severity":2,"message":"Unnecessary semicolon.","line":369,"column":40,"nodeType":"EmptyStatement","messageId":"unexpected","endLine":369,"endColumn":41,"fix":{"range":[14352,14397],"text":";\n\n    // Catch-all route for 404\n    server"}},{"ruleId":"no-irregular-whitespace","severity":2,"message":"Irregular whitespace not allowed.","line":391,"column":20,"nodeType":"Program","messageId":"noIrregularWhitespace","endLine":391,"endColumn":21},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":528,"column":36,"nodeType":"BlockStatement","messageId":"unexpected","endLine":529,"endColumn":6,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[20111,20116],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":2,"fixableWarningCount":0,"source":"import Fastify, { FastifyInstance, FastifyReply, FastifyRequest } from 'fastify';\nimport { config, isDevelopment, isProduction } from './config/index.js';\nimport { logger } from './lib/logger.js';\nimport { connectDB, createIndexes, disconnectDB } from './config/database.js';\nimport { connectRedis, initializeRedisUtilities, disconnectRedis, redisClient } from './config/redis.js';\nimport { configService } from './services/config.js';\nimport { metrics } from './middleware/metrics.js';\nimport { MetricsService } from './services/metrics.js';\nimport { ipRateLimit } from './middleware/distributed-rate-limit.js';\nimport { authenticate } from './middleware/auth.js';\nimport { setupWebSocket } from './lib/websocket.js';\nimport fastifyCors from '@fastify/cors';\nimport { createHash } from 'crypto';\nimport fastifyStatic from '@fastify/static';\nimport path from 'path';\nimport type { Server as SocketIOServer, Socket } from 'socket.io';\n\nconst getErrorMessage = (error: unknown) =>\n  error instanceof Error\n    ? error.message\n    : typeof error === 'string'\n      ? error\n      : (error as { message?: string } | null)?.message || 'Unknown error';\n\ntype ZodIssue = { path: Array<string | number>; message: string };\ntype ZodParseResult = { success: true; data: unknown } | { success: false; error: { issues: ZodIssue[] } };\ntype ZodLikeSchema = { safeParse: (data: unknown) => ZodParseResult };\n\nconsole.log('├░┼©┼íÔé¼ Starting YallaCatch Backend...');\n\n/**\n * Create and configure Fastify server\n */\nasync function createServer(): Promise<FastifyInstance> {\n  const server = Fastify({\n    logger: logger,\n    trustProxy: config.NODE_ENV === 'production',\n    bodyLimit: 10 * 1024 * 1024, // 10MB\n    keepAliveTimeout: 30000,\n    // Disable schema validation errors for now\n    schemaErrorFormatter: (errors, dataVar) => {\n      return new Error('Validation error');\n    },\n    ajv: {\n      customOptions: {\n        removeAdditional: false,\n        useDefaults: true,\n        coerceTypes: true,\n        allErrors: false,\n      },\n    },\n  });\n\n  // Allow Zod schemas in routes without AJV errors\n  server.setValidatorCompiler(({ schema }) => {\n    return (data) => {\n      const candidate = schema as ZodLikeSchema | undefined;\n      if (candidate && typeof candidate.safeParse === 'function') {\n        const result = candidate.safeParse(data);\n        if (result.success === false) {\n          const details = result.error.issues\n            .map(issue => `${issue.path.join('.') || 'value'} ${issue.message}`)\n            .join('; ');\n          throw new Error(details || 'Validation error');\n        }\n        return result.data;\n      }\n      return data;\n    };\n  });\n\n  const requireHealthAccess = async (request: FastifyRequest, reply: FastifyReply): Promise<void> => {\n    if (isProduction && config.HEALTH_AUTH_TOKEN) {\n      const token = request.headers['x-health-token'];\n      if (token !== config.HEALTH_AUTH_TOKEN) {\n        reply.code(403).send({\n          success: false,\n          error: 'FORBIDDEN',\n          message: 'Unauthorized health access',\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n    }\n  };\n\n  // Health check endpoint\n  server.get('/health', { preHandler: requireHealthAccess }, async (request, reply) => {\n    return {\n      status: 'ok',\n      timestamp: new Date().toISOString(),\n      environment: config.NODE_ENV,\n      version: '2.0.1',\n    };\n  });\n\n  // Root endpoint\n  server.get('/', async (request, reply) => {\n    return {\n      message: 'YallaCatch! Backend API',\n      version: '2.0.1',\n      environment: config.NODE_ENV,\n      endpoints: {\n        health: '/health',\n        api: '/api/v1',\n      },\n    };\n  });\n\n  // Basic caching headers helper\n  server.decorateReply('setStaticCache', function(this: FastifyReply, maxAgeSeconds: number = 86400) {\n    this.header('Cache-Control', `public, max-age=${maxAgeSeconds}, immutable`);\n    return this;\n  });\n\n  // Generic ETag/Last-Modified helper for GET 200 responses (buffers/strings only)\n  server.addHook('onSend', async (request, reply, payload) => {\n    try {\n      const isGet = request.method === 'GET';\n      const isOk = reply.statusCode === 200;\n      const hasEtag = !!reply.getHeader('ETag');\n      const cachablePayload = typeof payload === 'string' || Buffer.isBuffer(payload);\n      if (!isGet || !isOk || hasEtag || !cachablePayload) {\n        return payload;\n      }\n\n      const buffer = Buffer.isBuffer(payload) ? payload : Buffer.from(payload);\n      const etag = 'W/\"' + createHash('sha1').update(buffer).digest('base64') + '\"';\n\n      // If client already has this version, short-circuit with 304\n      if (request.headers['if-none-match'] === etag) {\n        reply.code(304);\n        return null;\n      }\n\n      reply.header('ETag', etag);\n      if (!reply.getHeader('Last-Modified')) {\n        reply.header('Last-Modified', new Date().toUTCString());\n      }\n      return payload;\n    } catch {\n      return payload;\n    }\n  });\n\n  // Register authenticate as decorator\n  server.decorate('authenticate', authenticate);\n  // Global distributed rate limiter (IP-based)\n  server.addHook('onRequest', ipRateLimit);\n  const maintenanceCache = { active: false, message: null as string | null, checkedAt: 0 };\n  const isMaintenanceBypass = (url: string) => {\n    return (\n      url.startsWith('/health') ||\n      url.startsWith('/metrics') ||\n      url.startsWith('/docs') ||\n      url.startsWith('/admin') ||\n      url.startsWith('/api/v1/auth') ||\n      url.startsWith('/api/v1/admin')\n    );\n  };\n  const getMaintenanceStatus = async () => {\n    const now = Date.now();\n    if (now - maintenanceCache.checkedAt < 5000) return maintenanceCache;\n    maintenanceCache.checkedAt = now;\n    if (!redisClient || redisClient.status !== 'ready') return maintenanceCache;\n    try {\n      const raw = await redisClient.get('system:maintenance');\n      if (!raw) {\n        maintenanceCache.active = false;\n        maintenanceCache.message = null;\n        return maintenanceCache;\n      }\n      const parsed = JSON.parse(raw) as { active?: boolean; message?: string };\n      maintenanceCache.active = parsed.active === true;\n      maintenanceCache.message = parsed.message || null;\n      return maintenanceCache;\n    } catch {\n      maintenanceCache.active = false;\n      maintenanceCache.message = null;\n      return maintenanceCache;\n    }\n  };\n\n  server.addHook('onRequest', async (request, reply) => {\n    const url = request.url || '';\n    if (isMaintenanceBypass(url)) return;\n    const status = await getMaintenanceStatus();\n    if (!status.active) return;\n    reply.code(503).send({\n      success: false,\n      error: 'MAINTENANCE_MODE',\n      message: status.message || 'System is under maintenance',\n      timestamp: new Date().toISOString(),\n    });\n  });\n  if (config.METRICS_ENABLED) {\n    server.addHook('onRequest', metrics.onRequest);\n    server.addHook('onResponse', metrics.onResponse);\n    server.addHook('onRequest', async (request) => {\n      (request as FastifyRequest & { apiMetricsStart?: number }).apiMetricsStart = Date.now();\n    });\n    server.addHook('onResponse', async (request, reply) => {\n      const requestWithMetrics = request as FastifyRequest & {\n        apiMetricsStart?: number;\n        routerPath?: string;\n        routeOptions?: { url?: string };\n        user?: { sub?: string };\n      };\n      const start = requestWithMetrics.apiMetricsStart;\n      if (!start) return;\n      const duration = Date.now() - start;\n      const endpoint =\n        requestWithMetrics.routerPath ||\n        requestWithMetrics.routeOptions?.url ||\n        request.url.split('?')[0];\n      const userId = requestWithMetrics.user?.sub;\n      await MetricsService.recordAPIMetrics(endpoint, request.method, reply.statusCode, duration, userId);\n    });\n  }\n  // CORS (permissive for admin testing; uses env origins when set)\n  const allowedOrigins = Array.isArray(config.CORS_ORIGINS) ? config.CORS_ORIGINS : [];\n  await server.register(fastifyCors, {\n    origin: (origin, cb) => {\n      if (!origin) return cb(null, true);\n      if (allowedOrigins.includes(origin)) return cb(null, true);\n      return cb(new Error('CORS origin not allowed'), false);\n    },\n    credentials: config.CORS_CREDENTIALS,\n    methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS', 'HEAD'],\n    allowedHeaders: [\n      'Origin',\n      'X-Requested-With',\n      'Content-Type',\n      'Accept',\n      'Authorization',\n      'X-Request-ID',\n      'X-Device-ID',\n      'X-Platform',\n      'X-App-Version',\n      'X-Session-ID',\n      'X-CSRF-Token',\n    ],\n    maxAge: 86400,\n  });\n  // Explicit preflight short-circuit\n  const preflight = (request: FastifyRequest, reply: FastifyReply): void => {\n    const origin = request.headers.origin as string | undefined;\n    const allowOrigin = origin && allowedOrigins.includes(origin)\n      ? origin\n      : (!origin ? (allowedOrigins[0] || '') : null);\n    if (!allowOrigin && origin) {\n      reply.code(403).send({ success: false, error: 'CORS_REJECTED' });\n      return;\n    }\n    reply\n      .header('Access-Control-Allow-Origin', allowOrigin || '')\n      .header('Access-Control-Allow-Credentials', 'true')\n      .header('Access-Control-Allow-Methods', 'GET,POST,PUT,PATCH,DELETE,OPTIONS,HEAD')\n      .header(\n        'Access-Control-Allow-Headers',\n        'Origin, X-Requested-With, Content-Type, Accept, Authorization, X-Request-ID, X-Device-ID, X-Platform, X-App-Version, X-Session-ID, X-CSRF-Token'\n      )\n      .code(204)\n      .send();\n  };\n  server.addHook('onRequest', async (request, reply) => {\n    if (request.method === 'OPTIONS') {\n      preflight(request, reply);\n      return;\n    }\n  });\n\n  if (config.METRICS_ENABLED && config.PROMETHEUS_ENABLED) {\n    server.get('/metrics', async (request, reply) => {\n      if (config.METRICS_AUTH_TOKEN) {\n        const token = request.headers['x-metrics-token'];\n        if (token !== config.METRICS_AUTH_TOKEN) {\n          return reply.code(403).send({\n            success: false,\n            error: 'FORBIDDEN',\n            message: 'Unauthorized metrics access',\n          });\n        }\n      }\n      reply.type('text/plain');\n      return metrics.getMetrics();\n    });\n  }\n\n  // Static mounts\n  await server.register(fastifyStatic, {\n    root: path.join(process.cwd(), '..', 'admin', 'dist'),\n    prefix: '/admin/',\n    decorateReply: false,\n    cacheControl: true,\n    maxAge: '365d',\n    etag: true,\n    lastModified: true,\n  });\n\n  await server.register(fastifyStatic, {\n    root: path.join(process.cwd(), 'uploads'),\n    prefix: '/uploads/',\n    decorateReply: false,\n    cacheControl: true,\n    maxAge: '1h',\n    etag: true,\n    lastModified: true,\n  });\n\n  return server;\n}\n\n/**\n * Register all API routes\n */\nasync function registerRoutes(server: FastifyInstance): Promise<void> {\n  const apiPrefix = '/api/v1';\n\n  try {\n    console.log('├░┼©ÔÇ£┬ª Loading routes...');\n\n    // Import routes dynamically\n    const authRoutes = (await import('./modules/auth/routes.js')).default;\n    const prizesRoutes = (await import('./modules/prizes/routes.js')).default;\n    const claimsRoutes = (await import('./modules/claims/routes.js')).default;\n    const rewardsRoutes = (await import('./modules/rewards/routes.js')).default;\n    const usersRoutes = (await import('./modules/users/routes.js')).default;\n    const adminRoutes = (await import('./modules/admin/routes.js')).default;\n    const notificationsRoutes = (await import('./modules/notifications/routes.js')).default;\n    // const analyticsRoutes = (await import('./modules/analytics/routes.js')).default; // Merged into admin\n    const gamificationRoutes = (await import('./modules/gamification/routes.js')).default;\n    // const partnersRoutes = (await import('./modules/partners/routes.js')).default; // Merged into admin\n    const captureRoutes = (await import('./modules/capture/routes.js')).default;\n    const marketplaceRoutes = (await import('./modules/marketplace/routes.js')).default;\n    const partnerMarketplaceRoutes = (await import('./modules/marketplace/partner.routes.js')).default;\n    // const distributionRoutes = (await import('./modules/distribution/routes.js')).default; // Merged into admin\n    const gameRoutes = (await import('./modules/game/routes.js')).default;\n    const socialRoutes = (await import('./modules/social/routes.js')).default;\n    const offlineRoutes = (await import('./modules/offline/routes.js')).default;\n     const integrationRoutes = (await import('./modules/integration/routes.js')).default;\n    const admobRoutes = (await import('./modules/admob/index.js')).default;\n\n    console.log('Ô£à Routes loaded');;\n\n    // Register routes\n    console.log('├░┼©ÔÇ£┬ª Registering routes...');\n    \n    await server.register(authRoutes, { prefix: `${apiPrefix}/auth` });\n    await server.register(prizesRoutes, { prefix: `${apiPrefix}/prizes` });\n    await server.register(claimsRoutes, { prefix: `${apiPrefix}/claims` });\n    await server.register(rewardsRoutes, { prefix: `${apiPrefix}/rewards` });\n    await server.register(usersRoutes, { prefix: `${apiPrefix}/users` });\n    await server.register(adminRoutes, { prefix: `${apiPrefix}/admin` });\n    await server.register(notificationsRoutes, { prefix: `${apiPrefix}/notifications` });\n    // await server.register(analyticsRoutes, { prefix: `${apiPrefix}/analytics` }); // Merged into admin\n    await server.register(gamificationRoutes, { prefix: `${apiPrefix}/gamification` });\n    // await server.register(partnersRoutes, { prefix: `${apiPrefix}/partners` }); // Merged into admin\n    await server.register(captureRoutes, { prefix: `${apiPrefix}/capture` });\n    await server.register(marketplaceRoutes, { prefix: `${apiPrefix}/marketplace` });\n    await server.register(partnerMarketplaceRoutes, { prefix: `${apiPrefix}/partner` });\n    // await server.register(distributionRoutes, { prefix: `${apiPrefix}/distribution` }); // Merged into admin\n    await server.register(gameRoutes, { prefix: `${apiPrefix}/game` });\n    await server.register(socialRoutes, { prefix: `${apiPrefix}/social` });\n    await server.register(offlineRoutes, { prefix: `${apiPrefix}/offline` });\n     await server.register(integrationRoutes, { prefix: `${apiPrefix}/integration` });\n    await server.register(admobRoutes, { prefix: `${apiPrefix}/admob` });\n\n    console.log('Ô£à Routes registered');;\n\n    // Catch-all route for 404\n    server.setNotFoundHandler(async (request, reply) => {\n      reply.code(404).send({\n        success: false,\n        error: 'Not Found',\n        message: `Route ${request.method} ${request.url} not found`,\n        timestamp: new Date().toISOString(),\n      });\n    });\n\n  } catch (error) {\n    console.error('├ó┬Ø┼Æ Error registering routes:', getErrorMessage(error));\n    throw error;\n  }\n}\n\n/**\n * Graceful shutdown handler\n */\nasync function gracefulShutdown(server: FastifyInstance, signal: string): Promise<void> {\n  console.log(`\\n├ó┼í┬á├»┬©┬Å  Received ${signal}, shutting down gracefully...`);\n\n  try {\n    // Stop accepting new connections\n    await server.close();\n    console.log('├ó┼ôÔÇª Server closed');\n\n    // Close database connections\n    await disconnectDB();\n    console.log('├ó┼ôÔÇª Database disconnected');\n\n    // Close Redis connections\n    await disconnectRedis();\n    console.log('├ó┼ôÔÇª Redis disconnected');\n\n    console.log('├ó┼ôÔÇª Graceful shutdown completed');\n    process.exit(0);\n  } catch (error) {\n    console.error('├ó┬Ø┼Æ Error during graceful shutdown:', getErrorMessage(error));\n    process.exit(1);\n  }\n}\n\n/**\n * Start the server\n */\nasync function start(): Promise<void> {\n  let server: FastifyInstance | null = null;\n\n  try {\n    console.log('├░┼©ÔÇ£ÔÇ╣ Environment:', config.NODE_ENV);\n    console.log('├░┼©ÔÇØ┼Æ Port:', config.PORT);\n    console.log('├░┼©┼Æ┬É Host:', config.HOST);\n\n    // Connect to databases\n    console.log('├░┼©ÔÇ£┬ª Connecting to MongoDB...');\n    await connectDB();\n    console.log('├ó┼ôÔÇª MongoDB connected');\n\n    console.log('­ƒöî Connecting to Redis...');\n    const redisClient = await connectRedis();\n    initializeRedisUtilities(redisClient);\n    // distributed rate limiters rely on redisClient set; no explicit init required\n    console.log('Ô£à Redis connected');\n\n    // Initialize ConfigService for real-time configuration\n    console.log('­ƒöº Initializing ConfigService...');\n    await configService.initialize();\n    console.log('Ô£à ConfigService initialized');\n\n    // Initialize MetricsService for game performance tracking\n    console.log('­ƒôè Initializing MetricsService...');\n    MetricsService.initialize();\n    console.log('Ô£à MetricsService initialized');\n\n    // Create database indexes\n    console.log('­ƒö¿ Creating database indexes...');\n    await createIndexes();\n    console.log('Ô£à Database indexes created');\n\n    // Create and configure server\n    console.log('├░┼©ÔÇ£┬ª Creating Fastify server...');\n    server = await createServer();\n    console.log('├ó┼ôÔÇª Fastify server created');\n\n    // Attempt to start Socket.io for admin/frontend realtime compatibility\n    try {\n      const { Server } = await import('socket.io');\n      const { verifyToken } = await import('./lib/jwt.js');\n      const { setSocketIO } = await import('./lib/websocket.js');\n      const corsOrigins = Array.isArray(config.CORS_ORIGINS) ? config.CORS_ORIGINS : [];\n      const io: SocketIOServer = new Server(server.server, {\n        cors: { origin: corsOrigins, credentials: config.CORS_CREDENTIALS },\n      });\n      io.use(async (socket: Socket, next) => {\n        try {\n          const authHeader = socket.handshake.headers['authorization'];\n          const tokenFromHeader = authHeader?.toString().startsWith('Bearer ')\n            ? authHeader.toString().slice(7)\n            : null;\n          const token = (socket.handshake.auth && socket.handshake.auth.token) || tokenFromHeader;\n          if (!token) return next(new Error('unauthorized'));\n          const result = await verifyToken(token);\n          if (!result.valid || !result.decoded) return next(new Error('unauthorized'));\n          socket.data.user = result.decoded;\n          return next();\n        } catch {\n          return next(new Error('unauthorized'));\n        }\n      });\n      io.on('connection', (socket: Socket) => {\n        const user = (socket.data.user as { role?: string; sub?: string }) || {};\n        const role = user.role || '';\n        const userId = user.sub || '';\n        const isAdmin = ['admin', 'super_admin', 'moderator'].includes(role);\n        const isPartner = role === 'partner';\n\n        const canJoinRoom = (room: string) => {\n          if (!room) return false;\n          if (room === 'admin' || room === 'dashboard' || room === 'marketplace' || room === 'rewards') {\n            return isAdmin || isPartner;\n          }\n          if (room.startsWith('user:')) {\n            return isAdmin || room === `user:${userId}`;\n          }\n          if (room.startsWith('partner:')) {\n            return isAdmin || isPartner;\n          }\n          if (room.startsWith('prize:')) {\n            return isAdmin;\n          }\n          if (room.startsWith('game:') || room === 'game') {\n            return isAdmin || isPartner;\n          }\n          return isAdmin;\n        };\n\n        logger.info({ type: 'socketio', event: 'connection', id: socket.id, userId });\n        socket.on('join_room', (data: { room?: string }) => {\n          const room = data?.room;\n          if (canJoinRoom(room)) {\n            socket.join(room);\n          } else {\n            socket.emit('error', { error: 'ROOM_FORBIDDEN', room });\n          }\n        });\n        socket.on('leave_room', (data: { room?: string }) => socket.leave(data?.room));\n        socket.on('disconnect', (reason: string) => logger.info({ type: 'socketio', event: 'disconnect', id: socket.id, reason }));\n      });\n      server.decorate('io', io);\n      // Register Socket.IO instance with websocket module for broadcasting\n      setSocketIO(io);\n      console.log('­ƒöî Socket.io initialized');\n    } catch (err) {\n      console.log('´┐¢?O Socket.io not installed, skipping realtime setup');\n    }\n    // Register rate limit plugin if enabled\n    if (config.RATE_LIMIT_ENABLED) {\n    }\n\n    // Optionally register Swagger\n    if (isDevelopment || config.ENABLE_SWAGGER) {\n      const swagger = (await import('@fastify/swagger')).default;\n      const swaggerUi = (await import('@fastify/swagger-ui')).default;\n      await server.register(swagger, {\n        swagger: {\n          info: {\n            title: 'YallaCatch! API',\n            description: 'AR Geolocation Game Backend API',\n            version: '2.0.2',\n          },\n          host: `${config.HOST}:${config.PORT}`,\n          schemes: ['http', 'https'],\n          consumes: ['application/json'],\n          produces: ['application/json'],\n          securityDefinitions: {\n            Bearer: {\n              type: 'apiKey',\n              name: 'Authorization',\n              in: 'header',\n              description: 'Enter bearer token as: Bearer <token>',\n            },\n          },\n        },\n      });\n      await server.register(swaggerUi, {\n        routePrefix: '/docs',\n        uiConfig: { docExpansion: 'list', deepLinking: false },\n        staticCSP: true,\n        transformStaticCSP: (header: string) => header,\n      });\n    }\n\n    // Register routes\n    await registerRoutes(server);\n\n    // Setup WebSocket\n    await setupWebSocket(server);\n\n    // Start scheduled jobs (analytics, cleanup, notifications)\n    try {\n      const jobs = await import('./jobs/index.js');\n      await jobs.startScheduledJobs();\n    } catch (err) {\n      console.log('Jobs module not available or failed to start, continuing without scheduled jobs');\n    }\n\n    // Start listening\n    console.log('├░┼©ÔÇ£┬ª Starting server...');\n    await server.listen({\n      port: config.PORT,\n      host: config.HOST,\n    });\n\n    console.log('');\n    console.log('├░┼©┼¢ÔÇ░ ============================================');\n    console.log('├░┼©┼¢ÔÇ░  YallaCatch! Backend started successfully!');\n    console.log('├░┼©┼¢ÔÇ░ ============================================');\n    console.log('');\n    console.log(`├░┼©ÔÇ£┬ì Server: http://${config.HOST}:${config.PORT}`);\n    console.log(`├░┼©ÔÇ£┬ì Health: http://${config.HOST}:${config.PORT}/health`);\n    console.log(`├░┼©ÔÇ£┬ì API: http://${config.HOST}:${config.PORT}/api/v1`);\n    console.log(`├░┼©ÔÇ£┬ì Environment: ${config.NODE_ENV}`);\n    console.log('');\n    console.log('├░┼©ÔÇ£┼á Routes registered:');\n    console.log('   - /api/v1/auth');\n    console.log('   - /api/v1/users');\n    console.log('   - /api/v1/prizes');\n    console.log('   - /api/v1/claims');\n    console.log('   - /api/v1/rewards');\n    console.log('   - /api/v1/partners');\n    console.log('   - /api/v1/marketplace');\n    console.log('   - /api/v1/gamification');\n    console.log('   - /api/v1/notifications');\n    console.log('   - /api/v1/analytics');\n    console.log('   - /api/v1/distribution');\n    console.log('   - /api/v1/capture');\n    console.log('   - /api/v1/game');\n    console.log('   - /api/v1/social');\n    console.log('   - /api/v1/offline');\n    console.log('   - /api/v1/integration');\n    console.log('   - /api/v1/admin');\n    console.log('');\n\n    // Setup graceful shutdown\n    const signals = ['SIGTERM', 'SIGINT', 'SIGUSR2'];\n    signals.forEach(signal => {\n      process.on(signal, () => gracefulShutdown(server!, signal));\n    });\n\n  } catch (error) {\n    console.error('├ó┬Ø┼Æ Failed to start server:', getErrorMessage(error));\n    if (error instanceof Error && error.stack) {\n      console.error(error.stack);\n    }\n\n    if (server) {\n      try {\n        await server.close();\n      } catch (closeError) {\n        console.error('├ó┬Ø┼Æ Error closing server:', getErrorMessage(closeError));\n      }\n    }\n\n    process.exit(1);\n  }\n}\n\n// Handle unhandled promise rejections\nprocess.on('unhandledRejection', (reason: unknown) => {\n  console.error('├ó┬Ø┼Æ Unhandled Promise Rejection:', reason);\n  process.exit(1);\n});\n\n// Handle uncaught exceptions\nprocess.on('uncaughtException', (error: Error) => {\n  console.error('├ó┬Ø┼Æ Uncaught Exception:', error.message);\n  console.error(error.stack);\n  process.exit(1);\n});\n\n// Start the server\nstart();\n\nexport { createServer, start };\nexport default start;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\services\\achievement.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'context' is defined but never used. Allowed unused args must match /^_/u.","line":87,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":87,"endColumn":22},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":99,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":99,"endColumn":60},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":103,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":103,"endColumn":55},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":107,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":113,"endColumn":13},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":114,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":114,"endColumn":58},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":115,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":115,"endColumn":48},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":119,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":119,"endColumn":57},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":124,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":126,"endColumn":14},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":132,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":134,"endColumn":14},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":139,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":139,"endColumn":59},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":143,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":143,"endColumn":76},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":144,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":144,"endColumn":77},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":148,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":148,"endColumn":68},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":253,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":253,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8207,8210],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8207,8210],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":300,"column":81,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":300,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9931,9934],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9931,9934],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":15,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Types } from 'mongoose';\nimport { User } from '@/models/User';\nimport {\n  Achievement,\n  AchievementTrigger,\n  AchievementConditionType,\n  AchievementReward,\n  IAchievement,\n} from '@/models/Achievement';\nimport { UserAchievement } from '@/models/UserAchievement';\nimport { Claim } from '@/models/Claim';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { ErrorLike, Metadata } from '@/types';\n\nconst getErrorMessage = (error: ErrorLike) =>\n  error instanceof Error ? error.message : typeof error === 'string' ? error : error.message || 'Unknown error';\n\n/**\n * Achievement Service\n * G├¿re le syst├¿me d'achievements automatique\n */\nexport class AchievementService {\n  /**\n   * V├®rifier et d├®bloquer les achievements pour un ├®v├®nement\n   */\n  static async checkAchievements(\n    userId: string,\n    trigger: AchievementTrigger | string,\n    context: Metadata = {}\n  ): Promise<void> {\n    try {\n      // R├®cup├®rer les achievements actifs li├®s ├á cet ├®v├®nement\n      const achievements = await Achievement.find({\n        trigger,\n        isActive: true,\n      }).lean();\n\n      if (achievements.length === 0) {\n        return;\n      }\n\n      // R├®cup├®rer l'utilisateur\n      const user = await User.findById(userId);\n      if (!user) {\n        return;\n      }\n\n      // V├®rifier chaque achievement\n      for (const achievement of achievements) {\n        const isUnlocked = await this.isUnlocked(userId, achievement._id.toString());\n\n        if (isUnlocked) {\n          continue; // D├®j├á d├®bloqu├®\n        }\n\n        // Calculer la progression\n        const progress = await this.calculateProgress(userId, achievement, context);\n\n        // Mettre ├á jour ou cr├®er UserAchievement\n        await UserAchievement.findOneAndUpdate(\n          { userId: new Types.ObjectId(userId), achievementId: achievement._id },\n          {\n            userId: new Types.ObjectId(userId),\n            achievementId: achievement._id,\n            progress,\n            updatedAt: new Date(),\n          },\n          { upsert: true }\n        );\n\n        // Si 100%, d├®bloquer\n        if (progress >= 100) {\n          await this.unlockAchievement(userId, achievement._id.toString(), achievement);\n        }\n      }\n    } catch (error) {\n      typedLogger.error('Check achievements error', { error: getErrorMessage(error), userId, trigger });\n    }\n  }\n\n  /**\n   * Calculer la progression d'un achievement\n   */\n  private static async calculateProgress(\n    userId: string,\n    achievement: IAchievement,\n    context: Metadata\n  ): Promise<number> {\n    try {\n      const user = await User.findById(userId);\n      if (!user) {\n        return 0;\n      }\n\n      const { condition } = achievement;\n\n      switch (condition.type) {\n        case AchievementConditionType.TOTAL_CLAIMS:\n          const totalClaims = user.stats?.prizesFound || 0;\n          return Math.min(100, (totalClaims / condition.target) * 100);\n\n        case AchievementConditionType.TOTAL_POINTS:\n          const totalPoints = user.points?.total || 0;\n          return Math.min(100, (totalPoints / condition.target) * 100);\n\n        case AchievementConditionType.LEVEL_REACHED:\n          const levelMap: Record<string, number> = {\n            bronze: 1,\n            silver: 2,\n            gold: 3,\n            platinum: 4,\n            diamond: 5\n          };\n          const currentLevel = levelMap[user.level] || 1;\n          const targetLevel = condition.target;\n          return currentLevel >= targetLevel ? 100 : 0;\n\n        case AchievementConditionType.STREAK_DAYS:\n          const streak = user.stats?.currentStreak || 0;\n          return Math.min(100, (streak / condition.target) * 100);\n\n        case AchievementConditionType.CATEGORY_CLAIMS:\n          // Compter les claims d'une cat├®gorie sp├®cifique\n          const categoryClaims = await Claim.countDocuments({\n            userId: new Types.ObjectId(userId),\n          });\n          // TODO: Filter by category when Prize is populated\n          return Math.min(100, (categoryClaims / condition.target) * 100);\n\n        case AchievementConditionType.RARITY_CLAIMS:\n          // Compter les claims d'une raret├® sp├®cifique\n          const rarityClaims = await Claim.countDocuments({\n            userId: new Types.ObjectId(userId),\n          });\n          // TODO: Filter by rarity when Prize is populated\n          return Math.min(100, (rarityClaims / condition.target) * 100);\n\n        case AchievementConditionType.DISTANCE_TRAVELED:\n          const distance = user.stats?.totalDistance || 0;\n          return Math.min(100, (distance / condition.target) * 100);\n\n        case AchievementConditionType.FRIENDS_COUNT:\n          const FriendshipService = (await import('./friendship')).default;\n          const friendsCount = await FriendshipService.countFriends(userId);\n          return Math.min(100, (friendsCount / condition.target) * 100);\n\n        case AchievementConditionType.REWARDS_REDEEMED:\n          const rewardsRedeemed = user.stats?.rewardsRedeemed || 0;\n          return Math.min(100, (rewardsRedeemed / condition.target) * 100);\n\n        default:\n          return 0;\n      }\n    } catch (error) {\n      typedLogger.error('Calculate progress error', { error: getErrorMessage(error), userId, achievement: achievement._id });\n      return 0;\n    }\n  }\n\n  /**\n   * V├®rifier si un achievement est d├®bloqu├®\n   */\n  private static async isUnlocked(userId: string, achievementId: string): Promise<boolean> {\n    const userAchievement = await UserAchievement.findOne({\n      userId: new Types.ObjectId(userId),\n      achievementId: new Types.ObjectId(achievementId),\n      unlockedAt: { $exists: true },\n    });\n    return !!userAchievement;\n  }\n\n  /**\n   * D├®bloquer un achievement\n   */\n  private static async unlockAchievement(\n    userId: string,\n    achievementId: string,\n    achievement: IAchievement\n  ): Promise<void> {\n    try {\n      // Marquer comme d├®bloqu├®\n      await UserAchievement.findOneAndUpdate(\n        { userId: new Types.ObjectId(userId), achievementId: new Types.ObjectId(achievementId) },\n        {\n          unlockedAt: new Date(),\n          progress: 100,\n        },\n        { upsert: true }\n      );\n\n      // Accorder les r├®compenses\n      await this.grantRewards(userId, achievement.rewards);\n\n      typedLogger.info('Achievement unlocked', {\n        userId,\n        achievementId,\n        achievementName: achievement.name,\n        rewards: achievement.rewards,\n      });\n    } catch (error) {\n      typedLogger.error('Unlock achievement error', { error: getErrorMessage(error), userId, achievementId });\n    }\n  }\n\n  /**\n   * Accorder les r├®compenses d'un achievement\n   */\n  private static async grantRewards(userId: string, rewards: AchievementReward[]): Promise<void> {\n    try {\n      const user = await User.findById(userId);\n      if (!user) {\n        return;\n      }\n\n      for (const reward of rewards) {\n        switch (reward.type) {\n          case 'POINTS':\n            user.addPoints(reward.value);\n            typedLogger.info('Achievement reward granted: points', { userId, points: reward.value });\n            break;\n\n          case 'POWER_UP':\n            // TODO: Impl├®menter le syst├¿me de power-ups\n            typedLogger.info('Achievement reward granted: power-up', { userId, powerUp: reward.value });\n            break;\n\n          case 'COSMETIC':\n            // TODO: Impl├®menter le syst├¿me de cosm├®tiques\n            typedLogger.info('Achievement reward granted: cosmetic', { userId, cosmetic: reward.value });\n            break;\n\n          case 'TITLE':\n            // TODO: Impl├®menter le syst├¿me de titres\n            typedLogger.info('Achievement reward granted: title', { userId, title: reward.value });\n            break;\n\n          case 'BADGE':\n            // TODO: Impl├®menter le syst├¿me de badges\n            typedLogger.info('Achievement reward granted: badge', { userId, badge: reward.value });\n            break;\n        }\n      }\n\n      await user.save();\n    } catch (error) {\n      typedLogger.error('Grant rewards error', { error: getErrorMessage(error), userId, rewards });\n    }\n  }\n\n  /**\n   * R├®cup├®rer tous les achievements d'un utilisateur\n   */\n  static async getUserAchievements(userId: string): Promise<any> {\n    try {\n      const [achievements, userAchievements] = await Promise.all([\n        Achievement.find({ isActive: true, isHidden: false }).sort({ category: 1, order: 1 }).lean(),\n        UserAchievement.find({ userId: new Types.ObjectId(userId) }).lean(),\n      ]);\n\n      // Mapper les achievements avec la progression\n      const achievementsWithProgress = achievements.map(achievement => {\n        const userAchievement = userAchievements.find(\n          ua => ua.achievementId.toString() === achievement._id.toString()\n        );\n\n        return {\n          ...achievement,\n          progress: userAchievement?.progress || 0,\n          unlockedAt: userAchievement?.unlockedAt || null,\n          isUnlocked: !!userAchievement?.unlockedAt,\n        };\n      });\n\n      const unlocked = achievementsWithProgress.filter(a => a.isUnlocked);\n      const inProgress = achievementsWithProgress.filter(a => !a.isUnlocked && a.progress > 0);\n      const locked = achievementsWithProgress.filter(a => a.progress === 0);\n\n      return {\n        achievements: achievementsWithProgress,\n        unlocked,\n        inProgress,\n        locked,\n        stats: {\n          total: achievements.length,\n          unlockedCount: unlocked.length,\n          inProgressCount: inProgress.length,\n          lockedCount: locked.length,\n          completionPercentage: Math.round((unlocked.length / achievements.length) * 100),\n        },\n      };\n    } catch (error) {\n      typedLogger.error('Get user achievements error', { error: getErrorMessage(error), userId });\n      throw error;\n    }\n  }\n\n  /**\n   * R├®cup├®rer les achievements r├®cemment d├®bloqu├®s\n   */\n  static async getRecentlyUnlocked(userId: string, limit: number = 10): Promise<any> {\n    try {\n      const recentlyUnlocked = await UserAchievement.find({\n        userId: new Types.ObjectId(userId),\n        unlockedAt: { $exists: true },\n      })\n      .populate('achievementId')\n      .sort({ unlockedAt: -1 })\n      .limit(limit)\n      .lean();\n\n      return {\n        achievements: recentlyUnlocked,\n        total: recentlyUnlocked.length,\n      };\n    } catch (error) {\n      typedLogger.error('Get recently unlocked error', { error: getErrorMessage(error), userId });\n      throw error;\n    }\n  }\n}\n\nexport default AchievementService;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\services\\alerting.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":36,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[624,627],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[624,627],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":218,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":218,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5600,5603],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5600,5603],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":301,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":301,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7787,7790],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7787,7790],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":509,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":509,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13490,13493],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13490,13493],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":533,"column":88,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":533,"endColumn":91,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14079,14082],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14079,14082],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":536,"column":84,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":536,"endColumn":87,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14259,14262],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14259,14262],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":539,"column":86,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":539,"endColumn":89,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14437,14440],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14437,14440],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":542,"column":83,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":542,"endColumn":86,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14614,14617],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14614,14617],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":550,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":550,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14825,14828],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14825,14828],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":550,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":550,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14839,14842],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14839,14842],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'reply' is defined but never used. Allowed unused args must match /^_/u.","line":550,"column":43,"nodeType":"Identifier","messageId":"unusedVar","endLine":550,"endColumn":53},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":550,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":550,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14851,14854],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14851,14854],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":553,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":553,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14946,14949],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14946,14949],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":566,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":566,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15308,15311],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15308,15311],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":569,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":569,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15422,15425],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15422,15425],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":15,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { typedLogger } from '@/lib/typed-logger';\nimport { config } from '@/config';\nimport nodemailer from 'nodemailer';\nimport { Twilio } from 'twilio';\n\n/**\n * Alert severity levels\n */\nexport enum AlertSeverity {\n  LOW = 'low',\n  MEDIUM = 'medium',\n  HIGH = 'high',\n  CRITICAL = 'critical',\n}\n\n/**\n * Alert channels\n */\nexport enum AlertChannel {\n  EMAIL = 'email',\n  SMS = 'sms',\n  WEBHOOK = 'webhook',\n  SLACK = 'slack',\n}\n\n/**\n * Alert interface\n */\nexport interface Alert {\n  id: string;\n  title: string;\n  message: string;\n  severity: AlertSeverity;\n  timestamp: Date;\n  source: string;\n  metadata?: Record<string, any>;\n  channels: AlertChannel[];\n}\n\n/**\n * Alert rule interface\n */\nexport interface AlertRule {\n  name: string;\n  condition: (alert: Alert) => boolean;\n  channels: AlertChannel[];\n  cooldown?: number; // Minutes between same alerts\n  enabled: boolean;\n}\n\n/**\n * Alerting service\n */\nexport class AlertingService {\n  private emailTransporter?: nodemailer.Transporter;\n  private twilioClient?: Twilio;\n  private alertHistory = new Map<string, Date>();\n  private rules: AlertRule[] = [];\n\n  constructor() {\n    this.initializeTransports();\n    this.setupDefaultRules();\n  }\n\n  private initializeTransports(): void {\n    // Initialize email transporter\n    if (config.SMTP_HOST && config.SMTP_USER && config.SMTP_PASS) {\n      this.emailTransporter = nodemailer.createTransport({\n        host: config.SMTP_HOST,\n        port: config.SMTP_PORT,\n        secure: config.SMTP_SECURE,\n        auth: {\n          user: config.SMTP_USER,\n          pass: config.SMTP_PASS,\n        },\n      });\n    }\n\n    // Initialize Twilio client\n    if (config.TWILIO_ACCOUNT_SID && config.TWILIO_AUTH_TOKEN) {\n      this.twilioClient = new Twilio(\n        config.TWILIO_ACCOUNT_SID,\n        config.TWILIO_AUTH_TOKEN\n      );\n    }\n  }\n\n  private setupDefaultRules(): void {\n    // Critical errors - immediate notification\n    this.addRule({\n      name: 'critical_errors',\n      condition: (alert) => alert.severity === AlertSeverity.CRITICAL,\n      channels: [AlertChannel.EMAIL, AlertChannel.SMS],\n      cooldown: 5, // 5 minutes\n      enabled: true,\n    });\n\n    // High severity - email notification\n    this.addRule({\n      name: 'high_severity',\n      condition: (alert) => alert.severity === AlertSeverity.HIGH,\n      channels: [AlertChannel.EMAIL],\n      cooldown: 15, // 15 minutes\n      enabled: true,\n    });\n\n    // Database connection issues\n    this.addRule({\n      name: 'database_issues',\n      condition: (alert) => \n        alert.source.includes('database') || \n        alert.source.includes('mongodb') ||\n        alert.message.toLowerCase().includes('connection'),\n      channels: [AlertChannel.EMAIL, AlertChannel.WEBHOOK],\n      cooldown: 10,\n      enabled: true,\n    });\n\n    // Security incidents\n    this.addRule({\n      name: 'security_incidents',\n      condition: (alert) => \n        alert.source.includes('security') ||\n        alert.message.toLowerCase().includes('breach') ||\n        alert.message.toLowerCase().includes('attack'),\n      channels: [AlertChannel.EMAIL, AlertChannel.SMS],\n      cooldown: 0, // No cooldown for security\n      enabled: true,\n    });\n\n    // Rate limiting exceeded frequently\n    this.addRule({\n      name: 'rate_limit_abuse',\n      condition: (alert) => \n        alert.source.includes('rate_limit') && \n        alert.severity === AlertSeverity.HIGH,\n      channels: [AlertChannel.EMAIL],\n      cooldown: 30,\n      enabled: true,\n    });\n  }\n\n  /**\n   * Add an alert rule\n   */\n  addRule(rule: AlertRule): void {\n    this.rules.push(rule);\n  }\n\n  /**\n   * Remove an alert rule\n   */\n  removeRule(name: string): void {\n    this.rules = this.rules.filter(rule => rule.name !== name);\n  }\n\n  /**\n   * Send an alert\n   */\n  async sendAlert(alert: Alert): Promise<void> {\n    try {\n      // Check which rules match this alert\n      const matchingRules = this.rules.filter(rule => \n        rule.enabled && rule.condition(alert)\n      );\n\n      if (matchingRules.length === 0) {\n        typedLogger.debug('No matching alert rules', { alertId: alert.id });\n        return;\n      }\n\n      // Check cooldown for each rule\n      const activeRules = matchingRules.filter(rule => {\n        const cooldownKey = `${rule.name}:${alert.source}`;\n        const lastAlert = this.alertHistory.get(cooldownKey);\n        \n        if (!lastAlert || !rule.cooldown) {\n          return true;\n        }\n\n        const cooldownMs = rule.cooldown * 60 * 1000;\n        return Date.now() - lastAlert.getTime() > cooldownMs;\n      });\n\n      if (activeRules.length === 0) {\n        typedLogger.debug('All matching rules in cooldown', { alertId: alert.id });\n        return;\n      }\n\n      // Collect all channels from active rules\n      const channels = new Set<AlertChannel>();\n      activeRules.forEach(rule => {\n        rule.channels.forEach(channel => channels.add(channel));\n      });\n\n      // Send to each channel\n      const promises = Array.from(channels).map(channel => \n        this.sendToChannel(alert, channel)\n      );\n\n      await Promise.allSettled(promises);\n\n      // Update cooldown history\n      activeRules.forEach(rule => {\n        const cooldownKey = `${rule.name}:${alert.source}`;\n        this.alertHistory.set(cooldownKey, new Date());\n      });\n\n      typedLogger.info('Alert sent successfully', {\n        alertId: alert.id,\n        channels: Array.from(channels),\n        rules: activeRules.map(r => r.name),\n      });\n\n    } catch (error) {\n      typedLogger.error('Failed to send alert', {\n        alertId: alert.id,\n        error: (error as any).message,\n      });\n    }\n  }\n\n  /**\n   * Send alert to specific channel\n   */\n  private async sendToChannel(alert: Alert, channel: AlertChannel): Promise<void> {\n    switch (channel) {\n      case AlertChannel.EMAIL:\n        await this.sendEmailAlert(alert);\n        break;\n      case AlertChannel.SMS:\n        await this.sendSmsAlert(alert);\n        break;\n      case AlertChannel.WEBHOOK:\n        await this.sendWebhookAlert(alert);\n        break;\n      case AlertChannel.SLACK:\n        await this.sendSlackAlert(alert);\n        break;\n      default:\n        typedLogger.warn('Unknown alert channel', { channel });\n    }\n  }\n\n  /**\n   * Send email alert\n   */\n  private async sendEmailAlert(alert: Alert): Promise<void> {\n    if (!this.emailTransporter) {\n      typedLogger.warn('Email transporter not configured');\n      return;\n    }\n\n    const recipients = this.getEmailRecipients(alert.severity);\n    if (recipients.length === 0) {\n      typedLogger.warn('No email recipients configured');\n      return;\n    }\n\n    const subject = `[${alert.severity.toUpperCase()}] ${alert.title}`;\n    const html = this.generateEmailHtml(alert);\n\n    await this.emailTransporter.sendMail({\n      from: config.EMAIL_FROM,\n      to: recipients.join(', '),\n      subject,\n      html,\n    });\n\n    typedLogger.info('Email alert sent', {\n      alertId: alert.id,\n      recipients: recipients.length,\n    });\n  }\n\n  /**\n   * Send SMS alert\n   */\n  private async sendSmsAlert(alert: Alert): Promise<void> {\n    if (!this.twilioClient) {\n      typedLogger.warn('Twilio client not configured');\n      return;\n    }\n\n    const recipients = this.getSmsRecipients(alert.severity);\n    if (recipients.length === 0) {\n      typedLogger.warn('No SMS recipients configured');\n      return;\n    }\n\n    const message = `[${alert.severity.toUpperCase()}] ${alert.title}\\n\\n${alert.message}`;\n\n    const promises = recipients.map(async (phone) => {\n      try {\n        await this.twilioClient!.messages.create({\n          body: message,\n          from: config.TWILIO_PHONE_NUMBER,\n          to: phone,\n        });\n      } catch (error) {\n        typedLogger.error('Failed to send SMS', { phone, error: (error as any).message });\n      }\n    });\n\n    await Promise.allSettled(promises);\n\n    typedLogger.info('SMS alerts sent', {\n      alertId: alert.id,\n      recipients: recipients.length,\n    });\n  }\n\n  /**\n   * Send webhook alert\n   */\n  private async sendWebhookAlert(alert: Alert): Promise<void> {\n    const webhookUrl = process.env.ALERT_WEBHOOK_URL;\n    if (!webhookUrl) {\n      typedLogger.warn('Webhook URL not configured');\n      return;\n    }\n\n    const axios = (await import('axios')).default;\n    \n    await axios.post(webhookUrl, {\n      alert,\n      timestamp: new Date().toISOString(),\n      service: 'yallacatch-backend',\n    }, {\n      timeout: 10000,\n      headers: {\n        'Content-Type': 'application/json',\n        'User-Agent': 'YallaCatch-Alerting/1.0',\n      },\n    });\n\n    typedLogger.info('Webhook alert sent', { alertId: alert.id });\n  }\n\n  /**\n   * Send Slack alert\n   */\n  private async sendSlackAlert(alert: Alert): Promise<void> {\n    const slackWebhookUrl = process.env.SLACK_WEBHOOK_URL;\n    if (!slackWebhookUrl) {\n      typedLogger.warn('Slack webhook URL not configured');\n      return;\n    }\n\n    const axios = (await import('axios')).default;\n    \n    const color = this.getSeverityColor(alert.severity);\n    const payload = {\n      attachments: [{\n        color,\n        title: alert.title,\n        text: alert.message,\n        fields: [\n          {\n            title: 'Severity',\n            value: alert.severity.toUpperCase(),\n            short: true,\n          },\n          {\n            title: 'Source',\n            value: alert.source,\n            short: true,\n          },\n          {\n            title: 'Timestamp',\n            value: alert.timestamp.toISOString(),\n            short: true,\n          },\n        ],\n        footer: 'YallaCatch Backend',\n        ts: Math.floor(alert.timestamp.getTime() / 1000),\n      }],\n    };\n\n    await axios.post(slackWebhookUrl, payload, {\n      timeout: 10000,\n      headers: { 'Content-Type': 'application/json' },\n    });\n\n    typedLogger.info('Slack alert sent', { alertId: alert.id });\n  }\n\n  /**\n   * Get email recipients based on severity\n   */\n  private getEmailRecipients(severity: AlertSeverity): string[] {\n    const recipients: string[] = [];\n    \n    // Always include admin email\n    if (config.ADMIN_EMAIL) {\n      recipients.push(config.ADMIN_EMAIL);\n    }\n\n    // Include super admin emails for high/critical\n    if (severity === AlertSeverity.HIGH || severity === AlertSeverity.CRITICAL) {\n      // Cast to unknown first to handle different possible types\n      const superAdminEmails = config.SUPER_ADMIN_EMAILS as unknown;\n      let superAdmins: string[];\n\n      if (superAdminEmails && Array.isArray(superAdminEmails)) {\n        superAdmins = superAdminEmails as string[];\n      } else if (superAdminEmails && typeof superAdminEmails === 'string') {\n        superAdmins = (superAdminEmails as string).split(',') as string[];\n      } else {\n        superAdmins = [];\n      }\n\n      recipients.push(...superAdmins);\n    }\n\n    return [...new Set(recipients)]; // Remove duplicates\n  }\n\n  /**\n   * Get SMS recipients based on severity\n   */\n  private getSmsRecipients(severity: AlertSeverity): string[] {\n    // Only send SMS for critical alerts\n    if (severity !== AlertSeverity.CRITICAL) {\n      return [];\n    }\n\n    // Handle the environment variable as either a string to split or already an array\n    const envValue = process.env.ALERT_SMS_RECIPIENTS;\n    let recipients: string[];\n\n    if (Array.isArray(envValue)) {\n      recipients = envValue;\n    } else if (typeof envValue === 'string') {\n      recipients = envValue.split(',');\n    } else {\n      recipients = [];\n    }\n\n    return recipients.filter(phone => phone.trim());\n  }\n\n  /**\n   * Generate HTML for email alerts\n   */\n  private generateEmailHtml(alert: Alert): string {\n    return `\n      <!DOCTYPE html>\n      <html>\n      <head>\n        <style>\n          body { font-family: Arial, sans-serif; margin: 0; padding: 20px; }\n          .alert { border-left: 4px solid ${this.getSeverityColor(alert.severity)}; padding: 20px; background: #f9f9f9; }\n          .severity { color: ${this.getSeverityColor(alert.severity)}; font-weight: bold; text-transform: uppercase; }\n          .metadata { background: #fff; padding: 10px; margin-top: 10px; border-radius: 4px; }\n          .timestamp { color: #666; font-size: 0.9em; }\n        </style>\n      </head>\n      <body>\n        <div class=\"alert\">\n          <h2>${alert.title}</h2>\n          <p class=\"severity\">Severity: ${alert.severity}</p>\n          <p><strong>Source:</strong> ${alert.source}</p>\n          <p><strong>Message:</strong></p>\n          <p>${alert.message}</p>\n          \n          ${alert.metadata ? `\n            <div class=\"metadata\">\n              <strong>Additional Information:</strong>\n              <pre>${JSON.stringify(alert.metadata, null, 2)}</pre>\n            </div>\n          ` : ''}\n          \n          <p class=\"timestamp\">\n            <strong>Timestamp:</strong> ${alert.timestamp.toISOString()}\n          </p>\n        </div>\n      </body>\n      </html>\n    `;\n  }\n\n  /**\n   * Get color for severity level\n   */\n  private getSeverityColor(severity: AlertSeverity): string {\n    switch (severity) {\n      case AlertSeverity.LOW:\n        return '#36a2eb';\n      case AlertSeverity.MEDIUM:\n        return '#ffcd56';\n      case AlertSeverity.HIGH:\n        return '#ff6384';\n      case AlertSeverity.CRITICAL:\n        return '#ff0000';\n      default:\n        return '#666666';\n    }\n  }\n\n  /**\n   * Create and send an alert\n   */\n  async alert(\n    title: string,\n    message: string,\n    severity: AlertSeverity,\n    source: string,\n    metadata?: Record<string, any>\n  ): Promise<void> {\n    const alert: Alert = {\n      id: `alert_${Date.now()}_${Math.random().toString(36).substring(2)}`,\n      title,\n      message,\n      severity,\n      source,\n      timestamp: new Date(),\n      metadata,\n      channels: [], // Will be determined by rules\n    };\n\n    await this.sendAlert(alert);\n  }\n}\n\n// Export singleton instance\nexport const alertingService = new AlertingService();\n\n/**\n * Convenience functions for different severity levels\n */\nexport const alerts = {\n  critical: (title: string, message: string, source: string, metadata?: Record<string, any>) =>\n    alertingService.alert(title, message, AlertSeverity.CRITICAL, source, metadata),\n  \n  high: (title: string, message: string, source: string, metadata?: Record<string, any>) =>\n    alertingService.alert(title, message, AlertSeverity.HIGH, source, metadata),\n  \n  medium: (title: string, message: string, source: string, metadata?: Record<string, any>) =>\n    alertingService.alert(title, message, AlertSeverity.MEDIUM, source, metadata),\n  \n  low: (title: string, message: string, source: string, metadata?: Record<string, any>) =>\n    alertingService.alert(title, message, AlertSeverity.LOW, source, metadata),\n};\n\n/**\n * Enhanced error handler with alerting\n */\nexport function createAlertingErrorHandler() {\n  return async (error: any, request: any, reply: any) => {\n    // Log the error\n    typedLogger.error('Request error', {\n      error: (error as any).message,\n      stack: error.stack,\n      url: request.url,\n      method: request.method,\n      ip: request.ip,\n      userId: request.user?.sub,\n      statusCode: error.statusCode,\n    });\n\n    // Send alert for 5xx errors\n    if (!error.statusCode || error.statusCode >= 500) {\n      await alerts.high(\n        'Server Error Detected',\n        `${(error as any).message} on ${request.method} ${request.url}`,\n        'error_handler',\n        {\n          error: (error as any).message,\n          stack: error.stack,\n          url: request.url,\n          method: request.method,\n          ip: request.ip,\n          userId: request.user?.sub,\n          statusCode: error.statusCode,\n        }\n      );\n    }\n\n    // Continue with normal error handling\n    // ... (rest of error handling logic)\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\services\\anti-cheat-monitoring.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'redisPubSub' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":21},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":87,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":87,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2751,2754],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2751,2754],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":111,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3446,3449],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3446,3449],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":141,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":141,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4333,4336],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4333,4336],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":143,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":143,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4463,4466],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4463,4466],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":147,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":147,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4647,4650],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4647,4650],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":182,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":182,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5860,5863],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5860,5863],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":219,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":219,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6868,6871],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6868,6871],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":220,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":220,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6951,6954],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6951,6954],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":221,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":221,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7042,7045],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7042,7045],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":222,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":222,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7135,7138],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7135,7138],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":226,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":226,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7293,7296],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7293,7296],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":227,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":227,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7372,7375],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7372,7375],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":228,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":228,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7494,7497],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7494,7497],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":229,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":229,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7641,7644],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7641,7644],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":234,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":234,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7844,7847],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7844,7847],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":249,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":249,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8424,8427],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8424,8427],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":250,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":250,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8486,8489],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8486,8489],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":328,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":328,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10857,10860],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10857,10860],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":334,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":334,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11100,11103],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11100,11103],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":359,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":359,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11789,11792],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11789,11792],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":380,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":380,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12493,12496],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12493,12496],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":394,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":394,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12991,12994],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12991,12994],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":424,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":424,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14021,14024],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14021,14024],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":24,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Types } from 'mongoose';\r\nimport { Claim } from '@/models/Claim';\r\nimport { User } from '@/models/User';\r\nimport { typedLogger } from '@/lib/typed-logger';\r\nimport { CacheService } from './cache';\r\nimport { redisPubSub, redisPublisher } from '@/config/redis';\r\n\r\n/**\r\n * Anti-Cheat Monitoring Service\r\n * Provides real-time visibility into fraud detection and suspicious activities\r\n * Enables admin to monitor, review, and override anti-cheat decisions\r\n */\r\n\r\nexport interface FlaggedClaim {\r\n  _id: Types.ObjectId;\r\n  userId: Types.ObjectId;\r\n  prizeId: Types.ObjectId;\r\n  riskScore: number;\r\n  riskFactors: string[];\r\n  flaggedAt: Date;\r\n  status: 'pending' | 'approved' | 'rejected' | 'overridden';\r\n  adminNotes?: string;\r\n  overriddenBy?: Types.ObjectId;\r\n  overriddenAt?: Date;\r\n  antiCheatDetails: {\r\n    speedCheck?: { flag: boolean; riskScore: number };\r\n    mockLocationDetection?: { flag: boolean; riskScore: number };\r\n    teleportDetection?: { flag: boolean; riskScore: number };\r\n    rapidClaimDetection?: { flag: boolean; riskScore: number };\r\n    dailyLimitCheck?: { flag: boolean; riskScore: number };\r\n    accuracyCheck?: { flag: boolean; riskScore: number };\r\n  };\r\n}\r\n\r\nexport interface UserRiskProfile {\r\n  userId: Types.ObjectId;\r\n  username: string;\r\n  riskLevel: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\r\n  riskScore: number;\r\n  flaggedClaimsCount: number;\r\n  rejectedClaimsCount: number;\r\n  totalClaimsCount: number;\r\n  lastFlaggedAt?: Date;\r\n  suspiciousPatterns: string[];\r\n  recommendation: 'SAFE' | 'MONITOR' | 'RESTRICT' | 'BAN';\r\n}\r\n\r\nexport interface AntiCheatMetrics {\r\n  totalClaimsAnalyzed: number;\r\n  flaggedClaimsCount: number;\r\n  approvalRate: number;\r\n  rejectionRate: number;\r\n  overrideRate: number;\r\n  topRiskFactors: Array<{ factor: string; count: number }>;\r\n  riskScoreDistribution: {\r\n    low: number;\r\n    medium: number;\r\n    high: number;\r\n    critical: number;\r\n  };\r\n  topFlaggedUsers: UserRiskProfile[];\r\n  lastUpdated: Date;\r\n}\r\n\r\nexport class AntiCheatMonitoringService {\r\n  private static readonly RISK_THRESHOLD = 50;\r\n  private static readonly CRITICAL_THRESHOLD = 75;\r\n  private static readonly MONITORING_CHANNEL = 'anti-cheat:alerts';\r\n  private static readonly CACHE_KEY_PREFIX = 'anti-cheat:';\r\n\r\n  /**\r\n   * Get all flagged claims with optional filters\r\n   */\r\n  static async getFlaggedClaims(\r\n    filters: {\r\n      userId?: string;\r\n      riskLevel?: 'high' | 'critical';\r\n      status?: 'pending' | 'approved' | 'rejected' | 'overridden';\r\n      limit?: number;\r\n      offset?: number;\r\n    } = {}\r\n  ): Promise<{ claims: FlaggedClaim[]; total: number }> {\r\n    try {\r\n      const limit = filters.limit || 50;\r\n      const offset = filters.offset || 0;\r\n\r\n      const query: any = {};\r\n      \r\n      if (filters.userId) {\r\n        query.userId = new Types.ObjectId(filters.userId);\r\n      }\r\n\r\n      if (filters.status) {\r\n        query.status = filters.status;\r\n      }\r\n\r\n      if (filters.riskLevel === 'high') {\r\n        query.riskScore = { $gte: this.RISK_THRESHOLD, $lt: this.CRITICAL_THRESHOLD };\r\n      } else if (filters.riskLevel === 'critical') {\r\n        query.riskScore = { $gte: this.CRITICAL_THRESHOLD };\r\n      }\r\n\r\n      const claims = await Claim.find(query)\r\n        .sort({ flaggedAt: -1 })\r\n        .skip(offset)\r\n        .limit(limit)\r\n        .lean();\r\n\r\n      const total = await Claim.countDocuments(query);\r\n\r\n      return { claims: (claims as any) as FlaggedClaim[], total };\r\n    } catch (error) {\r\n      typedLogger.error('Failed to get flagged claims', { error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get detailed user risk profile\r\n   */\r\n  static async getUserRiskProfile(userId: string): Promise<UserRiskProfile | null> {\r\n    try {\r\n      const cacheKey = `${this.CACHE_KEY_PREFIX}user-risk:${userId}`;\r\n\r\n      // Try cache first\r\n      const cached = await CacheService.get<UserRiskProfile>(cacheKey);\r\n      if (cached) {\r\n        return cached;\r\n      }\r\n\r\n      const user = await User.findById(userId);\r\n      if (!user) {\r\n        return null;\r\n      }\r\n\r\n      // Get user's claims\r\n      const userClaims = await Claim.find({ userId: new Types.ObjectId(userId) }).lean();\r\n      const totalClaims = userClaims.length;\r\n\r\n      // Filter flagged claims\r\n      const flaggedClaims = userClaims.filter((c: any) => c.riskScore > 0);\r\n      const flaggedCount = flaggedClaims.length;\r\n      const rejectedCount = flaggedClaims.filter((c: any) => c.status === 'rejected').length;\r\n\r\n      // Calculate average risk score\r\n      const avgRiskScore = flaggedClaims.length > 0\r\n        ? flaggedClaims.reduce((sum: number, c: any) => sum + (c.riskScore || 0), 0) /\r\n          flaggedClaims.length\r\n        : 0;\r\n\r\n      // Determine risk level\r\n      let riskLevel: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL' = 'LOW';\r\n      if (avgRiskScore >= this.CRITICAL_THRESHOLD) {\r\n        riskLevel = 'CRITICAL';\r\n      } else if (avgRiskScore >= this.RISK_THRESHOLD) {\r\n        riskLevel = 'HIGH';\r\n      } else if (avgRiskScore >= 25) {\r\n        riskLevel = 'MEDIUM';\r\n      }\r\n\r\n      // Identify suspicious patterns\r\n      const suspiciousPatterns = this.identifySuspiciousPatterns(userClaims);\r\n\r\n      // Generate recommendation\r\n      const recommendation = this.generateRecommendation(\r\n        riskLevel,\r\n        rejectedCount,\r\n        totalClaims,\r\n        suspiciousPatterns\r\n      );\r\n\r\n      const profile: UserRiskProfile = {\r\n        userId: new Types.ObjectId(userId),\r\n        username: user.displayName || user.email || 'Unknown',\r\n        riskLevel,\r\n        riskScore: avgRiskScore,\r\n        flaggedClaimsCount: flaggedCount,\r\n        rejectedClaimsCount: rejectedCount,\r\n        totalClaimsCount: totalClaims,\r\n        lastFlaggedAt:\r\n          flaggedClaims.length > 0\r\n            ? new Date(Math.max(...flaggedClaims.map((c: any) => new Date(c.createdAt).getTime())))\r\n            : undefined,\r\n        suspiciousPatterns,\r\n        recommendation,\r\n      };\r\n\r\n      // Cache the profile\r\n      await CacheService.set(cacheKey, profile, {\r\n        ttl: 3600, // 1 hour\r\n        tags: ['anti-cheat', 'user-risk'],\r\n      });\r\n\r\n      return profile;\r\n    } catch (error) {\r\n      typedLogger.error('Failed to get user risk profile', { error, userId });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get anti-cheat metrics and statistics\r\n   */\r\n  static async getMetrics(): Promise<AntiCheatMetrics> {\r\n    try {\r\n      const cacheKey = `${this.CACHE_KEY_PREFIX}metrics`;\r\n\r\n      // Try cache first\r\n      const cached = await CacheService.get<AntiCheatMetrics>(cacheKey);\r\n      if (cached) {\r\n        return cached;\r\n      }\r\n\r\n      // Get all claims\r\n      const allClaims = await Claim.find({}).lean();\r\n      const totalAnalyzed = allClaims.length;\r\n\r\n      // Count by status\r\n      const flaggedCount = allClaims.filter((c: any) => c.riskScore > 0).length;\r\n      const rejectedCount = allClaims.filter((c: any) => c.status === 'rejected').length;\r\n      const approvedCount = allClaims.filter((c: any) => c.status === 'approved').length;\r\n      const overriddenCount = allClaims.filter((c: any) => c.status === 'overridden').length;\r\n\r\n      // Calculate risk score distribution\r\n      const riskDistribution = {\r\n        low: allClaims.filter((c: any) => (c.riskScore || 0) < 25).length,\r\n        medium: allClaims.filter((c: any) => (c.riskScore || 0) >= 25 && (c.riskScore || 0) < this.RISK_THRESHOLD).length,\r\n        high: allClaims.filter((c: any) => (c.riskScore || 0) >= this.RISK_THRESHOLD && (c.riskScore || 0) < this.CRITICAL_THRESHOLD).length,\r\n        critical: allClaims.filter((c: any) => (c.riskScore || 0) >= this.CRITICAL_THRESHOLD).length,\r\n      };\r\n\r\n      // Identify top risk factors\r\n      const riskFactorCounts: { [key: string]: number } = {};\r\n      allClaims.forEach((c: any) => {\r\n        if (c.riskFactors && Array.isArray(c.riskFactors)) {\r\n          c.riskFactors.forEach((factor: string) => {\r\n            riskFactorCounts[factor] = (riskFactorCounts[factor] || 0) + 1;\r\n          });\r\n        }\r\n      });\r\n\r\n      const topRiskFactors = Object.entries(riskFactorCounts)\r\n        .map(([factor, count]) => ({ factor, count }))\r\n        .sort((a, b) => b.count - a.count)\r\n        .slice(0, 10);\r\n\r\n      // Get top flagged users\r\n      const userRisks: { [userId: string]: UserRiskProfile } = {};\r\n      for (const claim of allClaims.filter((c: any) => c.riskScore > 0)) {\r\n        const userId = (claim as any).userId?.toString();\r\n        if (userId && !userRisks[userId]) {\r\n          const profile = await this.getUserRiskProfile(userId);\r\n          if (profile) {\r\n            userRisks[userId] = profile;\r\n          }\r\n        }\r\n      }\r\n\r\n      const topFlaggedUsers = Object.values(userRisks)\r\n        .sort((a, b) => b.riskScore - a.riskScore)\r\n        .slice(0, 10);\r\n\r\n      const metrics: AntiCheatMetrics = {\r\n        totalClaimsAnalyzed: totalAnalyzed,\r\n        flaggedClaimsCount: flaggedCount,\r\n        approvalRate: totalAnalyzed > 0 ? (approvedCount / totalAnalyzed) * 100 : 0,\r\n        rejectionRate: totalAnalyzed > 0 ? (rejectedCount / totalAnalyzed) * 100 : 0,\r\n        overrideRate: totalAnalyzed > 0 ? (overriddenCount / totalAnalyzed) * 100 : 0,\r\n        topRiskFactors,\r\n        riskScoreDistribution: riskDistribution,\r\n        topFlaggedUsers,\r\n        lastUpdated: new Date(),\r\n      };\r\n\r\n      // Cache metrics\r\n      await CacheService.set(cacheKey, metrics, {\r\n        ttl: 600, // 10 minutes\r\n        tags: ['anti-cheat', 'metrics'],\r\n      });\r\n\r\n      return metrics;\r\n    } catch (error) {\r\n      typedLogger.error('Failed to get metrics', { error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Override anti-cheat decision\r\n   */\r\n  static async overrideClaim(\r\n    claimId: string,\r\n    adminId: string,\r\n    decision: 'approve' | 'reject',\r\n    notes?: string\r\n  ): Promise<FlaggedClaim | null> {\r\n    try {\r\n      typedLogger.info('Overriding claim anti-cheat decision', { claimId, adminId, decision });\r\n\r\n      const claim = await Claim.findByIdAndUpdate(\r\n        claimId,\r\n        {\r\n          status: decision === 'approve' ? 'approved' : 'rejected',\r\n          overriddenBy: new Types.ObjectId(adminId),\r\n          overriddenAt: new Date(),\r\n          adminNotes: notes,\r\n        },\r\n        { new: true }\r\n      ).lean();\r\n\r\n      if (!claim) {\r\n        throw new Error('Claim not found');\r\n      }\r\n\r\n      // Broadcast override event (use redisPublisher, not redisPubSub which is in subscriber mode)\r\n      await redisPublisher.publish(\r\n        this.MONITORING_CHANNEL,\r\n        JSON.stringify({\r\n          event: 'claim_overridden',\r\n          claimId,\r\n          decision,\r\n          adminId,\r\n          timestamp: new Date(),\r\n        })\r\n      );\r\n\r\n      // Invalidate user risk cache\r\n      const userId = (claim as any).userId?.toString();\r\n      if (userId) {\r\n        await CacheService.invalidate(`${this.CACHE_KEY_PREFIX}user-risk:${userId}`);\r\n        await CacheService.invalidate(`${this.CACHE_KEY_PREFIX}metrics`);\r\n      }\r\n\r\n      return (claim as any) as FlaggedClaim;\r\n    } catch (error) {\r\n      typedLogger.error('Failed to override claim', { error, claimId });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get fraud pattern analysis\r\n   */\r\n  static async analyzeFraudPatterns(): Promise<{\r\n    patterns: Array<{\r\n      name: string;\r\n      description: string;\r\n      affectedUsersCount: number;\r\n      severity: 'low' | 'medium' | 'high' | 'critical';\r\n    }>;\r\n    recommendations: string[];\r\n  }> {\r\n    try {\r\n      const allClaims = await Claim.find({}).lean();\r\n      const patterns = [];\r\n\r\n      // Pattern 1: Rapid consecutive claims\r\n      const rapidClaimers = new Map<string, number>();\r\n      allClaims.forEach((c: any) => {\r\n        const userId = c.userId?.toString();\r\n        if (userId) {\r\n          rapidClaimers.set(userId, (rapidClaimers.get(userId) || 0) + 1);\r\n        }\r\n      });\r\n\r\n      const rapidClaimCount = Array.from(rapidClaimers.values()).filter(\r\n        (count) => count > 50\r\n      ).length;\r\n\r\n      if (rapidClaimCount > 0) {\r\n        patterns.push({\r\n          name: 'Rapid Claims',\r\n          description: 'Users claiming prizes in rapid succession',\r\n          affectedUsersCount: rapidClaimCount,\r\n          severity: rapidClaimCount > 10 ? 'critical' : 'high',\r\n        });\r\n      }\r\n\r\n      // Pattern 2: Geographic impossibilities\r\n      const geographicPatterns = allClaims.filter((c: any) => \r\n        c.riskFactors?.includes('teleportDetection')\r\n      ).length;\r\n\r\n      if (geographicPatterns > 0) {\r\n        patterns.push({\r\n          name: 'Geographic Anomalies',\r\n          description: 'Users with impossible movements (teleportation)',\r\n          affectedUsersCount: geographicPatterns,\r\n          severity: geographicPatterns > 20 ? 'critical' : 'high',\r\n        });\r\n      }\r\n\r\n      // Pattern 3: Mock location usage\r\n      const mockLocationCount = allClaims.filter((c: any) =>\r\n        c.riskFactors?.includes('mockLocationDetection')\r\n      ).length;\r\n\r\n      if (mockLocationCount > 0) {\r\n        patterns.push({\r\n          name: 'Mock Location Detection',\r\n          description: 'Users using location spoofing services',\r\n          affectedUsersCount: mockLocationCount,\r\n          severity: mockLocationCount > 30 ? 'critical' : 'high',\r\n        });\r\n      }\r\n\r\n      const recommendations = [\r\n        'Monitor flagged users with CRITICAL risk level closely',\r\n        'Consider temporary ban for users with >75 avg risk score',\r\n        'Implement additional location verification for high-risk regions',\r\n        'Review and adjust anti-cheat thresholds based on false positive rate',\r\n      ];\r\n\r\n      return { patterns, recommendations };\r\n    } catch (error) {\r\n      typedLogger.error('Failed to analyze fraud patterns', { error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Identify suspicious patterns from user claims\r\n   */\r\n  private static identifySuspiciousPatterns(claims: any[]): string[] {\r\n    const patterns: Set<string> = new Set();\r\n\r\n    // Check for rapid consecutive claims\r\n    if (claims.length > 50) {\r\n      patterns.add('Excessive claims volume');\r\n    }\r\n\r\n    // Check for geographic anomalies\r\n    const teleportClaims = claims.filter((c) => c.riskFactors?.includes('teleportDetection'));\r\n    if (teleportClaims.length > claims.length * 0.1) {\r\n      patterns.add('Geographic anomalies');\r\n    }\r\n\r\n    // Check for mock location usage\r\n    const mockLocationClaims = claims.filter((c) => c.riskFactors?.includes('mockLocationDetection'));\r\n    if (mockLocationClaims.length > claims.length * 0.1) {\r\n      patterns.add('Mock location usage detected');\r\n    }\r\n\r\n    // Check for speed violations\r\n    const speedClaims = claims.filter((c) => c.riskFactors?.includes('speedCheck'));\r\n    if (speedClaims.length > claims.length * 0.15) {\r\n      patterns.add('Speed violations');\r\n    }\r\n\r\n    // Check for low GPS accuracy\r\n    const accuracyClaims = claims.filter((c) => c.riskFactors?.includes('accuracyCheck'));\r\n    if (accuracyClaims.length > claims.length * 0.2) {\r\n      patterns.add('Consistently low GPS accuracy');\r\n    }\r\n\r\n    return Array.from(patterns);\r\n  }\r\n\r\n  /**\r\n   * Generate recommendation based on risk profile\r\n   */\r\n  private static generateRecommendation(\r\n    riskLevel: string,\r\n    rejectedCount: number,\r\n    totalCount: number,\r\n    patterns: string[]\r\n  ): 'SAFE' | 'MONITOR' | 'RESTRICT' | 'BAN' {\r\n    // If critical risk and multiple suspicious patterns\r\n    if (riskLevel === 'CRITICAL' && patterns.length >= 2) {\r\n      return 'BAN';\r\n    }\r\n\r\n    // If high rejection rate\r\n    if (totalCount > 10 && rejectedCount / totalCount > 0.3) {\r\n      return 'RESTRICT';\r\n    }\r\n\r\n    // If high risk with patterns\r\n    if ((riskLevel === 'HIGH' || riskLevel === 'CRITICAL') && patterns.length > 0) {\r\n      return 'RESTRICT';\r\n    }\r\n\r\n    // If high risk\r\n    if (riskLevel === 'HIGH') {\r\n      return 'MONITOR';\r\n    }\r\n\r\n    // If medium risk with patterns\r\n    if (riskLevel === 'MEDIUM' && patterns.length > 0) {\r\n      return 'MONITOR';\r\n    }\r\n\r\n    return 'SAFE';\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\services\\cache.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":42,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1142,1145],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1142,1145],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":76,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":76,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2089,2092],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2089,2092],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":86,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":86,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2268,2271],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2268,2271],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":116,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":116,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3202,3205],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3202,3205],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":135,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":135,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3755,3758],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3755,3758],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":143,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":143,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3928,3931],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3928,3931],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":163,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":163,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4463,4466],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4463,4466],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":197,"column":78,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":197,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5432,5435],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5432,5435],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":223,"column":81,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":223,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6272,6275],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6272,6275],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":233,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":233,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6507,6510],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6507,6510],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":259,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":259,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7272,7275],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7272,7275],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":266,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":266,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7420,7423],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7420,7423],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":273,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":273,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7688,7691],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7688,7691],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":282,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":282,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7848,7851],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7848,7851],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":295,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":295,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8217,8220],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8217,8220],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":318,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":318,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8806,8809],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8806,8809],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":360,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":360,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10073,10076],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10073,10076],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":387,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":387,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10745,10748],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10745,10748],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":400,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":400,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10987,10990],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10987,10990],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":410,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":410,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11327,11330],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11327,11330],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":418,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":418,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11599,11602],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11599,11602],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":426,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":426,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11874,11877],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11874,11877],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":448,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":448,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12710,12713],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12710,12713],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":486,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":486,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13956,13959],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13956,13959],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":499,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":499,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14403,14406],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14403,14406],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":511,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":511,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14722,14725],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14722,14725],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":523,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":523,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15041,15044],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15041,15044],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":529,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":529,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15195,15198],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15195,15198],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":530,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":530,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15221,15224],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15221,15224],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":537,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":537,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15378,15381],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15378,15381],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":540,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":540,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15532,15535],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15532,15535],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":31,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { redisClient } from '@/config/redis';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { config } from '@/config';\n\n/**\n * Intelligent Caching Service\n * Critical for Unity performance - reduces API calls, improves response times\n * Implements multi-layer caching with automatic invalidation\n */\n\nexport interface CacheOptions {\n  ttl?: number; // Time to live in seconds\n  tags?: string[]; // Cache tags for group invalidation\n  compress?: boolean; // Compress large data\n  serialize?: boolean; // Auto JSON serialize/deserialize\n  namespace?: string; // Cache namespace\n}\n\nexport interface CacheStats {\n  hits: number;\n  misses: number;\n  hitRate: number;\n  totalKeys: number;\n  memoryUsage: number;\n}\n\nexport class CacheService {\n  private static redis = redisClient;\n  // Always return a live Redis client; avoid undefined during early bootstrap\n  private static get client() {\n    return CacheService.redis ?? redisClient;\n  }\n  private static defaultTTL = 3600; // 1 hour\n  private static stats = {\n    hits: 0,\n    misses: 0,\n  };\n\n  /**\n   * Get cached data with automatic deserialization\n   */\n  static async get<T = any>(key: string, options: CacheOptions = {}): Promise<T | null> {\n    try {\n      const fullKey = this.buildKey(key, options.namespace);\n      const client = this.client;\n      if (!client) {\n        typedLogger.error('Cache get skipped: redis client not ready', { key });\n        return null;\n      }\n      const cached = await client.get(fullKey);\n\n      if (cached === null) {\n        this.stats.misses++;\n        return null;\n      }\n\n      this.stats.hits++;\n\n      // Handle compressed data\n      let data = cached;\n      if (options.compress && cached.startsWith('COMPRESSED:')) {\n        data = this.decompress(cached.substring(11));\n      }\n\n      // Handle serialized data\n      if (options.serialize !== false) {\n        try {\n          return JSON.parse(data);\n        } catch {\n          return data as T;\n        }\n      }\n\n      return data as T;\n    } catch (error) {\n      typedLogger.error('Cache get error', { error: (error as any).message, key });\n      return null;\n    }\n  }\n\n  /**\n   * Set cached data with automatic serialization and compression\n   */\n  static async set(\n    key: string, \n    value: any, \n    options: CacheOptions = {}\n  ): Promise<boolean> {\n    try {\n      const fullKey = this.buildKey(key, options.namespace);\n      const ttl = options.ttl || this.defaultTTL;\n      const client = this.client;\n      if (!client) {\n        typedLogger.error('Cache set skipped: redis client not ready', { key });\n        return false;\n      }\n\n      // Serialize data\n      let data = options.serialize !== false ? JSON.stringify(value) : value;\n\n      // Compress large data\n      if (options.compress && data.length > 1024) {\n        data = 'COMPRESSED:' + this.compress(data);\n      }\n\n      // Set with expiration\n      await client.setex(fullKey, ttl, data);\n\n      // Add tags for group invalidation\n      if (options.tags && options.tags.length > 0) {\n        await this.addToTags(fullKey, options.tags, ttl);\n      }\n\n      return true;\n    } catch (error) {\n      typedLogger.error('Cache set error', { error: (error as any).message, key });\n      return false;\n    }\n  }\n\n  /**\n   * Delete cached data\n   */\n  static async del(key: string, namespace?: string): Promise<boolean> {\n    try {\n      const fullKey = this.buildKey(key, namespace);\n      const client = this.client;\n      if (!client) {\n        typedLogger.error('Cache delete skipped: redis client not ready', { key });\n        return false;\n      }\n      const result = await client.del(fullKey);\n      return result > 0;\n    } catch (error) {\n      typedLogger.error('Cache delete error', { error: (error as any).message, key });\n      return false;\n    }\n  }\n\n  /**\n   * Get or set pattern - fetch from cache or execute function and cache result\n   */\n  static async getOrSet<T = any>(\n    key: string,\n    fetchFunction: () => Promise<T>,\n    options: CacheOptions = {}\n  ): Promise<T> {\n    try {\n      // Try to get from cache first\n      const cached = await this.get<T>(key, options);\n      if (cached !== null) {\n        return cached;\n      }\n\n      // Execute fetch function\n      const data = await fetchFunction();\n      \n      // Cache the result\n      await this.set(key, data, options);\n      \n      return data;\n    } catch (error) {\n      typedLogger.error('Cache getOrSet error', { error: (error as any).message, key });\n      throw error;\n    }\n  }\n\n  /**\n   * Invalidate cache by tags\n   */\n  static async invalidateByTags(tags: string[]): Promise<number> {\n    try {\n      let deletedCount = 0;\n      const client = this.client;\n      if (!client) {\n        typedLogger.error('Cache invalidateByTags skipped: redis client not ready', { tags });\n        return 0;\n      }\n\n      for (const tag of tags) {\n        const tagKey = `tag:${tag}`;\n        const keys = await client.smembers(tagKey);\n        \n        if (keys.length > 0) {\n          // Delete all keys with this tag\n          const deleted = await client.del(...keys);\n          deletedCount += deleted;\n          \n          // Remove the tag set\n          await client.del(tagKey);\n        }\n      }\n\n      typedLogger.info('Cache invalidated by tags', { tags, deletedCount });\n      return deletedCount;\n    } catch (error) {\n      typedLogger.error('Cache invalidate by tags error', { error: (error as any).message, tags });\n      return 0;\n    }\n  }\n\n  /**\n   * Invalidate cache by key pattern (supports wildcards)\n   */\n  static async invalidate(pattern: string, namespace?: string): Promise<number> {\n    try {\n      const fullPattern = this.buildKey(pattern, namespace);\n      const client = this.client;\n      if (!client) {\n        typedLogger.error('Cache invalidate skipped: redis client not ready', { pattern });\n        return 0;\n      }\n      const keys = await client.keys(fullPattern);\n      \n      if (keys.length === 0) {\n        return 0;\n      }\n\n      const deleted = await client.del(...keys);\n      typedLogger.info('Cache invalidated by pattern', { pattern: fullPattern, deletedCount: deleted });\n      return deleted;\n    } catch (error) {\n      typedLogger.error('Cache invalidate by pattern error', { error: (error as any).message, pattern });\n      return 0;\n    }\n  }\n\n  /**\n   * Cache Unity-specific map data with spatial indexing\n   */\n  static async cacheMapData(\n    bounds: { north: number; south: number; east: number; west: number },\n    data: any,\n    ttl: number = 300 // 5 minutes for map data\n  ): Promise<void> {\n    try {\n      const key = `map:${bounds.north}_${bounds.south}_${bounds.east}_${bounds.west}`;\n      \n      await this.set(key, {\n        bounds,\n        data,\n        timestamp: new Date().toISOString(),\n      }, {\n        ttl,\n        tags: ['map_data', 'unity'],\n        compress: true,\n      });\n\n      // Also cache individual prizes for faster lookup\n      if (data.prizes) {\n        for (const prize of data.prizes) {\n          await this.set(`prize:${prize.id}`, prize, {\n            ttl: ttl * 2, // Prizes cache longer\n            tags: ['prizes', 'unity'],\n          });\n        }\n      }\n    } catch (error) {\n      typedLogger.error('Cache map data error', { error: (error as any).message, bounds });\n    }\n  }\n\n  /**\n   * Cache user session data for Unity\n   */\n  static async cacheUserSession(userId: string, sessionData: any): Promise<void> {\n    try {\n      await this.set(`user_session:${userId}`, sessionData, {\n        ttl: 3600, // 1 hour\n        tags: ['user_sessions', 'unity'],\n      });\n    } catch (error) {\n      typedLogger.error('Cache user session error', { error: (error as any).message, userId });\n    }\n  }\n\n  /**\n   * Cache leaderboard data with automatic refresh\n   */\n  static async cacheLeaderboard(\n    type: string,\n    data: any,\n    ttl: number = 300 // 5 minutes\n  ): Promise<void> {\n    try {\n      await this.set(`leaderboard:${type}`, {\n        data,\n        lastUpdated: new Date().toISOString(),\n      }, {\n        ttl,\n        tags: ['leaderboards', 'unity'],\n        compress: true,\n      });\n    } catch (error) {\n      typedLogger.error('Cache leaderboard error', { error: (error as any).message, type });\n    }\n  }\n\n  /**\n   * Warm up cache with frequently accessed data\n   */\n  static async warmupCache(): Promise<void> {\n    try {\n      typedLogger.info('Starting cache warmup...');\n\n      // Warmup common queries\n      const warmupTasks = [\n        this.warmupMapData(),\n        this.warmupLeaderboards(),\n        this.warmupSettings(),\n        this.warmupPartners(),\n      ];\n\n      await Promise.allSettled(warmupTasks);\n      \n      typedLogger.info('Cache warmup completed');\n    } catch (error) {\n      typedLogger.error('Cache warmup error', { error: (error as any).message });\n    }\n  }\n\n  /**\n   * Get cache statistics\n   */\n  static async getStats(): Promise<CacheStats> {\n    try {\n      const client = this.client;\n      if (!client) {\n        typedLogger.error('Cache stats skipped: redis client not ready');\n        return {\n          hits: this.stats.hits,\n          misses: this.stats.misses,\n          hitRate: 0,\n          totalKeys: 0,\n          memoryUsage: 0,\n        };\n      }\n      const info = await client.info('memory');\n      const keyspace = await client.info('keyspace');\n      \n      // Parse memory usage\n      const memoryMatch = info.match(/used_memory:(\\d+)/);\n      const memoryUsage = memoryMatch ? parseInt(memoryMatch[1]) : 0;\n\n      // Parse total keys\n      const keysMatch = keyspace.match(/keys=(\\d+)/);\n      const totalKeys = keysMatch ? parseInt(keysMatch[1]) : 0;\n\n      const totalRequests = this.stats.hits + this.stats.misses;\n      const hitRate = totalRequests > 0 ? (this.stats.hits / totalRequests) * 100 : 0;\n\n      return {\n        hits: this.stats.hits,\n        misses: this.stats.misses,\n        hitRate: Math.round(hitRate * 100) / 100,\n        totalKeys,\n        memoryUsage,\n      };\n    } catch (error) {\n      typedLogger.error('Get cache stats error', { error: (error as any).message });\n      return {\n        hits: this.stats.hits,\n        misses: this.stats.misses,\n        hitRate: 0,\n        totalKeys: 0,\n        memoryUsage: 0,\n      };\n    }\n  }\n\n  /**\n   * Clear all cache\n   */\n  static async clearAll(): Promise<boolean> {\n    try {\n      const client = this.client;\n      if (!client) {\n        typedLogger.error('Cache clear skipped: redis client not ready');\n        return false;\n      }\n      await client.flushdb();\n      this.stats.hits = 0;\n      this.stats.misses = 0;\n      typedLogger.info('All cache cleared');\n      return true;\n    } catch (error) {\n      typedLogger.error('Clear all cache error', { error: (error as any).message });\n      return false;\n    }\n  }\n\n  /**\n   * Unity-specific cache methods\n   */\n  \n  // Cache nearby prizes for Unity\n  static async cacheNearbyPrizes(\n    location: { lat: number; lng: number },\n    radius: number,\n    prizes: any[]\n  ): Promise<void> {\n    const key = `nearby_prizes:${location.lat}_${location.lng}_${radius}`;\n    await this.set(key, prizes, {\n      ttl: 60, // 1 minute for nearby prizes\n      tags: ['nearby_prizes', 'unity'],\n    });\n  }\n\n  // Cache user achievements for Unity\n  static async cacheUserAchievements(userId: string, achievements: any[]): Promise<void> {\n    await this.set(`achievements:${userId}`, achievements, {\n      ttl: 1800, // 30 minutes\n      tags: ['achievements', 'unity', `user:${userId}`],\n    });\n  }\n\n  // Cache power-ups for Unity\n  static async cachePowerUps(userId: string, powerUps: any[]): Promise<void> {\n    await this.set(`powerups:${userId}`, powerUps, {\n      ttl: 600, // 10 minutes\n      tags: ['powerups', 'unity', `user:${userId}`],\n    });\n  }\n\n  // Cache daily challenges for Unity\n  static async cacheDailyChallenges(userId: string, challenges: any[]): Promise<void> {\n    await this.set(`daily_challenges:${userId}`, challenges, {\n      ttl: 3600, // 1 hour\n      tags: ['challenges', 'unity', `user:${userId}`],\n    });\n  }\n\n  // Private helper methods\n  private static buildKey(key: string, namespace?: string): string {\n    const prefix = config.NODE_ENV === 'production' ? 'yc:prod:' : 'yc:dev:';\n    const ns = namespace ? `${namespace}:` : '';\n    return `${prefix}${ns}${key}`;\n  }\n\n  private static async addToTags(key: string, tags: string[], ttl: number): Promise<void> {\n    try {\n      for (const tag of tags) {\n        const tagKey = `tag:${tag}`;\n        await this.redis.sadd(tagKey, key);\n        await this.redis.expire(tagKey, ttl + 60); // Tag expires slightly later\n      }\n    } catch (error) {\n      typedLogger.error('Add to tags error', { error: (error as any).message, key, tags });\n    }\n  }\n\n  private static compress(data: string): string {\n    // Simple compression implementation\n    // In production, use a proper compression library like zlib\n    return Buffer.from(data).toString('base64');\n  }\n\n  private static decompress(data: string): string {\n    // Simple decompression implementation\n    return Buffer.from(data, 'base64').toString();\n  }\n\n  // Warmup methods\n  private static async warmupMapData(): Promise<void> {\n    try {\n      // Warmup major cities in Tunisia\n      const majorCities = [\n        { name: 'Tunis', lat: 36.8065, lng: 10.1815 },\n        { name: 'Sfax', lat: 34.7406, lng: 10.7603 },\n        { name: 'Sousse', lat: 35.8256, lng: 10.6411 },\n        { name: 'Kairouan', lat: 35.6781, lng: 10.0963 },\n      ];\n\n      for (const city of majorCities) {\n        const bounds = {\n          north: city.lat + 0.05,\n          south: city.lat - 0.05,\n          east: city.lng + 0.05,\n          west: city.lng - 0.05,\n        };\n        \n        // This would typically call the actual map data service\n        await this.cacheMapData(bounds, { prizes: [], partners: [] }, 1800);\n      }\n    } catch (error) {\n      typedLogger.error('Warmup map data error', { error: (error as any).message });\n    }\n  }\n\n  private static async warmupLeaderboards(): Promise<void> {\n    try {\n      const leaderboardTypes = ['points', 'claims', 'distance', 'level'];\n      \n      for (const type of leaderboardTypes) {\n        // This would typically call the actual leaderboard service\n        await this.cacheLeaderboard(type, [], 600);\n      }\n    } catch (error) {\n      typedLogger.error('Warmup leaderboards error', { error: (error as any).message });\n    }\n  }\n\n  private static async warmupSettings(): Promise<void> {\n    try {\n      // Cache system settings\n      await this.set('system_settings', {}, {\n        ttl: 3600,\n        tags: ['settings'],\n      });\n    } catch (error) {\n      typedLogger.error('Warmup settings error', { error: (error as any).message });\n    }\n  }\n\n  private static async warmupPartners(): Promise<void> {\n    try {\n      // Cache active partners\n      await this.set('active_partners', [], {\n        ttl: 1800,\n        tags: ['partners'],\n      });\n    } catch (error) {\n      typedLogger.error('Warmup partners error', { error: (error as any).message });\n    }\n  }\n}\n\n// Allow Redis initialization to be injected after connect to avoid circular imports\nexport function setCacheClient(client: any) {\n  (CacheService as any).redis = client;\n}\n\n/**\n * Cache decorators for automatic caching\n */\nexport function Cacheable(options: CacheOptions = {}) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    const originalMethod = descriptor.value;\n\n    descriptor.value = async function (...args: any[]) {\n      const cacheKey = `${target.constructor.name}:${propertyKey}:${JSON.stringify(args)}`;\n      \n      return await CacheService.getOrSet(\n        cacheKey,\n        () => originalMethod.apply(this, args),\n        options\n      );\n    };\n\n    return descriptor;\n  };\n}\n\nexport default CacheService;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\services\\config.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":16,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[565,568],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[565,568],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":148,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":148,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4501,4504],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4501,4504],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":164,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":164,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4926,4929],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4926,4929],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":186,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":186,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5507,5510],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5507,5510],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":195,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":195,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5770,5773],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5770,5773],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":215,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":215,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6240,6243],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6240,6243],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":285,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":285,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8187,8190],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8187,8190],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":349,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":349,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10052,10055],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10052,10055],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":418,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":418,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12039,12042],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12039,12042],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":424,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":424,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12249,12252],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12249,12252],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Settings, ISettings } from '@/models/Settings';\r\nimport { CacheService } from './cache';\r\nimport { redisPubSub, redisPublisher } from '@/config/redis';\r\nimport { typedLogger } from '@/lib/typed-logger';\r\nimport { audit } from '@/lib/audit-logger';\r\nimport { EventEmitter } from 'events';\r\n\r\n/**\r\n * Real-time Configuration Service\r\n * Provides hot-reloadable game configuration with Redis pub/sub\r\n * Eliminates need for server restart when changing game settings\r\n */\r\n\r\nexport interface ConfigChangeEvent {\r\n  section: string;\r\n  changes: Record<string, any>;\r\n  changedBy: string;\r\n  timestamp: number;\r\n  version: number;\r\n}\r\n\r\nexport class ConfigService extends EventEmitter {\r\n  private static instance: ConfigService;\r\n  private static readonly CACHE_TTL = 3600; // 1 hour\r\n  private static readonly CONFIG_CHANNEL = 'game:config:changes';\r\n  private static readonly CONFIG_VERSION_KEY = 'config:version';\r\n  private configVersion = 0;\r\n  private isSubscribed = false;\r\n\r\n  private constructor() {\r\n    super();\r\n  }\r\n\r\n  /**\r\n   * Get singleton instance\r\n   */\r\n  static getInstance(): ConfigService {\r\n    if (!ConfigService.instance) {\r\n      ConfigService.instance = new ConfigService();\r\n    }\r\n    return ConfigService.instance;\r\n  }\r\n\r\n  /**\r\n   * Initialize the config service (call on app startup)\r\n   */\r\n  async initialize(): Promise<void> {\r\n    try {\r\n      typedLogger.info('Initializing ConfigService');\r\n\r\n      // Load initial config version from Redis\r\n      const versionStr = await CacheService.get<number>(ConfigService.CONFIG_VERSION_KEY);\r\n      this.configVersion = versionStr || 0;\r\n\r\n      // Subscribe to config changes\r\n      await this.subscribeToConfigChanges();\r\n\r\n      typedLogger.info('ConfigService initialized', { version: this.configVersion });\r\n    } catch (error) {\r\n      typedLogger.error('ConfigService initialization failed', { error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Subscribe to config change events via Redis pub/sub\r\n   */\r\n  private async subscribeToConfigChanges(): Promise<void> {\r\n    if (this.isSubscribed) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      await redisPubSub.subscribe(ConfigService.CONFIG_CHANNEL, (err, count) => {\r\n        if (err) {\r\n          typedLogger.error('Failed to subscribe to config changes', { error: err.message });\r\n        } else {\n          const channelCount = typeof count === 'number' ? count : Number(count) || 0;\n          typedLogger.info('Subscribed to config changes', { channels: channelCount });\n          this.isSubscribed = true;\n        }\n      });\r\n\r\n      // Listen for messages\r\n      redisPubSub.on('message', async (channel, message) => {\r\n        if (channel === ConfigService.CONFIG_CHANNEL) {\r\n          try {\r\n            const event: ConfigChangeEvent = JSON.parse(message);\r\n            this.configVersion = event.version;\r\n            \r\n            // Invalidate cache for this section\r\n            await CacheService.invalidate(`config:${event.section}`);\r\n            \r\n            // Emit event to local listeners\r\n            this.emit('configChanged', event);\r\n            \r\n            typedLogger.info('Config change received', {\r\n              section: event.section,\r\n              version: event.version,\r\n              changedBy: event.changedBy,\r\n            });\r\n          } catch (error) {\r\n            typedLogger.error('Failed to process config change', { error });\r\n          }\r\n        }\r\n      });\r\n    } catch (error) {\r\n      typedLogger.error('Failed to subscribe to config changes', { error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get full game configuration\r\n   */\r\n  async getConfig(): Promise<Partial<ISettings> | null> {\r\n    try {\r\n      const cacheKey = 'config:full';\r\n      \r\n      // Try cache first\r\n      const cached = await CacheService.get<Partial<ISettings>>(cacheKey);\r\n      if (cached) {\r\n        return cached;\r\n      }\r\n\r\n      // Fetch from database\r\n      const settings = await Settings.findOne();\r\n      if (!settings) {\r\n        return null;\r\n      }\r\n\r\n      // Cache the result\r\n      await CacheService.set(cacheKey, settings.toObject(), {\r\n        ttl: ConfigService.CACHE_TTL,\r\n        tags: ['config', 'game-settings'],\r\n      });\r\n\r\n      return settings.toObject();\r\n    } catch (error) {\r\n      typedLogger.error('Failed to get config', { error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get specific config section (game, antiCheat, rewards, etc.)\r\n   */\r\n  async getConfigSection<T = any>(section: string): Promise<T | null> {\r\n    try {\r\n      const cacheKey = `config:${section}`;\r\n      \r\n      // Try cache first\r\n      const cached = await CacheService.get<T>(cacheKey);\r\n      if (cached) {\r\n        return cached;\r\n      }\r\n\r\n      // Fetch from database\r\n      const settings = await Settings.findOne();\r\n      if (!settings) {\r\n        return null;\r\n      }\r\n\r\n      const sectionData = (settings as any)[section];\r\n      if (!sectionData) {\r\n        return null;\r\n      }\r\n\r\n      // Cache the section\r\n      await CacheService.set(cacheKey, sectionData, {\r\n        ttl: ConfigService.CACHE_TTL,\r\n        tags: ['config', section],\r\n      });\r\n\r\n      return sectionData as T;\r\n    } catch (error) {\r\n      typedLogger.error('Failed to get config section', { error, section });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get a specific config value with dot notation support\r\n   * Example: getConfigValue('game.antiCheat.maxSpeedThreshold')\r\n   */\r\n  async getConfigValue<T = any>(path: string): Promise<T | undefined> {\r\n    try {\r\n      const [section, ...keys] = path.split('.');\r\n      \r\n      const sectionData = await this.getConfigSection(section);\r\n      if (!sectionData) {\r\n        return undefined;\r\n      }\r\n\r\n      let value: any = sectionData;\r\n      for (const key of keys) {\r\n        value = value?.[key];\r\n        if (value === undefined) {\r\n          return undefined;\r\n        }\r\n      }\r\n\r\n      return value as T;\r\n    } catch (error) {\r\n      typedLogger.error('Failed to get config value', { error, path });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update config section and broadcast change\r\n   */\r\n  async updateConfigSection(\r\n    section: string,\r\n    updates: Record<string, any>,\r\n    adminId: string\r\n  ): Promise<Partial<ISettings> | null> {\r\n    try {\r\n      typedLogger.info('Updating config section', { section, adminId });\r\n\r\n      // Update database\r\n      const updatePath = section;\r\n      const settings = await Settings.findOneAndUpdate(\r\n        {},\r\n        {\r\n          $set: { [updatePath]: updates },\r\n          updatedBy: adminId,\r\n        },\r\n        { new: true, upsert: true }\r\n      );\r\n\r\n      if (!settings) {\r\n        throw new Error('Failed to update settings');\r\n      }\r\n\r\n      // Increment version\r\n      this.configVersion++;\r\n      await CacheService.set(ConfigService.CONFIG_VERSION_KEY, this.configVersion, {\r\n        ttl: 86400 * 30, // 30 days\r\n      });\r\n\r\n      // Clear all related caches\r\n      await CacheService.invalidate(`config:${section}`);\r\n      await CacheService.invalidate('config:full');\r\n\r\n      // Broadcast change via Redis pub/sub\r\n      const event: ConfigChangeEvent = {\r\n        section,\r\n        changes: updates,\r\n        changedBy: adminId,\r\n        timestamp: Date.now(),\r\n        version: this.configVersion,\r\n      };\r\n\r\n      // Use redisPublisher (not redisPubSub which is in subscriber mode)\r\n      await redisPublisher.publish(\r\n        ConfigService.CONFIG_CHANNEL,\r\n        JSON.stringify(event)\r\n      );\r\n\r\n      // Audit log for config updates\r\n      await audit.settingsUpdated(adminId, section, {\r\n        configSection: section,\r\n        changesApplied: Object.keys(updates),\r\n        version: this.configVersion,\r\n      });\r\n\r\n      typedLogger.info('Config section updated and broadcasted', {\r\n        section,\r\n        version: this.configVersion,\r\n      });\r\n\r\n      return settings.toObject();\r\n    } catch (error) {\r\n      typedLogger.error('Failed to update config section', { error, section });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update specific config value\r\n   */\r\n  async updateConfigValue(\r\n    path: string,\r\n    value: any,\r\n    adminId: string\r\n  ): Promise<Partial<ISettings> | null> {\r\n    try {\r\n      const [section, ...keys] = path.split('.');\r\n      \r\n      // Get current section\r\n      const sectionData = await this.getConfigSection(section);\r\n      if (!sectionData && keys.length > 0) {\r\n        throw new Error(`Config section ${section} not found`);\r\n      }\r\n\r\n      // Build nested update\r\n      let updateObject = sectionData || {};\r\n      if (keys.length > 0) {\r\n        let current = updateObject;\r\n        for (let i = 0; i < keys.length - 1; i++) {\r\n          if (!current[keys[i]]) {\r\n            current[keys[i]] = {};\r\n          }\r\n          current = current[keys[i]];\r\n        }\r\n        current[keys[keys.length - 1]] = value;\r\n      } else {\r\n        updateObject = value;\r\n      }\r\n\r\n      return this.updateConfigSection(section, updateObject, adminId);\r\n    } catch (error) {\r\n      typedLogger.error('Failed to update config value', { error, path });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get configuration history (changes over time)\r\n   */\r\n  async getConfigHistory(\r\n    section?: string,\r\n    limit: number = 50\r\n  ): Promise<ConfigChangeEvent[]> {\r\n    try {\r\n      const cacheKey = section\r\n        ? `config:history:${section}`\r\n        : 'config:history:all';\r\n\r\n      // Try cache first\r\n      const cached = await CacheService.get<ConfigChangeEvent[]>(cacheKey);\r\n      if (cached) {\r\n        return cached.slice(0, limit);\r\n      }\r\n\r\n      // In a production system, you'd fetch from a dedicated history collection\r\n      // For now, returning empty array\r\n      return [];\r\n    } catch (error) {\r\n      typedLogger.error('Failed to get config history', { error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate config changes before applying\r\n   */\r\n  async validateConfigUpdate(section: string, updates: Record<string, any>): Promise<{\r\n    valid: boolean;\r\n    errors: string[];\r\n  }> {\r\n    const errors: string[] = [];\r\n\r\n    // Validate game settings\r\n    if (section === 'game') {\r\n      if (updates.maxDailyClaims && updates.maxDailyClaims < 1) {\r\n        errors.push('maxDailyClaims must be at least 1');\r\n      }\r\n      if (updates.claimCooldownMs && updates.claimCooldownMs < 100) {\r\n        errors.push('claimCooldownMs must be at least 100ms');\r\n      }\r\n      if (updates.prizeDetectionRadiusM && updates.prizeDetectionRadiusM < 1) {\r\n        errors.push('prizeDetectionRadiusM must be at least 1m');\r\n      }\r\n    }\r\n\r\n    // Validate anti-cheat settings\r\n    if (section === 'antiCheat') {\r\n      if (updates.riskScoreThreshold && (updates.riskScoreThreshold < 0 || updates.riskScoreThreshold > 100)) {\r\n        errors.push('riskScoreThreshold must be between 0 and 100');\r\n      }\r\n    }\r\n\r\n    // Validate progression settings\r\n    if (section === 'progression') {\r\n      if (updates.maxLevel && updates.maxLevel < 1) {\r\n        errors.push('maxLevel must be at least 1');\r\n      }\r\n    }\r\n\r\n    return {\r\n      valid: errors.length === 0,\r\n      errors,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Reload config from database (force refresh)\r\n   */\r\n  async reload(): Promise<void> {\r\n    try {\n      typedLogger.info('Force reloading config');\n      \n      // Clear all caches\n      await CacheService.invalidate('config:*');\n      \n      // Load fresh config\n      await this.getConfig();\n      \r\n      typedLogger.info('Config reloaded successfully');\r\n    } catch (error) {\r\n      typedLogger.error('Failed to reload config', { error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if a feature is enabled\r\n   */\r\n  async isFeatureEnabled(featureName: string): Promise<boolean> {\r\n    try {\r\n      const gameConfig = await this.getConfigSection('game');\r\n      if (!gameConfig) return false;\r\n\r\n      // Check power-ups\r\n      if (featureName === 'powerUps') {\r\n        return (gameConfig as any).powerUps?.enabled ?? false;\r\n      }\r\n\r\n      // Check anti-cheat\r\n      if (featureName === 'antiCheat') {\r\n        const acConfig = await this.getConfigSection('antiCheat');\r\n        return (acConfig as any)?.enabled ?? false;\r\n      }\r\n\r\n      return false;\r\n    } catch (error) {\r\n      typedLogger.error('Failed to check feature', { error, featureName });\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current config version\r\n   */\r\n  getVersion(): number {\r\n    return this.configVersion;\r\n  }\r\n\r\n  /**\r\n   * Listen to config changes\r\n   */\r\n  onConfigChange(callback: (event: ConfigChangeEvent) => void): void {\r\n    this.on('configChanged', callback);\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const configService = ConfigService.getInstance();\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\services\\friendship.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":14,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[421,424],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[421,424],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":55,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1734,1737],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1734,1737],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":63,"column":83,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":63,"endColumn":86,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1925,1928],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1925,1928],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":94,"column":91,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":94,"endColumn":94,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3024,3027],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3024,3027],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":102,"column":91,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":102,"endColumn":94,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3387,3390],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3387,3390],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":111,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3649,3652],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3649,3652],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":119,"column":83,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":119,"endColumn":86,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3843,3846],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3843,3846],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":146,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":146,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4601,4604],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4601,4604],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":154,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":154,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4779,4782],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4779,4782],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":179,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":179,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5440,5443],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5440,5443],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":208,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":208,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6271,6274],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6271,6274],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":216,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":216,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6453,6456],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6453,6456],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":242,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":242,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7104,7107],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7104,7107],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":250,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":250,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7269,7272],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7269,7272],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":278,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":278,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8243,8246],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8243,8246],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":286,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":286,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8408,8411],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8408,8411],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":301,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":301,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8886,8889],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8886,8889],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":309,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":309,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9046,9049],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9046,9049],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":324,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":324,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9521,9524],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9521,9524],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":343,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":343,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10178,10181],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10178,10181],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":366,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":366,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10840,10843],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10840,10843],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":385,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":385,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11400,11403],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11400,11403],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":22,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Types } from 'mongoose';\nimport { Friendship, FriendshipStatus } from '@/models/Friendship';\nimport { User } from '@/models/User';\nimport { typedLogger } from '@/lib/typed-logger';\n\n/**\n * Friendship Service\n * G├¿re toutes les op├®rations li├®es aux amiti├®s\n */\nexport class FriendshipService {\n  /**\n   * Envoyer une demande d'ami\n   */\n  static async sendFriendRequest(userId: string, friendId: string): Promise<any> {\n    try {\n      // V├®rifier que l'utilisateur n'essaie pas de s'ajouter lui-m├¬me\n      if (userId === friendId) {\n        throw new Error('CANNOT_ADD_SELF');\n      }\n\n      // V├®rifier que le friend existe\n      const friend = await User.findById(friendId);\n      if (!friend) {\n        throw new Error('USER_NOT_FOUND');\n      }\n\n      // V├®rifier qu'il n'y a pas d├®j├á une demande ou une amiti├®\n      const existing = await Friendship.findOne({\n        $or: [\n          { userId: new Types.ObjectId(userId), friendId: new Types.ObjectId(friendId) },\n          { userId: new Types.ObjectId(friendId), friendId: new Types.ObjectId(userId) }\n        ]\n      });\n\n      if (existing) {\n        throw new Error(`FRIENDSHIP_ALREADY_EXISTS_${existing.status.toUpperCase()}`);\n      }\n\n      // Cr├®er la demande\n      const friendship = new Friendship({\n        userId: new Types.ObjectId(userId),\n        friendId: new Types.ObjectId(friendId),\n        status: FriendshipStatus.PENDING,\n      });\n\n      await friendship.save();\n\n      typedLogger.info('Friend request sent', { userId, friendId, friendshipId: friendship._id });\n\n      return {\n        success: true,\n        friendship: friendship.toJSON(),\n      };\n    } catch (error) {\n      typedLogger.error('Send friend request error', { error: (error as any).message, userId, friendId });\n      throw error;\n    }\n  }\n\n  /**\n   * Accepter une demande d'ami\n   */\n  static async acceptFriendRequest(userId: string, friendshipId: string): Promise<any> {\n    try {\n      const friendship = await Friendship.findById(friendshipId);\n\n      if (!friendship) {\n        throw new Error('FRIENDSHIP_NOT_FOUND');\n      }\n\n      // V├®rifier que c'est bien le destinataire\n      if (friendship.friendId.toString() !== userId) {\n        throw new Error('FORBIDDEN');\n      }\n\n      // V├®rifier le statut\n      if (friendship.status !== FriendshipStatus.PENDING) {\n        throw new Error(`FRIENDSHIP_ALREADY_${friendship.status.toUpperCase()}`);\n      }\n\n      // Accepter\n      friendship.accept();\n      await friendship.save();\n\n      typedLogger.info('Friend request accepted', { userId, friendshipId });\n\n      // Trigger achievements for both users (async, don't wait)\n      import('@/services/achievement').then(({ default: AchievementService }) => {\n        // For the user who accepts\n        AchievementService.checkAchievements(userId, 'FRIEND_ADDED', {\n          friendId: friendship.userId.toString(),\n          friendshipId,\n        }).catch(error => {\n          typedLogger.error('Check achievements error (FRIEND_ADDED)', { error: (error as any).message, userId });\n        });\n        \n        // Pour l'utilisateur qui a envoy├® la demande\n        AchievementService.checkAchievements(friendship.userId.toString(), 'FRIEND_ADDED', {\n          friendId: userId,\n          friendshipId,\n        }).catch(error => {\n          typedLogger.error('Check achievements error (FRIEND_ADDED)', { error: (error as any).message, userId: friendship.userId.toString() });\n        });\n      });\n\n      return {\n        success: true,\n        friendship: friendship.toJSON(),\n      };\n    } catch (error) {\n      typedLogger.error('Accept friend request error', { error: (error as any).message, userId, friendshipId });\n      throw error;\n    }\n  }\n\n  /**\n   * Rejeter une demande d'ami\n   */\n  static async rejectFriendRequest(userId: string, friendshipId: string): Promise<any> {\n    try {\n      const friendship = await Friendship.findById(friendshipId);\n\n      if (!friendship) {\n        throw new Error('FRIENDSHIP_NOT_FOUND');\n      }\n\n      if (friendship.friendId.toString() !== userId) {\n        throw new Error('FORBIDDEN');\n      }\n\n      if (friendship.status !== FriendshipStatus.PENDING) {\n        throw new Error(`FRIENDSHIP_ALREADY_${friendship.status.toUpperCase()}`);\n      }\n\n      // Rejeter\n      friendship.reject();\n      await friendship.save();\n\n      typedLogger.info('Friend request rejected', { userId, friendshipId });\n\n      return {\n        success: true,\n        friendship: friendship.toJSON(),\n      };\n    } catch (error) {\n      typedLogger.error('Reject friend request error', { error: (error as any).message, userId, friendshipId });\n      throw error;\n    }\n  }\n\n  /**\n   * Supprimer un ami\n   */\n  static async removeFriend(userId: string, friendshipId: string): Promise<any> {\n    try {\n      const friendship = await Friendship.findById(friendshipId);\n\n      if (!friendship) {\n        throw new Error('FRIENDSHIP_NOT_FOUND');\n      }\n\n      // V├®rifier que l'utilisateur est impliqu├®\n      if (\n        friendship.userId.toString() !== userId &&\n        friendship.friendId.toString() !== userId\n      ) {\n        throw new Error('FORBIDDEN');\n      }\n\n      await friendship.deleteOne();\n\n      typedLogger.info('Friend removed', { userId, friendshipId });\n\n      return {\n        success: true,\n        message: 'Friend removed',\n      };\n    } catch (error) {\n      typedLogger.error('Remove friend error', { error: (error as any).message, userId, friendshipId });\n      throw error;\n    }\n  }\n\n  /**\n   * Admin: remove friendship regardless of requester (with audit-friendly payload)\n   */\n  static async adminRemoveFriendship(adminId: string, friendshipId: string) {\n    try {\n      const friendship = await Friendship.findById(friendshipId);\n      if (!friendship) {\n        throw new Error('FRIENDSHIP_NOT_FOUND');\n      }\n\n      await friendship.deleteOne();\n\n      typedLogger.info('Admin removed friendship', { adminId, friendshipId });\n\n      return {\n        success: true,\n        message: 'Friendship removed',\n        friendshipId,\n        userIds: {\n          userId: friendship.userId,\n          friendId: friendship.friendId\n        }\n      };\n    } catch (error) {\n      typedLogger.error('Admin remove friendship error', { error: (error as any).message, adminId, friendshipId });\n      throw error;\n    }\n  }\n\n  /**\n   * Bloquer un utilisateur\n   */\n  static async blockUser(userId: string, friendshipId: string): Promise<any> {\n    try {\n      const friendship = await Friendship.findById(friendshipId);\n\n      if (!friendship) {\n        throw new Error('FRIENDSHIP_NOT_FOUND');\n      }\n\n      if (\n        friendship.userId.toString() !== userId &&\n        friendship.friendId.toString() !== userId\n      ) {\n        throw new Error('FORBIDDEN');\n      }\n\n      // Bloquer\n      friendship.block();\n      await friendship.save();\n\n      typedLogger.info('User blocked', { userId, friendshipId });\n\n      return {\n        success: true,\n        friendship: friendship.toJSON(),\n      };\n    } catch (error) {\n      typedLogger.error('Block user error', { error: (error as any).message, userId, friendshipId });\n      throw error;\n    }\n  }\n\n  /**\n   * R├®cup├®rer la liste des amis\n   */\n  static async getFriends(userId: string): Promise<any> {\n    try {\n      const friendships = await Friendship.find({\n        $or: [\n          { userId: new Types.ObjectId(userId), status: FriendshipStatus.ACCEPTED },\n          { friendId: new Types.ObjectId(userId), status: FriendshipStatus.ACCEPTED }\n        ]\n      })\n      .populate('userId', 'displayName level points.total stats.prizesFound stats.rewardsRedeemed')\n      .populate('friendId', 'displayName level points.total stats.prizesFound stats.rewardsRedeemed')\n      .sort({ acceptedAt: -1 })\n      .lean();\n\n      // Extraire les infos des amis\n      const friends = friendships.map(f => {\n        const friend = f.userId._id.toString() === userId ? f.friendId : f.userId;\n        return {\n          ...friend,\n          friendshipId: f._id,\n          friendsSince: f.acceptedAt,\n        };\n      });\n\n      return {\n        friends,\n        total: friends.length,\n      };\n    } catch (error) {\n      typedLogger.error('Get friends error', { error: (error as any).message, userId });\n      throw error;\n    }\n  }\n\n  /**\n   * R├®cup├®rer les demandes en attente\n   */\n  static async getPendingRequests(userId: string): Promise<any> {\n    try {\n      const requests = await Friendship.find({\n        friendId: new Types.ObjectId(userId),\n        status: FriendshipStatus.PENDING\n      })\n      .populate('userId', 'displayName level points.total stats.prizesFound stats.rewardsRedeemed')\n      .sort({ requestedAt: -1 })\n      .lean();\n\n      return {\n        requests,\n        total: requests.length,\n      };\n    } catch (error) {\n      typedLogger.error('Get pending requests error', { error: (error as any).message, userId });\n      throw error;\n    }\n  }\n\n  /**\n   * R├®cup├®rer les demandes envoy├®es\n   */\n  static async getSentRequests(userId: string): Promise<any> {\n    try {\n      const requests = await Friendship.find({\n        userId: new Types.ObjectId(userId),\n        status: FriendshipStatus.PENDING\n      })\n      .populate('friendId', 'displayName level points.total stats.prizesFound stats.rewardsRedeemed')\n      .sort({ requestedAt: -1 })\n      .lean();\n\n      return {\n        requests,\n        total: requests.length,\n      };\n    } catch (error) {\n      typedLogger.error('Get sent requests error', { error: (error as any).message, userId });\n      throw error;\n    }\n  }\n\n  /**\n   * V├®rifier si deux utilisateurs sont amis\n   */\n  static async areFriends(userId1: string, userId2: string): Promise<boolean> {\n    try {\n      const friendship = await Friendship.findOne({\n        $or: [\n          { userId: new Types.ObjectId(userId1), friendId: new Types.ObjectId(userId2), status: FriendshipStatus.ACCEPTED },\n          { userId: new Types.ObjectId(userId2), friendId: new Types.ObjectId(userId1), status: FriendshipStatus.ACCEPTED }\n        ]\n      });\n\n      return !!friendship;\n    } catch (error) {\n      typedLogger.error('Check friendship error', { error: (error as any).message, userId1, userId2 });\n      return false;\n    }\n  }\n\n  /**\n   * R├®cup├®rer le statut d'amiti├®\n   */\n  static async getFriendshipStatus(userId1: string, userId2: string): Promise<string> {\n    try {\n      const friendship = await Friendship.findOne({\n        $or: [\n          { userId: new Types.ObjectId(userId1), friendId: new Types.ObjectId(userId2) },\n          { userId: new Types.ObjectId(userId2), friendId: new Types.ObjectId(userId1) }\n        ]\n      });\n\n      if (!friendship) {\n        return 'none';\n      }\n\n      return friendship.status;\n    } catch (error) {\n      typedLogger.error('Get friendship status error', { error: (error as any).message, userId1, userId2 });\n      return 'none';\n    }\n  }\n\n  /**\n   * Compter les amis d'un utilisateur\n   */\n  static async countFriends(userId: string): Promise<number> {\n    try {\n      const count = await Friendship.countDocuments({\n        $or: [\n          { userId: new Types.ObjectId(userId), status: FriendshipStatus.ACCEPTED },\n          { friendId: new Types.ObjectId(userId), status: FriendshipStatus.ACCEPTED }\n        ]\n      });\n\n      return count;\n    } catch (error) {\n      typedLogger.error('Count friends error', { error: (error as any).message, userId });\n      return 0;\n    }\n  }\n}\n\nexport default FriendshipService;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\services\\metrics.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'config' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":16},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":87,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":87,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2222,2225],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2222,2225],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":168,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":168,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4352,4355],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4352,4355],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":209,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":209,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5301,5304],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5301,5304],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":257,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":257,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6668,6671],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6668,6671],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":264,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":264,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6821,6824],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6821,6824],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":279,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":279,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7354,7357],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7354,7357],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":287,"column":91,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":287,"endColumn":94,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7545,7548],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7545,7548],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":300,"column":83,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":300,"endColumn":86,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8212,8215],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8212,8215],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":308,"column":87,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":308,"endColumn":90,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8415,8418],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8415,8418],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":337,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":337,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9435,9438],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9435,9438],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":364,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":364,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10245,10248],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10245,10248],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":393,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":393,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11127,11130],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11127,11130],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":406,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":406,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11583,11586],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11583,11586],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":425,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":425,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12072,12075],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12072,12075],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"prefer-const","severity":2,"message":"'stats' is never reassigned. Use 'const' instead.","line":436,"column":11,"nodeType":"Identifier","messageId":"useConst","endLine":436,"endColumn":16,"fix":{"range":[12386,12635],"text":"const stats = currentStats ? JSON.parse(currentStats) : {\n        totalSessions: 0,\n        totalDuration: 0,\n        totalDistance: 0,\n        totalPrizesClaimed: 0,\n        averageFrameRate: 0,\n        lastUpdated: new Date().toISOString(),\n      };"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":456,"column":79,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":456,"endColumn":82,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13217,13220],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13217,13220],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":536,"column":80,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":536,"endColumn":83,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16248,16251],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16248,16251],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":549,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":549,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16567,16570],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16567,16570],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":566,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":566,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17298,17301],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17298,17301],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":571,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":571,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17426,17429],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17426,17429],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":581,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":581,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18003,18006],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18003,18006],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":586,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":586,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18111,18114],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18111,18114],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":595,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":595,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18397,18400],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18397,18400],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":600,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":600,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18517,18520],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18517,18520],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":608,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":608,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18845,18848],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18845,18848],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":634,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":634,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19533,19536],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19533,19536],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":644,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":644,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20004,20007],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20004,20007],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":654,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":654,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20374,20377],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20374,20377],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":664,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":664,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20761,20764],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20761,20764],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":675,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":675,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21284,21287],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21284,21287],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":680,"column":97,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":680,"endColumn":100,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21435,21438],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21435,21438],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":689,"column":81,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":689,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21741,21744],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21741,21744],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":694,"column":90,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":694,"endColumn":93,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21886,21889],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21886,21889],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":703,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":703,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22365,22368],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22365,22368],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":708,"column":89,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":708,"endColumn":92,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22509,22512],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22509,22512],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":718,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":718,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22793,22796],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22793,22796],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":723,"column":89,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":723,"endColumn":92,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22937,22940],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22937,22940],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":749,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":749,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23795,23798],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23795,23798],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":754,"column":98,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":754,"endColumn":101,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23948,23951],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23948,23951],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":770,"column":81,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":770,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24492,24495],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24492,24495],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":781,"column":78,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":781,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24945,24948],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24945,24948],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":794,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":794,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25327,25330],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25327,25330],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":804,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":804,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25616,25619],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25616,25619],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":833,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":833,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26782,26785],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26782,26785],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":842,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":842,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[27112,27115],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[27112,27115],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":851,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":851,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[27436,27439],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[27436,27439],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":879,"column":78,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":879,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28280,28283],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28280,28283],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":48,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import { redisClient } from '@/config/redis';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { config } from '@/config';\nimport { User, Session, Claim, Redemption } from '@/models';\n\n/**\n * Advanced Metrics Service\n * Critical for Unity performance monitoring and business intelligence\n * Tracks game-specific metrics, performance data, and user behavior\n */\n\nexport interface MetricEvent {\n  name: string;\n  value: number;\n  timestamp?: Date;\n  tags?: Record<string, string>;\n  userId?: string;\n  sessionId?: string;\n}\n\nexport interface GameMetrics {\n  sessionDuration: number;\n  prizesFound: number;\n  prizesClaimed: number;\n  distanceTraveled: number;\n  averageSpeed: number;\n  batteryUsage: number;\n  networkLatency: number;\n  frameRate: number;\n  crashes: number;\n}\n\nexport interface BusinessMetrics {\n  dailyActiveUsers: number;\n  monthlyActiveUsers: number;\n  retentionRate: number;\n  conversionRate: number;\n  averageSessionDuration: number;\n  revenuePerUser: number;\n  churnRate: number;\n}\n\nexport class MetricsService {\n  private static redis = redisClient;\n  private static metricsBuffer: MetricEvent[] = [];\n  private static bufferSize = 100;\n  private static flushInterval = 30000; // 30 seconds\n\n  /**\n   * Initialize metrics service with automatic flushing\n   */\n  static initialize(): void {\n    // Start automatic buffer flushing\n    setInterval(() => {\n      this.flushMetrics();\n    }, this.flushInterval);\n\n    typedLogger.info('Metrics service initialized');\n  }\n\n  /**\n   * Record a metric event\n   */\n  static async recordMetric(event: MetricEvent): Promise<void> {\n    try {\n      if (!this.hasRedis()) {\n        return;\n      }\n      // Add timestamp if not provided\n      if (!event.timestamp) {\n        event.timestamp = new Date();\n      }\n\n      // Add to buffer\n      this.metricsBuffer.push(event);\n\n      // Flush if buffer is full\n      if (this.metricsBuffer.length >= this.bufferSize) {\n        await this.flushMetrics();\n      }\n\n      // Also record in real-time for critical metrics\n      if (this.isCriticalMetric(event.name)) {\n        await this.recordRealTimeMetric(event);\n      }\n    } catch (error) {\n      typedLogger.error('Record metric error', { error: (error as any).message, event });\n    }\n  }\n\n  /**\n   * Record Unity-specific game metrics\n   */\n  static async recordGameMetrics(userId: string, sessionId: string, metrics: GameMetrics): Promise<void> {\n    try {\n      const events: MetricEvent[] = [\n        {\n          name: 'game.session.duration',\n          value: metrics.sessionDuration,\n          userId,\n          sessionId,\n          tags: { platform: 'unity' },\n        },\n        {\n          name: 'game.prizes.found',\n          value: metrics.prizesFound,\n          userId,\n          sessionId,\n          tags: { platform: 'unity' },\n        },\n        {\n          name: 'game.prizes.claimed',\n          value: metrics.prizesClaimed,\n          userId,\n          sessionId,\n          tags: { platform: 'unity' },\n        },\n        {\n          name: 'game.distance.traveled',\n          value: metrics.distanceTraveled,\n          userId,\n          sessionId,\n          tags: { platform: 'unity', unit: 'meters' },\n        },\n        {\n          name: 'game.performance.fps',\n          value: metrics.frameRate,\n          userId,\n          sessionId,\n          tags: { platform: 'unity' },\n        },\n        {\n          name: 'game.performance.latency',\n          value: metrics.networkLatency,\n          userId,\n          sessionId,\n          tags: { platform: 'unity', unit: 'ms' },\n        },\n        {\n          name: 'game.battery.usage',\n          value: metrics.batteryUsage,\n          userId,\n          sessionId,\n          tags: { platform: 'unity', unit: 'percent' },\n        },\n      ];\n\n      // Record crashes separately if any\n      if (metrics.crashes > 0) {\n        events.push({\n          name: 'game.crashes',\n          value: metrics.crashes,\n          userId,\n          sessionId,\n          tags: { platform: 'unity', severity: 'high' },\n        });\n      }\n\n      // Record all events\n      for (const event of events) {\n        await this.recordMetric(event);\n      }\n\n      // Update user session stats\n      await this.updateUserSessionStats(userId, metrics);\n\n    } catch (error) {\n      typedLogger.error('Record game metrics error', { error: (error as any).message, userId, sessionId });\n    }\n  }\n\n  /**\n   * Record API performance metrics\n   */\n  static async recordAPIMetrics(\n    endpoint: string,\n    method: string,\n    statusCode: number,\n    duration: number,\n    userId?: string\n  ): Promise<void> {\n    try {\n      await this.recordMetric({\n        name: 'api.request.duration',\n        value: duration,\n        userId,\n        tags: {\n          endpoint,\n          method,\n          status: statusCode.toString(),\n          success: statusCode < 400 ? 'true' : 'false',\n        },\n      });\n\n      // Record error rates\n      if (statusCode >= 400) {\n        await this.recordMetric({\n          name: 'api.request.errors',\n          value: 1,\n          userId,\n          tags: {\n            endpoint,\n            method,\n            status: statusCode.toString(),\n          },\n        });\n      }\n    } catch (error) {\n      typedLogger.error('Record API metrics error', { error: (error as any).message, endpoint, method });\n    }\n  }\n\n  /**\n   * Record business metrics\n   */\n  static async recordBusinessMetrics(): Promise<void> {\n    try {\n      const metrics = await this.calculateBusinessMetrics();\n      \n      const events: MetricEvent[] = [\n        {\n          name: 'business.users.daily_active',\n          value: metrics.dailyActiveUsers,\n          tags: { period: 'daily' },\n        },\n        {\n          name: 'business.users.monthly_active',\n          value: metrics.monthlyActiveUsers,\n          tags: { period: 'monthly' },\n        },\n        {\n          name: 'business.retention.rate',\n          value: metrics.retentionRate,\n          tags: { period: 'weekly', unit: 'percent' },\n        },\n        {\n          name: 'business.conversion.rate',\n          value: metrics.conversionRate,\n          tags: { unit: 'percent' },\n        },\n        {\n          name: 'business.session.average_duration',\n          value: metrics.averageSessionDuration,\n          tags: { unit: 'seconds' },\n        },\n        {\n          name: 'business.churn.rate',\n          value: metrics.churnRate,\n          tags: { period: 'monthly', unit: 'percent' },\n        },\n      ];\n\n      for (const event of events) {\n        await this.recordMetric(event);\n      }\n    } catch (error) {\n      typedLogger.error('Record business metrics error', { error: (error as any).message });\n    }\n  }\n\n  /**\n   * Get real-time metrics for monitoring dashboards\n   */\n  static async getRealTimeMetrics(): Promise<Record<string, any>> {\n    try {\n      const now = new Date();\n      const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);\n\n      const metrics = {\n        timestamp: now.toISOString(),\n        api: await this.getAPIMetrics(oneHourAgo, now),\n        game: await this.getGameMetrics(oneHourAgo, now),\n        system: await this.getSystemMetrics(),\n        business: await this.getBusinessMetrics(oneHourAgo, now),\n      };\n\n      return metrics;\n    } catch (error) {\n      typedLogger.error('Get real-time metrics error', { error: (error as any).message });\n      return {};\n    }\n  }\n\n  /**\n   * Get Unity-specific performance metrics\n   */\n  static async getUnityPerformanceMetrics(timeRange: { start: Date; end: Date }): Promise<any> {\n    try {\n      const metrics = {\n        averageFrameRate: await this.getAverageMetric('game.performance.fps', timeRange),\n        averageLatency: await this.getAverageMetric('game.performance.latency', timeRange),\n        averageBatteryUsage: await this.getAverageMetric('game.battery.usage', timeRange),\n        crashRate: await this.getCrashRate(timeRange),\n        sessionDuration: await this.getAverageMetric('game.session.duration', timeRange),\n        userEngagement: await this.getUserEngagementMetrics(timeRange),\n      };\n\n      return metrics;\n    } catch (error) {\n      typedLogger.error('Get Unity performance metrics error', { error: (error as any).message, timeRange });\n      return {};\n    }\n  }\n\n  /**\n   * Generate metrics report for admin dashboard\n   */\n  static async generateMetricsReport(period: 'daily' | 'weekly' | 'monthly'): Promise<any> {\n    try {\n      const now = new Date();\n      let startDate: Date;\n\n      switch (period) {\n        case 'daily':\n          startDate = new Date(now.getTime() - 24 * 60 * 60 * 1000);\n          break;\n        case 'weekly':\n          startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\n          break;\n        case 'monthly':\n          startDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\n          break;\n      }\n\n      const report = {\n        period,\n        startDate: startDate.toISOString(),\n        endDate: now.toISOString(),\n        summary: await this.getMetricsSummary({ start: startDate, end: now }),\n        trends: await this.getMetricsTrends({ start: startDate, end: now }),\n        alerts: await this.getMetricsAlerts({ start: startDate, end: now }),\n        recommendations: await this.getMetricsRecommendations({ start: startDate, end: now }),\n      };\n\n      return report;\n    } catch (error) {\n      typedLogger.error('Generate metrics report error', { error: (error as any).message, period });\n      return {};\n    }\n  }\n\n  // Private helper methods\n  private static async flushMetrics(): Promise<void> {\n    try {\n      if (!this.hasRedis()) {\n        this.metricsBuffer = [];\n        return;\n      }\n      if (this.metricsBuffer.length === 0) return;\n\n      const metricsToFlush = [...this.metricsBuffer];\n      this.metricsBuffer = [];\n\n      // Store metrics in Redis for real-time access\n      for (const metric of metricsToFlush) {\n        await this.storeMetric(metric);\n      }\n\n      // Also send to external monitoring systems (Prometheus, etc.)\n      await this.sendToExternalSystems(metricsToFlush);\n\n      typedLogger.debug('Metrics flushed', { count: metricsToFlush.length });\n    } catch (error) {\n      typedLogger.error('Flush metrics error', { error: (error as any).message });\n    }\n  }\n\n  private static async storeMetric(metric: MetricEvent): Promise<void> {\n    try {\n      if (!this.hasRedis()) {\n        return;\n      }\n      const key = `metric:${metric.name}:${metric.timestamp?.getTime()}`;\n      const data = {\n        ...metric,\n        timestamp: metric.timestamp?.toISOString(),\n      };\n\n      // Store with 7 days TTL\n      await this.redis.setex(key, 7 * 24 * 60 * 60, JSON.stringify(data));\n\n      // Also add to time series for aggregation\n      const timeSeriesKey = `ts:${metric.name}`;\n      await this.redis.zadd(\n        timeSeriesKey,\n        metric.timestamp?.getTime() || Date.now(),\n        JSON.stringify(data)\n      );\n\n      // Expire time series after 30 days\n      await this.redis.expire(timeSeriesKey, 30 * 24 * 60 * 60);\n    } catch (error) {\n      typedLogger.error('Store metric error', { error: (error as any).message, metric });\n    }\n  }\n\n  private static async recordRealTimeMetric(event: MetricEvent): Promise<void> {\n    try {\n      if (!this.hasRedis()) {\n        return;\n      }\n      // Store in real-time metrics with shorter TTL\n      const key = `realtime:${event.name}`;\n      await this.redis.setex(key, 300, JSON.stringify(event)); // 5 minutes TTL\n    } catch (error) {\n      typedLogger.error('Record real-time metric error', { error: (error as any).message, event });\n    }\n  }\n\n  private static isCriticalMetric(metricName: string): boolean {\n    const criticalMetrics = [\n      'api.request.errors',\n      'game.crashes',\n      'system.memory.usage',\n      'system.cpu.usage',\n      'database.connection.errors',\n    ];\n    return criticalMetrics.includes(metricName);\n  }\n\n  private static hasRedis(): boolean {\n    if (!this.redis && redisClient) {\n      this.redis = redisClient;\n    }\n    return !!this.redis && (this.redis as any).status === 'ready';\n  }\n\n  private static async updateUserSessionStats(userId: string, metrics: GameMetrics): Promise<void> {\n    try {\n      if (!this.hasRedis()) {\n        return;\n      }\n      const statsKey = `user_stats:${userId}`;\n      const currentStats = await this.redis.get(statsKey);\n      \n      let stats = currentStats ? JSON.parse(currentStats) : {\n        totalSessions: 0,\n        totalDuration: 0,\n        totalDistance: 0,\n        totalPrizesClaimed: 0,\n        averageFrameRate: 0,\n        lastUpdated: new Date().toISOString(),\n      };\n\n      // Update stats\n      stats.totalSessions += 1;\n      stats.totalDuration += metrics.sessionDuration;\n      stats.totalDistance += metrics.distanceTraveled;\n      stats.totalPrizesClaimed += metrics.prizesClaimed;\n      stats.averageFrameRate = (stats.averageFrameRate + metrics.frameRate) / 2;\n      stats.lastUpdated = new Date().toISOString();\n\n      // Store updated stats\n      await this.redis.setex(statsKey, 30 * 24 * 60 * 60, JSON.stringify(stats)); // 30 days TTL\n    } catch (error) {\n      typedLogger.error('Update user session stats error', { error: (error as any).message, userId });\n    }\n  }\n\n  private static async calculateBusinessMetrics(): Promise<BusinessMetrics> {\n    try {\n      const now = new Date();\n      const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);\n      const oneMonthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\n\n      const [\n        totalUsers,\n        dailyActiveUsers,\n        monthlyActiveUsers,\n        totalClaims,\n        totalRedemptions,\n        revenueAgg,\n        avgSessionAgg,\n      ] = await Promise.all([\n        User.countDocuments(),\n        User.countDocuments({ lastActive: { $gte: oneDayAgo } }),\n        User.countDocuments({ lastActive: { $gte: oneMonthAgo } }),\n        Claim.countDocuments({ claimedAt: { $gte: oneMonthAgo, $lte: now } }),\n        Redemption.countDocuments({ redeemedAt: { $gte: oneMonthAgo, $lte: now } }),\n        Redemption.aggregate([\n          { $match: { redeemedAt: { $gte: oneMonthAgo, $lte: now } } },\n          { $group: { _id: null, total: { $sum: '$pointsSpent' } } }\n        ]),\n        Session.aggregate([\n          {\n            $match: {\n              $or: [\n                { endTime: { $gte: oneMonthAgo, $lte: now } },\n                { createdAt: { $gte: oneMonthAgo, $lte: now } },\n              ]\n            }\n          },\n          {\n            $project: {\n              durationSeconds: {\n                $ifNull: [\n                  '$duration',\n                  {\n                    $cond: [\n                      {\n                        $and: [\n                          { $ifNull: ['$endTime', false] },\n                          { $ifNull: ['$startTime', false] },\n                        ]\n                      },\n                      { $divide: [{ $subtract: ['$endTime', '$startTime'] }, 1000] },\n                      0\n                    ]\n                  }\n                ]\n              }\n            }\n          },\n          { $match: { durationSeconds: { $gt: 0 } } },\n          { $group: { _id: null, avg: { $avg: '$durationSeconds' } } }\n        ])\n      ]);\n\n      const totalRevenue = revenueAgg[0]?.total || 0;\n      const averageSessionDuration = avgSessionAgg[0]?.avg || 0;\n      const retentionRate = totalUsers > 0 ? (monthlyActiveUsers / totalUsers) * 100 : 0;\n      const conversionRate = totalClaims > 0 ? (totalRedemptions / totalClaims) * 100 : 0;\n      const revenuePerUser = monthlyActiveUsers > 0 ? totalRevenue / monthlyActiveUsers : 0;\n      const churnRate = totalUsers > 0 ? ((totalUsers - monthlyActiveUsers) / totalUsers) * 100 : 0;\n\n      return {\n        dailyActiveUsers,\n        monthlyActiveUsers,\n        retentionRate: Math.round(retentionRate * 100) / 100,\n        conversionRate: Math.round(conversionRate * 100) / 100,\n        averageSessionDuration: Math.round(averageSessionDuration),\n        revenuePerUser: Math.round(revenuePerUser * 100) / 100,\n        churnRate: Math.round(churnRate * 100) / 100,\n      };\n    } catch (error) {\n      typedLogger.error('Calculate business metrics error', { error: (error as any).message });\n      return {\n        dailyActiveUsers: 0,\n        monthlyActiveUsers: 0,\n        retentionRate: 0,\n        conversionRate: 0,\n        averageSessionDuration: 0,\n        revenuePerUser: 0,\n        churnRate: 0,\n      };\n    }\n  }\n\n  private static async getAPIMetrics(start: Date, end: Date): Promise<any> {\n    try {\n      // Get API metrics from time series\n      const requestDurations = await this.getMetricValues('api.request.duration', start, end);\n      const errorCounts = await this.getMetricValues('api.request.errors', start, end);\n\n      return {\n        averageResponseTime: requestDurations.length > 0 \n          ? requestDurations.reduce((a, b) => a + b, 0) / requestDurations.length \n          : 0,\n        totalRequests: requestDurations.length,\n        errorRate: requestDurations.length > 0 \n          ? (errorCounts.length / requestDurations.length) * 100 \n          : 0,\n        totalErrors: errorCounts.length,\n      };\n    } catch (error) {\n      typedLogger.error('Get API metrics error', { error: (error as any).message, start, end });\n      return {};\n    }\n  }\n\n  private static async getGameMetrics(start: Date, end: Date): Promise<any> {\n    try {\n      return {\n        totalSessions: await this.getMetricCount('game.session.duration', start, end),\n        averageSessionDuration: await this.getAverageMetric('game.session.duration', { start, end }),\n        totalPrizesClaimed: await this.getMetricSum('game.prizes.claimed', start, end),\n        averageFrameRate: await this.getAverageMetric('game.performance.fps', { start, end }),\n        crashCount: await this.getMetricSum('game.crashes', start, end),\n      };\n    } catch (error) {\n      typedLogger.error('Get game metrics error', { error: (error as any).message, start, end });\n      return {};\n    }\n  }\n\n  private static async getSystemMetrics(): Promise<any> {\n    try {\n      // Get current system metrics\n      return {\n        memoryUsage: process.memoryUsage(),\n        uptime: process.uptime(),\n        cpuUsage: process.cpuUsage(),\n      };\n    } catch (error) {\n      typedLogger.error('Get system metrics error', { error: (error as any).message });\n      return {};\n    }\n  }\n\n  private static async getBusinessMetrics(start: Date, end: Date): Promise<any> {\n    try {\n      return {\n        activeUsers: await this.getUniqueUserCount(start, end),\n        newUsers: await this.getNewUserCount(start, end),\n        retentionRate: await this.calculateRetentionRate(start, end),\n      };\n    } catch (error) {\n      typedLogger.error('Get business metrics error', { error: (error as any).message, start, end });\n      return {};\n    }\n  }\n\n  private static async getMetricValues(metricName: string, start: Date, end: Date): Promise<number[]> {\n    try {\n      if (!this.hasRedis()) {\n        return [];\n      }\n      const timeSeriesKey = `ts:${metricName}`;\n      const results = await this.redis.zrangebyscore(\n        timeSeriesKey,\n        start.getTime(),\n        end.getTime()\n      );\n\n      return results.map(result => {\n        try {\n          const data = JSON.parse(result);\n          return data.value || 0;\n        } catch {\n          return 0;\n        }\n      });\n    } catch (error) {\n      typedLogger.error('Get metric values error', { error: (error as any).message, metricName, start, end });\n      return [];\n    }\n  }\n\n  private static async getAverageMetric(metricName: string, timeRange: { start: Date; end: Date }): Promise<number> {\n    try {\n      const values = await this.getMetricValues(metricName, timeRange.start, timeRange.end);\n      return values.length > 0 ? values.reduce((a, b) => a + b, 0) / values.length : 0;\n    } catch (error) {\n      typedLogger.error('Get average metric error', { error: (error as any).message, metricName, timeRange });\n      return 0;\n    }\n  }\n\n  private static async getMetricCount(metricName: string, start: Date, end: Date): Promise<number> {\n    try {\n      const values = await this.getMetricValues(metricName, start, end);\n      return values.length;\n    } catch (error) {\n      typedLogger.error('Get metric count error', { error: (error as any).message, metricName, start, end });\n      return 0;\n    }\n  }\n\n  private static async getMetricSum(metricName: string, start: Date, end: Date): Promise<number> {\n    try {\n      const values = await this.getMetricValues(metricName, start, end);\n      return values.reduce((a, b) => a + b, 0);\n    } catch (error) {\n      typedLogger.error('Get metric sum error', { error: (error as any).message, metricName, start, end });\n      return 0;\n    }\n  }\n\n  private static async getCrashRate(timeRange: { start: Date; end: Date }): Promise<number> {\n    try {\n      const crashes = await this.getMetricSum('game.crashes', timeRange.start, timeRange.end);\n      const sessions = await this.getMetricCount('game.session.duration', timeRange.start, timeRange.end);\n      return sessions > 0 ? (crashes / sessions) * 100 : 0;\n    } catch (error) {\n      typedLogger.error('Get crash rate error', { error: (error as any).message, timeRange });\n      return 0;\n    }\n  }\n\n  private static async getUserEngagementMetrics(timeRange: { start: Date; end: Date }): Promise<any> {\n    try {\n      // This would calculate user engagement based on session data\n      return {\n        averageSessionsPerUser: 0,\n        averageTimePerSession: 0,\n        retentionRate: 0,\n      };\n    } catch (error) {\n      typedLogger.error('Get user engagement metrics error', { error: (error as any).message, timeRange });\n      return {};\n    }\n  }\n\n  private static async getMetricsSummary(timeRange: { start: Date; end: Date }): Promise<any> {\n    try {\n      return {\n        totalEvents: await this.getTotalEventCount(timeRange),\n        uniqueUsers: await this.getUniqueUserCount(timeRange.start, timeRange.end),\n        averageSessionDuration: await this.getAverageMetric('game.session.duration', timeRange),\n        totalErrors: await this.getMetricSum('api.request.errors', timeRange.start, timeRange.end),\n      };\n    } catch (error) {\n      typedLogger.error('Get metrics summary error', { error: (error as any).message, timeRange });\n      return {};\n    }\n  }\n\n  private static async getMetricsTrends(timeRange: { start: Date; end: Date }): Promise<any> {\n    try {\n      // Calculate trends over the time period\n      return {\n        userGrowth: 0,\n        engagementTrend: 0,\n        performanceTrend: 0,\n        errorTrend: 0,\n      };\n    } catch (error) {\n      typedLogger.error('Get metrics trends error', { error: (error as any).message, timeRange });\n      return {};\n    }\n  }\n\n  private static async getMetricsAlerts(timeRange: { start: Date; end: Date }): Promise<any[]> {\n    try {\n      const alerts = [];\n\n      // Check for high error rates\n      const errorRate = await this.getAPIMetrics(timeRange.start, timeRange.end);\n      if (errorRate.errorRate > 5) {\n        alerts.push({\n          type: 'error_rate',\n          severity: 'high',\n          message: `Error rate is ${errorRate.errorRate.toFixed(2)}% (threshold: 5%)`,\n        });\n      }\n\n      // Check for low frame rates\n      const avgFrameRate = await this.getAverageMetric('game.performance.fps', timeRange);\n      if (avgFrameRate < 30) {\n        alerts.push({\n          type: 'performance',\n          severity: 'medium',\n          message: `Average frame rate is ${avgFrameRate.toFixed(1)} FPS (threshold: 30 FPS)`,\n        });\n      }\n\n      return alerts;\n    } catch (error) {\n      typedLogger.error('Get metrics alerts error', { error: (error as any).message, timeRange });\n      return [];\n    }\n  }\n\n  private static async getMetricsRecommendations(timeRange: { start: Date; end: Date }): Promise<any[]> {\n    try {\n      const recommendations = [];\n\n      // Analyze metrics and provide recommendations\n      const crashRate = await this.getCrashRate(timeRange);\n      if (crashRate > 1) {\n        recommendations.push({\n          type: 'stability',\n          priority: 'high',\n          message: 'High crash rate detected. Consider implementing additional error handling and testing.',\n        });\n      }\n\n      return recommendations;\n    } catch (error) {\n      typedLogger.error('Get metrics recommendations error', { error: (error as any).message, timeRange });\n      return [];\n    }\n  }\n\n  private static async sendToExternalSystems(metrics: MetricEvent[]): Promise<void> {\n    try {\n      // Send metrics to external monitoring systems\n      // This would integrate with Prometheus, DataDog, etc.\n      typedLogger.debug('Metrics sent to external systems', { count: metrics.length });\n    } catch (error) {\n      typedLogger.error('Send to external systems error', { error: (error as any).message });\n    }\n  }\n\n  private static async getTotalEventCount(timeRange: { start: Date; end: Date }): Promise<number> {\n    try {\n      if (this.hasRedis()) {\n        let cursor = '0';\n        let total = 0;\n        const start = timeRange.start.getTime();\n        const end = timeRange.end.getTime();\n\n        do {\n          const [nextCursor, keys] = await (this.redis as any).scan(\n            cursor,\n            'MATCH',\n            'ts:*',\n            'COUNT',\n            '100'\n          );\n          cursor = nextCursor;\n          if (keys.length > 0) {\n            const counts = await Promise.all(\n              keys.map((key: string) => (this.redis as any).zcount(key, start, end))\n            );\n            total += counts.reduce((sum: number, count: number) => sum + Number(count || 0), 0);\n          }\n        } while (cursor !== '0');\n\n        return total;\n      }\n\n      const [claims, redemptions, sessions, users] = await Promise.all([\n        Claim.countDocuments({ claimedAt: { $gte: timeRange.start, $lte: timeRange.end } }),\n        Redemption.countDocuments({\n          $or: [\n            { redeemedAt: { $gte: timeRange.start, $lte: timeRange.end } },\n            { createdAt: { $gte: timeRange.start, $lte: timeRange.end } },\n          ],\n        }),\n        Session.countDocuments({\n          $or: [\n            { startTime: { $gte: timeRange.start, $lte: timeRange.end } },\n            { endTime: { $gte: timeRange.start, $lte: timeRange.end } },\n            { createdAt: { $gte: timeRange.start, $lte: timeRange.end } },\n          ],\n        }),\n        User.countDocuments({ createdAt: { $gte: timeRange.start, $lte: timeRange.end } }),\n      ]);\n\n      return claims + redemptions + sessions + users;\n    } catch (error) {\n      typedLogger.error('Get total event count error', { error: (error as any).message, timeRange });\n      return 0;\n    }\n  }\n\n  private static async getUniqueUserCount(start: Date, end: Date): Promise<number> {\n    try {\n      return await User.countDocuments({ lastActive: { $gte: start, $lte: end } });\n    } catch (error) {\n      typedLogger.error('Get unique user count error', { error: (error as any).message, start, end });\n      return 0;\n    }\n  }\n\n  private static async getNewUserCount(start: Date, end: Date): Promise<number> {\n    try {\n      return await User.countDocuments({ createdAt: { $gte: start, $lte: end } });\n    } catch (error) {\n      typedLogger.error('Get new user count error', { error: (error as any).message, start, end });\n      return 0;\n    }\n  }\n\n  private static async calculateRetentionRate(start: Date, end: Date): Promise<number> {\n    try {\n      const windowMs = end.getTime() - start.getTime();\n      if (windowMs <= 0) return 0;\n\n      const prevStart = new Date(start.getTime() - windowMs);\n      const prevEnd = start;\n\n      const cohortTotal = await User.countDocuments({\n        createdAt: { $gte: prevStart, $lt: prevEnd },\n      });\n\n      if (cohortTotal === 0) {\n        return 0;\n      }\n\n      const retained = await User.countDocuments({\n        createdAt: { $gte: prevStart, $lt: prevEnd },\n        lastActive: { $gte: start, $lte: end },\n      });\n\n      return Math.round((retained / cohortTotal) * 10000) / 100;\n    } catch (error) {\n      typedLogger.error('Calculate retention rate error', { error: (error as any).message, start, end });\n      return 0;\n    }\n  }\n}\n\nexport default MetricsService;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\services\\notification-service.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":27,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[865,868],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[865,868],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":180,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":180,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6154,6157],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6154,6157],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":192,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":192,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6518,6521],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6518,6521],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":193,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":193,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6628,6631],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6628,6631],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":197,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":197,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6767,6770],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6767,6770],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":198,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":198,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6822,6825],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6822,6825],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":199,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":199,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6881,6884],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6881,6884],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":200,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":200,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6947,6950],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6947,6950],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":201,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":201,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7003,7006],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7003,7006],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":205,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":205,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7124,7127],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7124,7127],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":206,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":206,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7167,7170],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7167,7170],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":207,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":207,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7212,7215],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7212,7215],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":208,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":208,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7258,7261],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7258,7261],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":221,"column":84,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":221,"endColumn":87,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7679,7682],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7679,7682],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":271,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":271,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9157,9160],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9157,9160],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":292,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":292,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9926,9929],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9926,9929],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":298,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":298,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10042,10045],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10042,10045],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":300,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":300,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10129,10132],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10129,10132],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":348,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":348,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11737,11740],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11737,11740],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":355,"column":78,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":355,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11931,11934],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11931,11934],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":377,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":377,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12430,12433],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12430,12433],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":422,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":422,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14031,14034],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14031,14034],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":442,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":442,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14763,14766],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14763,14766],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":453,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":453,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15062,15065],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15062,15065],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":481,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":481,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15865,15868],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15865,15868],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":513,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":513,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16879,16882],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16879,16882],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":528,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":528,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17312,17315],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17312,17315],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":548,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":548,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17837,17840],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17837,17840],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":560,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":560,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18262,18265],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18262,18265],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":614,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":614,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19758,19761],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19758,19761],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":657,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":657,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20897,20900],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20897,20900],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":669,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":669,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21183,21186],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21183,21186],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":724,"column":80,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":724,"endColumn":83,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22976,22979],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22976,22979],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":807,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":807,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25133,25136],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25133,25136],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":841,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":841,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25871,25874],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25871,25874],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":854,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":854,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26225,26228],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26225,26228],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":862,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":862,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26402,26405],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26402,26405],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":869,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":869,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26647,26650],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26647,26650],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":897,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":897,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[27424,27427],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[27424,27427],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":927,"column":83,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":927,"endColumn":86,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28267,28270],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28267,28270],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":40,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Types } from 'mongoose';\nimport { Notification } from '@/models/Notification';\nimport { UserNotification } from '@/models/UserNotification';\nimport { User } from '@/models/User';\nimport { PushNotificationService } from './push-notifications';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { NotificationType, NotificationTargetType, NotificationStatus } from '@/types';\nimport { z } from 'zod';\n\n// Input validation schemas\ntype SendNotificationPayload = {\n  createdBy: string;\n  title: string;\n  message: string;\n  type: NotificationType;\n  targetType: NotificationTargetType;\n  targetValue?: string;\n  priority?: number;\n  expiresAt?: string;\n  scheduledFor?: string;\n  deliveryMethod?: 'push' | 'email' | 'inapp' | 'all';\n  channelPreferences?: {\n    push?: boolean;\n    email?: boolean;\n    inApp?: boolean;\n  };\n  metadata?: Record<string, any>;\n};\n\nconst sendNotificationSchema = z.object({\n  createdBy: z.string().regex(/^[0-9a-fA-F]{24}$/),\n  title: z.string().min(1).max(100),\n  message: z.string().min(1).max(500),\n  type: z.nativeEnum(NotificationType),\n  targetType: z.nativeEnum(NotificationTargetType),\n  targetValue: z.string().optional(),\n  priority: z.number().int().min(1).max(5).optional(),\n  expiresAt: z.string().datetime().optional(),\n  scheduledFor: z.string().datetime().optional(),\n  deliveryMethod: z.enum(['push', 'email', 'inapp', 'all']).default('all'),\n  channelPreferences: z.object({\n    push: z.boolean().optional(),\n    email: z.boolean().optional(),\n    inApp: z.boolean().optional()\n  }).optional(),\n  metadata: z.record(z.any()).optional()\n});\n\nconst getUserNotificationsSchema = z.object({\n  userId: z.string().regex(/^[0-9a-fA-F]{24}$/),\n  page: z.number().min(1).default(1),\n  limit: z.number().min(1).max(100).default(20),\n  unreadOnly: z.boolean().default(false),\n  type: z.nativeEnum(NotificationType).optional(),\n});\n\nconst markAsReadSchema = z.object({\n  userId: z.string().regex(/^[0-9a-fA-F]{24}$/),\n  notificationIds: z.array(z.string().regex(/^[0-9a-fA-F]{24}$/)).optional(),\n  all: z.boolean().optional()\n});\n\ntype TargetingInput = Pick<\n  SendNotificationPayload,\n  'targetType' | 'targetValue' | 'deliveryMethod' | 'channelPreferences' | 'type'\n>;\n\ntype TargetUser = {\n  _id: Types.ObjectId;\n  preferences?: {\n    notifications?: {\n      push?: boolean;\n      email?: boolean;\n      sms?: boolean;\n      inApp?: boolean;\n      types?: Record<string, boolean>;\n    };\n  };\n};\n\ntype ResolvedPreferences = {\n  push: boolean;\n  email: boolean;\n  sms: boolean;\n  inApp: boolean;\n  types: Record<string, boolean>;\n};\n\ntype DeliveryTarget = {\n  userId: string;\n  sendPush: boolean;\n  markDelivered: boolean;\n};\n\n/**\n * Unified Notification Service\n * Handles all notification-related operations including global notifications,\n * user-specific notifications, and cross-platform delivery\n */\nexport class UnifiedNotificationService {\n  /**\n   * Send a notification to targeted users\n   */\n  static async sendNotification(input: SendNotificationPayload) {\n    try {\n      // Validate input\n      const validatedData = sendNotificationSchema.parse(input) as SendNotificationPayload;\n      const createdBy = new Types.ObjectId(validatedData.createdBy);\n      const scheduledFor = validatedData.scheduledFor ? new Date(validatedData.scheduledFor) : undefined;\n      const isScheduled = scheduledFor ? scheduledFor.getTime() > Date.now() : false;\n      const deliveryMethod = (() => {\n        const requested = validatedData.deliveryMethod || 'all';\n        if (requested !== 'all') return requested;\n        if (validatedData.type === NotificationType.IN_APP) return 'inapp';\n        if (validatedData.type === NotificationType.PUSH || validatedData.type === NotificationType.EMAIL) {\n          return validatedData.type;\n        }\n        return 'all';\n      })();\n\n      // Create global notification record\n      const globalNotification = await Notification.create({\n        title: validatedData.title,\n        message: validatedData.message,\n        type: validatedData.type,\n        targetType: validatedData.targetType,\n        targetValue: validatedData.targetValue,\n        status: isScheduled ? NotificationStatus.SCHEDULED : NotificationStatus.SENT,\n        priority: validatedData.priority || 3, // Use numerical value instead of enum\n        expiresAt: validatedData.expiresAt ? new Date(validatedData.expiresAt) : undefined,\n        scheduledFor: isScheduled ? scheduledFor : undefined,\n        sentAt: isScheduled ? undefined : new Date(),\n        deliveryMethod,\n        channelPreferences: validatedData.channelPreferences,\n        metadata: validatedData.metadata,\n        createdBy,\n      });\n\n      // Get target users based on targetType\n      const targetUsers = await this.getTargetUsers(validatedData);\n      const targetCount = targetUsers.length;\n\n      // Update global notification statistics\n      await Notification.findByIdAndUpdate(globalNotification._id, {\n        $set: {\n          'statistics.totalTargets': targetCount,\n        }\n      });\n\n      if (!isScheduled) {\n        await this.dispatchNotification(globalNotification, targetUsers, {\n          title: validatedData.title,\n          body: validatedData.message,\n          data: validatedData.metadata,\n          type: validatedData.type,\n        });\n      }\n\n      typedLogger.info(isScheduled ? 'Notification scheduled' : 'Notification created and queued', {\n        notificationId: globalNotification._id,\n        targetType: validatedData.targetType,\n        targetCount,\n        scheduledFor: isScheduled ? scheduledFor?.toISOString() : undefined,\n        title: validatedData.title,\n      });\n\n      return {\n        success: true,\n        notificationId: globalNotification._id,\n        targetCount,\n        message: isScheduled\n          ? `Notification scheduled for ${targetCount} users`\n          : `Notification queued for ${targetCount} users`,\n      };\n\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        throw new Error(`VALIDATION_ERROR: ${error.errors.map(e => e.message).join(', ')}`);\n      }\n      typedLogger.error('Send notification error', { error: (error as any).message, input });\n      throw error;\n    }\n  }\n\n  static async processScheduledNotification(notificationId: string): Promise<{ success: boolean; targetCount?: number }> {\n    try {\n      const notification = await Notification.findById(notificationId).lean();\n      if (!notification) {\n        return { success: false };\n      }\n\n      if ((notification as any).status !== NotificationStatus.SCHEDULED) {\n        return { success: true, targetCount: (notification as any)?.statistics?.totalTargets || 0 };\n      }\n\n      const targetUsers = await this.getTargetUsers({\n        targetType: (notification as any).targetType,\n        targetValue: (notification as any).targetValue,\n        deliveryMethod: (notification as any).deliveryMethod,\n        channelPreferences: (notification as any).channelPreferences,\n        type: (notification as any).type,\n      });\n\n      await this.dispatchNotification(notification, targetUsers, {\n        title: (notification as any).title,\n        body: (notification as any).message,\n        data: (notification as any).metadata,\n        type: (notification as any).type,\n      });\n\n      await Notification.findByIdAndUpdate(notificationId, {\n        $set: {\n          status: NotificationStatus.SENT,\n          sentAt: new Date(),\n          'statistics.totalTargets': targetUsers.length,\n        },\n      });\n\n      return { success: true, targetCount: targetUsers.length };\n    } catch (error) {\n      typedLogger.error('Process scheduled notification error', { error: (error as any).message, notificationId });\n      return { success: false };\n    }\n  }\n\n  /**\n   * Get targeted users based on notification type\n   */\n  private static async getTargetUsers(data: TargetingInput): Promise<TargetUser[]> {\n    try {\n      let users: TargetUser[] = [];\n\n      switch (data.targetType) {\n        case 'all':\n          users = await User.find({ isBanned: false })\n            .select('_id preferences.notifications')\n            .lean();\n          break;\n\n        case 'city':\n          if (data.targetValue) {\n            users = await User.find({\n              'location.city': data.targetValue,\n              isBanned: false\n            })\n              .select('_id preferences.notifications')\n              .lean();\n          }\n          break;\n\n        case 'level':\n          if (data.targetValue) {\n            users = await User.find({\n              level: data.targetValue,\n              isBanned: false\n            })\n              .select('_id preferences.notifications')\n              .lean();\n          }\n          break;\n\n        case 'user':\n          if (data.targetValue) {\n            // Validate that targetValue is a valid ObjectId\n            if (!Types.ObjectId.isValid(data.targetValue)) {\n              throw new Error('INVALID_USER_ID');\n            }\n            const user = await User.findById(data.targetValue)\n              .select('_id preferences.notifications isBanned')\n              .lean();\n            if (user && !(user as any).isBanned) {\n              users = [user as TargetUser];\n            }\n          }\n          break;\n\n        default:\n          users = [];\n      }\n\n      const allowedChannels = this.getAllowedChannels(data.deliveryMethod);\n      const filtered = users.filter(user => {\n        const resolved = this.resolvePreferences(user.preferences?.notifications, data.channelPreferences);\n        const typeKey = (data.type || '').toString();\n        const typeAllowed = !typeKey || resolved.types?.[typeKey] !== false;\n        if (!typeAllowed) return false;\n        return allowedChannels.some(channel => this.isChannelEnabled(channel, resolved));\n      });\n\n      return filtered;\n    } catch (error) {\n      typedLogger.error('Get target users error', { error: (error as any).message, data });\n      throw error;\n    }\n  }\n\n  private static async dispatchNotification(\n    notification: any,\n    targetUsers: TargetUser[],\n    payload: { title: string; body: string; data?: any; type?: string }\n  ): Promise<void> {\n    const deliveries: DeliveryTarget[] = [];\n    const deliveryMethod = notification.deliveryMethod || 'all';\n    const allowedChannels = this.getAllowedChannels(deliveryMethod);\n\n    const userNotificationOps = targetUsers.map(async (user) => {\n      const resolved = this.resolvePreferences(\n        user.preferences?.notifications,\n        notification.channelPreferences\n      );\n      const primaryChannel = this.resolvePrimaryChannel(allowedChannels, resolved);\n      const sendPush = allowedChannels.includes('push') && resolved.push !== false;\n      const markDelivered = allowedChannels.includes('inApp') && resolved.inApp !== false;\n\n      deliveries.push({\n        userId: user._id.toString(),\n        sendPush,\n        markDelivered,\n      });\n\n      await UserNotification.updateOne(\n        {\n          userId: new Types.ObjectId(user._id),\n          notificationId: new Types.ObjectId(notification._id),\n        },\n        {\n          $set: {\n            status: 'sent',\n            isRead: false,\n            isDelivered: false,\n            isArchived: false,\n            channel: primaryChannel,\n            preferencesApplied: {\n              push: resolved.push,\n              email: resolved.email,\n              inApp: resolved.inApp,\n            },\n          },\n        },\n        { upsert: true }\n      );\n    });\n\n    await Promise.all(userNotificationOps);\n\n    this.initiateDelivery(notification._id.toString(), deliveries, payload).catch(error => {\n      typedLogger.error('Async notification delivery failed', { \n        error: (error as any).message, \n        notificationId: notification._id \n      });\n    });\n  }\n\n  private static resolvePreferences(\n    raw: TargetUser['preferences'] extends { notifications?: infer N } ? N : any,\n    overrides?: { push?: boolean; email?: boolean; inApp?: boolean }\n  ): ResolvedPreferences {\n    const defaults = {\n      push: true,\n      email: false,\n      sms: false,\n      inApp: true,\n      types: {},\n    } as ResolvedPreferences;\n\n    const base = typeof raw === 'boolean'\n      ? {\n          push: raw,\n          email: raw,\n          sms: raw,\n          inApp: raw,\n          types: {},\n        }\n      : {\n          ...defaults,\n          ...(raw || {}),\n          types: (raw as any)?.types || {},\n        };\n\n    return {\n      push: overrides?.push ?? base.push,\n      email: overrides?.email ?? base.email,\n      sms: base.sms,\n      inApp: overrides?.inApp ?? base.inApp,\n      types: base.types || {},\n    };\n  }\n\n  private static getAllowedChannels(\n    deliveryMethod?: string\n  ): Array<'push' | 'email' | 'sms' | 'inApp'> {\n    const method = deliveryMethod || 'all';\n    if (method === 'all') return ['push', 'email', 'inApp'];\n    if (method === 'inapp') return ['inApp'];\n    if (method === 'push' || method === 'email' || method === 'sms') return [method];\n    return ['push'];\n  }\n\n  private static isChannelEnabled(channel: 'push' | 'email' | 'sms' | 'inApp', prefs: ResolvedPreferences): boolean {\n    if (channel === 'push') return prefs.push !== false;\n    if (channel === 'email') return prefs.email !== false;\n    if (channel === 'sms') return prefs.sms !== false;\n    return prefs.inApp !== false;\n  }\n\n  private static resolvePrimaryChannel(\n    allowedChannels: Array<'push' | 'email' | 'sms' | 'inApp'>,\n    prefs: ResolvedPreferences\n  ): 'push' | 'email' | 'inapp' {\n    if (allowedChannels.includes('inApp') && prefs.inApp !== false) return 'inapp';\n    if (allowedChannels.includes('push') && prefs.push !== false) return 'push';\n    if (allowedChannels.includes('email') && prefs.email !== false) return 'email';\n    return 'push';\n  }\n\n  /**\n   * Initiate async delivery of notifications\n   */\n  private static async initiateDelivery(\n    notificationId: string, \n    deliveries: DeliveryTarget[], \n    payload: { title: string; body: string; data?: any; type?: string }\n  ) {\n    try {\n      // Process delivery in batches to avoid overwhelming the system\n      const batchSize = 100;\n      for (let i = 0; i < deliveries.length; i += batchSize) {\n        const batch = deliveries.slice(i, i + batchSize);\n        \n        // Send to each user in the batch\n        await Promise.allSettled(batch.map(delivery => \n          this.deliverToUser(notificationId, delivery, payload)\n        ));\n      }\n\n      typedLogger.info('Notification delivery initiated', {\n        notificationId,\n        totalUsers: deliveries.length,\n        batches: Math.ceil(deliveries.length / batchSize)\n      });\n    } catch (error) {\n      typedLogger.error('Initiate delivery error', { error: (error as any).message, notificationId, userIdCount: deliveries.length });\n      throw error;\n    }\n  }\n\n  /**\n   * Deliver notification to a specific user\n   */\n  private static async deliverToUser(\n    notificationId: string,\n    delivery: DeliveryTarget,\n    payload: { title: string; body: string; data?: any; type?: string }\n  ): Promise<void> {\n    try {\n      if (!delivery.sendPush) {\n        if (delivery.markDelivered) {\n          await UserNotification.findOneAndUpdate(\n            { \n              notificationId: new Types.ObjectId(notificationId),\n              userId: new Types.ObjectId(delivery.userId) \n            },\n            {\n              $set: {\n                status: 'delivered',\n                isDelivered: true,\n                deliveredAt: new Date()\n              }\n            }\n          );\n        }\n        return;\n      }\n\n      // Send via appropriate channel\n      const result = await PushNotificationService.sendToUser(delivery.userId, {\n        title: payload.title,\n        body: payload.body,\n        data: payload.data || {},\n        type: payload.type\n      } as any);\n\n      const success = result.some(item => item.success);\n\n      // Update delivery status based on result\n      await UserNotification.findOneAndUpdate(\n        { \n          notificationId: new Types.ObjectId(notificationId),\n          userId: new Types.ObjectId(delivery.userId) \n        },\n        {\n          $set: {\n            status: success ? 'delivered' : 'sent',\n            isDelivered: success,\n            deliveredAt: success ? new Date() : undefined,\n            deliveryToken: result.find(item => item.success)?.messageId,\n            ...(success ? {} : { errorReason: result[0]?.error })\n          }\n        }\n      );\n\n      typedLogger.info('Notification delivered to user', {\n        notificationId,\n        userId: delivery.userId,\n        deliveryResult: result.map(r => ({ \n          deviceId: r.deviceId, \n          success: r.success, \n          error: r.error \n        }))\n      });\n    } catch (error) {\n      typedLogger.error('Deliver to user error', { \n        error: (error as any).message, \n        notificationId, \n        userId: delivery.userId \n      });\n      \n      // Update with error status\n      await UserNotification.findOneAndUpdate(\n        { \n          notificationId: new Types.ObjectId(notificationId),\n          userId: new Types.ObjectId(delivery.userId) \n        },\n        {\n          $set: {\n            status: 'sent',\n            isDelivered: false,\n            errorReason: (error as any).message\n          }\n        }\n      );\n    }\n  }\n\n  /**\n   * Get user-specific notifications\n   */\n  static async getUserNotifications(input: z.infer<typeof getUserNotificationsSchema>) {\n    try {\n      const validatedData = getUserNotificationsSchema.parse(input);\n      \n      const userId = new Types.ObjectId(validatedData.userId);\n      const page = validatedData.page;\n      const limit = validatedData.limit;\n      const skip = (page - 1) * limit;\n\n      // Build query for user notifications\n      const query: any = { userId, 'preferencesApplied.inApp': { $ne: false } };\n      \n      if (validatedData.unreadOnly) {\n        query.isRead = false;\n      }\n      \n      if (validatedData.type) {\n        // This would require a more complex query to match the type in the related Notification document\n        // For now, we'll handle this in the aggregate lookup stage\n      }\n\n      // Build aggregation pipeline\n      const pipeline: any[] = [\n        { $match: query },\n        {\n          $lookup: {\n            from: 'notifications',\n            localField: 'notificationId',\n            foreignField: '_id',\n            as: 'globalNotification'\n          }\n        },\n        { $unwind: '$globalNotification' },\n      ];\n\n      // Add type filter if specified\n      if (validatedData.type) {\n        pipeline.push({\n          $match: {\n            'globalNotification.type': validatedData.type\n          }\n        });\n      }\n\n      pipeline.push(\n        {\n          $project: {\n            id: '$_id',\n            userId: 1,\n            notificationId: 1,\n            title: '$globalNotification.title',\n            message: '$globalNotification.message',\n            type: '$globalNotification.type',\n            isRead: 1,\n            isDelivered: 1,\n            isArchived: 1,\n            deliveredAt: 1,\n            readAt: 1,\n            archivedAt: 1,\n            status: 1,\n            createdAt: 1,\n            // Include global notification metadata\n            metadata: '$globalNotification.metadata',\n            priority: '$globalNotification.priority',\n            expiresAt: '$globalNotification.expiresAt'\n          }\n        },\n        { $sort: { createdAt: -1 } },\n        { $skip: skip },\n        { $limit: limit }\n      );\n\n      // Execute aggregation\n      const results = await UserNotification.aggregate(pipeline);\n\n      // Count total for pagination (apply same filters)\n      const countPipeline: any[] = [\n        { $match: query },\n        {\n          $lookup: {\n            from: 'notifications',\n            localField: 'notificationId',\n            foreignField: '_id',\n            as: 'globalNotification'\n          }\n        },\n        { $unwind: '$globalNotification' },\n      ];\n\n      if (validatedData.type) {\n        countPipeline.push({\n          $match: {\n            'globalNotification.type': validatedData.type\n          }\n        });\n      }\n\n      countPipeline.push({\n        $count: 'total'\n      });\n\n      const countResult = await UserNotification.aggregate(countPipeline);\n      const total = countResult[0]?.total || 0;\n\n      return {\n        notifications: results,\n        pagination: {\n          page,\n          limit,\n          total,\n          pages: Math.ceil(total / limit),\n          hasNext: skip + limit < total,\n          hasPrev: page > 1\n        }\n      };\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        throw new Error(`VALIDATION_ERROR: ${error.errors.map(e => e.message).join(', ')}`);\n      }\n      typedLogger.error('Get user notifications error', { error: (error as any).message, input });\n      throw error;\n    }\n  }\n\n  /**\n   * Mark notifications as read for a user\n   */\n  static async markNotificationsAsRead(input: z.infer<typeof markAsReadSchema>) {\n    try {\n      const validatedData = markAsReadSchema.parse(input);\n\n      const updateQuery: any = {\n        userId: new Types.ObjectId(validatedData.userId)\n      };\n\n      if (validatedData.all) {\n        // Mark all as read\n        updateQuery.isRead = false;\n      } else if (validatedData.notificationIds && validatedData.notificationIds.length > 0) {\n        // Mark specific notifications as read\n        updateQuery._id = {\n          $in: validatedData.notificationIds.map(id => new Types.ObjectId(id))\n        };\n      } else {\n        throw new Error('Either \"all\" or \"notificationIds\" must be provided');\n      }\n\n      const result = await UserNotification.updateMany(\n        updateQuery,\n        {\n          $set: {\n            isRead: true,\n            readAt: new Date(),\n            status: 'opened'\n          }\n        }\n      );\n\n      // Update global notification statistics if needed\n      if (validatedData.notificationIds && validatedData.notificationIds.length > 0) {\n        // Update statistics for each notification\n        for (const notificationId of validatedData.notificationIds) {\n          await Notification.findByIdAndUpdate(\n            new Types.ObjectId(notificationId),\n            {\n              $inc: { 'statistics.openedCount': 1 }\n            }\n          );\n        }\n      }\n\n      typedLogger.info('Notifications marked as read', {\n        userId: validatedData.userId,\n        count: result.modifiedCount,\n        all: validatedData.all,\n        notificationIds: validatedData.notificationIds\n      });\n\n      return {\n        success: true,\n        modifiedCount: result.modifiedCount\n      };\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        throw new Error(`VALIDATION_ERROR: ${error.errors.map(e => e.message).join(', ')}`);\n      }\n      typedLogger.error('Mark notifications as read error', { error: (error as any).message, input });\n      throw error;\n    }\n  }\n\n  /**\n   * Get notification statistics for admin panel\n   */\n  static async getNotificationStats() {\n    try {\n      // Get global notification statistics\n      const globalStats = await Notification.aggregate([\n        {\n          $group: {\n            _id: null,\n            totalNotifications: { $sum: 1 },\n            totalDelivered: { $sum: '$statistics.deliveredCount' },\n            totalOpened: { $sum: '$statistics.openedCount' },\n            byStatus: {\n              $push: {\n                status: '$status',\n                count: 1\n              }\n            },\n            byType: {\n              $push: {\n                type: '$type',\n                count: 1\n              }\n            },\n            byChannel: {\n              $push: {\n                channel: '$deliveryMethod',\n                count: 1\n              }\n            }\n          }\n        }\n      ]);\n\n      // Get user engagement statistics\n      const userEngagement = await UserNotification.aggregate([\n        {\n          $group: {\n            _id: null,\n            totalUserNotifications: { $sum: 1 },\n            totalRead: { \n              $sum: { \n                $cond: ['$isRead', 1, 0] \n              } \n            },\n            totalDelivered: {\n              $sum: {\n                $cond: ['$isDelivered', 1, 0]\n              }\n            }\n          }\n        }\n      ]);\n\n      // Calculate open rate\n      const openRate = globalStats[0]?.totalDelivered > 0 \n        ? (globalStats[0]?.totalOpened / globalStats[0]?.totalDelivered) * 100 \n        : 0;\n\n      return {\n        global: globalStats[0] || {\n          totalNotifications: 0,\n          totalDelivered: 0,\n          totalOpened: 0,\n          byStatus: [],\n          byType: [],\n          byChannel: []\n        },\n        engagement: userEngagement[0] || {\n          totalUserNotifications: 0,\n          totalRead: 0,\n          totalDelivered: 0\n        },\n        openRate: openRate,\n        timestamp: new Date().toISOString()\n      };\n    } catch (error) {\n      typedLogger.error('Get notification stats error', { error: (error as any).message });\n      throw error;\n    }\n  }\n\n  /**\n   * Get user's notification preferences\n   */\n  static async getUserPreferences(userId: string) {\n    try {\n      if (!Types.ObjectId.isValid(userId)) {\n        throw new Error('INVALID_USER_ID');\n      }\n\n      const user = await User.findById(userId).select('preferences.notifications').lean();\n      \n      if (!user) {\n        throw new Error('USER_NOT_FOUND');\n      }\n\n      const defaults = {\n        push: true,\n        email: false,\n        inApp: true,\n        sms: false,\n        types: {\n          system: true,\n          promotional: false,\n          social: true,\n          achievement: true,\n          challenge: true,\n        },\n      };\n\n      const prefs = (user as any)?.preferences?.notifications;\n      if (typeof prefs === 'boolean') {\n        return {\n          ...defaults,\n          push: prefs,\n          email: prefs,\n          sms: prefs,\n          inApp: prefs,\n        };\n      }\n\n      return prefs || defaults;\n    } catch (error) {\n      typedLogger.error('Get user preferences error', { error: (error as any).message, userId });\n      throw error;\n    }\n  }\n\n  /**\n   * Update user's notification preferences\n   */\n  static async updateUserPreferences(userId: string, preferences: any) {\n    try {\n      if (!Types.ObjectId.isValid(userId)) {\n        throw new Error('INVALID_USER_ID');\n      }\n\n      const existing = await User.findById(userId).select('preferences.notifications').lean();\n      const current = (existing as any)?.preferences?.notifications || {};\n      const merged = {\n        ...current,\n        ...preferences,\n        types: {\n          ...(current?.types || {}),\n          ...(preferences?.types || {}),\n        },\n      };\n\n      const updatedUser = await User.findByIdAndUpdate(\n        userId,\n        { $set: { 'preferences.notifications': merged } },\n        { new: true, select: 'preferences.notifications' }\n      );\n\n      if (!updatedUser) {\n        throw new Error('USER_NOT_FOUND');\n      }\n\n      typedLogger.info('User notification preferences updated', { \n        userId, \n        preferences \n      });\n\n      return updatedUser.preferences?.notifications;\n    } catch (error) {\n      typedLogger.error('Update user preferences error', { \n        error: (error as any).message, \n        userId, \n        preferences \n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Clean up expired notifications (to be called by scheduler)\n   */\n  static async cleanupExpiredNotifications() {\n    try {\n      const now = new Date();\n      \n      // Find notifications that have expired and are no longer needed\n      const result = await Notification.deleteMany({\n        expiresAt: { $lt: now },\n        createdAt: { $lt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) } // Keep for at least 30 days\n      });\n\n      typedLogger.info('Expired notifications cleaned up', {\n        deletedCount: result.deletedCount\n      });\n\n      return {\n        success: true,\n        deletedCount: result.deletedCount\n      };\n    } catch (error) {\n      typedLogger.error('Cleanup expired notifications error', { error: (error as any).message });\n      throw error;\n    }\n  }\n}\n\nexport default UnifiedNotificationService;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\services\\partner-locations.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'typedLogger' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":21},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":62,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":62,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1857,1860],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1857,1860],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":73,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2247,2250],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2247,2250],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":99,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":99,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3190,3193],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3190,3193],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Partner, IPartnerLocation } from '@/models/Partner';\nimport { typedLogger } from '@/lib/typed-logger';\n\ntype LocationPayload = {\n  locationId?: string;\n  name?: string;\n  address?: string;\n  city?: string;\n  phone?: string;\n  isActive?: boolean;\n  features?: string[];\n  coordinates?: [number, number];\n  lat?: number;\n  lng?: number;\n};\n\nconst normalizeCoordinates = (payload: LocationPayload): [number, number] | undefined => {\n  if (Array.isArray(payload.coordinates) && payload.coordinates.length === 2) {\n    const lng = Number(payload.coordinates[0]);\n    const lat = Number(payload.coordinates[1]);\n    if (Number.isFinite(lng) && Number.isFinite(lat)) {\n      return [lng, lat];\n    }\n  }\n  if (payload.lat !== undefined && payload.lng !== undefined) {\n    const lat = Number(payload.lat);\n    const lng = Number(payload.lng);\n    if (Number.isFinite(lat) && Number.isFinite(lng)) {\n      return [lng, lat];\n    }\n  }\n  return undefined;\n};\n\nclass PartnerLocationsService {\n  static async getLocations(partnerId: string): Promise<IPartnerLocation[]> {\n    const partner = await Partner.findById(partnerId);\n    if (!partner) {\n      throw new Error('PARTNER_NOT_FOUND');\n    }\n    return partner.locations || [];\n  }\n\n  static async addLocation(partnerId: string, payload: LocationPayload): Promise<IPartnerLocation> {\n    const partner = await Partner.findById(partnerId);\n    if (!partner) {\n      throw new Error('PARTNER_NOT_FOUND');\n    }\n    const coordinates = normalizeCoordinates(payload);\n    if (!coordinates) {\n      throw new Error('COORDINATES_REQUIRED');\n    }\n\n    partner.locations.push({\n      name: payload.name || '',\n      address: payload.address || '',\n      city: payload.city || '',\n      coordinates,\n      phone: payload.phone,\n      isActive: payload.isActive ?? true,\n      features: payload.features,\n    } as any);\n\n    await partner.save();\n    return partner.locations[partner.locations.length - 1];\n  }\n\n  static async updateLocation(partnerId: string, locationId: string, payload: LocationPayload): Promise<IPartnerLocation> {\n    const partner = await Partner.findById(partnerId);\n    if (!partner) {\n      throw new Error('PARTNER_NOT_FOUND');\n    }\n    const location = (partner.locations as any).id(locationId);\n    if (!location) {\n      throw new Error('LOCATION_NOT_FOUND');\n    }\n\n    if (payload.name !== undefined) location.name = payload.name;\n    if (payload.address !== undefined) location.address = payload.address;\n    if (payload.city !== undefined) location.city = payload.city;\n    if (payload.phone !== undefined) location.phone = payload.phone;\n    if (payload.isActive !== undefined) location.isActive = payload.isActive;\n    if (payload.features !== undefined) location.features = payload.features;\n\n    const coordinates = normalizeCoordinates(payload);\n    if (coordinates) {\n      location.coordinates = coordinates;\n    }\n\n    await partner.save();\n    return location;\n  }\n\n  static async removeLocation(partnerId: string, locationId: string): Promise<void> {\n    const partner = await Partner.findById(partnerId);\n    if (!partner) {\n      throw new Error('PARTNER_NOT_FOUND');\n    }\n    (partner.locations as any).pull({ _id: locationId });\n    await partner.save();\n  }\n\n  static async upsertLocation(partnerId: string, payload: LocationPayload): Promise<IPartnerLocation> {\n    if (payload.locationId) {\n      return this.updateLocation(partnerId, payload.locationId, payload);\n    }\n    return this.addLocation(partnerId, payload);\n  }\n}\n\nexport { PartnerLocationsService };\nexport default PartnerLocationsService;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\services\\partner-marketplace-analytics.ts","messages":[{"ruleId":"prefer-const","severity":2,"message":"'commissionRate' is never reassigned. Use 'const' instead.","line":113,"column":11,"nodeType":"Identifier","messageId":"useConst","endLine":113,"endColumn":25,"fix":{"range":[3640,3718],"text":"const commissionRate = (partner as PartnerRateLean | null)?.commissionRate || 0;"}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import { Partner } from '@/models/Partner';\nimport { Reward } from '@/models/Reward';\nimport { Redemption } from '@/models/Redemption';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { Metadata, MongoQuery, RedemptionStatus } from '@/types';\nimport { Types } from 'mongoose';\n\ntype AnalyticsOptions = {\n  startDate?: Date;\n  endDate?: Date;\n};\n\ntype AnalyticsResult = {\n  itemsCount: number;\n  totalRedemptions: number;\n  pointsSpent: number;\n  commission: number;\n  commissionRate: number;\n};\n\nconst buildRedemptionDateFilter = (options: AnalyticsOptions) => {\n  if (!options.startDate && !options.endDate) return undefined;\n  const filter: Record<string, Date> = {};\n  if (options.startDate) filter.$gte = options.startDate;\n  if (options.endDate) filter.$lte = options.endDate;\n  return filter;\n};\n\ntype RewardLean = {\n  _id?: Types.ObjectId;\n  pointsCost?: number;\n  metadata?: Metadata;\n  partnerId?: Types.ObjectId;\n};\n\ntype RedemptionLean = {\n  pointsSpent?: number;\n  rewardId?: Types.ObjectId | RewardLean;\n  partnerId?: Types.ObjectId;\n  metadata?: Metadata;\n};\n\ntype PartnerRateLean = {\n  _id: Types.ObjectId;\n  commissionRate?: number;\n};\n\nconst isRewardLean = (value: Types.ObjectId | RewardLean | undefined): value is RewardLean =>\n  !!value && typeof value === 'object' && 'pointsCost' in value;\n\nconst extractPartnerId = (redemption: RedemptionLean): string | undefined => {\n  const reward = isRewardLean(redemption.rewardId) ? redemption.rewardId : undefined;\n  return reward?.partnerId?.toString?.() || redemption?.partnerId?.toString?.();\n};\n\nclass PartnerMarketplaceAnalyticsService {\n  static async getPartnerAnalytics(partnerId: string, options: AnalyticsOptions = {}): Promise<AnalyticsResult> {\n    return this.buildAnalytics({ partnerId, ...options });\n  }\n\n  static async getMarketplaceSummary(options: AnalyticsOptions = {}): Promise<AnalyticsResult> {\n    return this.buildAnalytics({ ...options });\n  }\n\n  private static async buildAnalytics({\n    partnerId,\n    startDate,\n    endDate,\n  }: { partnerId?: string } & AnalyticsOptions): Promise<AnalyticsResult> {\n    try {\n      const rewardQuery: MongoQuery = { isDeleted: { $ne: true } };\n      if (partnerId) {\n        rewardQuery.partnerId = partnerId;\n      } else {\n        rewardQuery.partnerId = { $exists: true };\n      }\n\n      const redemptionQuery: MongoQuery = {\n        'metadata.source': 'marketplace',\n        status: { $ne: RedemptionStatus.CANCELLED },\n      };\n      const rewardIds = await Reward.find(rewardQuery).distinct('_id');\n      if (rewardIds.length === 0) {\n        return {\n          itemsCount: 0,\n          totalRedemptions: 0,\n          pointsSpent: 0,\n          commission: 0,\n          commissionRate: 0,\n        };\n      }\n      redemptionQuery.rewardId = { $in: rewardIds };\n      const dateFilter = buildRedemptionDateFilter({ startDate, endDate });\n      if (dateFilter) {\n        redemptionQuery.redeemedAt = dateFilter;\n      }\n\n      const [itemsCount, redemptions, partner] = await Promise.all([\n        Reward.countDocuments(rewardQuery),\n        Redemption.find(redemptionQuery)\n          .populate('rewardId', 'pointsCost metadata partnerId')\n          .lean(),\n        partnerId ? Partner.findById(partnerId).select('commissionRate').lean() : null,\n      ]);\n\n      const typedRedemptions = redemptions as RedemptionLean[];\n      const totalRedemptions = typedRedemptions.length;\n      const pointsSpent = typedRedemptions.reduce((sum, r) => {\n        const reward = isRewardLean(r.rewardId) ? r.rewardId : undefined;\n        return sum + (r.pointsSpent || reward?.pointsCost || 0);\n      }, 0);\n\n      let commissionRate = (partner as PartnerRateLean | null)?.commissionRate || 0;\n      let partnerRateMap: Record<string, number> = {};\n\n      if (!partnerId) {\n        const partnerIds = Array.from(\n          new Set(typedRedemptions.map(extractPartnerId).filter(Boolean))\n        ) as string[];\n        if (partnerIds.length) {\n          const partners = await Partner.find({ _id: { $in: partnerIds } })\n            .select('commissionRate')\n            .lean();\n          partnerRateMap = (partners as PartnerRateLean[]).reduce((acc, p) => {\n            acc[p._id.toString()] = p.commissionRate || 0;\n            return acc;\n          }, {} as Record<string, number>);\n        }\n      }\n\n      const commission = typedRedemptions.reduce((sum, r) => {\n        const reward = isRewardLean(r.rewardId) ? r.rewardId : undefined;\n        const rewardRate = typeof reward?.metadata?.commissionRate === 'number'\n          ? reward.metadata.commissionRate\n          : undefined;\n        const partnerKey = extractPartnerId(r);\n        const fallbackRate = partnerId ? commissionRate : (partnerKey ? partnerRateMap[partnerKey] : 0);\n        const rate = rewardRate ?? fallbackRate ?? 0;\n        const pts = r.pointsSpent || reward?.pointsCost || 0;\n        return sum + pts * (rate / 100);\n      }, 0);\n\n      return {\n        itemsCount,\n        totalRedemptions,\n        pointsSpent,\n        commission,\n        commissionRate,\n      };\n    } catch (error) {\n      typedLogger.error('Partner marketplace analytics error', {\n        error: error instanceof Error ? error.message : String(error),\n        partnerId,\n      });\n      throw error;\n    }\n  }\n}\n\nexport { PartnerMarketplaceAnalyticsService };\nexport default PartnerMarketplaceAnalyticsService;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\services\\partner-stats.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":73,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2664,2667],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2664,2667],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":81,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":81,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3030,3033],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3030,3033],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Types } from 'mongoose';\nimport { Reward } from '@/models/Reward';\nimport { Redemption } from '@/models/Redemption';\nimport { RedemptionStatus } from '@/types';\nimport { typedLogger } from '@/lib/typed-logger';\n\ntype PartnerStatsResult = {\n  totals: { pending: number; fulfilled: number; cancelled: number; total: number };\n  byCategory: Array<{ category: string; count: number }>;\n  recent: Array<{\n    id: string;\n    status: string;\n    createdAt: Date;\n    reward: { id: string; name: string; category: string } | null;\n    user: { id: string; displayName: string; email: string } | null;\n  }>;\n};\n\nclass PartnerStatsService {\n  static async getPartnerStats(partnerId: string, limitRecent: number = 5): Promise<PartnerStatsResult> {\n    try {\n      if (!Types.ObjectId.isValid(partnerId)) {\n        throw new Error('INVALID_PARTNER_ID');\n      }\n\n      const rewardsForPartner = await Reward.find({ partnerId: new Types.ObjectId(partnerId) }).select('_id category');\n      const rewardIds = rewardsForPartner.map(r => r._id);\n      if (!rewardIds.length) {\n        return {\n          totals: { pending: 0, fulfilled: 0, cancelled: 0, total: 0 },\n          byCategory: [],\n          recent: [],\n        };\n      }\n\n      const [statusAgg, categoryAgg, recent] = await Promise.all([\n        Redemption.aggregate([\n          { $match: { rewardId: { $in: rewardIds } } },\n          { $group: { _id: '$status', count: { $sum: 1 } } }\n        ]),\n        Redemption.aggregate([\n          { $match: { rewardId: { $in: rewardIds } } },\n          {\n            $lookup: {\n              from: 'rewards',\n              localField: 'rewardId',\n              foreignField: '_id',\n              as: 'reward'\n            }\n          },\n          { $unwind: '$reward' },\n          { $group: { _id: '$reward.category', count: { $sum: 1 } } }\n        ]),\n        Redemption.find({ rewardId: { $in: rewardIds } })\n          .populate('rewardId', 'name category')\n          .populate('userId', 'displayName email')\n          .sort({ createdAt: -1 })\n          .limit(Math.min(Math.max(limitRecent, 1), 50))\n          .lean()\n      ]);\n\n      const totals = {\n        pending: statusAgg.find(s => s._id === RedemptionStatus.PENDING)?.count || 0,\n        fulfilled: statusAgg.find(s => s._id === RedemptionStatus.FULFILLED)?.count || 0,\n        cancelled: statusAgg.find(s => s._id === RedemptionStatus.CANCELLED)?.count || 0,\n        total: 0,\n      };\n      totals.total = totals.pending + totals.fulfilled + totals.cancelled;\n\n      return {\n        totals,\n        byCategory: categoryAgg.map(c => ({ category: c._id, count: c.count })),\n        recent: recent.map((r: any) => ({\n          id: r._id,\n          status: r.status,\n          createdAt: r.createdAt,\n          reward: r.rewardId ? { id: r.rewardId._id, name: r.rewardId.name, category: r.rewardId.category } : null,\n          user: r.userId ? { id: r.userId._id, displayName: r.userId.displayName, email: r.userId.email } : null,\n        })),\n      };\n    } catch (error: any) {\n      typedLogger.error('Partner stats error', { error: error.message, partnerId });\n      throw error;\n    }\n  }\n}\n\nexport { PartnerStatsService };\nexport default PartnerStatsService;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\services\\points-history.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\services\\progression.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Claim' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":15},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":104,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":104,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2813,2816],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2813,2816],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":113,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":113,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3100,3103],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3100,3103],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":169,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":169,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4949,4952],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4949,4952],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":245,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":245,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7086,7089],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7086,7089],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":267,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":267,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7753,7756],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7753,7756],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":267,"column":94,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":267,"endColumn":97,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7812,7815],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7812,7815],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":273,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":273,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8052,8055],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8052,8055],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":274,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":274,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8149,8152],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8149,8152],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":274,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":274,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8157,8160],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8157,8160],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":275,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":275,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8217,8220],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8217,8220],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":284,"column":95,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":284,"endColumn":98,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8565,8568],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8565,8568],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":307,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":307,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9097,9100],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9097,9100],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":327,"column":81,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":327,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9760,9763],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9760,9763],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { User } from '@/models/User';\nimport { Claim } from '@/models/Claim';\nimport { Settings } from '@/models/Settings';\nimport { redisClient } from '@/config/redis';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { UserRole } from '@/types';\n\n/**\n * Progression Service (CLEANED VERSION)\n * Ô£à Removed XP system (1-10 levels)\n * Ô£à Uses only UserLevel system (Bronze/Silver/Gold/Platinum/Diamond)\n * Core Feature: Points accumulate ÔåÆ Level increases automatically\n */\n\nexport interface ProgressionResult {\n  userId: string;\n  currentLevel: string; // 'bronze' | 'silver' | 'gold' | 'platinum' | 'diamond'\n  levelNumber: number; // 1-5\n  points: {\n    available: number;\n    total: number;\n    spent: number;\n  };\n  nextLevel: {\n    level: string;\n    requiredPoints: number;\n    progress: number; // 0-100%\n    pointsToNext: number;\n  } | null;\n  stats: {\n    totalClaims: number;\n    totalPoints: number;\n    averagePointsPerClaim: number;\n    streakDays: number;\n    favoriteCategory: string;\n  };\n}\n\nexport interface LevelUpdateResult {\n  leveledUp: boolean;\n  newLevel: string;\n  progress: number;\n  nextLevel: {\n    level: string;\n    requiredPoints: number;\n    pointsToNext: number;\n  } | null;\n}\n\nexport class ProgressionService {\n  private static redis = redisClient;\n  \n  // UserLevel thresholds\n  private static readonly DEFAULT_LEVEL_THRESHOLDS = {\n    bronze: 0,\n    silver: 1000,\n    gold: 5000,\n    platinum: 15000,\n    diamond: 50000,\n  };\n\n  // Cached settings to avoid frequent DB hits\n  private static cachedThresholds: Record<string, number> | null = null;\n  private static lastFetchedAt = 0;\n  private static readonly CACHE_TTL_MS = 60_000; // 1 minute\n\n  /**\n   * Calculate user progression based on current points\n   */\n  static async calculateProgression(userId: string): Promise<ProgressionResult> {\n    try {\n      const user = await User.findById(userId);\n      if (!user) {\n        throw new Error('USER_NOT_FOUND');\n      }\n\n      // Get user's points\n      const points = {\n        available: user.points.available || 0,\n        total: user.points.total || 0,\n        spent: user.points.spent || 0,\n      };\n      \n      // Get current level info\n      const thresholds = await this.getLevelThresholds();\n      const currentLevel = user.level || 'bronze';\n      const levelNumber = this.getLevelNumber(currentLevel);\n      \n      // Calculate next level info\n      const nextLevel = this.getNextLevelInfo(currentLevel, points.total, thresholds);\n      \n      // Get user statistics\n      const stats = await this.getUserStats(userId);\n      \n      return {\n        userId,\n        currentLevel,\n        levelNumber,\n        points,\n        nextLevel,\n        stats,\n      };\n    } catch (error) {\n      typedLogger.error('Calculate progression error', { error: (error as any).message, userId });\n      throw error;\n    }\n  }\n\n  /**\n   * Update a user's level based on total points; returns level change + progress.\n   * Accepts either a user id or a hydrated user document to avoid an extra lookup.\n   */\n  static async updateLevelForUser(userOrId: string | any): Promise<LevelUpdateResult> {\n    try {\n      const user = typeof userOrId === 'string'\n        ? await User.findById(userOrId)\n        : userOrId;\n\n      if (!user) {\n        throw new Error('USER_NOT_FOUND');\n      }\n\n      const thresholds = await this.getLevelThresholds();\n      const totalPoints = user.points?.total ?? user.points ?? 0;\n      const currentLevel = user.level || 'bronze';\n\n      // Determine next level info\n      const levels = Object.keys(thresholds);\n      const currentIndex = levels.indexOf(currentLevel);\n      const nextLevel = currentIndex >= 0 && currentIndex < levels.length - 1\n        ? levels[currentIndex + 1]\n        : null;\n\n      const nextThreshold = nextLevel ? thresholds[nextLevel] : null;\n      const currentThreshold = thresholds[currentLevel] ?? 0;\n\n      // Find highest level attainable with current points\n      let newLevel = currentLevel;\n      for (const level of levels) {\n        if (totalPoints >= thresholds[level]) {\n          newLevel = level;\n        }\n      }\n\n      // Compute progress toward the next level (if any)\n      let progress = 100;\n      let pointsToNext = 0;\n      if (nextLevel && nextThreshold !== null) {\n        const span = nextThreshold - currentThreshold || 1;\n        progress = Math.min(100, Math.round(((totalPoints - currentThreshold) / span) * 100));\n        pointsToNext = Math.max(0, nextThreshold - totalPoints);\n      }\n\n      const leveledUp = newLevel !== currentLevel;\n      if (leveledUp) {\n        user.level = newLevel;\n        await user.save();\n      }\n\n      return {\n        leveledUp,\n        newLevel,\n        progress,\n        nextLevel: nextLevel\n          ? { level: nextLevel, requiredPoints: nextThreshold!, pointsToNext }\n          : null,\n      };\n    } catch (error) {\n      typedLogger.error('Update level error', { error: (error as any).message, userId: typeof userOrId === 'string' ? userOrId : userOrId?._id });\n      throw error;\n    }\n  }\n\n  /**\n   * Get level number from level name\n   */\n  private static getLevelNumber(level: string): number {\n    const levelMap = {\n      bronze: 1,\n      silver: 2,\n      gold: 3,\n      platinum: 4,\n      diamond: 5,\n    };\n    return levelMap[level] || 1;\n  }\n\n  /**\n   * Get next level information\n   */\n  private static getNextLevelInfo(currentLevel: string, totalPoints: number, thresholds: Record<string, number>) {\n    const levels = Object.keys(thresholds);\n    const currentIndex = levels.indexOf(currentLevel);\n    \n    if (currentIndex === levels.length - 1) {\n      // Max level reached\n      return null;\n    }\n    \n    const nextLevel = levels[currentIndex + 1];\n    const currentThreshold = thresholds[currentLevel];\n    const nextThreshold = thresholds[nextLevel];\n    \n    const pointsToNext = Math.max(0, nextThreshold - totalPoints);\n    const progress = Math.min(100, Math.round(((totalPoints - currentThreshold) / (nextThreshold - currentThreshold)) * 100));\n    \n    return {\n      level: nextLevel,\n      requiredPoints: nextThreshold,\n      progress,\n      pointsToNext,\n    };\n  }\n\n  /**\n   * Get user statistics\n   */\n  private static async getUserStats(userId: string) {\n    try {\n      const user = await User.findById(userId);\n      if (!user) {\n        return {\n          totalClaims: 0,\n          totalPoints: 0,\n          averagePointsPerClaim: 0,\n          streakDays: 0,\n          favoriteCategory: 'unknown',\n        };\n      }\n\n      const totalClaims = user.stats?.prizesFound || 0;\n      const totalPoints = user.points.total || 0;\n      const averagePointsPerClaim = totalClaims > 0 ? Math.round(totalPoints / totalClaims) : 0;\n      const streakDays = user.stats?.currentStreak || 0;\n      const favoriteCategory = user.stats?.favoriteCity || 'unknown';\n\n      return {\n        totalClaims,\n        totalPoints,\n        averagePointsPerClaim,\n        streakDays,\n        favoriteCategory,\n      };\n    } catch (error) {\n      typedLogger.error('Get user stats error', { error: (error as any).message, userId });\n      return {\n        totalClaims: 0,\n        totalPoints: 0,\n        averagePointsPerClaim: 0,\n        streakDays: 0,\n        favoriteCategory: 'unknown',\n      };\n    }\n  }\n\n  /**\n   * Load level thresholds from Settings.custom.progression.levels or fallback defaults.\n   */\n  private static async getLevelThresholds(): Promise<Record<string, number>> {\n    const now = Date.now();\n    if (this.cachedThresholds && (now - this.lastFetchedAt) < this.CACHE_TTL_MS) {\n      return this.cachedThresholds;\n    }\n\n    try {\n      const settings = await Settings.findOne({}, { 'custom.progression': 1 }).lean();\n      const levels = (settings as any)?.custom?.get?.('progression')?.levels || (settings as any)?.custom?.progression?.levels;\n\n      if (Array.isArray(levels) && levels.length > 0) {\n        // Normalize into record, sorted by threshold\n        const normalized: Record<string, number> = {};\n        levels\n          .filter((lvl: any) => typeof lvl?.name === 'string' && typeof lvl?.threshold === 'number')\n          .sort((a: any, b: any) => a.threshold - b.threshold)\n          .forEach((lvl: any) => { normalized[lvl.name] = lvl.threshold; });\n\n        if (Object.keys(normalized).length > 0) {\n          this.cachedThresholds = normalized;\n          this.lastFetchedAt = now;\n          return normalized;\n        }\n      }\n    } catch (error) {\n      typedLogger.warn('Progression settings load failed, using defaults', { error: (error as any).message });\n    }\n\n    this.cachedThresholds = this.DEFAULT_LEVEL_THRESHOLDS;\n    this.lastFetchedAt = now;\n    return this.DEFAULT_LEVEL_THRESHOLDS;\n  }\n\n  /**\n   * Get user streak days\n   */\n  private static async getUserStreakDays(userId: string): Promise<number> {\n    try {\n      const user = await User.findById(userId);\n      return user?.stats?.currentStreak || 0;\n    } catch (error) {\n      return 0;\n    }\n  }\n\n  /**\n   * Get progression leaderboard\n   */\n  static async getLeaderboard(limit: number = 100): Promise<any[]> {\n    try {\n      const users = await User.find({ role: UserRole.PLAYER })\n        .select('displayName level points stats')\n        .sort({ 'points.total': -1 })\n        .limit(limit)\n        .lean();\n\n      return users.map((user, index) => {\n        return {\n          rank: index + 1,\n          userId: user._id,\n          displayName: user.displayName,\n          level: user.level,\n          levelNumber: this.getLevelNumber(user.level),\n          points: user.points.total,\n          totalClaims: user.stats?.prizesFound || 0,\n        };\n      });\n    } catch (error) {\n      typedLogger.error('Get progression leaderboard error', { error: (error as any).message, limit });\n      return [];\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\services\\proximity.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":134,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":134,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3774,3777],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3774,3777],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":208,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":208,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5772,5775],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5772,5775],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":220,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":220,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6085,6088],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6085,6088],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":277,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":277,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7808,7811],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7808,7811],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":306,"column":87,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":306,"endColumn":90,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8886,8889],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8886,8889],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'lastUpdateTimestamp' is defined but never used. Allowed unused args must match /^_/u.","line":317,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":317,"endColumn":33},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":318,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":318,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9189,9192],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9189,9192],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":360,"column":83,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":360,"endColumn":86,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10525,10528],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10525,10528],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":392,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":392,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11483,11486],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11483,11486],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":429,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":429,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12599,12602],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12599,12602],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":434,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":434,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12735,12738],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12735,12738],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":434,"column":84,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":434,"endColumn":87,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12751,12754],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12751,12754],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":448,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":448,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13234,13237],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13234,13237],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":455,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":455,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13398,13401],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13398,13401],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'userLocation' is defined but never used. Allowed unused args must match /^_/u.","line":532,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":532,"endColumn":58},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":638,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":638,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19436,19439],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19436,19439],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":661,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":661,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19981,19984],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19981,19984],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":665,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":665,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20102,20105],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20102,20105],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":684,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":684,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20700,20703],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20700,20703],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":736,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":736,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22592,22595],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22592,22595],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":758,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":758,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23291,23294],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23291,23294],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":765,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":765,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23458,23461],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23458,23461],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":782,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":782,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24031,24034],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24031,24034],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":786,"column":103,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":786,"endColumn":106,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24169,24172],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24169,24172],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":796,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":796,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24561,24564],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24561,24564],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":799,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":799,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24741,24744],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24741,24744],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":827,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":827,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25699,25702],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25699,25702],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":832,"column":81,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":832,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25832,25835],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25832,25835],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":838,"column":84,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":838,"endColumn":87,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26181,26184],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26181,26184],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":29,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { redisClient } from '@/config/redis';\nimport { Prize } from '@/models/Prize';\nimport { User } from '@/models/User';\nimport { Claim } from '@/models/Claim';\nimport { typedLogger } from '@/lib/typed-logger';\n\n/**\n * Proximity Detection Service\n * Core Feature 2: Unity proximity system (50m/20m/5m detection circles)\n * Optimized for real-time AR gameplay with progressive hint system\n */\n\nexport interface ProximityZone {\n  distance: number;\n  zone: 'hint' | 'visible' | 'catchable';\n  features: string[];\n}\n\nexport interface ProximityResult {\n  userId: string;\n  location: {\n    latitude: number;\n    longitude: number;\n    accuracy?: number;\n  };\n  zones: {\n    hint: ProximityPrize[];      // 50m zone\n    visible: ProximityPrize[];   // 20m zone  \n    catchable: ProximityPrize[]; // 5m zone\n  };\n  metadata: {\n    totalNearby: number;\n    searchRadius: number;\n    timestamp: string;\n    performanceMs: number;\n  };\n}\n\nexport interface ProximityPrize {\n  id: string;\n  title: string;\n  category: string;\n  rarity: 'common' | 'uncommon' | 'rare' | 'epic' | 'legendary';\n  points: number;\n  distance: number;\n  bearing: number; // degrees from north\n  zone: 'hint' | 'visible' | 'catchable';\n  hint?: string;\n  animation: string;\n  canCatch: boolean;\n  estimatedValue: number;\n  coordinates?: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\nexport interface HintConfig {\n  distance: number;\n  hintType: 'direction' | 'proximity' | 'category' | 'value';\n  message: string;\n  intensity: number; // 0-100\n}\n\nexport class ProximityService {\n  private static redis = redisClient;\n  \n  // Proximity zones configuration\n  private static readonly ZONES = {\n    HINT: 50,      // 50m - Show hints only\n    VISIBLE: 20,   // 20m - Show prize in AR\n    CATCHABLE: 5,  // 5m - Enable catch button\n  };\n\n  /**\n   * Get all prizes within proximity zones for Unity client\n   */\n  static async getProximityPrizes(\n    userId: string, \n    location: { latitude: number; longitude: number; accuracy?: number },\n    options: { maxRadius?: number; includeHints?: boolean } = {}\n  ): Promise<ProximityResult> {\n    const startTime = Date.now();\n    \n    try {\n      const { maxRadius = this.ZONES.HINT, includeHints = true } = options;\n      \n      // Validate user and location\n      await this.validateUserAndLocation(userId, location);\n      \n      // Get nearby prizes using geospatial query\n      const nearbyPrizes = await this.getNearbyPrizes(location, maxRadius);\n      \n      // Filter out already claimed prizes\n      const availablePrizes = await this.filterClaimedPrizes(userId, nearbyPrizes);\n      \n      // Categorize prizes by proximity zones\n      const zones = this.categorizeByZones(location, availablePrizes, includeHints);\n      \n      // Generate hints for hint zone prizes\n      if (includeHints && zones.hint.length > 0) {\n        zones.hint = await this.generateHints(zones.hint, location);\n      }\n      \n      // Cache result for performance\n      await this.cacheProximityResult(userId, location, zones);\n      \n      const performanceMs = Date.now() - startTime;\n      \n      typedLogger.debug('Proximity detection completed', {\n        userId,\n        location,\n        totalFound: availablePrizes.length,\n        zones: {\n          hint: zones.hint.length,\n          visible: zones.visible.length,\n          catchable: zones.catchable.length,\n        },\n        performanceMs,\n      });\n      \n      return {\n        userId,\n        location,\n        zones,\n        metadata: {\n          totalNearby: availablePrizes.length,\n          searchRadius: maxRadius,\n          timestamp: new Date().toISOString(),\n          performanceMs,\n        },\n      };\n    } catch (error) {\n      typedLogger.error('Get proximity prizes error', { error: (error as any).message, userId, location });\n      throw error;\n    }\n  }\n\n  /**\n   * Get dynamic hints for prizes in hint zone (50m)\n   */\n  static async getDynamicHints(\n    userId: string,\n    prizeId: string,\n    userLocation: { latitude: number; longitude: number }\n  ): Promise<HintConfig[]> {\n    try {\n      const prize = await Prize.findById(prizeId);\n      if (!prize || prize.status !== 'active') {\n        throw new Error('PRIZE_NOT_AVAILABLE');\n      }\n\n      const distance = this.calculateDistance(\n        userLocation.latitude,\n        userLocation.longitude,\n        prize.location.coordinates[1],\n        prize.location.coordinates[0]\n      );\n\n      const hints: HintConfig[] = [];\n\n      // Distance-based hints\n      if (distance > 30) {\n        hints.push({\n          distance,\n          hintType: 'direction',\n          message: this.generateDirectionHint(userLocation, prize.location.coordinates),\n          intensity: 30,\n        });\n      } else if (distance > 15) {\n        hints.push({\n          distance,\n          hintType: 'proximity',\n          message: `You're getting warmer! ${Math.round(distance)}m away`,\n          intensity: 60,\n        });\n      } else {\n        hints.push({\n          distance,\n          hintType: 'proximity',\n          message: `Very close! Look around carefully`,\n          intensity: 90,\n        });\n      }\n\n      // Category hints\n      if (distance < 40) {\n        hints.push({\n          distance,\n          hintType: 'category',\n          message: this.generateCategoryHint(prize.category),\n          intensity: 50,\n        });\n      }\n\n      // Value hints for rare prizes\n      if (prize.rarity !== 'common' && distance < 25) {\n        hints.push({\n          distance,\n          hintType: 'value',\n          message: this.generateValueHint(prize.rarity, this.resolvePoints(prize)),\n          intensity: 70,\n        });\n      }\n\n      return hints;\n    } catch (error) {\n      typedLogger.error('Get dynamic hints error', { error: (error as any).message, userId, prizeId });\n      return [];\n    }\n  }\n\n  /**\n   * Validate if user can catch a prize (distance and anti-cheat)\n   */\n  static async validateCatchAttempt(\n    userId: string,\n    prizeId: string,\n    userLocation: { latitude: number; longitude: number; accuracy?: number },\n    deviceInfo?: any\n  ): Promise<{ canCatch: boolean; reason?: string; distance?: number }> {\n    try {\n      const prize = await Prize.findById(prizeId);\n      if (!prize || prize.status !== 'active') {\n        return { canCatch: false, reason: 'PRIZE_NOT_AVAILABLE' };\n      }\n\n      // Check if already claimed\n      const existingClaim = await Claim.findOne({ userId, prizeId });\n      if (existingClaim) {\n        return { canCatch: false, reason: 'ALREADY_CLAIMED' };\n      }\n\n      // Calculate distance\n      const distance = this.calculateDistance(\n        userLocation.latitude,\n        userLocation.longitude,\n        prize.location.coordinates[1],\n        prize.location.coordinates[0]\n      );\n\n      // Check if within catchable zone\n      if (distance > this.ZONES.CATCHABLE) {\n        return { \n          canCatch: false, \n          reason: 'TOO_FAR', \n          distance: Math.round(distance * 100) / 100 \n        };\n      }\n\n      // Anti-cheat validation\n      const antiCheatResult = await this.performAntiCheatValidation(\n        userId,\n        userLocation,\n        prize.location.coordinates,\n        deviceInfo\n      );\n\n      if (!antiCheatResult.valid) {\n        return { \n          canCatch: false, \n          reason: antiCheatResult.reason,\n          distance: Math.round(distance * 100) / 100 \n        };\n      }\n\n      // Check prize availability (max claims, etc.)\n      if (prize.quantity && prize.claimedCount >= prize.quantity) {\n        return { canCatch: false, reason: 'MAX_CLAIMS_REACHED' };\n      }\n\n      return { \n        canCatch: true, \n        distance: Math.round(distance * 100) / 100 \n      };\n    } catch (error) {\n      typedLogger.error('Validate catch attempt error', { error: (error as any).message, userId, prizeId });\n      return { canCatch: false, reason: 'VALIDATION_ERROR' };\n    }\n  }\n\n  /**\n   * Update user location and get real-time proximity updates\n   */\n  static async updateLocationAndGetProximity(\n    userId: string,\n    location: { latitude: number; longitude: number; accuracy?: number; timestamp?: string }\n  ): Promise<ProximityResult> {\n    try {\n      // Store location update\n      await this.storeLocationUpdate(userId, location);\n      \n      // Get proximity results\n      const proximityResult = await this.getProximityPrizes(userId, location);\n      \n      // Check for zone transitions (e.g., prize moved from hint to visible zone)\n      const transitions = await this.detectZoneTransitions(userId, proximityResult);\n      \n      if (transitions.length > 0) {\n        // Trigger real-time events for Unity client\n        await this.triggerZoneTransitionEvents(userId, transitions);\n      }\n      \n      return proximityResult;\n    } catch (error) {\n      typedLogger.error('Update location and get proximity error', { error: (error as any).message, userId, location });\n      throw error;\n    }\n  }\n\n  /**\n   * Get optimized proximity data for Unity (reduced payload)\n   */\n  static async getUnityOptimizedProximity(\n    userId: string,\n    location: { latitude: number; longitude: number },\n    lastUpdateTimestamp?: string\n  ): Promise<any> {\n    try {\n      const fullResult = await this.getProximityPrizes(userId, location);\n      \n      // Optimize for Unity by reducing data size\n      const optimized = {\n        zones: {\n          hint: fullResult.zones.hint.map(p => ({\n            id: p.id,\n            d: Math.round(p.distance),\n            b: Math.round(p.bearing),\n            h: p.hint,\n            r: p.rarity[0], // First letter only\n          })),\n          visible: fullResult.zones.visible.map(p => ({\n            id: p.id,\n            t: p.title,\n            c: p.category[0], // First letter only\n            p: p.points,\n            d: Math.round(p.distance),\n            b: Math.round(p.bearing),\n            a: p.animation,\n            coords: p.coordinates,\n          })),\n          catchable: fullResult.zones.catchable.map(p => ({\n            id: p.id,\n            t: p.title,\n            p: p.points,\n            d: Math.round(p.distance),\n            a: p.animation,\n            coords: p.coordinates,\n          })),\n        },\n        meta: {\n          total: fullResult.metadata.totalNearby,\n          ts: fullResult.metadata.timestamp,\n          perf: fullResult.metadata.performanceMs,\n        },\n      };\n      \n      return optimized;\n    } catch (error) {\n      typedLogger.error('Get Unity optimized proximity error', { error: (error as any).message, userId, location });\n      throw error;\n    }\n  }\n\n  // Private helper methods\n  private static async validateUserAndLocation(\n    userId: string,\n    location: { latitude: number; longitude: number; accuracy?: number }\n  ): Promise<void> {\n    const user = await User.findById(userId);\n    if (!user || user.isBanned) {\n      throw new Error('USER_NOT_VALID');\n    }\n\n    if (!location.latitude || !location.longitude) {\n      throw new Error('INVALID_LOCATION');\n    }\n\n    if (Math.abs(location.latitude) > 90 || Math.abs(location.longitude) > 180) {\n      throw new Error('INVALID_COORDINATES');\n    }\n\n    // Check location accuracy if provided\n    if (location.accuracy && location.accuracy > 100) {\n      typedLogger.warn('Low GPS accuracy detected', { userId, accuracy: location.accuracy });\n    }\n  }\n\n  private static async getNearbyPrizes(\n    location: { latitude: number; longitude: number },\n    radiusMeters: number\n  ): Promise<any[]> {\n    try {\n      // Use MongoDB geospatial query for efficient proximity search\n      const radiusInRadians = radiusMeters / 6378100; // Earth radius in meters\n      const now = new Date();\n      \n      const prizes = await Prize.find({\n        status: 'active',\n        'visibility.startAt': { $lte: now },\n        'location.coordinates': {\n          $geoWithin: {\n            $centerSphere: [\n              [location.longitude, location.latitude],\n              radiusInRadians\n            ]\n          }\n        },\n        $and: [\n          {\n            $or: [\n              { 'visibility.endAt': { $exists: false } },\n              { 'visibility.endAt': { $gt: now } }\n            ]\n          },\n          {\n            $or: [\n              { expiresAt: { $exists: false } },\n              { expiresAt: { $gt: now } }\n            ]\n          }\n        ],\n      })\n      .select('name category rarity points pointsReward displayType contentType location visibility metadata')\n      .lean();\n\n      return prizes;\n    } catch (error) {\n      typedLogger.error('Get nearby prizes error', { error: (error as any).message, location, radiusMeters });\n      return [];\n    }\n  }\n\n  private static async filterClaimedPrizes(userId: string, prizes: any[]): Promise<any[]> {\n    try {\n      if (prizes.length === 0) return [];\n\n      const prizeIds = prizes.map(p => p._id);\n      const claims = await Claim.find({ \n        userId, \n        prizeId: { $in: prizeIds } \n      }).select('prizeId').lean();\n\n      const claimedIds = new Set(claims.map(c => c.prizeId.toString()));\n      \n      return prizes.filter(p => !claimedIds.has(p._id.toString()));\n    } catch (error) {\n      typedLogger.error('Filter claimed prizes error', { error: (error as any).message, userId });\n      return prizes;\n    }\n  }\n\n  private static categorizeByZones(\n    userLocation: { latitude: number; longitude: number },\n    prizes: any[],\n    includeHints: boolean\n  ): { hint: ProximityPrize[]; visible: ProximityPrize[]; catchable: ProximityPrize[] } {\n    const zones = {\n      hint: [] as ProximityPrize[],\n      visible: [] as ProximityPrize[],\n      catchable: [] as ProximityPrize[],\n    };\n\n    for (const prize of prizes) {\n      const distance = this.calculateDistance(\n        userLocation.latitude,\n        userLocation.longitude,\n        prize.location.coordinates[1],\n        prize.location.coordinates[0]\n      );\n\n      const bearing = this.calculateBearing(\n        userLocation.latitude,\n        userLocation.longitude,\n        prize.location.coordinates[1],\n        prize.location.coordinates[0]\n      );\n\n      const proximityPrize: ProximityPrize = {\n        id: prize._id.toString(),\n        title: prize.name,\n        category: prize.category,\n        rarity: prize.rarity,\n        points: this.resolvePoints(prize),\n        distance: Math.round(distance * 100) / 100,\n        bearing: Math.round(bearing),\n        zone: distance <= this.ZONES.CATCHABLE ? 'catchable' : \n              distance <= this.ZONES.VISIBLE ? 'visible' : 'hint',\n        animation: this.resolveAnimation(prize),\n        canCatch: distance <= this.ZONES.CATCHABLE,\n        estimatedValue: this.calculateEstimatedValue(prize),\n      };\n\n      // Add coordinates for visible and catchable zones\n      if (distance <= this.ZONES.VISIBLE) {\n        proximityPrize.coordinates = {\n          latitude: prize.location.coordinates[1],\n          longitude: prize.location.coordinates[0],\n        };\n      }\n\n      // Categorize into appropriate zone\n      if (distance <= this.ZONES.CATCHABLE) {\n        zones.catchable.push(proximityPrize);\n      } else if (distance <= this.ZONES.VISIBLE) {\n        zones.visible.push(proximityPrize);\n      } else if (distance <= this.ZONES.HINT && includeHints) {\n        zones.hint.push(proximityPrize);\n      }\n    }\n\n    // Sort by distance within each zone\n    zones.hint.sort((a, b) => a.distance - b.distance);\n    zones.visible.sort((a, b) => a.distance - b.distance);\n    zones.catchable.sort((a, b) => a.distance - b.distance);\n\n    return zones;\n  }\n\n  private static async generateHints(\n    hintPrizes: ProximityPrize[],\n    userLocation: { latitude: number; longitude: number }\n  ): Promise<ProximityPrize[]> {\n    return hintPrizes.map(prize => ({\n      ...prize,\n      hint: this.generateHintMessage(prize, userLocation),\n    }));\n  }\n\n  private static generateHintMessage(\n    prize: ProximityPrize,\n    userLocation: { latitude: number; longitude: number }\n  ): string {\n    const distance = prize.distance;\n    const direction = this.getCardinalDirection(prize.bearing);\n    \n    if (distance > 40) {\n      return `Something ${this.getRarityHint(prize.rarity)} is ${direction}`;\n    } else if (distance > 25) {\n      return `A ${prize.category} treasure awaits ${direction}`;\n    } else {\n      return `You're close to something ${this.getValueHint(prize.points)}!`;\n    }\n  }\n\n  private static generateDirectionHint(\n    userLocation: { latitude: number; longitude: number },\n    prizeCoordinates: [number, number]\n  ): string {\n    const bearing = this.calculateBearing(\n      userLocation.latitude,\n      userLocation.longitude,\n      prizeCoordinates[1],\n      prizeCoordinates[0]\n    );\n    \n    const direction = this.getCardinalDirection(bearing);\n    return `Look ${direction}`;\n  }\n\n  private static generateCategoryHint(category: string): string {\n    const hints = {\n      food: \"Something delicious is nearby\",\n      shopping: \"A great deal awaits\",\n      entertainment: \"Fun is just around the corner\",\n      transport: \"Your journey can be rewarded\",\n      special: \"Something extraordinary is here\",\n    };\n    \n    return hints[category] || \"A treasure is hidden nearby\";\n  }\n\n  private static generateValueHint(rarity: string, points: number): string {\n    if (rarity === 'legendary') {\n      return \"An incredible treasure awaits!\";\n    } else if (rarity === 'epic') {\n      return \"Something very valuable is close!\";\n    } else if (points > 500) {\n      return \"A high-value prize is nearby!\";\n    } else {\n      return \"A nice reward is waiting!\";\n    }\n  }\n\n  private static getRarityHint(rarity: string): string {\n    const hints = {\n      common: \"interesting\",\n      uncommon: \"notable\",\n      rare: \"valuable\",\n      epic: \"extraordinary\",\n      legendary: \"legendary\",\n    };\n    \n    return hints[rarity] || \"mysterious\";\n  }\n\n  private static getValueHint(points: number): string {\n    if (points > 1000) return \"very valuable\";\n    if (points > 500) return \"valuable\";\n    if (points > 100) return \"worthwhile\";\n    return \"interesting\";\n  }\n\n  private static getCardinalDirection(bearing: number): string {\n    const directions = [\n      \"north\", \"northeast\", \"east\", \"southeast\",\n      \"south\", \"southwest\", \"west\", \"northwest\"\n    ];\n    \n    const index = Math.round(bearing / 45) % 8;\n    return directions[index];\n  }\n\n  private static calculateDistance(lat1: number, lng1: number, lat2: number, lng2: number): number {\n    const R = 6371000; // Earth's radius in meters\n    const dLat = (lat2 - lat1) * Math.PI / 180;\n    const dLng = (lng2 - lng1) * Math.PI / 180;\n    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +\n              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n              Math.sin(dLng/2) * Math.sin(dLng/2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n    return R * c;\n  }\n\n  private static calculateBearing(lat1: number, lng1: number, lat2: number, lng2: number): number {\n    const dLng = (lng2 - lng1) * Math.PI / 180;\n    const lat1Rad = lat1 * Math.PI / 180;\n    const lat2Rad = lat2 * Math.PI / 180;\n    \n    const y = Math.sin(dLng) * Math.cos(lat2Rad);\n    const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) - \n              Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLng);\n    \n    const bearing = Math.atan2(y, x) * 180 / Math.PI;\n    return (bearing + 360) % 360;\n  }\n\n  private static calculateEstimatedValue(prize: any): number {\n    let value = this.resolvePoints(prize);\n    \n    // Rarity multiplier\n    const rarityMultipliers = {\n      common: 1,\n      uncommon: 1.2,\n      rare: 1.5,\n      epic: 2,\n      legendary: 3,\n    };\n    \n    value *= rarityMultipliers[prize.rarity] || 1;\n    \n    // Bonus multiplier\n    const bonusMultiplier = prize.pointsReward?.bonusMultiplier ?? prize.metadata?.bonusMultiplier;\n    if (bonusMultiplier) {\n      value *= bonusMultiplier;\n    }\n    \n    return Math.round(value);\n  }\n\n  private static resolvePoints(prize: any): number {\n    return prize.pointsReward?.amount ?? prize.points ?? 0;\n  }\n\n  private static resolveAnimation(prize: any): string {\n    if (prize?.metadata?.animation) {\n      return String(prize.metadata.animation);\n    }\n    const displayType = prize.displayType || 'standard';\n    const animationMap: Record<string, string> = {\n      standard: 'standard',\n      mystery_box: 'rare',\n      treasure: 'epic',\n      bonus: 'legendary',\n      special: 'legendary',\n    };\n    return animationMap[displayType] || 'standard';\n  }\n\n  private static async performAntiCheatValidation(\n    userId: string,\n    userLocation: { latitude: number; longitude: number },\n    prizeCoordinates: [number, number],\n    deviceInfo?: any\n  ): Promise<{ valid: boolean; reason?: string }> {\n    try {\n      // Check for GPS spoofing indicators\n      if (deviceInfo?.accuracy && deviceInfo.accuracy < 1) {\n        typedLogger.warn('Suspicious GPS accuracy detected', { userId, accuracy: deviceInfo.accuracy });\n        return { valid: false, reason: 'SUSPICIOUS_GPS_ACCURACY' };\n      }\n\n      // Check movement speed (basic anti-teleportation)\n      const lastLocationKey = `last_location:${userId}`;\n      const lastLocationData = await this.redis.get(lastLocationKey);\n      \n      if (lastLocationData) {\n        const lastLocation = JSON.parse(lastLocationData);\n        const timeDiff = Date.now() - lastLocation.timestamp;\n        const distance = this.calculateDistance(\n          lastLocation.latitude,\n          lastLocation.longitude,\n          userLocation.latitude,\n          userLocation.longitude\n        );\n        \n        // Check if movement speed is humanly possible (max 100 km/h)\n        const maxSpeed = 100 * 1000 / 3600; // m/s\n        const actualSpeed = distance / (timeDiff / 1000);\n        \n        if (actualSpeed > maxSpeed && timeDiff > 5000) { // Allow 5 seconds grace period\n          typedLogger.warn('Suspicious movement speed detected', {\n            userId,\n            distance,\n            timeDiff,\n            actualSpeed,\n            maxSpeed,\n          });\n          return { valid: false, reason: 'SUSPICIOUS_MOVEMENT_SPEED' };\n        }\n      }\n\n      // Store current location for next validation\n      await this.redis.setex(\n        `last_location:${userId}`,\n        300, // 5 minutes\n        JSON.stringify({\n          latitude: userLocation.latitude,\n          longitude: userLocation.longitude,\n          timestamp: Date.now(),\n        })\n      );\n\n      return { valid: true };\n    } catch (error) {\n      typedLogger.error('Anti-cheat validation error', { error: (error as any).message, userId });\n      return { valid: true }; // Fail open to avoid blocking legitimate users\n    }\n  }\n\n  private static async storeLocationUpdate(\n    userId: string,\n    location: { latitude: number; longitude: number; accuracy?: number; timestamp?: string }\n  ): Promise<void> {\n    try {\n      const locationData = {\n        ...location,\n        timestamp: location.timestamp || new Date().toISOString(),\n        serverTimestamp: Date.now(),\n      };\n\n      await this.redis.setex(\n        `user_location:${userId}`,\n        300, // 5 minutes\n        JSON.stringify(locationData)\n      );\n    } catch (error) {\n      typedLogger.error('Store location update error', { error: (error as any).message, userId });\n    }\n  }\n\n  private static async cacheProximityResult(\n    userId: string,\n    location: { latitude: number; longitude: number },\n    zones: any\n  ): Promise<void> {\n    try {\n      const cacheKey = `proximity_result:${userId}`;\n      const prevKey = `proximity_result_prev:${userId}`;\n      const cacheData = {\n        location,\n        zones,\n        timestamp: Date.now(),\n      };\n\n      const previous = await this.redis.get(cacheKey);\n      if (previous) {\n        await this.redis.setex(prevKey, 30, previous);\n      }\n      await this.redis.setex(cacheKey, 30, JSON.stringify(cacheData)); // 30 seconds cache\n    } catch (error) {\n      typedLogger.error('Cache proximity result error', { error: (error as any).message, userId });\n    }\n  }\n\n  private static async detectZoneTransitions(userId: string, currentResult: ProximityResult): Promise<any[]> {\n    try {\n      const lastResultKey = `proximity_result_prev:${userId}`;\n      const lastResultData = await this.redis.get(lastResultKey);\n      \n      if (!lastResultData) return [];\n      \n      const lastResult = JSON.parse(lastResultData);\n      const transitions: Array<{ prizeId: string; from: string; to: string; distance?: number }> = [];\n\n      const flattenZones = (zones: any) => {\n        const entries: Record<string, string> = {};\n        (['hint', 'visible', 'catchable'] as const).forEach(zone => {\n          (zones?.[zone] || []).forEach((prize: any) => {\n            if (prize?.id) entries[prize.id] = zone;\n          });\n        });\n        return entries;\n      };\n\n      const prevZones = flattenZones(lastResult?.zones || {});\n      const currentZones = flattenZones(currentResult?.zones || {});\n\n      Object.entries(currentZones).forEach(([prizeId, zone]) => {\n        const prevZone = prevZones[prizeId];\n        if (prevZone && prevZone !== zone) {\n          const currentPrize =\n            currentResult.zones.hint.find(p => p.id === prizeId) ||\n            currentResult.zones.visible.find(p => p.id === prizeId) ||\n            currentResult.zones.catchable.find(p => p.id === prizeId);\n          transitions.push({\n            prizeId,\n            from: prevZone,\n            to: zone,\n            distance: currentPrize?.distance,\n          });\n        }\n      });\n\n      return transitions;\n    } catch (error) {\n      typedLogger.error('Detect zone transitions error', { error: (error as any).message, userId });\n      return [];\n    }\n  }\n\n  private static async triggerZoneTransitionEvents(userId: string, transitions: any[]): Promise<void> {\n    try {\n      // This would trigger WebSocket events to Unity client\n      // Implementation depends on WebSocket setup\n      typedLogger.info('Zone transitions detected', { userId, transitions: transitions.length });\n    } catch (error) {\n      typedLogger.error('Trigger zone transition events error', { error: (error as any).message, userId });\n    }\n  }\n}\n\nexport default ProximityService;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\services\\push-notifications.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":12,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[351,354],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[351,354],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":96,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":96,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1807,1810],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1807,1810],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":174,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":174,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4069,4072],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4069,4072],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":177,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":177,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4165,4168],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4165,4168],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":216,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":216,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5236,5239],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5236,5239],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":232,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":232,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5752,5755],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5752,5755],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":237,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":237,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5893,5896],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5893,5896],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":246,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":246,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6039,6042],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6039,6042],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":321,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":321,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8207,8210],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8207,8210],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":324,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":324,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8318,8321],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8318,8321],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":331,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":331,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8477,8480],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8477,8480],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":340,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":340,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8623,8626],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8623,8626],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":399,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":399,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10459,10462],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10459,10462],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":402,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":402,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10571,10574],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10571,10574],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":409,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":409,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10730,10733],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10730,10733],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":417,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":417,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10888,10891],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10888,10891],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":16,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Types } from 'mongoose';\nimport { DeviceToken, DevicePlatform, INotificationPreferences } from '@/models/DeviceToken';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { config } from '@/config';\n\n/**\n * Push Notification Payload\n */\nexport interface PushNotificationPayload {\n  title: string;\n  body: string;\n  data?: Record<string, any>;\n  imageUrl?: string;\n  actionUrl?: string;\n  badge?: number;\n  sound?: string;\n  priority?: 'high' | 'normal';\n  ttl?: number; // Time to live in seconds\n}\n\n/**\n * Push Notification Result\n */\nexport interface PushNotificationResult {\n  success: boolean;\n  deviceId: string;\n  platform: DevicePlatform;\n  messageId?: string;\n  error?: string;\n}\n\n/**\n * FCM Message Format\n */\ninterface FCMMessage {\n  token: string;\n  notification?: {\n    title: string;\n    body: string;\n    image?: string;\n  };\n  data?: Record<string, string>;\n  android?: {\n    priority: 'high' | 'normal';\n    ttl?: string;\n    notification?: {\n      sound?: string;\n      click_action?: string;\n    };\n  };\n  apns?: {\n    payload: {\n      aps: {\n        alert: {\n          title: string;\n          body: string;\n        };\n        badge?: number;\n        sound?: string;\n        'content-available'?: number;\n      };\n    };\n    fcm_options?: {\n      image?: string;\n    };\n  };\n  webpush?: {\n    notification: {\n      title: string;\n      body: string;\n      icon?: string;\n      image?: string;\n    };\n    fcm_options?: {\n      link?: string;\n    };\n  };\n}\n\n/**\n * APNS Message Format\n */\ninterface APNSMessage {\n  deviceToken: string;\n  payload: {\n    aps: {\n      alert: {\n        title: string;\n        body: string;\n      };\n      badge?: number;\n      sound?: string;\n      'content-available'?: number;\n      'mutable-content'?: number;\n    };\n    data?: Record<string, any>;\n  };\n  priority?: number;\n  expiry?: number;\n}\n\n/**\n * Push Notification Service\n * Handles sending push notifications via FCM (Android/Web) and APNS (iOS)\n */\nexport class PushNotificationService {\n  private static fcmEnabled = !!config.FCM_SERVER_KEY;\n  private static apnsEnabled = !!config.APNS_KEY_ID;\n\n  /**\n   * Send push notification to a single user\n   */\n  static async sendToUser(\n    userId: string,\n    payload: PushNotificationPayload,\n    notificationType?: keyof INotificationPreferences\n  ): Promise<PushNotificationResult[]> {\n    try {\n      // Get all active devices for the user\n      const devices = await DeviceToken.find({\n        userId: new Types.ObjectId(userId),\n        isActive: true,\n        'preferences.enabled': true,\n      });\n\n      if (devices.length === 0) {\n        typedLogger.info('No active devices for user', { userId });\n        return [];\n      }\n\n      // Filter by notification type preference\n      const filteredDevices = notificationType\n        ? devices.filter(device => device.preferences[notificationType] !== false)\n        : devices;\n\n      if (filteredDevices.length === 0) {\n        typedLogger.info('User has disabled this notification type', {\n          userId,\n          notificationType,\n        });\n        return [];\n      }\n\n      // Send to all devices\n      const results = await Promise.all(\n        filteredDevices.map(device => this.sendToDevice(device, payload))\n      );\n\n      // Update last used timestamp for successful sends\n      const successfulDeviceIds = results\n        .filter(r => r.success)\n        .map(r => r.deviceId);\n\n      if (successfulDeviceIds.length > 0) {\n        await DeviceToken.updateMany(\n          { deviceId: { $in: successfulDeviceIds } },\n          { $set: { lastUsed: new Date() } }\n        );\n      }\n\n      // Deactivate devices with permanent errors\n      const failedDevices = results.filter(\n        r => !r.success && (r.error?.includes('invalid') || r.error?.includes('not registered'))\n      );\n\n      if (failedDevices.length > 0) {\n        await DeviceToken.updateMany(\n          { deviceId: { $in: failedDevices.map(d => d.deviceId) } },\n          { $set: { isActive: false } }\n        );\n      }\n\n      return results;\n    } catch (error: any) {\n      typedLogger.error('Send to user error', {\n        userId,\n        error: (error as any).message,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Send push notification to multiple users\n   */\n  static async sendToUsers(\n    userIds: string[],\n    payload: PushNotificationPayload,\n    notificationType?: keyof INotificationPreferences\n  ): Promise<Record<string, PushNotificationResult[]>> {\n    const results: Record<string, PushNotificationResult[]> = {};\n\n    // Send in batches to avoid overwhelming the system\n    const batchSize = 100;\n    for (let i = 0; i < userIds.length; i += batchSize) {\n      const batch = userIds.slice(i, i + batchSize);\n      const batchResults = await Promise.all(\n        batch.map(async userId => {\n          const userResults = await this.sendToUser(userId, payload, notificationType);\n          return { userId, results: userResults };\n        })\n      );\n\n      batchResults.forEach(({ userId, results: userResults }) => {\n        results[userId] = userResults;\n      });\n    }\n\n    return results;\n  }\n\n  /**\n   * Send push notification to a single device\n   */\n  private static async sendToDevice(\n    device: any,\n    payload: PushNotificationPayload\n  ): Promise<PushNotificationResult> {\n    try {\n      if (device.platform === DevicePlatform.IOS && device.apnsToken) {\n        return await this.sendViaAPNS(device, payload);\n      } else if (device.fcmToken) {\n        return await this.sendViaFCM(device, payload);\n      } else {\n        return {\n          success: false,\n          deviceId: device.deviceId,\n          platform: device.platform,\n          error: 'No valid token',\n        };\n      }\n    } catch (error: any) {\n      return {\n        success: false,\n        deviceId: device.deviceId,\n        platform: device.platform,\n        error: (error as any).message,\n      };\n    }\n  }\n\n  /**\n   * Send via Firebase Cloud Messaging (Android/Web)\n   */\n  private static async sendViaFCM(\n    device: any,\n    payload: PushNotificationPayload\n  ): Promise<PushNotificationResult> {\n    if (!this.fcmEnabled) {\n      // Mock mode for development\n      typedLogger.info('[MOCK] FCM notification sent', {\n        deviceId: device.deviceId,\n        platform: device.platform,\n        payload,\n      });\n\n      return {\n        success: true,\n        deviceId: device.deviceId,\n        platform: device.platform,\n        messageId: `mock-fcm-${Date.now()}`,\n      };\n    }\n\n    try {\n      // Prepare FCM message\n      const message: FCMMessage = {\n        token: device.fcmToken,\n        notification: {\n          title: payload.title,\n          body: payload.body,\n          image: payload.imageUrl,\n        },\n        data: payload.data ? this.stringifyData(payload.data) : undefined,\n      };\n\n      // Android-specific options\n      if (device.platform === DevicePlatform.ANDROID) {\n        message.android = {\n          priority: payload.priority || 'high',\n          ttl: payload.ttl ? `${payload.ttl}s` : undefined,\n          notification: {\n            sound: payload.sound || 'default',\n            click_action: payload.actionUrl,\n          },\n        };\n      }\n\n      // Web-specific options\n      if (device.platform === DevicePlatform.WEB) {\n        message.webpush = {\n          notification: {\n            title: payload.title,\n            body: payload.body,\n            icon: '/icon.png',\n            image: payload.imageUrl,\n          },\n          fcm_options: {\n            link: payload.actionUrl,\n          },\n        };\n      }\n\n      // In production, use Firebase Admin SDK:\n      // const admin = require('firebase-admin');\n      // const response = await admin.messaging().send(message);\n      // return { success: true, deviceId: device.deviceId, platform: device.platform, messageId: response };\n\n      // For now, mock the response\n      typedLogger.info('[MOCK] FCM notification would be sent', {\n        deviceId: device.deviceId,\n        message,\n      });\n\n      return {\n        success: true,\n        deviceId: device.deviceId,\n        platform: device.platform,\n        messageId: `mock-fcm-${Date.now()}`,\n      };\n    } catch (error: any) {\n      typedLogger.error('FCM send error', {\n        deviceId: device.deviceId,\n        error: (error as any).message,\n      });\n\n      return {\n        success: false,\n        deviceId: device.deviceId,\n        platform: device.platform,\n        error: (error as any).message,\n      };\n    }\n  }\n\n  /**\n   * Send via Apple Push Notification Service (iOS)\n   */\n  private static async sendViaAPNS(\n    device: any,\n    payload: PushNotificationPayload\n  ): Promise<PushNotificationResult> {\n    if (!this.apnsEnabled) {\n      // Mock mode for development\n      typedLogger.info('[MOCK] APNS notification sent', {\n        deviceId: device.deviceId,\n        platform: device.platform,\n        payload,\n      });\n\n      return {\n        success: true,\n        deviceId: device.deviceId,\n        platform: device.platform,\n        messageId: `mock-apns-${Date.now()}`,\n      };\n    }\n\n    try {\n      // Prepare APNS message\n      const message: APNSMessage = {\n        deviceToken: device.apnsToken,\n        payload: {\n          aps: {\n            alert: {\n              title: payload.title,\n              body: payload.body,\n            },\n            badge: payload.badge,\n            sound: payload.sound || 'default',\n            'content-available': 1,\n            'mutable-content': 1,\n          },\n          data: payload.data,\n        },\n        priority: payload.priority === 'high' ? 10 : 5,\n        expiry: payload.ttl ? Math.floor(Date.now() / 1000) + payload.ttl : undefined,\n      };\n\n      // In production, use node-apn or similar:\n      // const apn = require('apn');\n      // const provider = new apn.Provider({ ... });\n      // const notification = new apn.Notification(message.payload);\n      // const response = await provider.send(notification, message.deviceToken);\n      // return { success: response.sent.length > 0, deviceId: device.deviceId, platform: device.platform };\n\n      // For now, mock the response\n      typedLogger.info('[MOCK] APNS notification would be sent', {\n        deviceId: device.deviceId,\n        message,\n      });\n\n      return {\n        success: true,\n        deviceId: device.deviceId,\n        platform: device.platform,\n        messageId: `mock-apns-${Date.now()}`,\n      };\n    } catch (error: any) {\n      typedLogger.error('APNS send error', {\n        deviceId: device.deviceId,\n        error: (error as any).message,\n      });\n\n      return {\n        success: false,\n        deviceId: device.deviceId,\n        platform: device.platform,\n        error: (error as any).message,\n      };\n    }\n  }\n\n  /**\n   * Convert data object to string values (required by FCM)\n   */\n  private static stringifyData(data: Record<string, any>): Record<string, string> {\n    const result: Record<string, string> = {};\n    for (const [key, value] of Object.entries(data)) {\n      result[key] = typeof value === 'string' ? value : JSON.stringify(value);\n    }\n    return result;\n  }\n\n  /**\n   * Send test notification\n   */\n  static async sendTestNotification(userId: string): Promise<PushNotificationResult[]> {\n    return this.sendToUser(userId, {\n      title: 'Test Notification',\n      body: 'This is a test notification from YallaCatch!',\n      data: {\n        type: 'test',\n        timestamp: new Date().toISOString(),\n      },\n    });\n  }\n}\n\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\types\\aws-sdk-client-s3.d.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":3,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":3,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[83,86],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[83,86],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":4,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":4,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[115,118],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[115,118],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":4,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":4,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[131,134],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[131,134],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":5,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":5,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[162,165],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[162,165],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":5,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":5,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[178,181],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[178,181],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":9,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[240,243],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[240,243],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":10,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[266,269],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[266,269],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":10,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[280,283],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[280,283],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":14,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[351,354],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[351,354],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"declare module '@aws-sdk/client-s3' {\n  export class S3 {\n    constructor(...args: any[]);\n    headBucket(...args: any[]): Promise<any>;\n    listBuckets(...args: any[]): Promise<any>;\n  }\n\n  export class S3Client {\n    constructor(...args: any[]);\n    send(command: any): Promise<any>;\n  }\n\n  export class HeadBucketCommand {\n    constructor(...args: any[]);\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\types\\fastify.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\types\\index.ts","messages":[{"ruleId":"@typescript-eslint/ban-types","severity":2,"message":"Don't use `{}` as a type. `{}` actually means \"any non-nullish value\".\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.\n- If you want a type meaning \"empty object\", you probably want `Record<string, never>` instead.\n- If you really want a type meaning \"any non-nullish value\", you probably want `NonNullable<unknown>` instead.","line":855,"column":50,"nodeType":"TSTypeLiteral","messageId":"bannedTypeMessage","endLine":855,"endColumn":52,"suggestions":[{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"object"},"fix":{"range":[20127,20129],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"unknown"},"fix":{"range":[20127,20129],"text":"unknown"},"desc":"Replace `{}` with `unknown`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"Record<string, never>"},"fix":{"range":[20127,20129],"text":"Record<string, never>"},"desc":"Replace `{}` with `Record<string, never>`."},{"messageId":"bannedTypeReplacement","data":{"name":"{}","replacement":"NonNullable<unknown>"},"fix":{"range":[20127,20129],"text":"NonNullable<unknown>"},"desc":"Replace `{}` with `NonNullable<unknown>`."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Document, FilterQuery, HydratedDocument, Model, Types } from 'mongoose';\n\nexport type JSONPrimitive = string | number | boolean | null;\nexport type JSONValue = JSONPrimitive | JSONValue[] | { [key: string]: JSONValue };\nexport type MetadataValue = JSONPrimitive | Date | Types.ObjectId | Error | object;\nexport type Metadata = Record<string, MetadataValue>;\nexport type LogValue = MetadataValue;\nexport type LogMetadata = Record<string, LogValue>;\nexport type ErrorLike = Error | { message?: string; name?: string } | string;\nexport type MongoValue = JSONValue | Date | Types.ObjectId | RegExp;\nexport type MongoQuery<T = unknown> = FilterQuery<T>;\n\r\nexport interface PrizeCityStats {\r\n  _id: string;\r\n  totalPrizes: number;\r\n  activePrizes: number;\r\n  claimedPrizes: number;\r\n  totalPoints: number;\r\n  averagePoints: number;\r\n  rarityDistribution: PrizeRarity[];\r\n}\r\n\r\nexport interface PrizeHeatmapPoint {\r\n  lat: number;\r\n  lng: number;\r\n  count: number;\r\n  totalPoints: number;\r\n  averagePoints: number;\r\n}\r\n\r\nexport interface PrizeCleanupResult {\r\n  matchedCount?: number;\r\n  modifiedCount: number;\r\n  acknowledged?: boolean;\r\n}\r\n\r\n// Base interfaces\r\nexport interface BaseDocument extends Document {\r\n  _id: Types.ObjectId;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\n// User related types\r\nexport interface IUser extends BaseDocument {\n  email?: string;\n  username?: string;\n  passwordHash?: string;\n  displayName: string;\n  role: UserRole;\n  status?: 'active' | 'suspended' | 'banned' | 'deleted' | 'inactive';\n  points: {\n    available: number;\n    total: number;\n    spent: number;\n  };\n  level: UserLevel;\r\n  location?: {\r\n    lat: number;\r\n    lng: number;\r\n    city: string;\r\n    lastUpdated: Date;\r\n  };\r\n  stats: {\r\n    prizesFound: number;\r\n    rewardsRedeemed: number;\r\n    sessionsCount: number;\r\n    totalPlayTime: number;\r\n    totalDistance?: number;\r\n    longestStreak: number;\r\n    currentStreak: number;\r\n    favoriteCity?: string;\r\n    lastClaimDate?: Date;\r\n    dailyClaimsCount: number;\r\n  };\r\n  devices: IDevice[];\r\n  preferences: {\r\n    notifications: {\r\n      push?: boolean;\r\n      email?: boolean;\r\n      sms?: boolean;\r\n      inApp?: boolean;\r\n      types?: Record<string, boolean>;\r\n    };\r\n    language: Language;\r\n    theme: Theme;\r\n  };\r\n  partnerId?: Types.ObjectId;\r\n  isGuest: boolean;\r\n  isBanned: boolean;\r\n  banReason?: string;\r\n  banExpiresAt?: Date;\r\n  lastIp?: string;\r\n  lastUserAgent?: string;\r\n  phoneNumber?: string;\r\n  avatar?: string;\r\n  lastActive: Date;\r\n  deletedAt?: Date;\r\n  // Inventory and active effects for game mechanics\r\n  inventory?: {\r\n    powerUps?: Array<{\r\n      id: string;\r\n      type: string;\r\n      quantity: number;\r\n      expiresAt?: Date;\r\n    }>;\r\n    items?: Array<{\r\n      id: string;\r\n      name: string;\r\n      type: string;\r\n      quantity: number;\r\n      expiresAt?: Date;\r\n    }>;\r\n  };\r\n  activeEffects?: Array<{\r\n    type: string;\r\n    effect: Metadata;\r\n    expiresAt?: Date;\r\n    createdAt: Date;\r\n  }>;\r\n\r\n  // Offline mode properties\r\n  offlineMode?: boolean;\r\n  lastSync?: Date;\r\n}\r\n\r\nexport interface IUserMethods {\r\n  comparePassword: (candidatePassword: string) => Promise<boolean>;\r\n  updateLevel: () => void;\r\n  addPoints: (points: number) => void;\r\n  spendPoints: (points: number) => boolean;\r\n  updateLocation: (lat: number, lng: number, city: string) => void;\r\n  updateFavoriteCity: (city: string) => void;\r\n  addDevice: (\r\n    deviceId: string,\r\n    platform: Platform,\r\n    fcmToken?: string,\r\n    meta?: { model?: string; osVersion?: string; appVersion?: string; userAgent?: string }\r\n  ) => void;\r\n  removeDevice: (deviceId: string) => void;\r\n  updateStreak: () => void;\r\n  resetDailyClaimsIfNeeded: () => void;\r\n  incrementDailyClaims: () => void;\r\n  ban: (reason: string, duration?: number) => void;\r\n  unban: () => void;\r\n  softDelete: () => void;\r\n  restore: () => void;\r\n}\r\n\r\nexport interface IUserVirtuals {\r\n  readonly isActive: boolean;\r\n  readonly levelProgress: {\r\n    progress: number;\r\n    pointsToNext: number;\r\n    nextLevel: UserLevel | null;\r\n    currentLevel: UserLevel;\r\n    pointsForNext: number;\r\n  };\r\n  readonly activeDevice: IDevice;\r\n  readonly canClaim: boolean;\r\n}\r\n\r\nexport type IUserDocument = HydratedDocument<IUser, IUserMethods & IUserVirtuals>;\r\n\r\nexport interface IDevice {\r\n  deviceId: string;\r\n  platform: Platform;\r\n  fcmToken?: string;\r\n  model?: string;\r\n  osVersion?: string;\r\n  appVersion?: string;\r\n  userAgent?: string;\r\n  lastUsed: Date;\r\n  isActive: boolean;\r\n}\r\n\r\n// Prize related types\r\nexport interface IPrize extends BaseDocument {\r\n  name: string;\r\n  description: string;\r\n  type: PrizeType;\r\n  displayType: PrizeDisplayType;\r\n  contentType: PrizeContentType;\r\n  category: PrizeCategory;\r\n  points: number; // Legacy field, use pointsReward.amount instead\r\n  pointsReward?: {\r\n    amount: number;\r\n    bonusMultiplier?: number;\r\n  };\r\n  directReward?: {\r\n    rewardId: Types.ObjectId;\r\n    autoRedeem: boolean;\r\n    probability?: number; // For hybrid type (0-1)\r\n  };\r\n  rarity: PrizeRarity;\r\n  quantity: number;\r\n  claimedCount: number;\r\n  location: {\r\n    type: LocationType;\r\n    coordinates: [number, number]; // [lng, lat]\r\n    radius: number;\r\n    city: string;\r\n    address?: string;\r\n    markerUrl?: string;\r\n    confidenceThreshold?: number;\r\n  };\r\n  visibility: {\r\n    startAt: Date;\r\n    endAt?: Date;\r\n  };\r\n  expiresAt?: Date;\r\n  status: PrizeStatus;\r\n  createdBy: Types.ObjectId;\r\n  distributionId?: Types.ObjectId;\r\n  imageUrl?: string;\r\n  value?: number;\r\n  tags: string[];\r\n  capturedAt?: Date;\r\n  capturedBy?: Types.ObjectId;\r\n  metadata?: Metadata;\r\n}\r\n\r\n// Claim related types\r\nexport interface IClaim extends BaseDocument {\r\n  userId: Types.ObjectId;\r\n  prizeId: Types.ObjectId;\r\n  location: {\r\n    lat: number;\r\n    lng: number;\r\n    accuracy?: number;\r\n  };\r\n  distance: number;\r\n  pointsAwarded: number;\r\n  deviceSignals?: {\r\n    speed?: number;\r\n    mockLocation?: boolean;\r\n    attestationToken?: string;\r\n  };\r\n  validationChecks: {\r\n    distanceValid: boolean;\r\n    timeValid: boolean;\r\n    speedValid: boolean;\r\n    cooldownValid: boolean;\r\n    dailyLimitValid: boolean;\r\n  };\r\n  status?: 'pending' | 'approved' | 'rejected' | 'overridden';\r\n  riskScore?: number;\r\n  riskFactors?: string[];\r\n  flaggedAt?: Date;\r\n  adminNotes?: string;\r\n  overriddenBy?: Types.ObjectId;\r\n  overriddenAt?: Date;\r\n  antiCheatDetails?: Metadata;\r\n  idempotencyKey: string;\r\n  claimedAt: Date;\r\n  metadata?: Metadata;\r\n}\r\n\r\n// Reward related types\r\nexport interface IReward extends BaseDocument {\r\n  name: string;\r\n  description: string;\r\n  category: RewardCategory;\r\n  pointsCost: number;\r\n  stockQuantity: number;\r\n  stockReserved: number;\r\n  stockAvailable: number;\r\n  imageUrl?: string;\r\n  isActive: boolean;\r\n  isPopular: boolean;\r\n  partnerId?: Types.ObjectId;\r\n  metadata?: Metadata;\r\n  updatedBy?: Types.ObjectId;\r\n}\r\n\r\nexport interface IRedemption extends BaseDocument {\r\n  userId: Types.ObjectId;\r\n  rewardId: Types.ObjectId;\r\n  pointsSpent: number;\r\n  status: RedemptionStatus;\r\n  codeId?: Types.ObjectId;\r\n  redeemedAt: Date;\r\n  fulfilledAt?: Date;\r\n  redeemedBy?: Types.ObjectId;\r\n  idempotencyKey: string;\r\n  metadata?: Metadata;\r\n}\r\n\r\n// Code related types\r\nexport interface ICode extends BaseDocument {\r\n  code: string;\r\n  poolName?: string;  // Optional for promo codes\r\n  rewardId?: Types.ObjectId;  // Optional for promo codes\r\n  status: CodeStatus;\r\n  // Promo code specific fields\r\n  pointsValue?: number;\r\n  isActive?: boolean;\r\n  isUsed?: boolean;\r\n  reservedBy?: Types.ObjectId;\r\n  reservedAt?: Date;\r\n  usedBy?: Types.ObjectId;\r\n  usedAt?: Date;\r\n  expiresAt?: Date;\r\n  metadata?: Metadata;\r\n}\r\n\r\n// Notification related types\r\nexport interface INotification extends BaseDocument {\r\n  title: string;\r\n  message: string;\r\n  type: NotificationType;\r\n  targetType: NotificationTargetType;\r\n  targetValue?: string;\r\n  status: NotificationStatus;\r\n  scheduledFor?: Date;\r\n  sentAt?: Date;\r\n  createdBy: Types.ObjectId;\r\n  metadata?: Metadata;\r\n\r\n  // Production-level fields\r\n  priority?: number; // 1-5 priority level\r\n  expiresAt?: Date; // Notification expiration\r\n  deliveryMethod?: 'push' | 'email' | 'inapp' | 'all';\r\n  channelPreferences?: { // Override user channel preferences\r\n    push?: boolean;\r\n    email?: boolean;\r\n    inApp?: boolean;\r\n  };\r\n  statistics?: {\r\n    totalTargets: number;\r\n    deliveredCount: number;\r\n    openedCount: number;\r\n    clickedCount: number;\r\n  };\r\n  // User-specific fields (handled in UserNotification model but sometimes joined)\r\n  isRead?: boolean;\r\n  userId?: Types.ObjectId;\r\n}\r\n\r\n// Analytics related types\r\nexport interface IAnalytics extends BaseDocument {\r\n  date: Date;\r\n  metrics: {\r\n    totalUsers: number;\r\n    activeUsers: number;\r\n    newUsers: number;\r\n    totalPrizes: number;\r\n    claimedPrizes: number;\r\n    totalRewards: number;\r\n    redeemedRewards: number;\r\n    totalPoints: number;\r\n    averageSessionTime: number;\r\n    retentionRate: number;\r\n    conversionRate: number;\r\n  };\r\n  cityMetrics: Record<string, {\r\n    users: number;\r\n    claims: number;\r\n    redemptions: number;\r\n  }>;\r\n  generatedAt: Date;\r\n}\r\n\r\n// Distribution related types\r\nexport interface IDistribution extends BaseDocument {\r\n  name: string;\r\n  description: string;\r\n  targetArea: {\r\n    type: 'city' | 'polygon' | 'circle';\r\n    coordinates: number[][];\r\n    city?: string;\r\n    radius?: number;\r\n  };\r\n  prizeTemplate: {\r\n    name: string;\r\n    description: string;\r\n    type: PrizeType;\r\n    category: PrizeCategory;\r\n    points: number;\r\n    rarity: PrizeRarity;\r\n    imageUrl?: string;\r\n  };\r\n  quantity: number;\r\n  spacing: number;\r\n  status: DistributionStatus;\r\n  createdBy: Types.ObjectId;\r\n  undoExpiresAt?: Date;\r\n  metadata?: Metadata;\r\n}\r\n\r\n// Partner related types\r\nexport interface IPartner extends BaseDocument {\r\n  name: string;\r\n  description: string;\r\n  logoUrl?: string;\r\n  contactEmail: string;\r\n  contactPhone?: string;\r\n  website?: string;\r\n  isActive: boolean;\r\n  commissionRate: number;\r\n  metadata?: Metadata;\r\n}\r\n\r\n// Session related types\r\nexport interface ISession extends BaseDocument {\r\n  userId: Types.ObjectId;\r\n  deviceId: string;\r\n  sessionId: string;\r\n  startTime: Date;\r\n  endTime?: Date;\r\n  duration?: number;\r\n  isActive: boolean;\r\n  expiresAt: Date;\r\n  metadata?: Metadata;\r\n}\r\n\r\n// Audit log related types\r\nexport interface IAuditLog extends BaseDocument {\r\n  userId: Types.ObjectId;\r\n  action: string;\r\n  resource: string;\r\n  resourceId?: string;\r\n  details: Metadata;\r\n  ipAddress?: string;\r\n  userAgent?: string;\r\n  timestamp: Date;\r\n}\r\n\r\n// Settings related types\r\nexport interface ISettings extends BaseDocument {\n  key: string;\n  value: JSONValue;\n  type: SettingType;\n  description?: string;\n  isPublic: boolean;\n  updatedBy: Types.ObjectId;\n}\n\r\n// Enum types\r\nexport enum UserRole {\r\n  PLAYER = 'player',\r\n  ADMIN = 'admin',\r\n  MODERATOR = 'moderator',\r\n  SUPER_ADMIN = 'super_admin',\r\n  PARTNER = 'partner',\r\n}\r\n\r\nexport enum UserLevel {\r\n  BRONZE = 'bronze',\r\n  SILVER = 'silver',\r\n  GOLD = 'gold',\r\n  PLATINUM = 'platinum',\r\n  DIAMOND = 'diamond',\r\n}\r\n\r\nexport enum Platform {\r\n  IOS = 'iOS',\r\n  ANDROID = 'Android',\r\n  WEB = 'Web',\r\n}\r\n\r\nexport enum Language {\r\n  FR = 'fr',\r\n  AR = 'ar',\r\n  EN = 'en',\r\n}\r\n\r\nexport enum Theme {\r\n  LIGHT = 'light',\r\n  DARK = 'dark',\r\n}\r\n\r\n// Prize display type (how the prize appears in AR/UI)\r\nexport enum PrizeDisplayType {\r\n  STANDARD = 'standard',      // Standard prize with simple animation\r\n  MYSTERY_BOX = 'mystery_box', // Mystery box with surprise animation\r\n  TREASURE = 'treasure',      // Treasure chest animation\r\n  BONUS = 'bonus',           // Bonus/power-up animation\r\n  SPECIAL = 'special',       // Special event prize\r\n}\r\n\r\n// Prize content type (what the prize actually contains)\r\nexport enum PrizeContentType {\r\n  POINTS = 'points',         // Pure points reward\r\n  REWARD = 'reward',         // Direct reward (coupon, gift)\r\n  HYBRID = 'hybrid',         // Points + chance for reward\r\n}\r\n\r\n// Legacy type for backward compatibility\r\nexport enum PrizeType {\n  PHYSICAL = 'physical',\n  DIGITAL = 'digital',\n  VOUCHER = 'voucher',\n  MYSTERY = 'mystery',\n  STANDARD = 'standard',\n  GEO_CRYPTO = 'geo_crypto',\n  NFT = 'nft',\n  COUPON = 'coupon',\n}\n\r\nexport enum PrizeCategory {\r\n  ELECTRONICS = 'electronics',\r\n  GAMING = 'gaming',\r\n  LIFESTYLE = 'lifestyle',\r\n  SHOPPING = 'shopping',\r\n  FOOD = 'food',\r\n  ENTERTAINMENT = 'entertainment',\r\n}\r\n\r\nexport enum PrizeRarity {\r\n  COMMON = 'common',\r\n  UNCOMMON = 'uncommon',\r\n  RARE = 'rare',\r\n  EPIC = 'epic',\r\n  LEGENDARY = 'legendary',\r\n}\r\n\r\nexport enum PrizeStatus {\r\n  ACTIVE = 'active',\r\n  CAPTURED = 'captured',\r\n  EXPIRED = 'expired',\r\n  INACTIVE = 'inactive',\r\n  REVOKED = 'revoked',\r\n}\r\n\r\nexport enum LocationType {\r\n  GPS = 'gps',\r\n  MARKER = 'marker',\r\n}\r\n\r\nexport enum RewardCategory {\n  VOUCHER = 'voucher',\n  GIFT_CARD = 'gift_card',\n  PHYSICAL = 'physical',\n  DIGITAL = 'digital',\n  EXPERIENCE = 'experience',\n  DISCOUNT = 'discount',\n  COUPON = 'coupon',\n  CASHBACK = 'cashback',\n  POINTS = 'points',\n  MERCHANDISE = 'merchandise',\n  SERVICE = 'service',\n  SUBSCRIPTION = 'subscription',\n  FOOD = 'food',\n  TRAVEL = 'travel',\n  ENTERTAINMENT = 'entertainment',\n  OTHER = 'other',\n}\n\r\nexport enum RedemptionStatus {\r\n  PENDING = 'pending',\r\n  FULFILLED = 'fulfilled',\r\n  CANCELLED = 'cancelled',\r\n  FAILED = 'failed',\r\n}\r\n\r\nexport enum CodeStatus {\r\n  AVAILABLE = 'available',\r\n  RESERVED = 'reserved',\r\n  USED = 'used',\r\n  EXPIRED = 'expired',\r\n}\r\n\r\nexport enum NotificationType {\r\n  PUSH = 'push',\r\n  EMAIL = 'email',\r\n  SMS = 'sms',\r\n  IN_APP = 'in_app',\r\n}\r\n\r\nexport enum NotificationTargetType {\r\n  ALL = 'all',\r\n  USER = 'user',\r\n  CITY = 'city',\r\n  LEVEL = 'level',\r\n  ROLE = 'role',\r\n}\r\n\r\nexport enum NotificationStatus {\r\n  DRAFT = 'draft',\r\n  SCHEDULED = 'scheduled',\r\n  SENT = 'sent',\r\n  FAILED = 'failed',\r\n  CANCELLED = 'cancelled',\r\n}\r\n\r\nexport enum DistributionStatus {\r\n  DRAFT = 'draft',\r\n  ACTIVE = 'active',\r\n  COMPLETED = 'completed',\r\n  CANCELLED = 'cancelled',\r\n}\r\n\r\nexport enum SettingType {\r\n  STRING = 'string',\r\n  NUMBER = 'number',\r\n  BOOLEAN = 'boolean',\r\n  JSON = 'json',\r\n}\r\n\r\nexport enum AchievementTrigger {\n  PRIZE_CLAIMED = 'PRIZE_CLAIMED',\n  LEVEL_UP = 'LEVEL_UP',\n  REWARD_REDEEMED = 'REWARD_REDEEMED',\n  FRIEND_ADDED = 'FRIEND_ADDED',\n  STREAK_MILESTONE = 'STREAK_MILESTONE',\n  DISTANCE_MILESTONE = 'DISTANCE_MILESTONE',\n  MANUAL = 'MANUAL',\n}\n\nexport type AchievementRewardType = 'POINTS' | 'POWER_UP' | 'COSMETIC' | 'TITLE' | 'BADGE';\n\nexport type AchievementReward =\n  | { type: 'POINTS'; value: number; description: string }\n  | { type: 'POWER_UP'; value: { powerUpId: string; durationMs?: number }; description: string }\n  | { type: 'COSMETIC'; value: string; description: string }\n  | { type: 'TITLE'; value: string; description: string }\n  | { type: 'BADGE'; value: string; description: string };\n\r\n// API Request/Response types\r\nexport interface PaginationQuery {\r\n  page?: number;\r\n  limit?: number;\r\n  sort?: string;\r\n  order?: 'asc' | 'desc';\r\n}\r\n\r\nexport interface PaginatedResponse<T> {\r\n  data: T[];\r\n  pagination: {\r\n    page: number;\r\n    limit: number;\r\n    total: number;\r\n    pages: number;\r\n    hasNext: boolean;\r\n    hasPrev: boolean;\r\n  };\r\n}\r\n\r\nexport interface ApiResponse<T = JSONValue> {\n  success: boolean;\n  data?: T;\n  message?: string;\n  error?: string;\n  timestamp: string;\n}\n\r\nexport interface ErrorResponse {\r\n  success: false;\r\n  error: string;\r\n  message: string;\r\n  code?: string;\r\n  details?: Metadata;\r\n  timestamp: string;\r\n}\r\n\r\n// Geolocation types\r\nexport interface Coordinates {\r\n  lat: number;\r\n  lng: number;\r\n}\r\n\r\nexport interface BoundingBox {\r\n  north: number;\r\n  south: number;\r\n  east: number;\r\n  west: number;\r\n}\r\n\r\nexport interface GeofenceArea {\r\n  center: Coordinates;\r\n  radius: number;\r\n}\r\n\r\n// Game mechanics types\r\nexport interface LevelRequirements {\r\n  level: UserLevel;\r\n  pointsRequired: number;\r\n  benefits: string[];\r\n}\r\n\r\nexport interface DailyChallenge {\r\n  id: string;\r\n  title: string;\r\n  description: string;\r\n  target: number;\r\n  reward: number;\r\n  type: 'claims' | 'distance' | 'time' | 'city';\r\n  expiresAt: Date;\r\n}\r\n\r\nexport interface Achievement {\n  id: string;\n  title: string;\n  description: string;\n  icon: string;\n  requirement: Metadata;\n  rewards: AchievementReward[];\n  isSecret: boolean;\n}\n\r\n// External service types\r\nexport interface FCMNotification {\r\n  title: string;\r\n  body: string;\r\n  data?: Record<string, string>;\r\n  tokens: string[];\r\n}\r\n\r\nexport interface EmailData {\r\n  to: string[];\r\n  subject: string;\r\n  html: string;\r\n  text?: string;\r\n  attachments?: Metadata[];\r\n}\r\n\r\nexport interface SMSData {\r\n  to: string;\r\n  message: string;\r\n}\r\n\r\n// Validation types\r\nexport interface ValidationError {\n  field: string;\n  message: string;\n  value?: JSONValue;\n}\n\r\nexport interface ValidationResult {\r\n  isValid: boolean;\r\n  errors: ValidationError[];\r\n}\r\n\r\n// Cache types\r\nexport interface CacheOptions {\r\n  ttl?: number;\r\n  tags?: string[];\r\n}\r\n\r\nexport interface CacheEntry<T> {\r\n  value: T;\r\n  expiresAt: number;\r\n  tags: string[];\r\n}\r\n\r\n// Rate limiting types\r\nexport interface RateLimitResult {\r\n  allowed: boolean;\r\n  remaining: number;\r\n  resetTime: number;\r\n  limit: number;\r\n}\r\n\r\n// Metrics types\r\nexport interface PerformanceMetrics {\r\n  operation: string;\r\n  duration: number;\r\n  success: boolean;\r\n  timestamp: Date;\r\n  metadata?: Metadata;\r\n}\r\n\r\nexport interface BusinessMetrics {\r\n  event: string;\r\n  category: string;\r\n  value?: number;\r\n  userId?: string;\r\n  timestamp: Date;\r\n  metadata?: Metadata;\r\n}\r\n\r\n// File upload types\r\nexport interface UploadedFile {\r\n  filename: string;\r\n  originalName: string;\r\n  mimeType: string;\r\n  size: number;\r\n  url: string;\r\n  path: string;\r\n}\r\n\r\n// Webhook types\r\nexport interface WebhookPayload {\r\n  event: string;\r\n  data: Metadata;\r\n  timestamp: string;\r\n  signature: string;\r\n}\r\n\r\n// Export utility types\r\nexport type DeepPartial<T> = {\r\n  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];\r\n};\r\n\r\nexport type RequiredFields<T, K extends keyof T> = T & Required<Pick<T, K>>;\r\n\r\nexport type OptionalFields<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\r\n\r\nexport type UpdateFields<T> = DeepPartial<Omit<T, '_id' | 'createdAt' | 'updatedAt'>>;\r\n\r\nexport type CreateFields<T> = Omit<T, '_id' | 'createdAt' | 'updatedAt'>;\r\n\r\n// Database query types\r\nexport interface QueryOptions {\r\n  select?: string;\r\n  populate?: string | string[];\r\n  sort?: string | Record<string, 1 | -1>;\r\n  limit?: number;\r\n  skip?: number;\r\n  lean?: boolean;\r\n}\r\n\r\nexport interface AggregationPipeline {\r\n  $match?: Metadata;\r\n  $group?: Metadata;\r\n  $sort?: Record<string, 1 | -1>;\r\n  $limit?: number;\r\n  $skip?: number;\r\n  $project?: Metadata;\r\n  $lookup?: Metadata;\r\n  $unwind?: string | Metadata;\r\n}\r\n\r\n// Model extensions\r\nexport interface IPrizeDocument extends IPrize, Document {\r\n  isAvailable: boolean;\r\n  isActive: boolean;\r\n  isExpired: boolean;\r\n  remainingQuantity: number;\r\n  claimRate: number;\r\n  rarityWeight: number;\r\n  estimatedValue: number;\r\n  findNearestCity(): string;\r\n  calculateDistance(lat1: number, lng1: number, lat2: number, lng2: number): number;\r\n  isWithinRadius(lat: number, lng: number): boolean;\r\n  claim(userId: Types.ObjectId): boolean;\r\n  activate(): void;\r\n  deactivate(): void;\r\n  revoke(): void;\r\n  extend(hours: number): void;\r\n  updateLocation(lat: number, lng: number, radius?: number): void;\r\n}\r\n\r\nexport interface IPrizeModel extends Model<IPrize> {\r\n  findNearby(lat: number, lng: number, radiusKm?: number, options?: QueryOptions & Metadata): Promise<IPrizeDocument[]>;\r\n  findByCity(city: string, options?: QueryOptions & Metadata): Promise<IPrizeDocument[]>;\r\n  findExpired(): Promise<IPrizeDocument[]>;\r\n  findByDistribution(distributionId: Types.ObjectId): Promise<IPrizeDocument[]>;\r\n  getStatsByCity(): Promise<PrizeCityStats[]>;\r\n  getHeatmapData(city?: string): Promise<PrizeHeatmapPoint[]>;\r\n  cleanupExpired(): Promise<PrizeCleanupResult>;\r\n}\r\n\r\nexport interface IUserModel extends Model<IUser, {}, IUserMethods, IUserVirtuals> {\r\n  findByEmail(email: string): Promise<IUserDocument | null>;\r\n  findByDeviceId(deviceId: string): Promise<IUserDocument | null>;\r\n  findActiveUsers(days?: number): Promise<IUserDocument[]>;\r\n  getLeaderboard(city?: string, limit?: number): Promise<IUserDocument[]>;\r\n  getUserStats(): Promise<Metadata>;\r\n  getPointsForLevel(level: UserLevel): number;\r\n}\r\n\r\n// Event types\r\nexport interface GameEvent {\r\n  type: string;\r\n  userId: string;\r\n  data: Metadata;\r\n  timestamp: Date;\r\n}\r\n\r\nexport interface SystemEvent {\r\n  type: string;\r\n  severity: 'low' | 'medium' | 'high' | 'critical';\r\n  message: string;\r\n  data: Metadata;\r\n  timestamp: Date;\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\types\\pino-custom-levels.d.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'pino' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CustomLevels' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":20,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":32}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import pino from 'pino';\n\n// Extend Pino's Logger interface to include custom log levels\ndeclare module 'pino' {\n  interface Logger<CustomLevels extends string = never> {\n    audit: LogFn;\n    security: LogFn;\n    performance: LogFn;\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\utils\\anti-cheat.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'logger' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'calculateSpeed' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":51},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'location' is defined but never used. Allowed unused args must match /^_/u.","line":544,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":544,"endColumn":24}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { RedisCache, RedisRateLimit, redisClient } from '@/config/redis';\nimport { config, GAME_CONSTANTS } from '@/config';\nimport { logger, logSecurity } from '@/lib/logger';\nimport { typedLogger } from '@/lib/typed-logger';\nimport { calculateGeodesicDistance, calculateSpeed, msToKmh } from './geo';\nimport { Coordinates, ErrorLike, Metadata } from '@/types';\n\n// Anti-cheat configuration\nconst ANTI_CHEAT_CONFIG = {\n  MAX_SPEED_MS: GAME_CONSTANTS.MAX_SPEED_MS,\n  GLOBAL_COOLDOWN_MS: GAME_CONSTANTS.COOLDOWN_MS,\n  CITY_COOLDOWN_MS: 30 * 1000, // 30 seconds between claims in same city\n  MAX_CLAIMS_PER_HOUR: 20,\n  MAX_CLAIMS_PER_DAY: GAME_CONSTANTS.MAX_DAILY_CLAIMS,\n  SUSPICIOUS_SPEED_THRESHOLD: 50, // m/s (180 km/h)\n  TELEPORT_THRESHOLD: 1000, // meters\n  MIN_TIME_BETWEEN_LOCATIONS: 5, // seconds\n  MAX_LOCATION_ACCURACY: 100, // meters\n} as const;\n\n// Device signals interface\nexport interface DeviceSignals {\n  speed?: number;\n  mockLocation?: boolean;\n  attestationToken?: string;\n  accuracy?: number;\n  provider?: string;\n  timestamp?: Date;\n}\n\n// Location history entry\ninterface LocationEntry {\n  lat: number;\n  lng: number;\n  timestamp: Date;\n  accuracy?: number;\n}\n\ntype StoredLocationEntry = {\n  lat: number;\n  lng: number;\n  timestamp: string;\n  accuracy?: number;\n};\n\n// Anti-cheat violation types\nexport enum ViolationType {\n  SPEED_VIOLATION = 'speed_violation',\n  MOCK_LOCATION = 'mock_location',\n  TELEPORTATION = 'teleportation',\n  RAPID_CLAIMS = 'rapid_claims',\n  COOLDOWN_VIOLATION = 'cooldown_violation',\n  DAILY_LIMIT_EXCEEDED = 'daily_limit_exceeded',\n  SUSPICIOUS_PATTERN = 'suspicious_pattern',\n  INVALID_ATTESTATION = 'invalid_attestation',\n  POOR_ACCURACY = 'poor_accuracy',\n}\n\n// Anti-cheat result\nexport interface AntiCheatResult {\n  allowed: boolean;\n  violations: ViolationType[];\n  riskScore: number;\n  details: Metadata;\n}\n\ninterface AntiCheatCheckResult {\n  valid: boolean;\n  riskScore: number;\n  details: Metadata;\n}\n\ninterface PatternAnalysisResult {\n  regularityScore: number;\n  impossibleTravelCount: number;\n  unusualLocationScore: number;\n  timeAnomalyScore: number;\n  totalLocations?: number;\n  averageDistance?: number;\n  averageSpeed?: number;\n}\n\nconst getErrorMessage = (error: ErrorLike) =>\n  error instanceof Error ? error.message : typeof error === 'string' ? error : error.message || 'Unknown error';\n\n/**\n * Comprehensive anti-cheat validation\n */\nexport async function validateAntiCheat(\n  userId: string,\n  location: Coordinates,\n  deviceSignals?: DeviceSignals\n): Promise<AntiCheatResult> {\n  const violations: ViolationType[] = [];\n  const details: Metadata = {};\n  let riskScore = 0;\n\n  try {\n    // 1. Speed validation\n    const speedResult = await validateSpeed(userId, location, deviceSignals);\n    if (!speedResult.valid) {\n      violations.push(ViolationType.SPEED_VIOLATION);\n      riskScore += speedResult.riskScore;\n      details.speed = speedResult.details;\n    }\n\n    // 2. Mock location detection\n    const mockResult = await validateMockLocation(deviceSignals);\n    if (!mockResult.valid) {\n      violations.push(ViolationType.MOCK_LOCATION);\n      riskScore += mockResult.riskScore;\n      details.mockLocation = mockResult.details;\n    }\n\n    // 3. Teleportation detection\n    const teleportResult = await validateTeleportation(userId, location);\n    if (!teleportResult.valid) {\n      violations.push(ViolationType.TELEPORTATION);\n      riskScore += teleportResult.riskScore;\n      details.teleportation = teleportResult.details;\n    }\n\n    // 4. Rapid claims detection\n    const rapidResult = await validateRapidClaims(userId);\n    if (!rapidResult.valid) {\n      violations.push(ViolationType.RAPID_CLAIMS);\n      riskScore += rapidResult.riskScore;\n      details.rapidClaims = rapidResult.details;\n    }\n\n    // 4b. Daily limit enforcement\n    const dailyLimitResult = await validateDailyLimit(userId);\n    if (!dailyLimitResult.valid) {\n      violations.push(ViolationType.DAILY_LIMIT_EXCEEDED);\n      riskScore += dailyLimitResult.riskScore;\n      details.dailyLimit = dailyLimitResult.details;\n    }\n\n    // 5. Location accuracy validation\n    const accuracyResult = await validateLocationAccuracy(deviceSignals);\n    if (!accuracyResult.valid) {\n      violations.push(ViolationType.POOR_ACCURACY);\n      riskScore += accuracyResult.riskScore;\n      details.accuracy = accuracyResult.details;\n    }\n\n    // 6. Device attestation validation (required or optional)\n    const attestationResult = await validateDeviceAttestation(deviceSignals?.attestationToken);\n    if (!attestationResult.valid) {\n      violations.push(ViolationType.INVALID_ATTESTATION);\n      riskScore += attestationResult.riskScore;\n      details.attestation = attestationResult.details;\n    }\n\n    // 7. Pattern analysis\n    const patternResult = await analyzeUserPatterns(userId, location);\n    if (!patternResult.valid) {\n      violations.push(ViolationType.SUSPICIOUS_PATTERN);\n      riskScore += patternResult.riskScore;\n      details.patterns = patternResult.details;\n    }\n\n    // Store location history\n    await storeLocationHistory(userId, location, deviceSignals);\n\n    // Log security event if violations found\n    if (violations.length > 0) {\n      logSecurity('anti_cheat_violation', 'medium', {\n        userId,\n        violations,\n        riskScore,\n        location,\n        deviceSignals,\n      });\n    }\n\n    const allowed = violations.length === 0 && riskScore < 20;\n\n    return {\n      allowed,\n      violations,\n      riskScore,\n      details,\n    };\n\n  } catch (error) {\n    typedLogger.error('Anti-cheat validation error', {\n      error: getErrorMessage(error),\n      userId,\n      location,\n    });\n\n    // Fail secure - deny on error\n    return {\n      allowed: false,\n      violations: [ViolationType.SUSPICIOUS_PATTERN],\n      riskScore: 100,\n      details: { error: 'Validation failed' },\n    };\n  }\n}\n\n/**\n * Validate global and per-city cooldowns for claiming.\n * Throws Error('COOLDOWN_ACTIVE') when cooldown active.\n */\nexport async function validateCooldowns(userId: string, city?: string): Promise<void> {\n  try {\n    const now = Date.now();\n    const windowMs = ANTI_CHEAT_CONFIG.GLOBAL_COOLDOWN_MS;\n    const keyGlobal = `cooldown:global:${userId}`;\n    const keyCity = city ? `cooldown:city:${userId}:${city}` : undefined;\n\n    const [globalExists, cityExists] = await Promise.all([\n      RedisCache.exists(keyGlobal),\n      keyCity ? RedisCache.exists(keyCity) : Promise.resolve(false),\n    ]);\n\n    if (globalExists || cityExists) {\n      throw new Error('COOLDOWN_ACTIVE');\n    }\n\n    // Set cooldowns\n    const ttlSeconds = Math.ceil(windowMs / 1000);\n    await RedisCache.set(keyGlobal, { at: now }, ttlSeconds);\n    if (keyCity) {\n      await RedisCache.set(keyCity, { at: now }, Math.ceil(ANTI_CHEAT_CONFIG.CITY_COOLDOWN_MS / 1000));\n    }\n  } catch (error) {\n    if (error instanceof Error && error.message === 'COOLDOWN_ACTIVE') {\n      throw error;\n    }\n    typedLogger.error('Cooldown validation error', { error: getErrorMessage(error), userId, city });\n    throw new Error('COOLDOWN_ACTIVE');\n  }\n}\n\n/**\n * Validate movement speed\n */\nasync function validateSpeed(\n  userId: string,\n  location: Coordinates,\n  deviceSignals?: DeviceSignals\n): Promise<AntiCheatCheckResult> {\n  try {\n    // Check device-reported speed first\n    if (deviceSignals?.speed && deviceSignals.speed > ANTI_CHEAT_CONFIG.MAX_SPEED_MS) {\n      return {\n        valid: false,\n        riskScore: 30,\n        details: {\n          reportedSpeed: msToKmh(deviceSignals.speed),\n          maxAllowed: msToKmh(ANTI_CHEAT_CONFIG.MAX_SPEED_MS),\n          source: 'device_reported',\n        },\n      };\n    }\n\n    // Calculate speed from location history\n    const lastLocation = await getLastLocation(userId);\n    if (lastLocation) {\n      const timeDiff = (Date.now() - lastLocation.timestamp.getTime()) / 1000; // seconds\n      \n      if (timeDiff < ANTI_CHEAT_CONFIG.MIN_TIME_BETWEEN_LOCATIONS) {\n        return {\n          valid: false,\n          riskScore: 20,\n          details: {\n            timeDiff,\n            minRequired: ANTI_CHEAT_CONFIG.MIN_TIME_BETWEEN_LOCATIONS,\n            reason: 'too_frequent',\n          },\n        };\n      }\n\n      const distance = calculateGeodesicDistance(location, lastLocation);\n      const calculatedSpeed = distance / timeDiff;\n\n      if (calculatedSpeed > ANTI_CHEAT_CONFIG.MAX_SPEED_MS) {\n        return {\n          valid: false,\n          riskScore: calculatedSpeed > ANTI_CHEAT_CONFIG.SUSPICIOUS_SPEED_THRESHOLD ? 50 : 30,\n          details: {\n            calculatedSpeed: msToKmh(calculatedSpeed),\n            maxAllowed: msToKmh(ANTI_CHEAT_CONFIG.MAX_SPEED_MS),\n            distance,\n            timeDiff,\n            source: 'calculated',\n          },\n        };\n      }\n    }\n\n    return { valid: true, riskScore: 0, details: {} };\n  } catch (error) {\n    typedLogger.error('Speed validation error', { error: getErrorMessage(error), userId });\n    return { valid: false, riskScore: 25, details: { error: 'validation_failed' } };\n  }\n}\n\n/**\n * Validate mock location detection\n */\nasync function validateMockLocation(\n  deviceSignals?: DeviceSignals\n): Promise<AntiCheatCheckResult> {\n  if (deviceSignals?.mockLocation === true) {\n    return {\n      valid: false,\n      riskScore: 40,\n      details: {\n        detected: true,\n        source: 'device_reported',\n      },\n    };\n  }\n\n  // Additional heuristics for mock location detection\n  const suspiciousIndicators = [];\n\n  if (deviceSignals?.provider === 'network' && deviceSignals?.accuracy && deviceSignals.accuracy < 5) {\n    suspiciousIndicators.push('perfect_network_accuracy');\n  }\n\n  if (deviceSignals?.accuracy === 0) {\n    suspiciousIndicators.push('zero_accuracy');\n  }\n\n  if (suspiciousIndicators.length > 0) {\n    return {\n      valid: false,\n      riskScore: 20,\n      details: {\n        indicators: suspiciousIndicators,\n        source: 'heuristic',\n      },\n    };\n  }\n\n  return { valid: true, riskScore: 0, details: {} };\n}\n\n/**\n * Validate daily claims limit using Redis counters\n */\nasync function validateDailyLimit(userId: string): Promise<AntiCheatCheckResult> {\n  try {\n    const now = new Date();\n    const y = now.getUTCFullYear();\n    const m = String(now.getUTCMonth() + 1).padStart(2, '0');\n    const d = String(now.getUTCDate()).padStart(2, '0');\n    const key = `daily_claims:${userId}:${y}${m}${d}`;\n\n    const ttlMsToMidnight = (() => {\n      const tomorrow = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() + 1));\n      return Math.max(1, Math.floor((tomorrow.getTime() - now.getTime()) / 1000));\n    })();\n\n    const count = await RedisCache.incr(key, ttlMsToMidnight);\n    const limit = ANTI_CHEAT_CONFIG.MAX_CLAIMS_PER_DAY;\n    if (count > limit) {\n      return {\n        valid: false,\n        riskScore: 30,\n        details: { count, limit },\n      };\n    }\n    return { valid: true, riskScore: 0, details: { count, limit } };\n  } catch (error) {\n    typedLogger.error('Daily limit validation error', { error: getErrorMessage(error), userId });\n    // Fail-open here; anti-cheat overall will still include other checks\n    return { valid: true, riskScore: 0, details: { error: 'validation_failed' } };\n  }\n}\n\n/**\n * Validate teleportation (impossible movement)\n */\nasync function validateTeleportation(\n  userId: string,\n  location: Coordinates\n): Promise<AntiCheatCheckResult> {\n  try {\n    const lastLocation = await getLastLocation(userId);\n    if (!lastLocation) {\n      return { valid: true, riskScore: 0, details: {} };\n    }\n\n    const distance = calculateGeodesicDistance(location, lastLocation);\n    const timeDiff = (Date.now() - lastLocation.timestamp.getTime()) / 1000;\n\n    // Check for teleportation (large distance, short time)\n    if (distance > ANTI_CHEAT_CONFIG.TELEPORT_THRESHOLD && timeDiff < 60) {\n      return {\n        valid: false,\n        riskScore: 45,\n        details: {\n          distance,\n          timeDiff,\n          threshold: ANTI_CHEAT_CONFIG.TELEPORT_THRESHOLD,\n          reason: 'teleportation',\n        },\n      };\n    }\n\n    return { valid: true, riskScore: 0, details: {} };\n  } catch (error) {\n    typedLogger.error('Teleportation validation error', { error: getErrorMessage(error), userId });\n    return { valid: false, riskScore: 25, details: { error: 'validation_failed' } };\n  }\n}\n\n/**\n * Validate rapid claims\n */\nasync function validateRapidClaims(\n  userId: string\n): Promise<AntiCheatCheckResult> {\n  try {\n    // Check hourly rate limit\n    const hourlyResult = await RedisRateLimit.checkLimit(\n      'claims_hourly',\n      ANTI_CHEAT_CONFIG.MAX_CLAIMS_PER_HOUR,\n      60 * 60 * 1000, // 1 hour\n      userId\n    );\n\n    if (!hourlyResult.allowed) {\n      return {\n        valid: false,\n        riskScore: 35,\n        details: {\n          type: 'hourly_limit',\n          limit: ANTI_CHEAT_CONFIG.MAX_CLAIMS_PER_HOUR,\n          remaining: hourlyResult.remaining,\n          resetTime: hourlyResult.resetTime,\n        },\n      };\n    }\n\n    // Check daily rate limit\n    const dailyResult = await RedisRateLimit.checkLimit(\n      'claims_daily',\n      ANTI_CHEAT_CONFIG.MAX_CLAIMS_PER_DAY,\n      24 * 60 * 60 * 1000, // 24 hours\n      userId\n    );\n\n    if (!dailyResult.allowed) {\n      return {\n        valid: false,\n        riskScore: 25,\n        details: {\n          type: 'daily_limit',\n          limit: ANTI_CHEAT_CONFIG.MAX_CLAIMS_PER_DAY,\n          remaining: dailyResult.remaining,\n          resetTime: dailyResult.resetTime,\n        },\n      };\n    }\n\n    return { valid: true, riskScore: 0, details: {} };\n  } catch (error) {\n    typedLogger.error('Rapid claims validation error', { error: getErrorMessage(error), userId });\n    return { valid: false, riskScore: 25, details: { error: 'validation_failed' } };\n  }\n}\n\n/**\n * Validate location accuracy\n */\nasync function validateLocationAccuracy(\n  deviceSignals?: DeviceSignals\n): Promise<AntiCheatCheckResult> {\n  if (!deviceSignals?.accuracy) {\n    return { valid: true, riskScore: 0, details: {} };\n  }\n\n  if (deviceSignals.accuracy > ANTI_CHEAT_CONFIG.MAX_LOCATION_ACCURACY) {\n    return {\n      valid: false,\n      riskScore: 15,\n      details: {\n        accuracy: deviceSignals.accuracy,\n        maxAllowed: ANTI_CHEAT_CONFIG.MAX_LOCATION_ACCURACY,\n        reason: 'poor_accuracy',\n      },\n    };\n  }\n\n  return { valid: true, riskScore: 0, details: {} };\n}\n\n/**\n * Validate device attestation (iOS DeviceCheck / Android SafetyNet)\n */\nasync function validateDeviceAttestation(\n  attestationToken?: string\n): Promise<AntiCheatCheckResult> {\n  try {\n    if (!config.DEVICE_ATTESTATION_REQUIRED) {\n      return { valid: true, riskScore: 0, details: { mode: 'not_required' } };\n    }\n\n    if (!attestationToken) {\n      return { valid: false, riskScore: 35, details: { reason: 'missing_token' } };\n    }\n\n    const parts = attestationToken.split('.');\n    const looksJwtLike = parts.length === 3;\n    const longEnough = attestationToken.length > 100;\n\n    if (!looksJwtLike || !longEnough) {\n      return {\n        valid: false,\n        riskScore: 35,\n        details: { reason: 'invalid_token_format' },\n      };\n    }\n\n    try {\n      const payload = JSON.parse(Buffer.from(parts[1], 'base64').toString('utf8'));\n      if (!payload || typeof payload !== 'object') {\n        return { valid: false, riskScore: 35, details: { reason: 'invalid_payload' } };\n      }\n    } catch {\n      return { valid: false, riskScore: 35, details: { reason: 'invalid_payload' } };\n    }\n\n    typedLogger.warn('Device attestation required but verification is not implemented');\n    return { valid: false, riskScore: 50, details: { reason: 'attestation_unverified' } };\n  } catch (error) {\n    typedLogger.error('Attestation validation error', { error: getErrorMessage(error) });\n    return { valid: false, riskScore: 15, details: { error: 'validation_failed' } };\n  }\n}\n\n/**\n * Analyze user behavior patterns\n */\nasync function analyzeUserPatterns(\n  userId: string,\n  location: Coordinates\n): Promise<AntiCheatCheckResult> {\n  try {\n    const patterns = await getUserPatterns(userId);\n    const suspiciousIndicators = [];\n    let riskScore = 0;\n\n    // Check for perfectly regular patterns (bot-like behavior)\n    if (patterns.regularityScore > 0.95) {\n      suspiciousIndicators.push('too_regular');\n      riskScore += 20;\n    }\n\n    // Check for impossible travel patterns\n    if (patterns.impossibleTravelCount > 3) {\n      suspiciousIndicators.push('impossible_travel');\n      riskScore += 25;\n    }\n\n    // Check for clustering in unusual locations\n    if (patterns.unusualLocationScore > 0.8) {\n      suspiciousIndicators.push('unusual_locations');\n      riskScore += 15;\n    }\n\n    // Check for time pattern anomalies\n    if (patterns.timeAnomalyScore > 0.7) {\n      suspiciousIndicators.push('time_anomalies');\n      riskScore += 10;\n    }\n\n    return {\n      valid: riskScore < 30,\n      riskScore,\n      details: {\n        indicators: suspiciousIndicators,\n        patterns,\n      },\n    };\n  } catch (error) {\n    typedLogger.error('Pattern analysis error', { error: getErrorMessage(error), userId });\n    return { valid: true, riskScore: 0, details: {} };\n  }\n}\n\n\n\n/**\n * Store location history for analysis\n */\nasync function storeLocationHistory(\n  userId: string,\n  location: Coordinates,\n  deviceSignals?: DeviceSignals\n): Promise<void> {\n  const entry: StoredLocationEntry = {\n    lat: location.lat,\n    lng: location.lng,\n    timestamp: new Date().toISOString(),\n    accuracy: deviceSignals?.accuracy,\n  };\n\n  // Store in Redis with TTL\n  await RedisCache.lpush(`location_history:${userId}`, entry, 24 * 60 * 60); // 24 hours\n\n  // Keep only last 50 locations\n  const history = await RedisCache.lrange(`location_history:${userId}`, 0, 49);\n  if (history.length > 50) {\n    await RedisCache.del(`location_history:${userId}`);\n    await Promise.all(\n      history.slice(0, 50).map(entry => \n        RedisCache.lpush(`location_history:${userId}`, entry, 24 * 60 * 60)\n      )\n    );\n  }\n}\n\n/**\n * Get last known location\n */\nasync function getLastLocation(userId: string): Promise<LocationEntry | null> {\n  const history = await RedisCache.lrange<StoredLocationEntry>(`location_history:${userId}`, 0, 0);\n  const normalized = history[0] ? normalizeLocationEntry(history[0]) : null;\n  return normalized;\n}\n\n/**\n * Get user behavior patterns\n */\nasync function getUserPatterns(userId: string): Promise<PatternAnalysisResult> {\n  const historyRaw = await RedisCache.lrange<StoredLocationEntry>(`location_history:${userId}`, 0, -1);\n  const history = historyRaw\n    .map(normalizeLocationEntry)\n    .filter((entry): entry is LocationEntry => !!entry);\n  \n  if (history.length < 5) {\n    return {\n      regularityScore: 0,\n      impossibleTravelCount: 0,\n      unusualLocationScore: 0,\n      timeAnomalyScore: 0,\n    };\n  }\n\n  // Analyze patterns (simplified implementation)\n  let impossibleTravelCount = 0;\n  let totalDistance = 0;\n  let totalTime = 0;\n\n  for (let i = 1; i < history.length; i++) {\n    const prev = history[i - 1];\n    const curr = history[i];\n    \n    const distance = calculateGeodesicDistance(prev, curr);\n    const timeDiff = (curr.timestamp.getTime() - prev.timestamp.getTime()) / 1000;\n    \n    if (timeDiff > 0) {\n      const speed = distance / timeDiff;\n      if (speed > ANTI_CHEAT_CONFIG.SUSPICIOUS_SPEED_THRESHOLD) {\n        impossibleTravelCount++;\n      }\n      \n      totalDistance += distance;\n      totalTime += timeDiff;\n    }\n  }\n\n  // Calculate regularity (simplified)\n  const distances = [];\n  for (let i = 1; i < history.length; i++) {\n    distances.push(calculateGeodesicDistance(history[i - 1], history[i]));\n  }\n  \n  const avgDistance = distances.reduce((a, b) => a + b, 0) / distances.length;\n  const variance = distances.reduce((a, b) => a + Math.pow(b - avgDistance, 2), 0) / distances.length;\n  const regularityScore = variance === 0 ? 1 : Math.max(0, 1 - (Math.sqrt(variance) / avgDistance));\n\n  return {\n    regularityScore,\n    impossibleTravelCount,\n    unusualLocationScore: 0, // TODO: Implement location clustering analysis\n    timeAnomalyScore: 0, // TODO: Implement time pattern analysis\n    totalLocations: history.length,\n    averageDistance: avgDistance,\n    averageSpeed: totalTime > 0 ? totalDistance / totalTime : 0,\n  };\n}\n\n/**\n * Get anti-cheat statistics for monitoring\n */\nexport async function getAntiCheatStats(): Promise<Metadata> {\n  // This would return aggregated statistics about anti-cheat violations\n  // for monitoring and tuning purposes\n  \n  return {\n    totalViolations: 0,\n    violationsByType: {},\n    averageRiskScore: 0,\n    falsePositiveRate: 0,\n    // TODO: Implement actual statistics collection\n  };\n}\n\n/**\n * Reset user anti-cheat data (for testing or appeals)\n */\nexport async function resetUserAntiCheatData(userId: string): Promise<void> {\n  const keys = [\n    `last_claim:${userId}`,\n    `location_history:${userId}`,\n    `claims_hourly:${userId}`,\n    `claims_daily:${userId}`,\n    `cooldown:global:${userId}`,\n  ];\n\n  await Promise.all(keys.map(key => RedisCache.del(key)));\n\n  try {\n    const cityKeys = redisClient ? await redisClient.keys(`cooldown:city:${userId}:*`) : [];\n    if (cityKeys.length && redisClient) {\n      await redisClient.del(...cityKeys);\n    }\n  } catch (err) {\n    typedLogger.error('Anti-cheat reset city cooldown error', { userId, error: getErrorMessage(err) });\n  }\n  \n  typedLogger.info('User anti-cheat data reset', { userId });\n}\n\nfunction normalizeLocationEntry(raw: unknown): LocationEntry | null {\n  if (!raw || typeof raw !== 'object') {\n    return null;\n  }\n  const candidate = raw as { lat?: unknown; lng?: unknown; timestamp?: unknown; accuracy?: unknown };\n  if (typeof candidate.lat !== 'number' || typeof candidate.lng !== 'number') {\n    return null;\n  }\n  const rawTimestamp = candidate.timestamp;\n  const timestamp = rawTimestamp instanceof Date ? rawTimestamp : new Date(String(rawTimestamp));\n  if (Number.isNaN(timestamp.getTime())) {\n    return null;\n  }\n  return {\n    lat: candidate.lat,\n    lng: candidate.lng,\n    timestamp,\n    accuracy: typeof candidate.accuracy === 'number' ? candidate.accuracy : undefined,\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\utils\\api-errors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\utils\\cookies.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\utils\\geo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\utils\\idempotency.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'operation' is defined but never used. Allowed unused args must match /^_/u.","line":91,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":91,"endColumn":56}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { redisClient } from '@/config/redis';\nimport { typedLogger } from '@/lib/typed-logger';\nimport crypto from 'crypto';\nimport { FastifyReply, FastifyRequest } from 'fastify';\nimport { ErrorLike, JSONValue } from '@/types';\n\nconst IDEMPOTENCY_PREFIX = 'idempotency:';\nconst DEFAULT_TTL = 24 * 60 * 60; // 24 hours in seconds\n\n/**\n * Check if an idempotency key has been used before\n */\nconst getErrorMessage = (error: ErrorLike) =>\n  error instanceof Error ? error.message : typeof error === 'string' ? error : error.message || 'Unknown error';\n\nexport async function checkIdempotency<T = JSONValue>(key: string): Promise<T | null> {\n  try {\n    const redisKey = `${IDEMPOTENCY_PREFIX}${key}`;\n    const result = await redisClient.get(redisKey);\n    \n    if (result) {\n      typedLogger.info('Idempotency key found', { key });\n      return JSON.parse(result) as T;\n    }\n    \n    return null;\n  } catch (error) {\n    typedLogger.error('Check idempotency error', {\n      error: getErrorMessage(error),\n      key,\n    });\n    return null;\n  }\n}\n\n/**\n * Store result for an idempotency key\n */\nexport async function setIdempotency(\n  key: string,\n  result: JSONValue,\n  ttlSeconds: number = DEFAULT_TTL\n): Promise<void> {\n  try {\n    const redisKey = `${IDEMPOTENCY_PREFIX}${key}`;\n    await redisClient.setex(redisKey, ttlSeconds, JSON.stringify(result));\n    \n    typedLogger.debug('Idempotency key stored', { key, ttl: ttlSeconds });\n  } catch (error) {\n    typedLogger.error('Set idempotency error', {\n      error: getErrorMessage(error),\n      key,\n    });\n  }\n}\n\n/**\n * Remove an idempotency key\n */\nexport async function removeIdempotency(key: string): Promise<void> {\n  try {\n    const redisKey = `${IDEMPOTENCY_PREFIX}${key}`;\n    await redisClient.del(redisKey);\n    \n    typedLogger.debug('Idempotency key removed', { key });\n  } catch (error) {\n    typedLogger.error('Remove idempotency error', {\n      error: getErrorMessage(error),\n      key,\n    });\n  }\n}\n\n/**\n * Generate a unique idempotency key\n */\nexport function generateIdempotencyKey(\n  userId: string,\n  operation: string,\n  data?: JSONValue\n): string {\n  const payload = data ? JSON.stringify(data) : '';\n  const combined = `${userId}:${operation}:${payload}`;\n  const hash = crypto.createHash('sha256').update(combined).digest('hex').slice(0, 24);\n  return `${operation}_${hash}`;\n}\n\n/**\n * Middleware to handle idempotency for Fastify routes\n */\nexport function idempotencyMiddleware(operation: string) {\n  type IdempotencyRequest = FastifyRequest & { idempotencyKey?: string };\n\n  return async (request: FastifyRequest, reply: FastifyReply): Promise<void> => {\n    const headerValue = request.headers['idempotency-key'];\n    const headerKey = Array.isArray(headerValue) ? headerValue[0] : headerValue;\n    const bodyKey = typeof request.body === 'object' && request.body !== null\n      ? (request.body as { idempotencyKey?: string }).idempotencyKey\n      : undefined;\n    const idempotencyKey = headerKey || bodyKey;\n\n    if (!idempotencyKey) {\n      reply.code(400).send({\n        success: false,\n        error: 'MISSING_IDEMPOTENCY_KEY',\n        message: 'Idempotency key is required for this operation',\n        timestamp: new Date().toISOString(),\n      });\n      return;\n    }\n\n    const existingResult = await checkIdempotency(idempotencyKey);\n    if (existingResult) {\n      reply.send(existingResult);\n      return;\n    }\n\n    // Store the idempotency key in request for later use\n    (request as IdempotencyRequest).idempotencyKey = idempotencyKey;\n    // No response sent here; next handler should handle response\n    return;\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\MSI\\Desktop\\YALLACATCH VERSION 3.0\\yallacatch-final-with-admob\\yallacatch-clean\\backend\\src\\utils\\zod.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]
