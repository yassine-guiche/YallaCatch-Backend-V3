import { FastifyInstance } from 'fastify';
import { authenticate, requireAdmin } from '@/middleware/auth';
import { z } from 'zod';
import { Types } from 'mongoose';
import { Reward } from '@/models/Reward';
import { Redemption } from '@/models/Redemption';
import { Code } from '@/models/Code';
import { User } from '@/models/User';
import { logger } from '@/lib/logger';
import { RewardCategory, RedemptionStatus } from '@/types';
import { checkIdempotency, setIdempotency } from '@/utils/idempotency';

// Validation schemas
const getRewardsSchema = z.object({
  category: z.enum(Object.values(RewardCategory) as [string, ...string[]]).optional(),
  minCost: z.number().min(1).optional(),
  maxCost: z.number().min(1).optional(),
  popular: z.boolean().optional(),
  page: z.number().min(1).default(1),
  limit: z.number().min(1).max(100).default(50),
  sort: z.enum(['pointsCost', 'name', 'popularity']).default('pointsCost')});

const searchRewardsSchema = z.object({
  query: z.string().min(1).max(100),
  category: z.enum(Object.values(RewardCategory) as [string, ...string[]]).optional(),
  limit: z.number().min(1).max(50).default(20)});

const redeemRewardSchema = z.object({
  rewardId: z.string().regex(/^[0-9a-fA-F]{24}$/, 'Invalid reward ID'),
  idempotencyKey: z.string().min(1).max(100)});

const createRewardSchema = z.object({
  name: z.string().min(2).max(100),
  description: z.string().min(10).max(500),
  category: z.enum(Object.values(RewardCategory) as [string, ...string[]]),
  pointsCost: z.number().min(1).max(100000),
  stockQuantity: z.number().min(1).max(10000),
  imageUrl: z.string().url().optional(),
  isPopular: z.boolean().default(false),
  partnerId: z.string().regex(/^[0-9a-fA-F]{24}$/).optional(),
  metadata: z.record(z.any()).optional()});

const updateRewardSchema = createRewardSchema.partial();

const addStockSchema = z.object({
  quantity: z.number().min(1).max(1000)});

/**
 * Rewards service
 */
export class RewardsService {
  /**
   * Get available rewards
   */
  static async getRewards(data: z.infer<typeof getRewardsSchema>) {
    try {
      const skip = (data.page - 1) * data.limit;
      
      const options = {
        category: data.category,
        minCost: data.minCost,
        maxCost: data.maxCost,
        limit: data.limit,
        sort: { [data.sort]: 1 }};

      let rewards;
      let total;

      if (data.popular) {
        // @ts-ignore - Property access
        rewards = await Reward.findPopular(data.limit);
        total = rewards.length;
      } else {
        // @ts-ignore - Property access
        rewards = await Reward.findAvailable(options);
        
        // Count total for pagination
        const countQuery: any = {
          isActive: true,
          stockAvailable: { $gt: 0 }};
        
        if (data.category) countQuery.category = data.category;
        if (data.maxCost) countQuery.pointsCost = { $lte: data.maxCost };
        if (data.minCost) {
          countQuery.pointsCost = { ...countQuery.pointsCost, $gte: data.minCost };
        }
        
        total = await Reward.countDocuments(countQuery);
      }

      return {
        rewards: rewards.map(reward => reward.toJSON()),
        pagination: {
          page: data.page,
          limit: data.limit,
          total,
          pages: Math.ceil(total / data.limit),
          hasNext: skip + data.limit < total,
          hasPrev: data.page > 1}};

    } catch (error) {
      // @ts-ignore - Overload mismatch
      logger.error('Get rewards error', {
        error: error.message,
        filters: data});
      throw error;
    }
  }

  /**
   * Search rewards
   */
  static async searchRewards(data: z.infer<typeof searchRewardsSchema>) {
    try {
      // @ts-ignore - Property access
      const rewards = await Reward.searchRewards(data.query, {
        category: data.category,
        limit: data.limit});

      return {
        rewards: rewards.map(reward => reward.toJSON()),
        query: data.query,
        total: rewards.length};

    } catch (error) {
      // @ts-ignore - Overload mismatch
      logger.error('Search rewards error', {
        error: error.message,
        query: data.query});
      throw error;
    }
  }

  /**
   * Get reward details
   */
  static async getRewardDetails(rewardId: string, userId?: string) {
    try {
      const reward = await Reward.findById(rewardId)
        .populate('partnerId', 'name logoUrl website');

      if (!reward) {
        throw new Error('REWARD_NOT_FOUND');
      }

      const result: any = {
        ...reward.toJSON(),
        // @ts-ignore - Property access
        canRedeem: reward.isAvailable};

      // Check if user can afford this reward
      if (userId) {
        const user = await User.findById(userId);
        if (user) {
          result.canAfford = user.points.available >= reward.pointsCost;
          result.canRedeem = result.canRedeem && result.canAfford;
        }
      }

      return result;

    } catch (error) {
      // @ts-ignore - Overload mismatch
      logger.error('Get reward details error', {
        error: error.message,
        rewardId,
        userId});
      throw error;
    }
  }

  /**
   * Redeem a reward
   */
  static async redeemReward(
    userId: string,
    data: z.infer<typeof redeemRewardSchema>
  ) {
    try {
      // Check idempotency
      const existingResult = await checkIdempotency(data.idempotencyKey);
      if (existingResult) {
        // @ts-ignore - Overload mismatch
        logger.info('Idempotent redemption request', {
          userId,
          rewardId: data.rewardId,
          idempotencyKey: data.idempotencyKey});
        return existingResult;
      }

      // Get user and reward
      const [user, reward] = await Promise.all([
        User.findById(userId),
        Reward.findById(data.rewardId).populate('partnerId', 'name')]);

      if (!user) {
        throw new Error('USER_NOT_FOUND');
      }

      if (!reward) {
        throw new Error('REWARD_NOT_FOUND');
      }

      // @ts-ignore - Property access
      if (!reward.isAvailable) {
        throw new Error('REWARD_NOT_AVAILABLE');
      }

      if (user.points.available < reward.pointsCost) {
        throw new Error('INSUFFICIENT_POINTS');
      }

      // Reserve stock
      // @ts-ignore - Property access
      if (!reward.reserveStock(1)) {
        throw new Error('OUT_OF_STOCK');
      }

      // Try to get a code for this reward
      // @ts-ignore - Property access
      const code = await Code.reserveCode(
        new Types.ObjectId(data.rewardId),
        new Types.ObjectId(userId)
      );

      // Create redemption record
      const redemption = new Redemption({
        userId: new Types.ObjectId(userId),
        rewardId: new Types.ObjectId(data.rewardId),
        pointsSpent: reward.pointsCost,
        status: code ? RedemptionStatus.FULFILLED : RedemptionStatus.PENDING,
        codeId: code?._id,
        idempotencyKey: data.idempotencyKey,
        fulfilledAt: code ? new Date() : undefined});

      // Deduct points from user
      // @ts-ignore - Property access
      user.spendPoints(reward.pointsCost);
      // @ts-ignore - Property access
      user.stats.totalRedemptions += 1;

      // Confirm redemption if we have a code
      if (code) {
        // @ts-ignore - Property access
        reward.confirmRedemption(1);
        code.status = 'USED';
        code.usedBy = new Types.ObjectId(userId);
        code.usedAt = new Date();
      }

      // Save all changes
      const savePromises = [redemption.save(), user.save(), reward.save()];
      if (code) savePromises.push(code.save());
      
      await Promise.all(savePromises);

      // Prepare result
      const result = {
        success: true,
        redemption: {
          id: redemption._id,
          status: redemption.status,
          pointsSpent: redemption.pointsSpent,
          redeemedAt: redemption.redeemedAt,
          code: code ? {
            id: code._id,
            code: code.code,
            poolName: code.poolName} : null},
        newBalance: user.points.available,
        reward: {
          id: reward._id,
          name: reward.name,
          category: reward.category,
          partner: reward.partnerId}};

      // Store idempotency result
      await setIdempotency(data.idempotencyKey, result);

      // @ts-ignore - Overload mismatch
      logger.info('Reward redeemed successfully', {
        userId,
        rewardId: data.rewardId,
        redemptionId: redemption._id,
        pointsSpent: reward.pointsCost,
        hasCode: !!code});

      return result;

    } catch (error) {
      // @ts-ignore - Overload mismatch
      logger.error('Redeem reward error', {
        error: error.message,
        userId,
        rewardId: data.rewardId});
      throw error;
    }
  }

  /**
   * Get user redemptions
   */
  static async getUserRedemptions(userId: string, options: any = {}) {
    try {
      // @ts-ignore - Property access
      const redemptions = await Redemption.findByUser(
        new Types.ObjectId(userId),
        options
      );

      return {
        redemptions: redemptions.map(redemption => redemption.toJSON()),
        total: redemptions.length};

    } catch (error) {
      // @ts-ignore - Overload mismatch
      logger.error('Get user redemptions error', {
        error: error.message,
        userId});
      throw error;
    }
  }

  /**
   * Admin: Create reward
   */
  static async createReward(
    adminId: string,
    data: z.infer<typeof createRewardSchema>
  ) {
    try {
      const reward = new Reward({
        ...data,
        stockAvailable: data.stockQuantity});

      await reward.save();

      // @ts-ignore - Overload mismatch
      logger.info('Reward created', {
        rewardId: reward._id,
        adminId,
        name: reward.name,
        pointsCost: reward.pointsCost});

      return reward.toJSON();

    } catch (error) {
      // @ts-ignore - Overload mismatch
      logger.error('Create reward error', {
        error: error.message,
        adminId,
        rewardName: data.name});
      throw error;
    }
  }

  /**
   * Admin: Update reward
   */
  static async updateReward(
    adminId: string,
    rewardId: string,
    data: z.infer<typeof updateRewardSchema>
  ) {
    try {
      const reward = await Reward.findById(rewardId);
      
      if (!reward) {
        throw new Error('REWARD_NOT_FOUND');
      }

      // Update fields
      Object.keys(data).forEach(key => {
        if (data[key] !== undefined) {
          reward[key] = data[key];
        }
      });

      await reward.save();

      // @ts-ignore - Overload mismatch
      logger.info('Reward updated', {
        rewardId: reward._id,
        adminId,
        updates: Object.keys(data)});

      return reward.toJSON();

    } catch (error) {
      // @ts-ignore - Overload mismatch
      logger.error('Update reward error', {
        error: error.message,
        adminId,
        rewardId});
      throw error;
    }
  }

  /**
   * Admin: Add stock to reward
   */
  static async addStock(
    adminId: string,
    rewardId: string,
    data: z.infer<typeof addStockSchema>
  ) {
    try {
      const reward = await Reward.findById(rewardId);
      
      if (!reward) {
        throw new Error('REWARD_NOT_FOUND');
      }

      // @ts-ignore - Property access
      reward.addStock(data.quantity);
      await reward.save();

      // @ts-ignore - Overload mismatch
      logger.info('Stock added to reward', {
        rewardId: reward._id,
        adminId,
        quantityAdded: data.quantity,
        newStock: reward.stockQuantity});

      return {
        success: true,
        newStock: reward.stockQuantity,
        newAvailable: reward.stockAvailable};

    } catch (error) {
      // @ts-ignore - Overload mismatch
      logger.error('Add stock error', {
        error: error.message,
        adminId,
        rewardId});
      throw error;
    }
  }

  /**
   * Admin: Get reward statistics
   */
  static async getRewardStats() {
    try {
      // @ts-ignore - Property access
      const stats = await Reward.getStats();
      // @ts-ignore - Property access
      const lowStockRewards = await Reward.getLowStockRewards();

      return {
        ...stats,
        lowStockRewards: lowStockRewards.map(reward => ({
          id: reward._id,
          name: reward.name,
          stockAvailable: reward.stockAvailable,
          partner: reward.partnerId}))};

    } catch (error) {
      // @ts-ignore - Overload mismatch
      logger.error('Get reward stats error', {
        error: error.message});
      throw error;
    }
  }

  /**
   * Admin: Get pending redemptions
   */
  static async getPendingRedemptions(options: any = {}) {
    try {
      // @ts-ignore - Property access
      const redemptions = await Redemption.findPending(options);

      return {
        redemptions: redemptions.map(redemption => redemption.toJSON()),
        total: redemptions.length};

    } catch (error) {
      // @ts-ignore - Overload mismatch
      logger.error('Get pending redemptions error', {
        error: error.message});
      throw error;
    }
  }
}

/**
 * Rewards routes
 */
export default async function rewardsRoutes(fastify: FastifyInstance) {
  // Get available rewards
  fastify.get('/', {
    // @ts-ignore - Property access
    preHandler: [authenticate]}, async (request, reply) => {
    try {
      const result = await RewardsService.getRewards(request.query);
      
      reply.send({
        success: true,
        data: result,
        timestamp: new Date().toISOString()});
    } catch (error) {
      reply.code(500).send({
        success: false,
        error: error.message,
        timestamp: new Date().toISOString()});
    }
  });

  // Search rewards
  fastify.get('/search', {
    // @ts-ignore - Property access
    preHandler: [authenticate]}, async (request, reply) => {
    try {
      const result = await RewardsService.searchRewards(request.query);
      
      reply.send({
        success: true,
        data: result,
        timestamp: new Date().toISOString()});
    } catch (error) {
      reply.code(500).send({
        success: false,
        error: error.message,
        timestamp: new Date().toISOString()});
    }
  });

  // Get reward details
  fastify.get('/:rewardId', {
    // @ts-ignore - Property access
    preHandler: [authenticate]}, async (request, reply) => {
    try {
      const result = await RewardsService.getRewardDetails(
        // @ts-ignore - Property access
        request.params.rewardId,
        request.user.sub
      );
      
      reply.send({
        success: true,
        data: result,
        timestamp: new Date().toISOString()});
    } catch (error) {
      const statusCode = error.message === 'REWARD_NOT_FOUND' ? 404 : 500;
      
      reply.code(statusCode).send({
        success: false,
        error: error.message,
        timestamp: new Date().toISOString()});
    }
  });

  // Redeem a reward
  fastify.post('/:rewardId/redeem', {
    // @ts-ignore - Property access
    preHandler: [authenticate],
      body: z.object({
        idempotencyKey: z.string().min(1).max(100)})}, async (request, reply) => {
    try {
      const result = await RewardsService.redeemReward(
        request.user.sub,
        {
          // @ts-ignore - Property access
          rewardId: request.params.rewardId,
          // @ts-ignore - Property access
          idempotencyKey: request.body.idempotencyKey}
      );
      
      reply.code(201).send({
        success: true,
        data: result,
        timestamp: new Date().toISOString()});
    } catch (error) {
      const statusCodes = {
        'USER_NOT_FOUND': 404,
        'REWARD_NOT_FOUND': 404,
        'REWARD_NOT_AVAILABLE': 409,
        'INSUFFICIENT_POINTS': 400,
        'OUT_OF_STOCK': 409};
      
      const statusCode = statusCodes[error.message] || 500;
      
      reply.code(statusCode).send({
        success: false,
        error: error.message,
        timestamp: new Date().toISOString()});
    }
  });

  // Get user redemptions
  fastify.get('/my-redemptions', {
    // @ts-ignore - Property access
    preHandler: [authenticate]}, async (request, reply) => {
    try {
      const result = await RewardsService.getUserRedemptions(
        request.user.sub,
        request.query
      );
      
      reply.send({
        success: true,
        data: result,
        timestamp: new Date().toISOString()});
    } catch (error) {
      reply.code(500).send({
        success: false,
        error: error.message,
        timestamp: new Date().toISOString()});
    }
  });

  // Admin routes

  // Create reward
  fastify.post('/admin', {
    // @ts-ignore - Property access
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin]}, async (request, reply) => {
    try {
      const result = await RewardsService.createReward(
        request.user.sub,
        request.body
      );
      
      reply.code(201).send({
        success: true,
        data: result,
        timestamp: new Date().toISOString()});
    } catch (error) {
      reply.code(500).send({
        success: false,
        error: error.message,
        timestamp: new Date().toISOString()});
    }
  });

  // Update reward
  fastify.patch('/admin/:rewardId', {
    // @ts-ignore - Property access
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin]}, async (request, reply) => {
    try {
      const result = await RewardsService.updateReward(
        request.user.sub,
        // @ts-ignore - Property access
        request.params.rewardId,
        request.body
      );
      
      reply.send({
        success: true,
        data: result,
        timestamp: new Date().toISOString()});
    } catch (error) {
      const statusCode = error.message === 'REWARD_NOT_FOUND' ? 404 : 500;
      
      reply.code(statusCode).send({
        success: false,
        error: error.message,
        timestamp: new Date().toISOString()});
    }
  });

  // Add stock
  fastify.post('/admin/:rewardId/stock', {
    // @ts-ignore - Property access
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin]}, async (request, reply) => {
    try {
      const result = await RewardsService.addStock(
        request.user.sub,
        // @ts-ignore - Property access
        request.params.rewardId,
        request.body
      );
      
      reply.send({
        success: true,
        data: result,
        timestamp: new Date().toISOString()});
    } catch (error) {
      const statusCode = error.message === 'REWARD_NOT_FOUND' ? 404 : 500;
      
      reply.code(statusCode).send({
        success: false,
        error: error.message,
        timestamp: new Date().toISOString()});
    }
  });

  // Get reward statistics
  fastify.get('/admin/stats', {
    // @ts-ignore - Property access
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin]}, async (request, reply) => {
    try {
      const result = await RewardsService.getRewardStats();
      
      reply.send({
        success: true,
        data: result,
        timestamp: new Date().toISOString()});
    } catch (error) {
      reply.code(500).send({
        success: false,
        error: error.message,
        timestamp: new Date().toISOString()});
    }
  });

  // Get pending redemptions
  fastify.get('/admin/pending', {
    // @ts-ignore - Property access
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin]}, async (request, reply) => {
    try {
      const result = await RewardsService.getPendingRedemptions(request.query);
      
      reply.send({
        success: true,
        data: result,
        timestamp: new Date().toISOString()});
    } catch (error) {
      reply.code(500).send({
        success: false,
        error: error.message,
        timestamp: new Date().toISOString()});
    }
  });
}
