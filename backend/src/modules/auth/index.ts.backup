import { FastifyInstance } from 'fastify';
import { z } from 'zod';
import bcrypt from 'bcrypt';
import { User } from '@/models/User';
import { signTokenPair, generateSessionId } from '@/lib/jwt';
import { logger, logSecurity } from '@/lib/logger';
import { config } from '@/config';
import { UserRole, Platform } from '@/types';
import { RedisCache } from '@/config/redis';
import { validateAntiCheat } from '@/utils/anti-cheat';
import { authenticate } from '@/middleware/auth';
import { authRateLimit } from '@/middleware/distributed-rate-limit';

// Validation schemas
const guestLoginSchema = z.object({
  deviceId: z.string().min(1).max(100),
  platform: z.enum([Platform.IOS, Platform.ANDROID, Platform.WEB]),
  fcmToken: z.string().optional(),
  location: z.object({
    lat: z.number().min(-90).max(90),
    lng: z.number().min(-180).max(180),
    city: z.string().min(1).max(50)}).optional()});

const emailRegisterSchema = z.object({
  email: z.string().email().max(255),
  password: z.string().min(8).max(128),
  displayName: z.string().min(2).max(50),
  deviceId: z.string().min(1).max(100),
  platform: z.enum([Platform.IOS, Platform.ANDROID, Platform.WEB]),
  fcmToken: z.string().optional(),
  location: z.object({
    lat: z.number().min(-90).max(90),
    lng: z.number().min(-180).max(180),
    city: z.string().min(1).max(50)}).optional()});

const emailLoginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(1),
  deviceId: z.string().min(1).max(100),
  platform: z.enum([Platform.IOS, Platform.ANDROID, Platform.WEB]),
  fcmToken: z.string().optional(),
  location: z.object({
    lat: z.number().min(-90).max(90),
    lng: z.number().min(-180).max(180),
    city: z.string().min(1).max(50)}).optional()});

const refreshTokenSchema = z.object({
  refreshToken: z.string().min(1)});

const logoutSchema = z.object({
  refreshToken: z.string().optional(),
  deviceId: z.string().optional()});

/**
 * Authentication service
 */
export class AuthService {
  /**
   * Guest login - create anonymous user
   */
  static async guestLogin(data: z.infer<typeof guestLoginSchema>) {
    try {
      // Check if user already exists with this device
      // @ts-ignore - Property access
      let user = await User.findByDeviceId(data.deviceId);
      
      if (user) {
        // Update existing user
        user.addDevice(data.deviceId, data.platform, data.fcmToken);
        
        if (data.location) {
          user.updateLocation(data.location.lat, data.location.lng, data.location.city);
        }
        
        user.lastActive = new Date();
        await user.save();
      } else {
        // Create new guest user
        const displayName = `Player_${Math.random().toString(36).substring(2, 8)}`;
        
        user = new User({
          displayName,
          role: UserRole.PLAYER,
          devices: [{
            deviceId: data.deviceId,
            platform: data.platform,
            fcmToken: data.fcmToken,
            lastUsed: new Date(),
            isActive: true}]});
        
        if (data.location) {
          user.updateLocation(data.location.lat, data.location.lng, data.location.city);
        }
        
        await user.save();
        
        // @ts-ignore - Overload mismatch
        logger.info('Guest user created', {
          userId: user._id,
          deviceId: data.deviceId,
          platform: data.platform});
      }
      
      // Generate session and tokens
      const sessionId = generateSessionId();
      const tokens = signTokenPair({
        sub: user._id.toString(),
        role: user.role,
        deviceId: data.deviceId,
        sessionId});
      
      // Store session in Redis
      await RedisCache.set(
        `session:${sessionId}`,
        {
          userId: user._id.toString(),
          deviceId: data.deviceId,
          platform: data.platform,
          createdAt: new Date()},
        30 * 24 * 60 * 60 // 30 days
      );
      
      return {
        user: {
          id: user._id,
          displayName: user.displayName,
          role: user.role,
          level: user.level,
          points: user.points,
          isGuest: user.isGuest},
        tokens,
        sessionId};
      
    } catch (error) {
      // @ts-ignore - Overload mismatch
      logger.error('Guest login error', {
        error: error.message,
        deviceId: data.deviceId});
      throw new Error('Guest login failed');
    }
  }
  
  /**
   * Email registration
   */
  static async emailRegister(data: z.infer<typeof emailRegisterSchema>) {
    try {
      // Check if email already exists
      // @ts-ignore - Property access
      const existingUser = await User.findByEmail(data.email);
      if (existingUser) {
        throw new Error('EMAIL_ALREADY_EXISTS');
      }
      
      // Check if device is already associated with another account
      // @ts-ignore - Property access
      const existingDevice = await User.findByDeviceId(data.deviceId);
      if (existingDevice && existingDevice.email) {
        throw new Error('DEVICE_ALREADY_REGISTERED');
      }
      
      // Hash password
      const passwordHash = await bcrypt.hash(data.password, config.BCRYPT_ROUNDS);
      
      let user: any;
      
      if (existingDevice) {
        // Convert guest account to registered account
        user = existingDevice;
        user.email = data.email;
        user.passwordHash = passwordHash;
        user.displayName = data.displayName;
        user.addDevice(data.deviceId, data.platform, data.fcmToken);
        
        // @ts-ignore - Overload mismatch
        logger.info('Guest account converted to registered', {
          userId: user._id,
          email: data.email});
      } else {
        // Create new registered user
        user = new User({
          email: data.email,
          passwordHash,
          displayName: data.displayName,
          role: UserRole.PLAYER,
          devices: [{
            deviceId: data.deviceId,
            platform: data.platform,
            fcmToken: data.fcmToken,
            lastUsed: new Date(),
            isActive: true}]});
        
        // @ts-ignore - Overload mismatch
        logger.info('New user registered', {
          email: data.email,
          deviceId: data.deviceId});
      }
      
      if (data.location) {
        user.updateLocation(data.location.lat, data.location.lng, data.location.city);
      }
      
      await user.save();
      
      // Generate session and tokens
      const sessionId = generateSessionId();
      const tokens = signTokenPair({
        sub: user._id.toString(),
        email: user.email,
        role: user.role,
        deviceId: data.deviceId,
        sessionId});
      
      // Store session in Redis
      await RedisCache.set(
        `session:${sessionId}`,
        {
          userId: user._id.toString(),
          deviceId: data.deviceId,
          platform: data.platform,
          email: user.email,
          createdAt: new Date()},
        30 * 24 * 60 * 60 // 30 days
      );
      
      return {
        user: {
          id: user._id,
          email: user.email,
          displayName: user.displayName,
          role: user.role,
          level: user.level,
          points: user.points,
          isGuest: false},
        tokens,
        sessionId};
      
    } catch (error) {
      // @ts-ignore - Overload mismatch
      logger.error('Email registration error', {
        error: error.message,
        email: data.email});
      
      if (error.message === 'EMAIL_ALREADY_EXISTS') {
        throw error;
      }
      if (error.message === 'DEVICE_ALREADY_REGISTERED') {
        throw error;
      }
      
      throw new Error('Registration failed');
    }
  }
  
  /**
   * Email login
   */
  static async emailLogin(data: z.infer<typeof emailLoginSchema>) {
    try {
      // Find user by email
      // @ts-ignore - Property access
      const user = await User.findByEmail(data.email).select('+passwordHash');
      if (!user) {
        // Don't reveal if email exists or not
        await new Promise(resolve => setTimeout(resolve, 1000));
        throw new Error('INVALID_CREDENTIALS');
      }
      
      // Check if user is banned
      if (user.isBanned) {
        if (user.banExpiresAt && user.banExpiresAt > new Date()) {
          logSecurity('banned_user_login_attempt', 'medium', {
            userId: user._id,
            email: data.email,
            banReason: user.banReason});
          throw new Error('ACCOUNT_BANNED');
        } else {
          // Unban expired bans
          user.unban();
          await user.save();
        }
      }
      
      // Verify password
      const isValidPassword = await user.comparePassword(data.password);
      if (!isValidPassword) {
        logSecurity('invalid_password_attempt', 'low', {
          userId: user._id,
          email: data.email});
        throw new Error('INVALID_CREDENTIALS');
      }
      
      // Update device and location
      user.addDevice(data.deviceId, data.platform, data.fcmToken);
      
      if (data.location) {
        user.updateLocation(data.location.lat, data.location.lng, data.location.city);
      }
      
      user.lastActive = new Date();
      await user.save();
      
      // Generate session and tokens
      const sessionId = generateSessionId();
      const tokens = signTokenPair({
        sub: user._id.toString(),
        email: user.email,
        role: user.role,
        deviceId: data.deviceId,
        sessionId});
      
      // Store session in Redis
      await RedisCache.set(
        `session:${sessionId}`,
        {
          userId: user._id.toString(),
          deviceId: data.deviceId,
          platform: data.platform,
          email: user.email,
          createdAt: new Date()},
        30 * 24 * 60 * 60 // 30 days
      );
      
      // @ts-ignore - Overload mismatch
      logger.info('User logged in', {
        userId: user._id,
        email: user.email,
        deviceId: data.deviceId});
      
      return {
        user: {
          id: user._id,
          email: user.email,
          displayName: user.displayName,
          role: user.role,
          level: user.level,
          points: user.points,
          isGuest: false},
        tokens,
        sessionId};
      
    } catch (error) {
      // @ts-ignore - Overload mismatch
      logger.error('Email login error', {
        error: error.message,
        email: data.email});
      
      if (['INVALID_CREDENTIALS', 'ACCOUNT_BANNED'].includes(error.message)) {
        throw error;
      }
      
      throw new Error('Login failed');
    }
  }
  
  /**
   * Refresh access token
   */
  static async refreshToken(data: z.infer<typeof refreshTokenSchema>) {
    try {
      const { refreshAccessToken } = await import('@/lib/jwt');
      const newTokens = await refreshAccessToken(data.refreshToken);
      
      if (!newTokens) {
        throw new Error('INVALID_REFRESH_TOKEN');
      }
      
      return { tokens: newTokens };
      
    } catch (error) {
      // @ts-ignore - Overload mismatch
      logger.error('Token refresh error', { error: error.message });
      throw new Error('Token refresh failed');
    }
  }
  
  /**
   * Logout user
   */
  static async logout(
    userId: string,
    data: z.infer<typeof logoutSchema>
  ) {
    try {
      const { revokeToken, revokeSessionTokens } = await import('@/lib/jwt');
      
      if (data.refreshToken) {
        // Revoke specific refresh token
        const { decodeToken } = await import('@/lib/jwt');
        const decoded = decodeToken(data.refreshToken);
        if (decoded?.jti) {
          await revokeToken(decoded.jti);
        }
        
        // Revoke session tokens
        if (decoded?.sessionId) {
          await revokeSessionTokens(decoded.sessionId);
          await RedisCache.del(`session:${decoded.sessionId}`);
        }
      }
      
      if (data.deviceId) {
        // Deactivate device
        const user = await User.findById(userId);
        if (user) {
          const device = user.devices.find(d => d.deviceId === data.deviceId);
          if (device) {
            device.isActive = false;
            device.fcmToken = undefined;
            await user.save();
          }
        }
      }
      
      // @ts-ignore - Overload mismatch
      logger.info('User logged out', { userId, deviceId: data.deviceId });
      
      return { success: true };
      
    } catch (error) {
      // @ts-ignore - Overload mismatch
      logger.error('Logout error', { error: error.message, userId });
      throw new Error('Logout failed');
    }
  }
  
  /**
   * Get current user profile
   */
  static async getProfile(userId: string) {
    try {
      const user = await User.findById(userId);
      if (!user) {
        throw new Error('USER_NOT_FOUND');
      }
      
      return {
        id: user._id,
        email: user.email,
        displayName: user.displayName,
        role: user.role,
        level: user.level,
        points: user.points,
        stats: user.stats,
        location: user.location,
        preferences: user.preferences,
        devices: user.devices,
        // @ts-ignore - Property access
        isGuest: user.isGuest,
        // @ts-ignore - Property access
        levelProgress: user.levelProgress,
        // @ts-ignore - Property access
        canClaim: user.canClaim,
        createdAt: user.createdAt,
        lastActive: user.lastActive};
      
    } catch (error) {
      // @ts-ignore - Overload mismatch
      logger.error('Get profile error', { error: error.message, userId });
      throw new Error('Failed to get profile');
    }
  }
  
  /**
   * Update user profile
   */
  static async updateProfile(
    userId: string,
    updates: {
      displayName?: string;
      preferences?: {
        notifications?: boolean;
        language?: string;
        theme?: string;
      };
    }
  ) {
    try {
      const user = await User.findById(userId);
      if (!user) {
        throw new Error('USER_NOT_FOUND');
      }
      
      if (updates.displayName) {
        user.displayName = updates.displayName;
      }
      
      if (updates.preferences) {
        // @ts-ignore - Type assignment
        user.preferences = { ...user.preferences, ...updates.preferences };
      }
      
      await user.save();
      
      // @ts-ignore - Overload mismatch
      logger.info('User profile updated', { userId, updates });
      
      return {
        id: user._id,
        displayName: user.displayName,
        preferences: user.preferences};
      
    } catch (error) {
      // @ts-ignore - Overload mismatch
      logger.error('Update profile error', { error: error.message, userId });
      throw new Error('Failed to update profile');
    }
  }
}

/**
 * Auth routes
 */
export default async function authRoutes(fastify: FastifyInstance) {
  // Alias for current user profile
  fastify.get('/me', {
    // @ts-ignore - Property access
    preHandler: [authenticate]}, async (request, reply) => {
    try {
      // Reuse existing service logic
      const result = await AuthService.getProfile((request as any).user.sub);
      reply.send({
        success: true,
        data: result,
        timestamp: new Date().toISOString()});
    } catch (error: any) {
      reply.code(404).send({
        success: false,
        error: error.message,
        timestamp: new Date().toISOString()});
    }
  });
  // Guest login
  fastify.post('/guest', {
      // @ts-ignore - Property access
      preHandler: [authRateLimit],
      response: {
        200: {
          type: 'object',
          properties: {
            success: { type: 'boolean' },
            data: {
              type: 'object',
              properties: {
                user: { type: 'object' },
                tokens: { type: 'object' },
                sessionId: { type: 'string' }}}}}}}, async (request, reply) => {
    try {
      const result = await AuthService.guestLogin(request.body);
      
      reply.send({
        success: true,
        data: result,
        timestamp: new Date().toISOString()});
    } catch (error) {
      reply.code(400).send({
        success: false,
        error: error.message,
        timestamp: new Date().toISOString()});
    }
  });
  
  // Email registration
  fastify.post('/register', {
    // @ts-ignore - Property access
    preHandler: [authRateLimit]
  }, async (request, reply) => {
    try {
      const result = await AuthService.emailRegister(request.body);
      
      reply.send({
        success: true,
        data: result,
        timestamp: new Date().toISOString()});
    } catch (error) {
      const statusCode = error.message === 'EMAIL_ALREADY_EXISTS' ? 409 : 400;
      
      reply.code(statusCode).send({
        success: false,
        error: error.message,
        timestamp: new Date().toISOString()});
    }
  });
  
  // Email login
  fastify.post('/login', {
    // @ts-ignore - Property access
    preHandler: [authRateLimit]
  }, async (request, reply) => {
    try {
      const result = await AuthService.emailLogin(request.body);
      
      reply.send({
        success: true,
        data: result,
        timestamp: new Date().toISOString()});
    } catch (error) {
      const statusCode = error.message === 'ACCOUNT_BANNED' ? 403 : 401;
      
      reply.code(statusCode).send({
        success: false,
        error: error.message,
        timestamp: new Date().toISOString()});
    }
  });
  
  // Refresh token
  fastify.post('/refresh', {
  }, async (request, reply) => {
    try {
      const result = await AuthService.refreshToken(request.body);
      
      reply.send({
        success: true,
        data: result,
        timestamp: new Date().toISOString()});
    } catch (error) {
      reply.code(401).send({
        success: false,
        error: error.message,
        timestamp: new Date().toISOString()});
    }
  });
  
  // Logout
  fastify.post('/logout', {
    // @ts-ignore - Property access
    preHandler: [authenticate]}, async (request, reply) => {
    try {
      const result = await AuthService.logout(request.user.sub, request.body);
      
      reply.send({
        success: true,
        data: result,
        timestamp: new Date().toISOString()});
    } catch (error) {
      reply.code(400).send({
        success: false,
        error: error.message,
        timestamp: new Date().toISOString()});
    }
  });
  
  // Get profile
  fastify.get('/profile', {
    // @ts-ignore - Property access
    preHandler: [authenticate]}, async (request, reply) => {
    try {
      const result = await AuthService.getProfile(request.user.sub);
      
      reply.send({
        success: true,
        data: result,
        timestamp: new Date().toISOString()});
    } catch (error) {
      reply.code(404).send({
        success: false,
        error: error.message,
        timestamp: new Date().toISOString()});
    }
  });
  
  // Update profile
  fastify.patch('/profile', {
    // @ts-ignore - Property access
    preHandler: [authenticate]}, async (request, reply) => {
    try {
      const result = await AuthService.updateProfile(request.user.sub, request.body);
      
      reply.send({
        success: true,
        data: result,
        timestamp: new Date().toISOString()});
    } catch (error) {
      reply.code(400).send({
        success: false,
        error: error.message,
        timestamp: new Date().toISOString()});
    }
  });
}
