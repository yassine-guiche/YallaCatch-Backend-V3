import { FastifyInstance } from 'fastify';
import { authenticate, requireAdmin } from '@/middleware/auth';
import { adminRateLimit } from '@/middleware/distributed-rate-limit';
import { z } from 'zod';
import { User } from '@/models/User';
import { Prize } from '@/models/Prize';
import { Claim } from '@/models/Claim';
import { Reward } from '@/models/Reward';
import { Redemption } from '@/models/Redemption';
import { AuditLog } from '@/models/AuditLog';
import { Partner } from '@/models/Partner';
import { UsersService } from '@/modules/users';
import { PrizeService } from '@/modules/prizes';
import { NotificationService } from '@/modules/notifications';
import { RewardsService } from '@/modules/rewards';
import { logger } from '@/lib/logger';
import { Settings } from '@/models/Settings';
import mongoose from 'mongoose';


// Admin dashboard service
export class AdminService {
  static async getDashboardStats() {
    try {
      const [userStats, prizeStats, claimStats, rewardStats] = await Promise.all([
        User.aggregate([
          {
            $group: {
              _id: null,
              totalUsers: { $sum: 1 },
              activeUsers: {
                $sum: {
                  $cond: [
                    { $gte: ['$lastActive', new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)] },
                    1,
                    0
                  ]
                }
              },
              bannedUsers: { $sum: { $cond: ['$isBanned', 1, 0] } }}
          }
        ]),
        Prize.aggregate([
          {
            $group: {
              _id: null,
              totalPrizes: { $sum: 1 },
              activePrizes: { $sum: { $cond: [{ $eq: ['$status', 'active'] }, 1, 0] } },
              claimedPrizes: { $sum: { $cond: [{ $eq: ['$status', 'claimed'] }, 1, 0] } }}
          }
        ]),
        Claim.aggregate([
          {
            $group: {
              _id: null,
              totalClaims: { $sum: 1 },
              totalPointsAwarded: { $sum: '$pointsAwarded' },
              averageDistance: { $avg: '$distance' }}
          }
        ]),
        Reward.aggregate([
          {
            $group: {
              _id: null,
              totalRewards: { $sum: 1 },
              activeRewards: { $sum: { $cond: ['$isActive', 1, 0] } },
              totalStock: { $sum: '$stockQuantity' },
              availableStock: { $sum: '$stockAvailable' }}
          }
        ])]);

      // Redemptions summary (core + marketplace)
      let redemptionsSummary: any = { total: 0, core: 0, marketplace: 0 };
      let purchasesSummary: any = { total: 0, unredeemed: 0, redeemed: 0 };
      try {
        const coreCount = await Redemption.countDocuments({});
        const marketplaceCount = await Redemption.countDocuments({ 'metadata.source': 'marketplace' });
        const redeemed = await Redemption.countDocuments({ 'metadata.source': 'marketplace', status: 'FULFILLED' });
        const unredeemed = await Redemption.countDocuments({ 'metadata.source': 'marketplace', status: 'PENDING' });
        purchasesSummary = { total: marketplaceCount, unredeemed, redeemed };
        redemptionsSummary = { total: coreCount, core: coreCount - marketplaceCount, marketplace: marketplaceCount };
      } catch {}

      return {
        users: userStats[0] || { totalUsers: 0, activeUsers: 0, bannedUsers: 0 },
        prizes: prizeStats[0] || { totalPrizes: 0, activePrizes: 0, claimedPrizes: 0 },
        claims: claimStats[0] || { totalClaims: 0, totalPointsAwarded: 0, averageDistance: 0 },
        rewards: rewardStats[0] || { totalRewards: 0, activeRewards: 0, totalStock: 0, availableStock: 0 },
        redemptions: redemptionsSummary,
        purchases: purchasesSummary,
        timestamp: new Date().toISOString()};
    } catch (error) {
      // @ts-ignore - Overload mismatch
      logger.error('Get dashboard stats error', { error: error.message });
      throw error;
    }
  }

  static async getAuditLogs(options: any = {}) {
    try {
      const skip = ((options.page || 1) - 1) * (options.limit || 50);
      
      const query: any = {};
      if (options.userId) query.userId = options.userId;
      if (options.action) query.action = options.action;
      if (options.resource) query.resource = options.resource;
      
      const [logs, total] = await Promise.all([
        AuditLog.find(query)
          .populate('userId', 'displayName email')
          .sort({ timestamp: -1 })
          .skip(skip)
          .limit(options.limit || 50),
        AuditLog.countDocuments(query)]);

      return {
        logs: logs.map(log => log.toJSON()),
        pagination: {
          page: options.page || 1,
          limit: options.limit || 50,
          total,
          pages: Math.ceil(total / (options.limit || 50))}};
    } catch (error) {
      // @ts-ignore - Overload mismatch
      logger.error('Get audit logs error', { error: error.message });
      throw error;
    }
  }
}

export default async function adminRoutes(fastify: FastifyInstance) {
  // Get dashboard statistics
  fastify.get('/dashboard', {
    // @ts-ignore - Property access
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin]}, async (request, reply) => {
    try {
      const result = await AdminService.getDashboardStats();
      reply.send({ success: true, data: result });
    } catch (error) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  // Get audit logs
  fastify.get('/audit-logs', {
    // @ts-ignore - Property access
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin]}, async (request, reply) => {
    try {
      const result = await AdminService.getAuditLogs(request.query);
      reply.send({ success: true, data: result });
    } catch (error) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  // ==================== Admin: Users ====================
  fastify.get('/users', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin, adminRateLimit]}, async (request, reply) => {
    try {
      // Delegate to UsersService with query as-is for compatibility
      const result: any = await UsersService.getAllUsers(request.query as any);
      const pagination = result?.pagination || {};
      reply.send({
        success: true,
        users: result?.users || [],
        total: pagination.total || (result?.users?.length || 0),
        page: pagination.page || 1,
        limit: pagination.limit || (result?.users?.length || 0),
        hasMore: pagination.hasNext || false,
        timestamp: new Date().toISOString(),
      });
    } catch (error: any) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  fastify.get('/users/:userId', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin, adminRateLimit]}, async (request, reply) => {
    try {
      // @ts-ignore - Property access
      const result = await UsersService.getProfile(request.params.userId);
      reply.send({ success: true, data: result });
    } catch (error: any) {
      const statusCode = error.message === 'USER_NOT_FOUND' ? 404 : 500;
      reply.code(statusCode).send({ success: false, error: error.message });
    }
  });

  fastify.patch('/users/:userId', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin, adminRateLimit]}, async (request, reply) => {
    try {
      // @ts-ignore - Property access
      const result = await UsersService.updateProfile(request.params.userId, request.body);
      reply.send({ success: true, data: result });
    } catch (error: any) {
      const statusCodes: Record<string, number> = {
        'USER_NOT_FOUND': 404,
        'EMAIL_ALREADY_EXISTS': 409,
      };
      const statusCode = statusCodes[error.message] || 500;
      reply.code(statusCode).send({ success: false, error: error.message });
    }
  });

  fastify.post('/users/:userId/ban', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin, adminRateLimit]}, async (request, reply) => {
    try {
      // @ts-ignore - Property access
      const { reason, duration } = request.body || {};
      if (!reason) {
        return reply.code(400).send({ success: false, error: 'REASON_REQUIRED' });
      }
      const result = await UsersService.banUser(
        // @ts-ignore - Property access
        request.user.sub,
        // @ts-ignore - Property access
        request.params.userId,
        reason,
        duration
      );
      reply.send({ success: true, data: result });
    } catch (error: any) {
      const statusCodes: Record<string, number> = {
        'USER_NOT_FOUND': 404,
        'CANNOT_BAN_SUPER_ADMIN': 403,
      };
      const statusCode = statusCodes[error.message] || 500;
      reply.code(statusCode).send({ success: false, error: error.message });
    }
  });

  fastify.post('/users/:userId/unban', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin, adminRateLimit]}, async (request, reply) => {
    try {
      const result = await UsersService.unbanUser(
        // @ts-ignore - Property access
        request.user.sub,
        // @ts-ignore - Property access
        request.params.userId
      );
      reply.send({ success: true, data: result });
    } catch (error: any) {
      const statusCode = error.message === 'USER_NOT_FOUND' ? 404 : 500;
      reply.code(statusCode).send({ success: false, error: error.message });
    }
  });

  // Adjust user points (add or subtract) with audit-friendly response
  fastify.post('/users/:userId/points', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin, adminRateLimit]}, async (request, reply) => {
    try {
      // @ts-ignore - Property access
      const { points, reason } = (request.body as any) || {};
      if (typeof points !== 'number' || points === 0) {
        return reply.code(400).send({ success: false, error: 'INVALID_POINTS_VALUE' });
      }

      // @ts-ignore - Property access
      const user = await User.findById(request.params.userId);
      if (!user) {
        return reply.code(404).send({ success: false, error: 'USER_NOT_FOUND' });
      }

      let applied = 0;
      if (points > 0) {
        // @ts-ignore - method exists on model
        user.addPoints(points);
        applied = points;
      } else {
        const spend = Math.abs(points);
        // @ts-ignore - method exists on model
        const ok = user.spendPoints(spend);
        if (!ok) {
          return reply.code(400).send({ success: false, error: 'INSUFFICIENT_POINTS' });
        }
        applied = -spend;
      }

      await user.save();

      // Audit log
      try {
        await AuditLog.logAction({
          userId: (request as any).user?.sub,
          action: applied > 0 ? 'add_points' : 'deduct_points',
          resource: 'user',
          resourceId: user._id.toString(),
          category: 'admin',
          severity: 'low',
          success: true,
          description: `Admin adjusted points by ${applied}`,
          metadata: { reason: reason || null, newBalance: (user as any).points?.available },
        } as any);
      } catch {}

      reply.send({
        success: true,
        data: {
          userId: user._id,
          delta: applied,
          // @ts-ignore - nested points fields
          balance: user.points?.available,
          reason: reason || null,
          timestamp: new Date().toISOString(),
        },
      });
    } catch (error: any) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  fastify.delete('/users/:userId', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin, adminRateLimit]}, async (request, reply) => {
    try {
      // @ts-ignore - Property access
      const user = await User.findById(request.params.userId);
      if (!user) {
        return reply.code(404).send({ success: false, error: 'USER_NOT_FOUND' });
      }
      // @ts-ignore - Method exists on model
      user.softDelete();
      await user.save();
      reply.send({ success: true, data: { id: user._id } });
    } catch (error: any) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  // ==================== Admin: Prizes ====================
  fastify.get('/prizes', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin, adminRateLimit]}, async (request, reply) => {
    try {
      const q: any = (request.query as any) || {};
      const page = Math.max(1, parseInt(q.page) || 1);
      const limit = Math.min(100, Math.max(1, parseInt(q.limit) || 50));
      const skip = (page - 1) * limit;
      const query: any = {};
      if (q.status) query.status = q.status;
      if (q.category) query.category = q.category;
      if (q.rarity) query.rarity = q.rarity;
      if (q.city) query['location.city'] = q.city;
      if (q.search) {
        query.$or = [
          { name: { $regex: q.search, $options: 'i' } },
          { description: { $regex: q.search, $options: 'i' } },
        ];
      }
      const [items, total] = await Promise.all([
        Prize.find(query).sort({ createdAt: -1 }).skip(skip).limit(limit),
        Prize.countDocuments(query),
      ]);
      reply.send({
        success: true,
        prizes: items.map(p => p.toJSON()),
        total,
        page,
        limit,
        hasMore: skip + limit < total,
        timestamp: new Date().toISOString(),
      });
    } catch (error: any) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  fastify.get('/prizes/:prizeId', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin, adminRateLimit]}, async (request, reply) => {
    try {
      // @ts-ignore - Property access
      const prize = await Prize.findById(request.params.prizeId);
      if (!prize) {
        return reply.code(404).send({ success: false, error: 'PRIZE_NOT_FOUND' });
      }
      reply.send({ success: true, data: prize.toJSON() });
    } catch (error: any) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  fastify.patch('/prizes/:prizeId', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin, adminRateLimit]}, async (request, reply) => {
    try {
      const result = await PrizeService.updatePrize(
        // @ts-ignore - Property access
        request.user.sub,
        // @ts-ignore - Property access
        request.params.prizeId,
        // @ts-ignore - Property access
        request.body
      );
      reply.send({ success: true, data: result });
    } catch (error: any) {
      const statusCodes: Record<string, number> = {
        'PRIZE_NOT_FOUND': 404,
        'COORDINATES_OUT_OF_BOUNDS': 400,
      };
      const statusCode = statusCodes[error.message] || 500;
      reply.code(statusCode).send({ success: false, error: error.message });
    }
  });

  fastify.delete('/prizes/:prizeId', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin, adminRateLimit]}, async (request, reply) => {
    try {
      const result = await PrizeService.deletePrize(
        // @ts-ignore - Property access
        request.user.sub,
        // @ts-ignore - Property access
        request.params.prizeId
      );
      reply.send({ success: true, data: result });
    } catch (error: any) {
      const statusCode = error.message === 'PRIZE_NOT_FOUND' ? 404 : 500;
      reply.code(statusCode).send({ success: false, error: error.message });
    }
  });

  // ==================== Admin: Notifications ====================
  fastify.get('/notifications', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin, adminRateLimit]}, async (request, reply) => {
    try {
      const result = await NotificationService.getNotifications(request.query as any);
      reply.send({
        success: true,
        notifications: (result as any).notifications || [],
        total: (result as any).pagination?.total || ((result as any).notifications || []).length,
        hasMore: !!(result as any).pagination && ((result as any).pagination.page * (result as any).pagination.limit < (result as any).pagination.total),
        timestamp: new Date().toISOString(),
      });
    } catch (error: any) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  fastify.post('/notifications/send', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin, adminRateLimit]}, async (request, reply) => {
    try {
      const result = await NotificationService.sendNotification(
        // @ts-ignore - Property access
        request.user.sub,
        // @ts-ignore - Property access
        request.body
      );
      reply.code(201).send({ success: true, data: result });
    } catch (error: any) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  // Broadcast notifications (ALL users)
  fastify.post('/notifications/broadcast', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin, adminRateLimit]}, async (request, reply) => {
    try {
      const body: any = (request as any).body || {};
      const payload = {
        title: body.title,
        message: body.message,
        type: (body.type || 'push'),
        targetType: 'all',
        scheduledFor: body.scheduledFor,
      } as any;
      const result = await NotificationService.sendNotification((request as any).user.sub, payload);
      reply.code(201).send({ success: true, data: result });
    } catch (error: any) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  // ==================== Admin: Rewards ====================
  // List rewards
  fastify.get('/rewards', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin, adminRateLimit]}, async (request, reply) => {
    try {
      const result: any = await RewardsService.getRewards(request.query as any);
      const pagination = result?.pagination || {};
      reply.send({
        success: true,
        rewards: result?.rewards || [],
        total: pagination.total || (result?.rewards?.length || 0),
        page: pagination.page || 1,
        limit: pagination.limit || (result?.rewards?.length || 0),
        hasMore: pagination.hasNext || false,
        timestamp: new Date().toISOString(),
      });
    } catch (error: any) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  // Rewards analytics
  fastify.get('/rewards/analytics', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin, adminRateLimit]}, async (request, reply) => {
    try {
      // @ts-ignore - Property access
      const timeframe = (request.query as any)?.period || '30d';
      const days = parseInt(String(timeframe).replace('d', '')) || 30;
      const start = new Date();
      start.setDate(start.getDate() - days);
      const [counts, lowStock] = await Promise.all([
        Reward.aggregate([
          { $match: { createdAt: { $gte: start } } },
          { $group: { _id: '$category', count: { $sum: 1 }, avgCost: { $avg: '$pointsCost' } } },
        ]),
        // @ts-ignore - Property access
        Reward.getLowStockRewards(10),
      ]);
      reply.send({ success: true, data: { byCategory: counts, lowStock: lowStock.map(r => ({ id: r._id, name: r.name, stockAvailable: r.stockAvailable })) } });
    } catch (error: any) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  // Create reward
  fastify.post('/rewards', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin, adminRateLimit]}, async (request, reply) => {
    try {
      const result = await RewardsService.createReward((request as any).user.sub, (request as any).body);
      reply.code(201).send({ success: true, data: result });
    } catch (error: any) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  // Update reward
  fastify.patch('/rewards/:rewardId', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin, adminRateLimit]}, async (request, reply) => {
    try {
      const result = await RewardsService.updateReward(
        (request as any).user.sub,
        (request as any).params.rewardId,
        (request as any).body
      );
      reply.send({ success: true, data: result });
    } catch (error: any) {
      const statusCode = error.message === 'REWARD_NOT_FOUND' ? 404 : 500;
      reply.code(statusCode).send({ success: false, error: error.message });
    }
  });

  // Delete reward (soft delete)
  fastify.delete('/rewards/:rewardId', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin, adminRateLimit]}, async (request, reply) => {
    try {
      const rewardModel = (await import('@/models/Reward')).default as any;
      const reward = await rewardModel.findById((request as any).params.rewardId);
      if (!reward) {
        return reply.code(404).send({ success: false, error: 'REWARD_NOT_FOUND' });
      }
      reward.isActive = false;
      await reward.save();
      reply.send({ success: true, data: { id: reward._id, isActive: reward.isActive } });
    } catch (error: any) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  // ==================== Admin: Settings ====================
  // Get settings
  fastify.get('/settings', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin, adminRateLimit]}, async (request, reply) => {
    try {
      const settings = await Settings.findOne({}).sort({ updatedAt: -1 });
      reply.send({ success: true, data: settings || {} });
    } catch (error: any) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  // Update settings (partial)
  fastify.patch('/settings', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin, adminRateLimit]}, async (request, reply) => {
    try {
      const adminId = (request as any).user?.sub;
      const update = (request as any).body || {};
      const settings = await Settings.findOneAndUpdate(
        {},
        { ...update, updatedBy: adminId },
        { new: true, upsert: true }
      );
      reply.send({ success: true, data: settings });
    } catch (error: any) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  // ==================== Admin: System ====================
  // Health summary
  fastify.get('/system/health', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin]}, async (request, reply) => {
    try {
      const mongo = mongoose.connection?.readyState === 1 ? 'connected' : 'disconnected';
      const redis = (require('@/config/redis') as any).redisClient?.status || 'unknown';
      reply.send({ success: true, data: { mongo, redis, uptime: process.uptime(), timestamp: new Date().toISOString() } });
    } catch (error: any) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  // Basic metrics
  fastify.get('/system/metrics', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin]}, async (request, reply) => {
    try {
      const os = await import('os');
      const [users, prizes, claims, rewards] = await Promise.all([
        User.countDocuments({}),
        Prize.countDocuments({}),
        Claim.countDocuments({}),
        Reward.countDocuments({}),
      ]);
      const totalMem = (os as any).default.totalmem();
      const usedMem = process.memoryUsage().rss;
      const memPct = totalMem ? Math.round((usedMem / totalMem) * 100) : 0;
      const cpuCores = (os as any).default.cpus()?.length || 1;
      const data = {
        users, prizes, claims, rewards,
        memory: { used: usedMem, total: totalMem, percentage: memPct },
        cpu: { usage: 0, cores: cpuCores },
        disk: { used: 'N/A', total: 'N/A', percentage: 0 },
        network: { inbound: 0, outbound: 0, latency: 0 },
      };
      reply.send({ success: true, data });
    } catch (error: any) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  // System logs (alias)
  fastify.get('/system/logs', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin]}, async (request, reply) => {
    try {
      const q: any = (request.query as any) || {};
      const limit = Math.min(1000, Math.max(1, parseInt(q.limit) || 200));
      const logs = await AuditLog.find({}).sort({ timestamp: -1 }).limit(limit);
      reply.send({ success: true, data: logs });
    } catch (error: any) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  // Backup and restore (stubs)
  fastify.post('/system/backup', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin]}, async (request, reply) => {
    try {
      const backupId = `bk_${Date.now()}`;
      reply.send({ success: true, data: { backupId } });
    } catch (error: any) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  fastify.post('/system/restore', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin]}, async (request, reply) => {
    try {
      const body: any = (request as any).body || {};
      reply.send({ success: true, data: { restoredFrom: body.backupId || null } });
    } catch (error: any) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  // Maintenance mode
  fastify.post('/maintenance/start', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin]}, async (request, reply) => {
    try {
      const body: any = (request as any).body || {};
      const adminId = (request as any).user?.sub;
      const settings = await Settings.findOneAndUpdate(
        {},
        { maintenance: { maintenanceMode: true, maintenanceMessage: body.message || 'Maintenance en cours' }, updatedBy: adminId },
        { new: true, upsert: true }
      );
      reply.send({ success: true, data: { maintenance: settings.maintenance } });
    } catch (error: any) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  fastify.post('/maintenance/stop', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin]}, async (request, reply) => {
    try {
      const adminId = (request as any).user?.sub;
      const settings = await Settings.findOneAndUpdate(
        {},
        { maintenance: { maintenanceMode: false, maintenanceMessage: '' }, updatedBy: adminId },
        { new: true, upsert: true }
      );
      reply.send({ success: true, data: { maintenance: settings.maintenance } });
    } catch (error: any) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  // ==================== Admin: Activity Logs (aliases) ====================
  // Create an activity log entry
  fastify.post('/activity-logs', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin]}, async (request, reply) => {
    try {
      const body = (request as any).body || {};
      const adminUser = (request as any).user || {};
      const log = await (AuditLog as any).logAction({
        userId: adminUser.sub,
        userEmail: adminUser.email,
        userRole: 'admin',
        action: body.action || 'admin_activity',
        resource: (body.target && body.target.type) || 'admin',
        resourceId: (body.target && (body.target.id || body.target.resourceId)) || undefined,
        description: body.message || body.description,
        category: 'admin',
        severity: 'low',
        success: true,
        metadata: body.details || body.metadata || {},
      });
      reply.code(201).send({ success: true, data: log });
    } catch (error: any) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  // ==================== Admin: Captures Aliases ====================
  // List captures (alias to claims)
  fastify.get('/captures', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin, adminRateLimit]}, async (request, reply) => {
    try {
      const q: any = (request.query as any) || {};
      const page = Math.max(1, parseInt(q.page) || 1);
      const limit = Math.min(100, Math.max(1, parseInt(q.limit) || 50));
      const skip = (page - 1) * limit;
      const query: any = {};
      if (q.status) query.status = q.status;
      if (q.userId) query.userId = q.userId;
      if (q.prizeId) query.prizeId = q.prizeId;
      const [claims, total] = await Promise.all([
        Claim.find(query).populate('userId', 'displayName email').populate('prizeId', 'name category')
          .sort({ createdAt: -1 }).skip(skip).limit(limit),
        Claim.countDocuments(query),
      ]);
      reply.send({ success: true, data: { captures: claims, total, page, limit } });
    } catch (error: any) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  // Validate capture (alias)
  fastify.post('/captures/:id/validate', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin, adminRateLimit]}, async (request, reply) => {
    try {
      const claim = await Claim.findById((request.params as any).id);
      if (!claim) return reply.code(404).send({ success: false, error: 'CAPTURE_NOT_FOUND' });
      (claim as any).metadata = { ...(claim as any).metadata, adminValidation: { isValid: true, validatedBy: (request as any).user.sub, validatedAt: new Date() } };
      await claim.save();
      reply.send({ success: true, data: claim });
    } catch (error: any) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  // Captures analytics (basic)
  fastify.get('/captures/analytics', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin, adminRateLimit]}, async (request, reply) => {
    try {
      const days = parseInt(String(((request.query as any)?.period || '30d')).replace('d', '')) || 30;
      const start = new Date(); start.setDate(start.getDate() - days);
      const stats = await Claim.aggregate([
        { $match: { createdAt: { $gte: start } } },
        { $group: { _id: null, total: { $sum: 1 }, avgDistance: { $avg: '$distance' }, pointsAwarded: { $sum: '$pointsAwarded' } } },
      ]);
      reply.send({ success: true, data: stats?.[0] || { total: 0, avgDistance: 0, pointsAwarded: 0 } });
    } catch (error: any) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  // ==================== Admin: Redemptions (aliases) ====================
  // List redemptions (core)
  fastify.get('/redemptions', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin, adminRateLimit]}, async (request, reply) => {
    try {
      const q: any = (request.query as any) || {};
      const page = Math.max(1, parseInt(q.page) || 1);
      const limit = Math.min(100, Math.max(1, parseInt(q.limit) || 50));
      const skip = (page - 1) * limit;
      const query: any = {};
      if (q.status && q.status !== 'all') query.status = q.status;
      const [items, total] = await Promise.all([
        Redemption.find(query).populate('userId', 'displayName email').populate('rewardId', 'name category pointsCost')
          .sort({ createdAt: -1 }).skip(skip).limit(limit),
        Redemption.countDocuments(query),
      ]);
      reply.send({ success: true, data: { redemptions: items, total, page, limit } });
    } catch (error: any) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  // Validate redemption (core)
  fastify.post('/redemptions/:id/validate', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin, adminRateLimit]}, async (request, reply) => {
    try {
      const redemption = await Redemption.findById((request.params as any).id);
      if (!redemption) return reply.code(404).send({ success: false, error: 'REDEMPTION_NOT_FOUND' });
      redemption.fulfill();
      await redemption.save();
      reply.send({ success: true, data: redemption });
    } catch (error: any) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  // ==================== Admin: Analytics ====================
  fastify.get('/analytics/users', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin, adminRateLimit]}, async (request, reply) => {
    try {
      const days = parseInt(String(((request.query as any)?.period || '30d')).replace('d', '')) || 30;
      const start = new Date(); start.setDate(start.getDate() - days);
      const [userMetrics] = await Promise.all([
        User.aggregate([
          { $group: { _id: null, total: { $sum: 1 }, active7d: { $sum: { $cond: [{ $gte: ['$lastActive', new Date(Date.now() - 7*864e5)] }, 1, 0] } }, newUsers: { $sum: { $cond: [{ $gte: ['$createdAt', start] }, 1, 0] } } } } ])
      ]);
      reply.send({ success: true, data: userMetrics || { total: 0, active7d: 0, newUsers: 0 } });
    } catch (error: any) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  fastify.get('/analytics/prizes', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin, adminRateLimit]}, async (request, reply) => {
    try {
      const days = parseInt(String(((request.query as any)?.period || '30d')).replace('d', '')) || 30;
      const start = new Date(); start.setDate(start.getDate() - days);
      const stats = await Claim.aggregate([
        { $match: { createdAt: { $gte: start } } },
        { $group: { _id: '$prizeId', count: { $sum: 1 }, totalPoints: { $sum: '$pointsAwarded' } } },
        { $sort: { count: -1 } },
        { $limit: 50 },
      ]);
      reply.send({ success: true, data: { topPrizes: stats } });
    } catch (error: any) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  fastify.get('/analytics/business', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin, adminRateLimit]}, async (request, reply) => {
    try {
      const days = parseInt(String(((request.query as any)?.period || '30d')).replace('d', '')) || 30;
      const start = new Date(); start.setDate(start.getDate() - days);
      const [totals, byPartner] = await Promise.all([
        Redemption.aggregate([
          { $match: { createdAt: { $gte: start } } },
          { $group: { _id: null, redemptions: { $sum: 1 }, points: { $sum: '$pointsSpent' }, gross: { $sum: { $ifNull: ['$metadata.grossValue', 0] } }, partnerShare: { $sum: { $ifNull: ['$metadata.partnerShare', 0] } }, platformShare: { $sum: { $ifNull: ['$metadata.platformShare', 0] } } } } ]),
        Redemption.aggregate([
          { $match: { createdAt: { $gte: start } } },
          { $group: { _id: '$metadata.partnerId', redemptions: { $sum: 1 }, gross: { $sum: { $ifNull: ['$metadata.grossValue', 0] } } } },
          { $sort: { redemptions: -1 } },
          { $limit: 20 },
        ]),
      ]);
      reply.send({ success: true, data: { overview: totals?.[0] || {}, topPartners: byPartner } });
    } catch (error: any) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  fastify.get('/analytics/heatmap', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin, adminRateLimit]}, async (request, reply) => {
    try {
      const days = parseInt(String(((request.query as any)?.period || '30d')).replace('d', '')) || 30;
      const start = new Date(); start.setDate(start.getDate() - days);
      // Use claims with location to produce simple heatmap points
      const points = await Claim.find({ createdAt: { $gte: start } }).select('location').limit(5000);
      const heatmap = points.filter(p => p.location && (p.location as any).lat !== undefined).map(p => ({ lat: (p.location as any).lat, lng: (p.location as any).lng, weight: 1 }));
      reply.send({ success: true, data: { heatmap } });
    } catch (error: any) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  // List activity logs
  fastify.get('/activity-logs', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin]}, async (request, reply) => {
    try {
      const q: any = (request.query as any) || {};
      const page = Math.max(1, parseInt(q.page) || 1);
      const limit = Math.min(200, Math.max(1, parseInt(q.limit) || 50));
      const skip = (page - 1) * limit;
      const query: any = {};
      if (q.action) query.action = q.action;
      if (q.actorEmail) query.userEmail = q.actorEmail;
      const [logs, total] = await Promise.all([
        (AuditLog as any).find(query).sort({ timestamp: -1 }).skip(skip).limit(limit),
        (AuditLog as any).countDocuments(query),
      ]);
      reply.send({ success: true, data: { logs, page, limit, total } });
    } catch (error: any) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  // Activity logs statistics
  fastify.get('/activity-logs/statistics', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin]}, async (request, reply) => {
    try {
      const stats = await (AuditLog as any).getStatistics(7);
      reply.send({ success: true, data: stats?.[0] || {} });
    } catch (error: any) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  // Clear old activity logs
  fastify.delete('/activity-logs/clear', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin]}, async (request, reply) => {
    try {
      const body: any = (request as any).body || {};
      const daysToKeep = parseInt(body.daysToKeep) || 90;
      const cutoff = new Date();
      cutoff.setDate(cutoff.getDate() - daysToKeep);
      const result = await (AuditLog as any).deleteMany({ createdAt: { $lt: cutoff } });
      reply.send({ success: true, data: { deleted: result.deletedCount || 0 } });
    } catch (error: any) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  // Export activity logs (JSON)
  fastify.get('/activity-logs/export', {
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin]}, async (request, reply) => {
    try {
      const q: any = (request.query as any) || {};
      const limit = Math.min(5000, Math.max(1, parseInt(q.limit) || 1000));
      const logs = await (AuditLog as any).find({}).sort({ timestamp: -1 }).limit(limit);
      reply.headers({ 'Content-Type': 'application/json' });
      reply.send({ success: true, data: logs });
    } catch (error: any) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });
}
