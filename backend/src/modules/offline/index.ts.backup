import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
import { z } from 'zod';
import { Types } from 'mongoose';
import { 
  OfflineQueue, 
  OfflineActionType, 
  OfflineActionStatus,
  ConflictResolution 
} from '@/models/OfflineQueue';
import { User } from '@/models/User';
import { Prize } from '@/models/Prize';
import { Claim } from '@/models/Claim';
import { logger } from '@/lib/logger';
import { ClaimsService } from '@/modules/claims';

// Validation schemas
const syncActionsSchema = z.object({
  actions: z.array(z.object({
    actionType: z.enum([
      'claim_prize',
      'update_profile',
      'send_friend_request',
      'accept_friend_request',
      'purchase_item',
      'unlock_achievement']),
    actionData: z.any(),
    clientTimestamp: z.string().datetime(),
    metadata: z.object({
      deviceId: z.string(),
      platform: z.string(),
      appVersion: z.string(),
      networkType: z.string().optional()})})),
  conflictResolution: z.enum(['server_wins', 'client_wins', 'merge', 'manual']).default('server_wins')});

const getSyncStatusSchema = z.object({
  since: z.string().datetime().optional()});

/**
 * Offline Service (Enhanced)
 */
export class OfflineService {
  /**
   * Sync offline actions
   */
  static async syncActions(
    userId: string,
    data: z.infer<typeof syncActionsSchema>
  ) {
    try {
      const results = {
        synced: [] as any[],
        failed: [] as any[],
        conflicts: [] as any[]};

      for (const action of data.actions) {
        try {
          // Create queue entry
          const queueEntry = new OfflineQueue({
            userId: new Types.ObjectId(userId),
            actionType: action.actionType as OfflineActionType,
            actionData: action.actionData,
            status: OfflineActionStatus.SYNCING,
            clientTimestamp: new Date(action.clientTimestamp),
            serverTimestamp: new Date(),
            attempts: 1,
            metadata: action.metadata});

          // Process action based on type
          const result = await this.processAction(
            userId,
            action.actionType as OfflineActionType,
            action.actionData,
            data.conflictResolution as ConflictResolution
          );

          if (result.success) {
            queueEntry.status = OfflineActionStatus.SYNCED;
            queueEntry.syncedAt = new Date();
            results.synced.push({
              actionType: action.actionType,
              result: result.data});
          } else if (result.conflict) {
            queueEntry.status = OfflineActionStatus.CONFLICT;
            queueEntry.conflict = {
              serverData: result.serverData,
              clientData: result.clientData,
              resolution: data.conflictResolution as ConflictResolution,
              resolvedData: result.resolvedData};
            results.conflicts.push({
              actionType: action.actionType,
              conflict: queueEntry.conflict});
          } else {
            queueEntry.status = OfflineActionStatus.FAILED;
            queueEntry.error = {
              code: result.error?.code || 'UNKNOWN_ERROR',
              message: result.error?.message || 'Unknown error',
              details: result.error?.details};
            results.failed.push({
              actionType: action.actionType,
              error: queueEntry.error});
          }

          await queueEntry.save();

        } catch (error: any) {
          results.failed.push({
            actionType: action.actionType,
            error: {
              code: 'PROCESSING_ERROR',
              message: error.message}});
        }
      }

      // @ts-ignore - Overload mismatch
      logger.info('Offline actions synced', {
        userId,
        total: data.actions.length,
        synced: results.synced.length,
        failed: results.failed.length,
        conflicts: results.conflicts.length});

      return results;
      
    } catch (error: any) {
      // @ts-ignore - Overload mismatch
      logger.error('Sync actions error', {
        userId,
        error: error.message});
      throw error;
    }
  }

  /**
   * Process individual action
   */
  private static async processAction(
    userId: string,
    actionType: OfflineActionType,
    actionData: any,
    conflictResolution: ConflictResolution
  ): Promise<any> {
    switch (actionType) {
      case OfflineActionType.CLAIM_PRIZE:
        return await this.processClaim(userId, actionData, conflictResolution);
      
      case OfflineActionType.UPDATE_PROFILE:
        return await this.processProfileUpdate(userId, actionData, conflictResolution);
      
      case OfflineActionType.SEND_FRIEND_REQUEST:
        return await this.processFriendRequest(userId, actionData);
      
      default:
        return {
          success: false,
          error: {
            code: 'UNSUPPORTED_ACTION',
            message: `Action type ${actionType} not supported`}};
    }
  }

  /**
   * Process claim with conflict detection
   */
  private static async processClaim(
    userId: string,
    actionData: any,
    conflictResolution: ConflictResolution
  ): Promise<any> {
    try {
      // Check if claim already exists (idempotency)
      const existingClaim = await Claim.findOne({
        userId: new Types.ObjectId(userId),
        prizeId: new Types.ObjectId(actionData.prizeId)});

      if (existingClaim) {
        // Conflict detected
        if (conflictResolution === ConflictResolution.SERVER_WINS) {
          return {
            success: true,
            data: existingClaim,
            conflict: false};
        } else {
          return {
            success: false,
            conflict: true,
            serverData: existingClaim,
            clientData: actionData,
            resolvedData: existingClaim, // Server wins by default
          };
        }
      }

      // Process claim normally
      const result = await ClaimsService.claimPrize(userId, actionData);
      
      return {
        success: true,
        data: result,
        conflict: false};
      
    } catch (error: any) {
      return {
        success: false,
        error: {
          code: error.message,
          message: error.message,
          details: error}};
    }
  }

  /**
   * Process profile update with conflict detection
   */
  private static async processProfileUpdate(
    userId: string,
    actionData: any,
    conflictResolution: ConflictResolution
  ): Promise<any> {
    try {
      const user = await User.findById(userId);
      
      if (!user) {
        return {
          success: false,
          error: {
            code: 'USER_NOT_FOUND',
            message: 'User not found'}};
      }

      // Check for conflicts
      const serverUpdatedAt = user.updatedAt;
      const clientUpdatedAt = new Date(actionData.updatedAt || 0);

      if (serverUpdatedAt > clientUpdatedAt) {
        // Conflict detected
        if (conflictResolution === ConflictResolution.SERVER_WINS) {
          return {
            success: true,
            data: user,
            conflict: false};
        } else if (conflictResolution === ConflictResolution.CLIENT_WINS) {
          // Apply client changes
          Object.assign(user, actionData.updates);
          await user.save();
          return {
            success: true,
            data: user,
            conflict: false};
        } else {
          // Merge strategy
          return {
            success: false,
            conflict: true,
            serverData: user,
            clientData: actionData,
            resolvedData: user, // Server wins by default
          };
        }
      }

      // No conflict, apply changes
      Object.assign(user, actionData.updates);
      await user.save();

      return {
        success: true,
        data: user,
        conflict: false};
      
    } catch (error: any) {
      return {
        success: false,
        error: {
          code: 'UPDATE_ERROR',
          message: error.message}};
    }
  }

  /**
   * Process friend request
   */
  private static async processFriendRequest(
    userId: string,
    actionData: any
  ): Promise<any> {
    // Implementation would go here
    return {
      success: true,
      data: { message: 'Friend request sent' },
      conflict: false};
  }

  /**
   * Get sync status
   */
  static async getSyncStatus(
    userId: string,
    data: z.infer<typeof getSyncStatusSchema>
  ) {
    try {
      const query: any = {
        userId: new Types.ObjectId(userId)};

      if (data.since) {
        query.createdAt = { $gte: new Date(data.since) };
      }

      const [pending, syncing, synced, failed, conflicts] = await Promise.all([
        OfflineQueue.countDocuments({ ...query, status: OfflineActionStatus.PENDING }),
        OfflineQueue.countDocuments({ ...query, status: OfflineActionStatus.SYNCING }),
        OfflineQueue.countDocuments({ ...query, status: OfflineActionStatus.SYNCED }),
        OfflineQueue.countDocuments({ ...query, status: OfflineActionStatus.FAILED }),
        OfflineQueue.countDocuments({ ...query, status: OfflineActionStatus.CONFLICT })]);

      const recentActions = await OfflineQueue.find(query)
        .sort({ createdAt: -1 })
        .limit(20)
        .select('actionType status clientTimestamp syncedAt error conflict');

      return {
        status: {
          pending,
          syncing,
          synced,
          failed,
          conflicts,
          total: pending + syncing + synced + failed + conflicts},
        recentActions};
      
    } catch (error: any) {
      // @ts-ignore - Overload mismatch
      logger.error('Get sync status error', {
        userId,
        error: error.message});
      throw error;
    }
  }

  /**
   * Retry failed actions
   */
  static async retryFailedActions(userId: string) {
    try {
      const failedActions = await OfflineQueue.find({
        userId: new Types.ObjectId(userId),
        status: OfflineActionStatus.FAILED,
        attempts: { $lt: 3 }}).limit(10);

      const results = [];

      for (const action of failedActions) {
        action.status = OfflineActionStatus.SYNCING;
        action.attempts += 1;
        await action.save();

        const result = await this.processAction(
          userId,
          action.actionType,
          action.actionData,
          ConflictResolution.SERVER_WINS
        );

        if (result.success) {
          action.status = OfflineActionStatus.SYNCED;
          action.syncedAt = new Date();
        } else {
          action.status = OfflineActionStatus.FAILED;
          action.error = result.error;
        }

        await action.save();
        results.push({
          actionType: action.actionType,
          success: result.success});
      }

      return {
        retried: results.length,
        results};
      
    } catch (error: any) {
      // @ts-ignore - Overload mismatch
      logger.error('Retry failed actions error', {
        userId,
        error: error.message});
      throw error;
    }
  }
}

/**
 * Enhanced Offline Routes
 */
export default async function offlineEnhancedRoutes(fastify: FastifyInstance) {
  // POST /api/offline/sync - Sync offline actions
  fastify.post('/sync', {
    preHandler: [(fastify as any).authenticate],
      description: 'Sync offline actions with conflict resolution',
      tags: ['Offline'],
      response: {
        200: {
          type: 'object',
          properties: {
            synced: { type: 'array' },
            failed: { type: 'array' },
            conflicts: { type: 'array' }}}}}, async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      const userId = request.user.sub;
      const data = syncActionsSchema.parse(request.body);
      
      const result = await OfflineService.syncActions(userId, data);
      
      return reply.code(200).send(result);
    } catch (error: any) {
      throw error;
    }
  });

  // GET /api/offline/status - Get sync status
  fastify.get('/status', {
    preHandler: [(fastify as any).authenticate],
      description: 'Get offline sync status',
      tags: ['Offline'],
      response: {
        200: {
          type: 'object',
          properties: {
            status: {
              type: 'object',
              properties: {
                pending: { type: 'number' },
                syncing: { type: 'number' },
                synced: { type: 'number' },
                failed: { type: 'number' },
                conflicts: { type: 'number' },
                total: { type: 'number' }},
            recentActions: { type: 'array' }}}}}}, async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      const userId = request.user.sub;
      const data = getSyncStatusSchema.parse(request.query);
      
      const result = await OfflineService.getSyncStatus(userId, data);
      
      return reply.code(200).send(result);
    } catch (error: any) {
      throw error;
    }
  });

  // POST /api/offline/retry - Retry failed actions
  fastify.post('/retry', {
    preHandler: [(fastify as any).authenticate],
      description: 'Retry failed offline actions',
      tags: ['Offline'],
      response: {
        200: {
          type: 'object',
          properties: {
            retried: { type: 'number' },
            results: { type: 'array' }}}}}, async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      const userId = request.user.sub;
      
      const result = await OfflineService.retryFailedActions(userId);
      
      return reply.code(200).send(result);
    } catch (error: any) {
      throw error;
    }
  });
}

