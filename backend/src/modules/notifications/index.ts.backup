import { FastifyInstance } from 'fastify';
import { authenticate, requireAdmin } from '@/middleware/auth';
import { z } from 'zod';
import { Notification } from '@/models/Notification';
import { User } from '@/models/User';
import { logger } from '@/lib/logger';
import { NotificationType, NotificationTargetType, NotificationStatus } from '@/types';

const sendNotificationSchema = z.object({
  title: z.string().min(1).max(100),
  message: z.string().min(1).max(500),
  type: z.enum(Object.values(NotificationType) as [string, ...string[]]),
  targetType: z.enum(Object.values(NotificationTargetType) as [string, ...string[]]),
  targetValue: z.string().optional(),
  scheduledFor: z.string().datetime().optional()});

export class NotificationService {
  static async sendNotification(adminId: string, data: z.infer<typeof sendNotificationSchema>) {
    try {
      const notification = new Notification({
        ...data,
        createdBy: adminId,
        status: data.scheduledFor ? NotificationStatus.SCHEDULED : NotificationStatus.SENT,
        sentAt: data.scheduledFor ? undefined : new Date(),
        scheduledFor: data.scheduledFor ? new Date(data.scheduledFor) : undefined});

      await notification.save();

      // If not scheduled, send immediately
      if (!data.scheduledFor) {
        await this.processNotification(notification);
      }

      // @ts-ignore - Overload mismatch
      logger.info('Notification created', {
        notificationId: notification._id,
        adminId,
        type: data.type,
        targetType: data.targetType});

      return notification.toJSON();
    } catch (error) {
      // @ts-ignore - Overload mismatch
      logger.error('Send notification error', { error: error.message, adminId });
      throw error;
    }
  }

  static async processNotification(notification: any) {
    try {
      let recipients: any[] = [];

      // Get recipients based on target type
      switch (notification.targetType) {
        case NotificationTargetType.ALL:
          recipients = await User.find({ 
            'preferences.notifications': { $ne: false },
          });
          break;
        case NotificationTargetType.CITY:
          recipients = await User.find({ 
            'location.city': notification.targetValue,
            'preferences.notifications': { $ne: false },
          });
          break;
        case NotificationTargetType.LEVEL:
          recipients = await User.find({ 
            level: notification.targetValue,
            'preferences.notifications': { $ne: false },
          });
          break;
        case NotificationTargetType.USER:
          recipients = await User.find({ 
            _id: notification.targetValue,
            'preferences.notifications': { $ne: false },
          });
          break;
      }

      // Send push notifications (mock implementation)
      for (const user of recipients) {
        const tokens = (user.devices || [])
          .map((d: any) => d?.fcmToken)
          .filter((t: any) => typeof t === 'string' && t.length > 0);
        for (const token of tokens) {
          // Here you would integrate with FCM
          // @ts-ignore - Overload mismatch
          logger.info('Push notification sent', {
            userId: user._id,
            token: token.substring(0, 20) + '...',
            title: notification.title});
        }
      }

      return { recipientCount: recipients.length };
    } catch (error) {
      // @ts-ignore - Overload mismatch
      logger.error('Process notification error', { error: error.message });
      throw error;
    }
  }

  static async getNotifications(options: any = {}) {
    try {
      const skip = ((options.page || 1) - 1) * (options.limit || 50);
      
      const [notifications, total] = await Promise.all([
        Notification.find()
          .populate('createdBy', 'displayName')
          .sort({ createdAt: -1 })
          .skip(skip)
          .limit(options.limit || 50),
        Notification.countDocuments()]);

      return {
        notifications: notifications.map(n => n.toJSON()),
        pagination: {
          page: options.page || 1,
          limit: options.limit || 50,
          total,
          pages: Math.ceil(total / (options.limit || 50))}};
    } catch (error) {
      // @ts-ignore - Overload mismatch
      logger.error('Get notifications error', { error: error.message });
      throw error;
    }
  }
}

export default async function notificationsRoutes(fastify: FastifyInstance) {
  // Send notification
  fastify.post('/', {
    // @ts-ignore - Property access
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin]}, async (request, reply) => {
    try {
      const result = await NotificationService.sendNotification(request.user.sub, request.body);
      reply.code(201).send({ success: true, data: result });
    } catch (error) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });

  // Get notifications
  fastify.get('/', {
    // @ts-ignore - Property access
    // @ts-ignore - Property access
    preHandler: [authenticate, requireAdmin]}, async (request, reply) => {
    try {
      const result = await NotificationService.getNotifications(request.query);
      reply.send({ success: true, data: result });
    } catch (error) {
      reply.code(500).send({ success: false, error: error.message });
    }
  });
}
